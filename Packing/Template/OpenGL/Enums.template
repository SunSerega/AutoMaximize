  
  
  
  {$region Core}
  
  AccumOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ACCUM  := new AccumOp($0100);
    private static _LOAD   := new AccumOp($0101);
    private static _RETURN := new AccumOp($0102);
    private static _MULT   := new AccumOp($0103);
    private static _ADD    := new AccumOp($0104);
    
    public static property ACCUM:  AccumOp read _ACCUM;
    public static property LOAD:   AccumOp read _LOAD;
    public static property RETURN: AccumOp read _RETURN;
    public static property MULT:   AccumOp read _MULT;
    public static property ADD:    AccumOp read _ADD;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0100) then Result := 'ACCUM' else
      if self.val = UInt32($0101) then Result := 'LOAD' else
      if self.val = UInt32($0102) then Result := 'RETURN' else
      if self.val = UInt32($0103) then Result := 'MULT' else
      if self.val = UInt32($0104) then Result := 'ADD' else
        Result := self.val.ToString;
    end;
    
  end;
  
  AlphaFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NEVER    := new AlphaFunction($0200);
    private static _LESS     := new AlphaFunction($0201);
    private static _EQUAL    := new AlphaFunction($0202);
    private static _LEQUAL   := new AlphaFunction($0203);
    private static _GREATER  := new AlphaFunction($0204);
    private static _NOTEQUAL := new AlphaFunction($0205);
    private static _GEQUAL   := new AlphaFunction($0206);
    private static _ALWAYS   := new AlphaFunction($0207);
    
    public static property NEVER:    AlphaFunction read _NEVER;
    public static property LESS:     AlphaFunction read _LESS;
    public static property EQUAL:    AlphaFunction read _EQUAL;
    public static property LEQUAL:   AlphaFunction read _LEQUAL;
    public static property GREATER:  AlphaFunction read _GREATER;
    public static property NOTEQUAL: AlphaFunction read _NOTEQUAL;
    public static property GEQUAL:   AlphaFunction read _GEQUAL;
    public static property ALWAYS:   AlphaFunction read _ALWAYS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  AtomicCounterBufferPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER         := new AtomicCounterBufferPName($90ED);
    private static _ATOMIC_COUNTER_BUFFER_BINDING                              := new AtomicCounterBufferPName($92C1);
    private static _ATOMIC_COUNTER_BUFFER_DATA_SIZE                            := new AtomicCounterBufferPName($92C4);
    private static _ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS               := new AtomicCounterBufferPName($92C5);
    private static _ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES        := new AtomicCounterBufferPName($92C6);
    private static _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER          := new AtomicCounterBufferPName($92C7);
    private static _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER    := new AtomicCounterBufferPName($92C8);
    private static _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER := new AtomicCounterBufferPName($92C9);
    private static _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER        := new AtomicCounterBufferPName($92CA);
    private static _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER        := new AtomicCounterBufferPName($92CB);
    
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER:         AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER;
    public static property ATOMIC_COUNTER_BUFFER_BINDING:                              AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_BINDING;
    public static property ATOMIC_COUNTER_BUFFER_DATA_SIZE:                            AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_DATA_SIZE;
    public static property ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS:               AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS;
    public static property ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES:        AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES;
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER:          AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER;
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER:    AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER;
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER;
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER:        AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER;
    public static property ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER:        AtomicCounterBufferPName read _ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($90ED) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER' else
      if self.val = UInt32($92C1) then Result := 'ATOMIC_COUNTER_BUFFER_BINDING' else
      if self.val = UInt32($92C4) then Result := 'ATOMIC_COUNTER_BUFFER_DATA_SIZE' else
      if self.val = UInt32($92C5) then Result := 'ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS' else
      if self.val = UInt32($92C6) then Result := 'ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES' else
      if self.val = UInt32($92C7) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER' else
      if self.val = UInt32($92C8) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER' else
      if self.val = UInt32($92C9) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if self.val = UInt32($92CA) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER' else
      if self.val = UInt32($92CB) then Result := 'ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  AttribMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CURRENT_BIT          := new AttribMask($0001);
    private static _POINT_BIT            := new AttribMask($0002);
    private static _LINE_BIT             := new AttribMask($0004);
    private static _POLYGON_BIT          := new AttribMask($0008);
    private static _POLYGON_STIPPLE_BIT  := new AttribMask($0010);
    private static _PIXEL_MODE_BIT       := new AttribMask($0020);
    private static _LIGHTING_BIT         := new AttribMask($0040);
    private static _FOG_BIT              := new AttribMask($0080);
    private static _DEPTH_BUFFER_BIT     := new AttribMask($0100);
    private static _ACCUM_BUFFER_BIT     := new AttribMask($0200);
    private static _STENCIL_BUFFER_BIT   := new AttribMask($0400);
    private static _VIEWPORT_BIT         := new AttribMask($0800);
    private static _TRANSFORM_BIT        := new AttribMask($1000);
    private static _ENABLE_BIT           := new AttribMask($2000);
    private static _COLOR_BUFFER_BIT     := new AttribMask($4000);
    private static _HINT_BIT             := new AttribMask($8000);
    private static _EVAL_BIT             := new AttribMask($10000);
    private static _LIST_BIT             := new AttribMask($20000);
    private static _TEXTURE_BIT          := new AttribMask($40000);
    private static _SCISSOR_BIT          := new AttribMask($80000);
    private static _MULTISAMPLE_BIT      := new AttribMask($20000000);
    private static _MULTISAMPLE_BIT_3DFX := new AttribMask($20000000);
    private static _MULTISAMPLE_BIT_ARB  := new AttribMask($20000000);
    private static _MULTISAMPLE_BIT_EXT  := new AttribMask($20000000);
    private static _ALL_ATTRIB_BITS      := new AttribMask($FFFFFFFF);
    
    public static property CURRENT_BIT:          AttribMask read _CURRENT_BIT;
    public static property POINT_BIT:            AttribMask read _POINT_BIT;
    public static property LINE_BIT:             AttribMask read _LINE_BIT;
    public static property POLYGON_BIT:          AttribMask read _POLYGON_BIT;
    public static property POLYGON_STIPPLE_BIT:  AttribMask read _POLYGON_STIPPLE_BIT;
    public static property PIXEL_MODE_BIT:       AttribMask read _PIXEL_MODE_BIT;
    public static property LIGHTING_BIT:         AttribMask read _LIGHTING_BIT;
    public static property FOG_BIT:              AttribMask read _FOG_BIT;
    public static property DEPTH_BUFFER_BIT:     AttribMask read _DEPTH_BUFFER_BIT;
    public static property ACCUM_BUFFER_BIT:     AttribMask read _ACCUM_BUFFER_BIT;
    public static property STENCIL_BUFFER_BIT:   AttribMask read _STENCIL_BUFFER_BIT;
    public static property VIEWPORT_BIT:         AttribMask read _VIEWPORT_BIT;
    public static property TRANSFORM_BIT:        AttribMask read _TRANSFORM_BIT;
    public static property ENABLE_BIT:           AttribMask read _ENABLE_BIT;
    public static property COLOR_BUFFER_BIT:     AttribMask read _COLOR_BUFFER_BIT;
    public static property HINT_BIT:             AttribMask read _HINT_BIT;
    public static property EVAL_BIT:             AttribMask read _EVAL_BIT;
    public static property LIST_BIT:             AttribMask read _LIST_BIT;
    public static property TEXTURE_BIT:          AttribMask read _TEXTURE_BIT;
    public static property SCISSOR_BIT:          AttribMask read _SCISSOR_BIT;
    public static property MULTISAMPLE_BIT:      AttribMask read _MULTISAMPLE_BIT;
    public static property MULTISAMPLE_BIT_3DFX: AttribMask read _MULTISAMPLE_BIT_3DFX;
    public static property MULTISAMPLE_BIT_ARB:  AttribMask read _MULTISAMPLE_BIT_ARB;
    public static property MULTISAMPLE_BIT_EXT:  AttribMask read _MULTISAMPLE_BIT_EXT;
    public static property ALL_ATTRIB_BITS:      AttribMask read _ALL_ATTRIB_BITS;
    
    public static function operator or(f1,f2: AttribMask) := new AttribMask(f1.val or f2.val);
    
    public property HAS_FLAG_CURRENT_BIT:          boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_POINT_BIT:            boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_LINE_BIT:             boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_POLYGON_BIT:          boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_POLYGON_STIPPLE_BIT:  boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_PIXEL_MODE_BIT:       boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_LIGHTING_BIT:         boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_FOG_BIT:              boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_DEPTH_BUFFER_BIT:     boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_ACCUM_BUFFER_BIT:     boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_STENCIL_BUFFER_BIT:   boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_VIEWPORT_BIT:         boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_TRANSFORM_BIT:        boolean read self.val and $1000 <> 0;
    public property HAS_FLAG_ENABLE_BIT:           boolean read self.val and $2000 <> 0;
    public property HAS_FLAG_COLOR_BUFFER_BIT:     boolean read self.val and $4000 <> 0;
    public property HAS_FLAG_HINT_BIT:             boolean read self.val and $8000 <> 0;
    public property HAS_FLAG_EVAL_BIT:             boolean read self.val and $10000 <> 0;
    public property HAS_FLAG_LIST_BIT:             boolean read self.val and $20000 <> 0;
    public property HAS_FLAG_TEXTURE_BIT:          boolean read self.val and $40000 <> 0;
    public property HAS_FLAG_SCISSOR_BIT:          boolean read self.val and $80000 <> 0;
    public property HAS_FLAG_MULTISAMPLE_BIT:      boolean read self.val and $20000000 <> 0;
    public property HAS_FLAG_MULTISAMPLE_BIT_3DFX: boolean read self.val and $20000000 <> 0;
    public property HAS_FLAG_MULTISAMPLE_BIT_ARB:  boolean read self.val and $20000000 <> 0;
    public property HAS_FLAG_MULTISAMPLE_BIT_EXT:  boolean read self.val and $20000000 <> 0;
    public property HAS_FLAG_ALL_ATTRIB_BITS:      boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'CURRENT_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'POINT_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'LINE_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'POLYGON_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'POLYGON_STIPPLE_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'PIXEL_MODE_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'LIGHTING_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'FOG_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'DEPTH_BUFFER_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'ACCUM_BUFFER_BIT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'STENCIL_BUFFER_BIT+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'VIEWPORT_BIT+';
      if self.val and UInt32($1000) = UInt32($1000) then res += 'TRANSFORM_BIT+';
      if self.val and UInt32($2000) = UInt32($2000) then res += 'ENABLE_BIT+';
      if self.val and UInt32($4000) = UInt32($4000) then res += 'COLOR_BUFFER_BIT+';
      if self.val and UInt32($8000) = UInt32($8000) then res += 'HINT_BIT+';
      if self.val and UInt32($10000) = UInt32($10000) then res += 'EVAL_BIT+';
      if self.val and UInt32($20000) = UInt32($20000) then res += 'LIST_BIT+';
      if self.val and UInt32($40000) = UInt32($40000) then res += 'TEXTURE_BIT+';
      if self.val and UInt32($80000) = UInt32($80000) then res += 'SCISSOR_BIT+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'MULTISAMPLE_BIT+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'MULTISAMPLE_BIT_3DFX+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'MULTISAMPLE_BIT_ARB+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'MULTISAMPLE_BIT_EXT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_ATTRIB_BITS+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  AttributeType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _INT                                       := new AttributeType($1404);
    private static _UNSIGNED_INT                              := new AttributeType($1405);
    private static _FLOAT                                     := new AttributeType($1406);
    private static _DOUBLE                                    := new AttributeType($140A);
    private static _INT64_ARB                                 := new AttributeType($140E);
    private static _INT64_NV                                  := new AttributeType($140E);
    private static _UNSIGNED_INT64_ARB                        := new AttributeType($140F);
    private static _UNSIGNED_INT64_NV                         := new AttributeType($140F);
    private static _FLOAT_VEC2                                := new AttributeType($8B50);
    private static _FLOAT_VEC2_ARB                            := new AttributeType($8B50);
    private static _FLOAT_VEC3                                := new AttributeType($8B51);
    private static _FLOAT_VEC3_ARB                            := new AttributeType($8B51);
    private static _FLOAT_VEC4                                := new AttributeType($8B52);
    private static _FLOAT_VEC4_ARB                            := new AttributeType($8B52);
    private static _INT_VEC2                                  := new AttributeType($8B53);
    private static _INT_VEC2_ARB                              := new AttributeType($8B53);
    private static _INT_VEC3                                  := new AttributeType($8B54);
    private static _INT_VEC3_ARB                              := new AttributeType($8B54);
    private static _INT_VEC4                                  := new AttributeType($8B55);
    private static _INT_VEC4_ARB                              := new AttributeType($8B55);
    private static _BOOL                                      := new AttributeType($8B56);
    private static _BOOL_ARB                                  := new AttributeType($8B56);
    private static _BOOL_VEC2                                 := new AttributeType($8B57);
    private static _BOOL_VEC2_ARB                             := new AttributeType($8B57);
    private static _BOOL_VEC3                                 := new AttributeType($8B58);
    private static _BOOL_VEC3_ARB                             := new AttributeType($8B58);
    private static _BOOL_VEC4                                 := new AttributeType($8B59);
    private static _BOOL_VEC4_ARB                             := new AttributeType($8B59);
    private static _FLOAT_MAT2                                := new AttributeType($8B5A);
    private static _FLOAT_MAT2_ARB                            := new AttributeType($8B5A);
    private static _FLOAT_MAT3                                := new AttributeType($8B5B);
    private static _FLOAT_MAT3_ARB                            := new AttributeType($8B5B);
    private static _FLOAT_MAT4                                := new AttributeType($8B5C);
    private static _FLOAT_MAT4_ARB                            := new AttributeType($8B5C);
    private static _SAMPLER_1D                                := new AttributeType($8B5D);
    private static _SAMPLER_1D_ARB                            := new AttributeType($8B5D);
    private static _SAMPLER_2D                                := new AttributeType($8B5E);
    private static _SAMPLER_2D_ARB                            := new AttributeType($8B5E);
    private static _SAMPLER_3D                                := new AttributeType($8B5F);
    private static _SAMPLER_3D_ARB                            := new AttributeType($8B5F);
    private static _SAMPLER_3D_OES                            := new AttributeType($8B5F);
    private static _SAMPLER_CUBE                              := new AttributeType($8B60);
    private static _SAMPLER_CUBE_ARB                          := new AttributeType($8B60);
    private static _SAMPLER_1D_SHADOW                         := new AttributeType($8B61);
    private static _SAMPLER_1D_SHADOW_ARB                     := new AttributeType($8B61);
    private static _SAMPLER_2D_SHADOW                         := new AttributeType($8B62);
    private static _SAMPLER_2D_SHADOW_ARB                     := new AttributeType($8B62);
    private static _SAMPLER_2D_SHADOW_EXT                     := new AttributeType($8B62);
    private static _SAMPLER_2D_RECT                           := new AttributeType($8B63);
    private static _SAMPLER_2D_RECT_ARB                       := new AttributeType($8B63);
    private static _SAMPLER_2D_RECT_SHADOW                    := new AttributeType($8B64);
    private static _SAMPLER_2D_RECT_SHADOW_ARB                := new AttributeType($8B64);
    private static _FLOAT_MAT2x3                              := new AttributeType($8B65);
    private static _FLOAT_MAT2x3_NV                           := new AttributeType($8B65);
    private static _FLOAT_MAT2x4                              := new AttributeType($8B66);
    private static _FLOAT_MAT2x4_NV                           := new AttributeType($8B66);
    private static _FLOAT_MAT3x2                              := new AttributeType($8B67);
    private static _FLOAT_MAT3x2_NV                           := new AttributeType($8B67);
    private static _FLOAT_MAT3x4                              := new AttributeType($8B68);
    private static _FLOAT_MAT3x4_NV                           := new AttributeType($8B68);
    private static _FLOAT_MAT4x2                              := new AttributeType($8B69);
    private static _FLOAT_MAT4x2_NV                           := new AttributeType($8B69);
    private static _FLOAT_MAT4x3                              := new AttributeType($8B6A);
    private static _FLOAT_MAT4x3_NV                           := new AttributeType($8B6A);
    private static _SAMPLER_BUFFER                            := new AttributeType($8DC2);
    private static _SAMPLER_1D_ARRAY_SHADOW                   := new AttributeType($8DC3);
    private static _SAMPLER_2D_ARRAY_SHADOW                   := new AttributeType($8DC4);
    private static _SAMPLER_CUBE_SHADOW                       := new AttributeType($8DC5);
    private static _UNSIGNED_INT_VEC2                         := new AttributeType($8DC6);
    private static _UNSIGNED_INT_VEC3                         := new AttributeType($8DC7);
    private static _UNSIGNED_INT_VEC4                         := new AttributeType($8DC8);
    private static _INT_SAMPLER_1D                            := new AttributeType($8DC9);
    private static _INT_SAMPLER_2D                            := new AttributeType($8DCA);
    private static _INT_SAMPLER_3D                            := new AttributeType($8DCB);
    private static _INT_SAMPLER_CUBE                          := new AttributeType($8DCC);
    private static _INT_SAMPLER_2D_RECT                       := new AttributeType($8DCD);
    private static _INT_SAMPLER_1D_ARRAY                      := new AttributeType($8DCE);
    private static _INT_SAMPLER_2D_ARRAY                      := new AttributeType($8DCF);
    private static _INT_SAMPLER_BUFFER                        := new AttributeType($8DD0);
    private static _UNSIGNED_INT_SAMPLER_1D                   := new AttributeType($8DD1);
    private static _UNSIGNED_INT_SAMPLER_2D                   := new AttributeType($8DD2);
    private static _UNSIGNED_INT_SAMPLER_3D                   := new AttributeType($8DD3);
    private static _UNSIGNED_INT_SAMPLER_CUBE                 := new AttributeType($8DD4);
    private static _UNSIGNED_INT_SAMPLER_2D_RECT              := new AttributeType($8DD5);
    private static _UNSIGNED_INT_SAMPLER_1D_ARRAY             := new AttributeType($8DD6);
    private static _UNSIGNED_INT_SAMPLER_2D_ARRAY             := new AttributeType($8DD7);
    private static _UNSIGNED_INT_SAMPLER_BUFFER               := new AttributeType($8DD8);
    private static _DOUBLE_MAT2                               := new AttributeType($8F46);
    private static _DOUBLE_MAT3                               := new AttributeType($8F47);
    private static _DOUBLE_MAT4                               := new AttributeType($8F48);
    private static _DOUBLE_MAT2x3                             := new AttributeType($8F49);
    private static _DOUBLE_MAT2x4                             := new AttributeType($8F4A);
    private static _DOUBLE_MAT3x2                             := new AttributeType($8F4B);
    private static _DOUBLE_MAT3x4                             := new AttributeType($8F4C);
    private static _DOUBLE_MAT4x2                             := new AttributeType($8F4D);
    private static _DOUBLE_MAT4x3                             := new AttributeType($8F4E);
    private static _INT64_VEC2_ARB                            := new AttributeType($8FE9);
    private static _INT64_VEC3_ARB                            := new AttributeType($8FEA);
    private static _INT64_VEC4_ARB                            := new AttributeType($8FEB);
    private static _UNSIGNED_INT64_VEC2_ARB                   := new AttributeType($8FF5);
    private static _UNSIGNED_INT64_VEC3_ARB                   := new AttributeType($8FF6);
    private static _UNSIGNED_INT64_VEC4_ARB                   := new AttributeType($8FF7);
    private static _DOUBLE_VEC2                               := new AttributeType($8FFC);
    private static _DOUBLE_VEC3                               := new AttributeType($8FFD);
    private static _DOUBLE_VEC4                               := new AttributeType($8FFE);
    private static _SAMPLER_CUBE_MAP_ARRAY                    := new AttributeType($900C);
    private static _SAMPLER_CUBE_MAP_ARRAY_SHADOW             := new AttributeType($900D);
    private static _INT_SAMPLER_CUBE_MAP_ARRAY                := new AttributeType($900E);
    private static _UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY       := new AttributeType($900F);
    private static _IMAGE_1D                                  := new AttributeType($904C);
    private static _IMAGE_2D                                  := new AttributeType($904D);
    private static _IMAGE_3D                                  := new AttributeType($904E);
    private static _IMAGE_2D_RECT                             := new AttributeType($904F);
    private static _IMAGE_CUBE                                := new AttributeType($9050);
    private static _IMAGE_BUFFER                              := new AttributeType($9051);
    private static _IMAGE_1D_ARRAY                            := new AttributeType($9052);
    private static _IMAGE_2D_ARRAY                            := new AttributeType($9053);
    private static _IMAGE_CUBE_MAP_ARRAY                      := new AttributeType($9054);
    private static _IMAGE_2D_MULTISAMPLE                      := new AttributeType($9055);
    private static _IMAGE_2D_MULTISAMPLE_ARRAY                := new AttributeType($9056);
    private static _INT_IMAGE_1D                              := new AttributeType($9057);
    private static _INT_IMAGE_2D                              := new AttributeType($9058);
    private static _INT_IMAGE_3D                              := new AttributeType($9059);
    private static _INT_IMAGE_2D_RECT                         := new AttributeType($905A);
    private static _INT_IMAGE_CUBE                            := new AttributeType($905B);
    private static _INT_IMAGE_BUFFER                          := new AttributeType($905C);
    private static _INT_IMAGE_1D_ARRAY                        := new AttributeType($905D);
    private static _INT_IMAGE_2D_ARRAY                        := new AttributeType($905E);
    private static _INT_IMAGE_CUBE_MAP_ARRAY                  := new AttributeType($905F);
    private static _INT_IMAGE_2D_MULTISAMPLE                  := new AttributeType($9060);
    private static _INT_IMAGE_2D_MULTISAMPLE_ARRAY            := new AttributeType($9061);
    private static _UNSIGNED_INT_IMAGE_1D                     := new AttributeType($9062);
    private static _UNSIGNED_INT_IMAGE_2D                     := new AttributeType($9063);
    private static _UNSIGNED_INT_IMAGE_3D                     := new AttributeType($9064);
    private static _UNSIGNED_INT_IMAGE_2D_RECT                := new AttributeType($9065);
    private static _UNSIGNED_INT_IMAGE_CUBE                   := new AttributeType($9066);
    private static _UNSIGNED_INT_IMAGE_BUFFER                 := new AttributeType($9067);
    private static _UNSIGNED_INT_IMAGE_1D_ARRAY               := new AttributeType($9068);
    private static _UNSIGNED_INT_IMAGE_2D_ARRAY               := new AttributeType($9069);
    private static _UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY         := new AttributeType($906A);
    private static _UNSIGNED_INT_IMAGE_2D_MULTISAMPLE         := new AttributeType($906B);
    private static _UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY   := new AttributeType($906C);
    private static _SAMPLER_2D_MULTISAMPLE                    := new AttributeType($9108);
    private static _INT_SAMPLER_2D_MULTISAMPLE                := new AttributeType($9109);
    private static _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE       := new AttributeType($910A);
    private static _SAMPLER_2D_MULTISAMPLE_ARRAY              := new AttributeType($910B);
    private static _INT_SAMPLER_2D_MULTISAMPLE_ARRAY          := new AttributeType($910C);
    private static _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY := new AttributeType($910D);
    
    public static property INT:                                       AttributeType read _INT;
    public static property UNSIGNED_INT:                              AttributeType read _UNSIGNED_INT;
    public static property FLOAT:                                     AttributeType read _FLOAT;
    public static property DOUBLE:                                    AttributeType read _DOUBLE;
    public static property INT64_ARB:                                 AttributeType read _INT64_ARB;
    public static property INT64_NV:                                  AttributeType read _INT64_NV;
    public static property UNSIGNED_INT64_ARB:                        AttributeType read _UNSIGNED_INT64_ARB;
    public static property UNSIGNED_INT64_NV:                         AttributeType read _UNSIGNED_INT64_NV;
    public static property FLOAT_VEC2:                                AttributeType read _FLOAT_VEC2;
    public static property FLOAT_VEC2_ARB:                            AttributeType read _FLOAT_VEC2_ARB;
    public static property FLOAT_VEC3:                                AttributeType read _FLOAT_VEC3;
    public static property FLOAT_VEC3_ARB:                            AttributeType read _FLOAT_VEC3_ARB;
    public static property FLOAT_VEC4:                                AttributeType read _FLOAT_VEC4;
    public static property FLOAT_VEC4_ARB:                            AttributeType read _FLOAT_VEC4_ARB;
    public static property INT_VEC2:                                  AttributeType read _INT_VEC2;
    public static property INT_VEC2_ARB:                              AttributeType read _INT_VEC2_ARB;
    public static property INT_VEC3:                                  AttributeType read _INT_VEC3;
    public static property INT_VEC3_ARB:                              AttributeType read _INT_VEC3_ARB;
    public static property INT_VEC4:                                  AttributeType read _INT_VEC4;
    public static property INT_VEC4_ARB:                              AttributeType read _INT_VEC4_ARB;
    public static property BOOL:                                      AttributeType read _BOOL;
    public static property BOOL_ARB:                                  AttributeType read _BOOL_ARB;
    public static property BOOL_VEC2:                                 AttributeType read _BOOL_VEC2;
    public static property BOOL_VEC2_ARB:                             AttributeType read _BOOL_VEC2_ARB;
    public static property BOOL_VEC3:                                 AttributeType read _BOOL_VEC3;
    public static property BOOL_VEC3_ARB:                             AttributeType read _BOOL_VEC3_ARB;
    public static property BOOL_VEC4:                                 AttributeType read _BOOL_VEC4;
    public static property BOOL_VEC4_ARB:                             AttributeType read _BOOL_VEC4_ARB;
    public static property FLOAT_MAT2:                                AttributeType read _FLOAT_MAT2;
    public static property FLOAT_MAT2_ARB:                            AttributeType read _FLOAT_MAT2_ARB;
    public static property FLOAT_MAT3:                                AttributeType read _FLOAT_MAT3;
    public static property FLOAT_MAT3_ARB:                            AttributeType read _FLOAT_MAT3_ARB;
    public static property FLOAT_MAT4:                                AttributeType read _FLOAT_MAT4;
    public static property FLOAT_MAT4_ARB:                            AttributeType read _FLOAT_MAT4_ARB;
    public static property SAMPLER_1D:                                AttributeType read _SAMPLER_1D;
    public static property SAMPLER_1D_ARB:                            AttributeType read _SAMPLER_1D_ARB;
    public static property SAMPLER_2D:                                AttributeType read _SAMPLER_2D;
    public static property SAMPLER_2D_ARB:                            AttributeType read _SAMPLER_2D_ARB;
    public static property SAMPLER_3D:                                AttributeType read _SAMPLER_3D;
    public static property SAMPLER_3D_ARB:                            AttributeType read _SAMPLER_3D_ARB;
    public static property SAMPLER_3D_OES:                            AttributeType read _SAMPLER_3D_OES;
    public static property SAMPLER_CUBE:                              AttributeType read _SAMPLER_CUBE;
    public static property SAMPLER_CUBE_ARB:                          AttributeType read _SAMPLER_CUBE_ARB;
    public static property SAMPLER_1D_SHADOW:                         AttributeType read _SAMPLER_1D_SHADOW;
    public static property SAMPLER_1D_SHADOW_ARB:                     AttributeType read _SAMPLER_1D_SHADOW_ARB;
    public static property SAMPLER_2D_SHADOW:                         AttributeType read _SAMPLER_2D_SHADOW;
    public static property SAMPLER_2D_SHADOW_ARB:                     AttributeType read _SAMPLER_2D_SHADOW_ARB;
    public static property SAMPLER_2D_SHADOW_EXT:                     AttributeType read _SAMPLER_2D_SHADOW_EXT;
    public static property SAMPLER_2D_RECT:                           AttributeType read _SAMPLER_2D_RECT;
    public static property SAMPLER_2D_RECT_ARB:                       AttributeType read _SAMPLER_2D_RECT_ARB;
    public static property SAMPLER_2D_RECT_SHADOW:                    AttributeType read _SAMPLER_2D_RECT_SHADOW;
    public static property SAMPLER_2D_RECT_SHADOW_ARB:                AttributeType read _SAMPLER_2D_RECT_SHADOW_ARB;
    public static property FLOAT_MAT2x3:                              AttributeType read _FLOAT_MAT2x3;
    public static property FLOAT_MAT2x3_NV:                           AttributeType read _FLOAT_MAT2x3_NV;
    public static property FLOAT_MAT2x4:                              AttributeType read _FLOAT_MAT2x4;
    public static property FLOAT_MAT2x4_NV:                           AttributeType read _FLOAT_MAT2x4_NV;
    public static property FLOAT_MAT3x2:                              AttributeType read _FLOAT_MAT3x2;
    public static property FLOAT_MAT3x2_NV:                           AttributeType read _FLOAT_MAT3x2_NV;
    public static property FLOAT_MAT3x4:                              AttributeType read _FLOAT_MAT3x4;
    public static property FLOAT_MAT3x4_NV:                           AttributeType read _FLOAT_MAT3x4_NV;
    public static property FLOAT_MAT4x2:                              AttributeType read _FLOAT_MAT4x2;
    public static property FLOAT_MAT4x2_NV:                           AttributeType read _FLOAT_MAT4x2_NV;
    public static property FLOAT_MAT4x3:                              AttributeType read _FLOAT_MAT4x3;
    public static property FLOAT_MAT4x3_NV:                           AttributeType read _FLOAT_MAT4x3_NV;
    public static property SAMPLER_BUFFER:                            AttributeType read _SAMPLER_BUFFER;
    public static property SAMPLER_1D_ARRAY_SHADOW:                   AttributeType read _SAMPLER_1D_ARRAY_SHADOW;
    public static property SAMPLER_2D_ARRAY_SHADOW:                   AttributeType read _SAMPLER_2D_ARRAY_SHADOW;
    public static property SAMPLER_CUBE_SHADOW:                       AttributeType read _SAMPLER_CUBE_SHADOW;
    public static property UNSIGNED_INT_VEC2:                         AttributeType read _UNSIGNED_INT_VEC2;
    public static property UNSIGNED_INT_VEC3:                         AttributeType read _UNSIGNED_INT_VEC3;
    public static property UNSIGNED_INT_VEC4:                         AttributeType read _UNSIGNED_INT_VEC4;
    public static property INT_SAMPLER_1D:                            AttributeType read _INT_SAMPLER_1D;
    public static property INT_SAMPLER_2D:                            AttributeType read _INT_SAMPLER_2D;
    public static property INT_SAMPLER_3D:                            AttributeType read _INT_SAMPLER_3D;
    public static property INT_SAMPLER_CUBE:                          AttributeType read _INT_SAMPLER_CUBE;
    public static property INT_SAMPLER_2D_RECT:                       AttributeType read _INT_SAMPLER_2D_RECT;
    public static property INT_SAMPLER_1D_ARRAY:                      AttributeType read _INT_SAMPLER_1D_ARRAY;
    public static property INT_SAMPLER_2D_ARRAY:                      AttributeType read _INT_SAMPLER_2D_ARRAY;
    public static property INT_SAMPLER_BUFFER:                        AttributeType read _INT_SAMPLER_BUFFER;
    public static property UNSIGNED_INT_SAMPLER_1D:                   AttributeType read _UNSIGNED_INT_SAMPLER_1D;
    public static property UNSIGNED_INT_SAMPLER_2D:                   AttributeType read _UNSIGNED_INT_SAMPLER_2D;
    public static property UNSIGNED_INT_SAMPLER_3D:                   AttributeType read _UNSIGNED_INT_SAMPLER_3D;
    public static property UNSIGNED_INT_SAMPLER_CUBE:                 AttributeType read _UNSIGNED_INT_SAMPLER_CUBE;
    public static property UNSIGNED_INT_SAMPLER_2D_RECT:              AttributeType read _UNSIGNED_INT_SAMPLER_2D_RECT;
    public static property UNSIGNED_INT_SAMPLER_1D_ARRAY:             AttributeType read _UNSIGNED_INT_SAMPLER_1D_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_2D_ARRAY:             AttributeType read _UNSIGNED_INT_SAMPLER_2D_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_BUFFER:               AttributeType read _UNSIGNED_INT_SAMPLER_BUFFER;
    public static property DOUBLE_MAT2:                               AttributeType read _DOUBLE_MAT2;
    public static property DOUBLE_MAT3:                               AttributeType read _DOUBLE_MAT3;
    public static property DOUBLE_MAT4:                               AttributeType read _DOUBLE_MAT4;
    public static property DOUBLE_MAT2x3:                             AttributeType read _DOUBLE_MAT2x3;
    public static property DOUBLE_MAT2x4:                             AttributeType read _DOUBLE_MAT2x4;
    public static property DOUBLE_MAT3x2:                             AttributeType read _DOUBLE_MAT3x2;
    public static property DOUBLE_MAT3x4:                             AttributeType read _DOUBLE_MAT3x4;
    public static property DOUBLE_MAT4x2:                             AttributeType read _DOUBLE_MAT4x2;
    public static property DOUBLE_MAT4x3:                             AttributeType read _DOUBLE_MAT4x3;
    public static property INT64_VEC2_ARB:                            AttributeType read _INT64_VEC2_ARB;
    public static property INT64_VEC3_ARB:                            AttributeType read _INT64_VEC3_ARB;
    public static property INT64_VEC4_ARB:                            AttributeType read _INT64_VEC4_ARB;
    public static property UNSIGNED_INT64_VEC2_ARB:                   AttributeType read _UNSIGNED_INT64_VEC2_ARB;
    public static property UNSIGNED_INT64_VEC3_ARB:                   AttributeType read _UNSIGNED_INT64_VEC3_ARB;
    public static property UNSIGNED_INT64_VEC4_ARB:                   AttributeType read _UNSIGNED_INT64_VEC4_ARB;
    public static property DOUBLE_VEC2:                               AttributeType read _DOUBLE_VEC2;
    public static property DOUBLE_VEC3:                               AttributeType read _DOUBLE_VEC3;
    public static property DOUBLE_VEC4:                               AttributeType read _DOUBLE_VEC4;
    public static property SAMPLER_CUBE_MAP_ARRAY:                    AttributeType read _SAMPLER_CUBE_MAP_ARRAY;
    public static property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             AttributeType read _SAMPLER_CUBE_MAP_ARRAY_SHADOW;
    public static property INT_SAMPLER_CUBE_MAP_ARRAY:                AttributeType read _INT_SAMPLER_CUBE_MAP_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       AttributeType read _UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY;
    public static property IMAGE_1D:                                  AttributeType read _IMAGE_1D;
    public static property IMAGE_2D:                                  AttributeType read _IMAGE_2D;
    public static property IMAGE_3D:                                  AttributeType read _IMAGE_3D;
    public static property IMAGE_2D_RECT:                             AttributeType read _IMAGE_2D_RECT;
    public static property IMAGE_CUBE:                                AttributeType read _IMAGE_CUBE;
    public static property IMAGE_BUFFER:                              AttributeType read _IMAGE_BUFFER;
    public static property IMAGE_1D_ARRAY:                            AttributeType read _IMAGE_1D_ARRAY;
    public static property IMAGE_2D_ARRAY:                            AttributeType read _IMAGE_2D_ARRAY;
    public static property IMAGE_CUBE_MAP_ARRAY:                      AttributeType read _IMAGE_CUBE_MAP_ARRAY;
    public static property IMAGE_2D_MULTISAMPLE:                      AttributeType read _IMAGE_2D_MULTISAMPLE;
    public static property IMAGE_2D_MULTISAMPLE_ARRAY:                AttributeType read _IMAGE_2D_MULTISAMPLE_ARRAY;
    public static property INT_IMAGE_1D:                              AttributeType read _INT_IMAGE_1D;
    public static property INT_IMAGE_2D:                              AttributeType read _INT_IMAGE_2D;
    public static property INT_IMAGE_3D:                              AttributeType read _INT_IMAGE_3D;
    public static property INT_IMAGE_2D_RECT:                         AttributeType read _INT_IMAGE_2D_RECT;
    public static property INT_IMAGE_CUBE:                            AttributeType read _INT_IMAGE_CUBE;
    public static property INT_IMAGE_BUFFER:                          AttributeType read _INT_IMAGE_BUFFER;
    public static property INT_IMAGE_1D_ARRAY:                        AttributeType read _INT_IMAGE_1D_ARRAY;
    public static property INT_IMAGE_2D_ARRAY:                        AttributeType read _INT_IMAGE_2D_ARRAY;
    public static property INT_IMAGE_CUBE_MAP_ARRAY:                  AttributeType read _INT_IMAGE_CUBE_MAP_ARRAY;
    public static property INT_IMAGE_2D_MULTISAMPLE:                  AttributeType read _INT_IMAGE_2D_MULTISAMPLE;
    public static property INT_IMAGE_2D_MULTISAMPLE_ARRAY:            AttributeType read _INT_IMAGE_2D_MULTISAMPLE_ARRAY;
    public static property UNSIGNED_INT_IMAGE_1D:                     AttributeType read _UNSIGNED_INT_IMAGE_1D;
    public static property UNSIGNED_INT_IMAGE_2D:                     AttributeType read _UNSIGNED_INT_IMAGE_2D;
    public static property UNSIGNED_INT_IMAGE_3D:                     AttributeType read _UNSIGNED_INT_IMAGE_3D;
    public static property UNSIGNED_INT_IMAGE_2D_RECT:                AttributeType read _UNSIGNED_INT_IMAGE_2D_RECT;
    public static property UNSIGNED_INT_IMAGE_CUBE:                   AttributeType read _UNSIGNED_INT_IMAGE_CUBE;
    public static property UNSIGNED_INT_IMAGE_BUFFER:                 AttributeType read _UNSIGNED_INT_IMAGE_BUFFER;
    public static property UNSIGNED_INT_IMAGE_1D_ARRAY:               AttributeType read _UNSIGNED_INT_IMAGE_1D_ARRAY;
    public static property UNSIGNED_INT_IMAGE_2D_ARRAY:               AttributeType read _UNSIGNED_INT_IMAGE_2D_ARRAY;
    public static property UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY:         AttributeType read _UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY;
    public static property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE:         AttributeType read _UNSIGNED_INT_IMAGE_2D_MULTISAMPLE;
    public static property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY:   AttributeType read _UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY;
    public static property SAMPLER_2D_MULTISAMPLE:                    AttributeType read _SAMPLER_2D_MULTISAMPLE;
    public static property INT_SAMPLER_2D_MULTISAMPLE:                AttributeType read _INT_SAMPLER_2D_MULTISAMPLE;
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       AttributeType read _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE;
    public static property SAMPLER_2D_MULTISAMPLE_ARRAY:              AttributeType read _SAMPLER_2D_MULTISAMPLE_ARRAY;
    public static property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          AttributeType read _INT_SAMPLER_2D_MULTISAMPLE_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: AttributeType read _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140E) then Result := 'INT64_ARB' else
      if self.val = UInt32($140E) then Result := 'INT64_NV' else
      if self.val = UInt32($140F) then Result := 'UNSIGNED_INT64_ARB' else
      if self.val = UInt32($140F) then Result := 'UNSIGNED_INT64_NV' else
      if self.val = UInt32($8B50) then Result := 'FLOAT_VEC2' else
      if self.val = UInt32($8B50) then Result := 'FLOAT_VEC2_ARB' else
      if self.val = UInt32($8B51) then Result := 'FLOAT_VEC3' else
      if self.val = UInt32($8B51) then Result := 'FLOAT_VEC3_ARB' else
      if self.val = UInt32($8B52) then Result := 'FLOAT_VEC4' else
      if self.val = UInt32($8B52) then Result := 'FLOAT_VEC4_ARB' else
      if self.val = UInt32($8B53) then Result := 'INT_VEC2' else
      if self.val = UInt32($8B53) then Result := 'INT_VEC2_ARB' else
      if self.val = UInt32($8B54) then Result := 'INT_VEC3' else
      if self.val = UInt32($8B54) then Result := 'INT_VEC3_ARB' else
      if self.val = UInt32($8B55) then Result := 'INT_VEC4' else
      if self.val = UInt32($8B55) then Result := 'INT_VEC4_ARB' else
      if self.val = UInt32($8B56) then Result := 'BOOL' else
      if self.val = UInt32($8B56) then Result := 'BOOL_ARB' else
      if self.val = UInt32($8B57) then Result := 'BOOL_VEC2' else
      if self.val = UInt32($8B57) then Result := 'BOOL_VEC2_ARB' else
      if self.val = UInt32($8B58) then Result := 'BOOL_VEC3' else
      if self.val = UInt32($8B58) then Result := 'BOOL_VEC3_ARB' else
      if self.val = UInt32($8B59) then Result := 'BOOL_VEC4' else
      if self.val = UInt32($8B59) then Result := 'BOOL_VEC4_ARB' else
      if self.val = UInt32($8B5A) then Result := 'FLOAT_MAT2' else
      if self.val = UInt32($8B5A) then Result := 'FLOAT_MAT2_ARB' else
      if self.val = UInt32($8B5B) then Result := 'FLOAT_MAT3' else
      if self.val = UInt32($8B5B) then Result := 'FLOAT_MAT3_ARB' else
      if self.val = UInt32($8B5C) then Result := 'FLOAT_MAT4' else
      if self.val = UInt32($8B5C) then Result := 'FLOAT_MAT4_ARB' else
      if self.val = UInt32($8B5D) then Result := 'SAMPLER_1D' else
      if self.val = UInt32($8B5D) then Result := 'SAMPLER_1D_ARB' else
      if self.val = UInt32($8B5E) then Result := 'SAMPLER_2D' else
      if self.val = UInt32($8B5E) then Result := 'SAMPLER_2D_ARB' else
      if self.val = UInt32($8B5F) then Result := 'SAMPLER_3D' else
      if self.val = UInt32($8B5F) then Result := 'SAMPLER_3D_ARB' else
      if self.val = UInt32($8B5F) then Result := 'SAMPLER_3D_OES' else
      if self.val = UInt32($8B60) then Result := 'SAMPLER_CUBE' else
      if self.val = UInt32($8B60) then Result := 'SAMPLER_CUBE_ARB' else
      if self.val = UInt32($8B61) then Result := 'SAMPLER_1D_SHADOW' else
      if self.val = UInt32($8B61) then Result := 'SAMPLER_1D_SHADOW_ARB' else
      if self.val = UInt32($8B62) then Result := 'SAMPLER_2D_SHADOW' else
      if self.val = UInt32($8B62) then Result := 'SAMPLER_2D_SHADOW_ARB' else
      if self.val = UInt32($8B62) then Result := 'SAMPLER_2D_SHADOW_EXT' else
      if self.val = UInt32($8B63) then Result := 'SAMPLER_2D_RECT' else
      if self.val = UInt32($8B63) then Result := 'SAMPLER_2D_RECT_ARB' else
      if self.val = UInt32($8B64) then Result := 'SAMPLER_2D_RECT_SHADOW' else
      if self.val = UInt32($8B64) then Result := 'SAMPLER_2D_RECT_SHADOW_ARB' else
      if self.val = UInt32($8B65) then Result := 'FLOAT_MAT2x3' else
      if self.val = UInt32($8B65) then Result := 'FLOAT_MAT2x3_NV' else
      if self.val = UInt32($8B66) then Result := 'FLOAT_MAT2x4' else
      if self.val = UInt32($8B66) then Result := 'FLOAT_MAT2x4_NV' else
      if self.val = UInt32($8B67) then Result := 'FLOAT_MAT3x2' else
      if self.val = UInt32($8B67) then Result := 'FLOAT_MAT3x2_NV' else
      if self.val = UInt32($8B68) then Result := 'FLOAT_MAT3x4' else
      if self.val = UInt32($8B68) then Result := 'FLOAT_MAT3x4_NV' else
      if self.val = UInt32($8B69) then Result := 'FLOAT_MAT4x2' else
      if self.val = UInt32($8B69) then Result := 'FLOAT_MAT4x2_NV' else
      if self.val = UInt32($8B6A) then Result := 'FLOAT_MAT4x3' else
      if self.val = UInt32($8B6A) then Result := 'FLOAT_MAT4x3_NV' else
      if self.val = UInt32($8DC2) then Result := 'SAMPLER_BUFFER' else
      if self.val = UInt32($8DC3) then Result := 'SAMPLER_1D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC4) then Result := 'SAMPLER_2D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC5) then Result := 'SAMPLER_CUBE_SHADOW' else
      if self.val = UInt32($8DC6) then Result := 'UNSIGNED_INT_VEC2' else
      if self.val = UInt32($8DC7) then Result := 'UNSIGNED_INT_VEC3' else
      if self.val = UInt32($8DC8) then Result := 'UNSIGNED_INT_VEC4' else
      if self.val = UInt32($8DC9) then Result := 'INT_SAMPLER_1D' else
      if self.val = UInt32($8DCA) then Result := 'INT_SAMPLER_2D' else
      if self.val = UInt32($8DCB) then Result := 'INT_SAMPLER_3D' else
      if self.val = UInt32($8DCC) then Result := 'INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DCD) then Result := 'INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DCE) then Result := 'INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DCF) then Result := 'INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD0) then Result := 'INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8DD1) then Result := 'UNSIGNED_INT_SAMPLER_1D' else
      if self.val = UInt32($8DD2) then Result := 'UNSIGNED_INT_SAMPLER_2D' else
      if self.val = UInt32($8DD3) then Result := 'UNSIGNED_INT_SAMPLER_3D' else
      if self.val = UInt32($8DD4) then Result := 'UNSIGNED_INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DD5) then Result := 'UNSIGNED_INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DD6) then Result := 'UNSIGNED_INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DD7) then Result := 'UNSIGNED_INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD8) then Result := 'UNSIGNED_INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8F46) then Result := 'DOUBLE_MAT2' else
      if self.val = UInt32($8F47) then Result := 'DOUBLE_MAT3' else
      if self.val = UInt32($8F48) then Result := 'DOUBLE_MAT4' else
      if self.val = UInt32($8F49) then Result := 'DOUBLE_MAT2x3' else
      if self.val = UInt32($8F4A) then Result := 'DOUBLE_MAT2x4' else
      if self.val = UInt32($8F4B) then Result := 'DOUBLE_MAT3x2' else
      if self.val = UInt32($8F4C) then Result := 'DOUBLE_MAT3x4' else
      if self.val = UInt32($8F4D) then Result := 'DOUBLE_MAT4x2' else
      if self.val = UInt32($8F4E) then Result := 'DOUBLE_MAT4x3' else
      if self.val = UInt32($8FE9) then Result := 'INT64_VEC2_ARB' else
      if self.val = UInt32($8FEA) then Result := 'INT64_VEC3_ARB' else
      if self.val = UInt32($8FEB) then Result := 'INT64_VEC4_ARB' else
      if self.val = UInt32($8FF5) then Result := 'UNSIGNED_INT64_VEC2_ARB' else
      if self.val = UInt32($8FF6) then Result := 'UNSIGNED_INT64_VEC3_ARB' else
      if self.val = UInt32($8FF7) then Result := 'UNSIGNED_INT64_VEC4_ARB' else
      if self.val = UInt32($8FFC) then Result := 'DOUBLE_VEC2' else
      if self.val = UInt32($8FFD) then Result := 'DOUBLE_VEC3' else
      if self.val = UInt32($8FFE) then Result := 'DOUBLE_VEC4' else
      if self.val = UInt32($900C) then Result := 'SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900D) then Result := 'SAMPLER_CUBE_MAP_ARRAY_SHADOW' else
      if self.val = UInt32($900E) then Result := 'INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900F) then Result := 'UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($904C) then Result := 'IMAGE_1D' else
      if self.val = UInt32($904D) then Result := 'IMAGE_2D' else
      if self.val = UInt32($904E) then Result := 'IMAGE_3D' else
      if self.val = UInt32($904F) then Result := 'IMAGE_2D_RECT' else
      if self.val = UInt32($9050) then Result := 'IMAGE_CUBE' else
      if self.val = UInt32($9051) then Result := 'IMAGE_BUFFER' else
      if self.val = UInt32($9052) then Result := 'IMAGE_1D_ARRAY' else
      if self.val = UInt32($9053) then Result := 'IMAGE_2D_ARRAY' else
      if self.val = UInt32($9054) then Result := 'IMAGE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9055) then Result := 'IMAGE_2D_MULTISAMPLE' else
      if self.val = UInt32($9056) then Result := 'IMAGE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9057) then Result := 'INT_IMAGE_1D' else
      if self.val = UInt32($9058) then Result := 'INT_IMAGE_2D' else
      if self.val = UInt32($9059) then Result := 'INT_IMAGE_3D' else
      if self.val = UInt32($905A) then Result := 'INT_IMAGE_2D_RECT' else
      if self.val = UInt32($905B) then Result := 'INT_IMAGE_CUBE' else
      if self.val = UInt32($905C) then Result := 'INT_IMAGE_BUFFER' else
      if self.val = UInt32($905D) then Result := 'INT_IMAGE_1D_ARRAY' else
      if self.val = UInt32($905E) then Result := 'INT_IMAGE_2D_ARRAY' else
      if self.val = UInt32($905F) then Result := 'INT_IMAGE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9060) then Result := 'INT_IMAGE_2D_MULTISAMPLE' else
      if self.val = UInt32($9061) then Result := 'INT_IMAGE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9062) then Result := 'UNSIGNED_INT_IMAGE_1D' else
      if self.val = UInt32($9063) then Result := 'UNSIGNED_INT_IMAGE_2D' else
      if self.val = UInt32($9064) then Result := 'UNSIGNED_INT_IMAGE_3D' else
      if self.val = UInt32($9065) then Result := 'UNSIGNED_INT_IMAGE_2D_RECT' else
      if self.val = UInt32($9066) then Result := 'UNSIGNED_INT_IMAGE_CUBE' else
      if self.val = UInt32($9067) then Result := 'UNSIGNED_INT_IMAGE_BUFFER' else
      if self.val = UInt32($9068) then Result := 'UNSIGNED_INT_IMAGE_1D_ARRAY' else
      if self.val = UInt32($9069) then Result := 'UNSIGNED_INT_IMAGE_2D_ARRAY' else
      if self.val = UInt32($906A) then Result := 'UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($906B) then Result := 'UNSIGNED_INT_IMAGE_2D_MULTISAMPLE' else
      if self.val = UInt32($906C) then Result := 'UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9108) then Result := 'SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($9109) then Result := 'INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910A) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910B) then Result := 'SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910C) then Result := 'INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910D) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BindTransformFeedbackTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TRANSFORM_FEEDBACK := new BindTransformFeedbackTarget($8E22);
    
    public static property TRANSFORM_FEEDBACK: BindTransformFeedbackTarget read _TRANSFORM_FEEDBACK;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E22) then Result := 'TRANSFORM_FEEDBACK' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BlendingFactor = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ZERO                     := new BlendingFactor($0000);
    private static _ONE                      := new BlendingFactor($0001);
    private static _SRC_COLOR                := new BlendingFactor($0300);
    private static _ONE_MINUS_SRC_COLOR      := new BlendingFactor($0301);
    private static _SRC_ALPHA                := new BlendingFactor($0302);
    private static _ONE_MINUS_SRC_ALPHA      := new BlendingFactor($0303);
    private static _DST_ALPHA                := new BlendingFactor($0304);
    private static _ONE_MINUS_DST_ALPHA      := new BlendingFactor($0305);
    private static _DST_COLOR                := new BlendingFactor($0306);
    private static _ONE_MINUS_DST_COLOR      := new BlendingFactor($0307);
    private static _SRC_ALPHA_SATURATE       := new BlendingFactor($0308);
    private static _CONSTANT_COLOR           := new BlendingFactor($8001);
    private static _ONE_MINUS_CONSTANT_COLOR := new BlendingFactor($8002);
    private static _CONSTANT_ALPHA           := new BlendingFactor($8003);
    private static _ONE_MINUS_CONSTANT_ALPHA := new BlendingFactor($8004);
    private static _SRC1_ALPHA               := new BlendingFactor($8589);
    private static _SRC1_COLOR               := new BlendingFactor($88F9);
    private static _ONE_MINUS_SRC1_COLOR     := new BlendingFactor($88FA);
    private static _ONE_MINUS_SRC1_ALPHA     := new BlendingFactor($88FB);
    
    public static property ZERO:                     BlendingFactor read _ZERO;
    public static property ONE:                      BlendingFactor read _ONE;
    public static property SRC_COLOR:                BlendingFactor read _SRC_COLOR;
    public static property ONE_MINUS_SRC_COLOR:      BlendingFactor read _ONE_MINUS_SRC_COLOR;
    public static property SRC_ALPHA:                BlendingFactor read _SRC_ALPHA;
    public static property ONE_MINUS_SRC_ALPHA:      BlendingFactor read _ONE_MINUS_SRC_ALPHA;
    public static property DST_ALPHA:                BlendingFactor read _DST_ALPHA;
    public static property ONE_MINUS_DST_ALPHA:      BlendingFactor read _ONE_MINUS_DST_ALPHA;
    public static property DST_COLOR:                BlendingFactor read _DST_COLOR;
    public static property ONE_MINUS_DST_COLOR:      BlendingFactor read _ONE_MINUS_DST_COLOR;
    public static property SRC_ALPHA_SATURATE:       BlendingFactor read _SRC_ALPHA_SATURATE;
    public static property CONSTANT_COLOR:           BlendingFactor read _CONSTANT_COLOR;
    public static property ONE_MINUS_CONSTANT_COLOR: BlendingFactor read _ONE_MINUS_CONSTANT_COLOR;
    public static property CONSTANT_ALPHA:           BlendingFactor read _CONSTANT_ALPHA;
    public static property ONE_MINUS_CONSTANT_ALPHA: BlendingFactor read _ONE_MINUS_CONSTANT_ALPHA;
    public static property SRC1_ALPHA:               BlendingFactor read _SRC1_ALPHA;
    public static property SRC1_COLOR:               BlendingFactor read _SRC1_COLOR;
    public static property ONE_MINUS_SRC1_COLOR:     BlendingFactor read _ONE_MINUS_SRC1_COLOR;
    public static property ONE_MINUS_SRC1_ALPHA:     BlendingFactor read _ONE_MINUS_SRC1_ALPHA;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'ZERO' else
      if self.val = UInt32($0001) then Result := 'ONE' else
      if self.val = UInt32($0300) then Result := 'SRC_COLOR' else
      if self.val = UInt32($0301) then Result := 'ONE_MINUS_SRC_COLOR' else
      if self.val = UInt32($0302) then Result := 'SRC_ALPHA' else
      if self.val = UInt32($0303) then Result := 'ONE_MINUS_SRC_ALPHA' else
      if self.val = UInt32($0304) then Result := 'DST_ALPHA' else
      if self.val = UInt32($0305) then Result := 'ONE_MINUS_DST_ALPHA' else
      if self.val = UInt32($0306) then Result := 'DST_COLOR' else
      if self.val = UInt32($0307) then Result := 'ONE_MINUS_DST_COLOR' else
      if self.val = UInt32($0308) then Result := 'SRC_ALPHA_SATURATE' else
      if self.val = UInt32($8001) then Result := 'CONSTANT_COLOR' else
      if self.val = UInt32($8002) then Result := 'ONE_MINUS_CONSTANT_COLOR' else
      if self.val = UInt32($8003) then Result := 'CONSTANT_ALPHA' else
      if self.val = UInt32($8004) then Result := 'ONE_MINUS_CONSTANT_ALPHA' else
      if self.val = UInt32($8589) then Result := 'SRC1_ALPHA' else
      if self.val = UInt32($88F9) then Result := 'SRC1_COLOR' else
      if self.val = UInt32($88FA) then Result := 'ONE_MINUS_SRC1_COLOR' else
      if self.val = UInt32($88FB) then Result := 'ONE_MINUS_SRC1_ALPHA' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BlitFramebufferFilter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NEAREST := new BlitFramebufferFilter($2600);
    private static _LINEAR  := new BlitFramebufferFilter($2601);
    
    public static property NEAREST: BlitFramebufferFilter read _NEAREST;
    public static property LINEAR:  BlitFramebufferFilter read _LINEAR;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2600) then Result := 'NEAREST' else
      if self.val = UInt32($2601) then Result := 'LINEAR' else
        Result := self.val.ToString;
    end;
    
  end;
  
  Buffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COLOR   := new Buffer($1800);
    private static _DEPTH   := new Buffer($1801);
    private static _STENCIL := new Buffer($1802);
    
    public static property COLOR:   Buffer read _COLOR;
    public static property DEPTH:   Buffer read _DEPTH;
    public static property STENCIL: Buffer read _STENCIL;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1800) then Result := 'COLOR' else
      if self.val = UInt32($1801) then Result := 'DEPTH' else
      if self.val = UInt32($1802) then Result := 'STENCIL' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BufferStorageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MAP_READ_BIT                  := new BufferStorageMask($0001);
    private static _MAP_READ_BIT_EXT              := new BufferStorageMask($0001);
    private static _MAP_WRITE_BIT                 := new BufferStorageMask($0002);
    private static _MAP_WRITE_BIT_EXT             := new BufferStorageMask($0002);
    private static _MAP_PERSISTENT_BIT            := new BufferStorageMask($0040);
    private static _MAP_PERSISTENT_BIT_EXT        := new BufferStorageMask($0040);
    private static _MAP_COHERENT_BIT              := new BufferStorageMask($0080);
    private static _MAP_COHERENT_BIT_EXT          := new BufferStorageMask($0080);
    private static _DYNAMIC_STORAGE_BIT           := new BufferStorageMask($0100);
    private static _DYNAMIC_STORAGE_BIT_EXT       := new BufferStorageMask($0100);
    private static _CLIENT_STORAGE_BIT            := new BufferStorageMask($0200);
    private static _CLIENT_STORAGE_BIT_EXT        := new BufferStorageMask($0200);
    private static _SPARSE_STORAGE_BIT_ARB        := new BufferStorageMask($0400);
    private static _LGPU_SEPARATE_STORAGE_BIT_NVX := new BufferStorageMask($0800);
    private static _PER_GPU_STORAGE_BIT_NV        := new BufferStorageMask($0800);
    private static _EXTERNAL_STORAGE_BIT_NVX      := new BufferStorageMask($2000);
    
    public static property MAP_READ_BIT:                  BufferStorageMask read _MAP_READ_BIT;
    public static property MAP_READ_BIT_EXT:              BufferStorageMask read _MAP_READ_BIT_EXT;
    public static property MAP_WRITE_BIT:                 BufferStorageMask read _MAP_WRITE_BIT;
    public static property MAP_WRITE_BIT_EXT:             BufferStorageMask read _MAP_WRITE_BIT_EXT;
    public static property MAP_PERSISTENT_BIT:            BufferStorageMask read _MAP_PERSISTENT_BIT;
    public static property MAP_PERSISTENT_BIT_EXT:        BufferStorageMask read _MAP_PERSISTENT_BIT_EXT;
    public static property MAP_COHERENT_BIT:              BufferStorageMask read _MAP_COHERENT_BIT;
    public static property MAP_COHERENT_BIT_EXT:          BufferStorageMask read _MAP_COHERENT_BIT_EXT;
    public static property DYNAMIC_STORAGE_BIT:           BufferStorageMask read _DYNAMIC_STORAGE_BIT;
    public static property DYNAMIC_STORAGE_BIT_EXT:       BufferStorageMask read _DYNAMIC_STORAGE_BIT_EXT;
    public static property CLIENT_STORAGE_BIT:            BufferStorageMask read _CLIENT_STORAGE_BIT;
    public static property CLIENT_STORAGE_BIT_EXT:        BufferStorageMask read _CLIENT_STORAGE_BIT_EXT;
    public static property SPARSE_STORAGE_BIT_ARB:        BufferStorageMask read _SPARSE_STORAGE_BIT_ARB;
    public static property LGPU_SEPARATE_STORAGE_BIT_NVX: BufferStorageMask read _LGPU_SEPARATE_STORAGE_BIT_NVX;
    public static property PER_GPU_STORAGE_BIT_NV:        BufferStorageMask read _PER_GPU_STORAGE_BIT_NV;
    public static property EXTERNAL_STORAGE_BIT_NVX:      BufferStorageMask read _EXTERNAL_STORAGE_BIT_NVX;
    
    public static function operator or(f1,f2: BufferStorageMask) := new BufferStorageMask(f1.val or f2.val);
    
    public property HAS_FLAG_MAP_READ_BIT:                  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_MAP_READ_BIT_EXT:              boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_MAP_WRITE_BIT:                 boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_MAP_WRITE_BIT_EXT:             boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_MAP_PERSISTENT_BIT:            boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_MAP_PERSISTENT_BIT_EXT:        boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_MAP_COHERENT_BIT:              boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_MAP_COHERENT_BIT_EXT:          boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_DYNAMIC_STORAGE_BIT:           boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_DYNAMIC_STORAGE_BIT_EXT:       boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_CLIENT_STORAGE_BIT:            boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_CLIENT_STORAGE_BIT_EXT:        boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_SPARSE_STORAGE_BIT_ARB:        boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_LGPU_SEPARATE_STORAGE_BIT_NVX: boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_PER_GPU_STORAGE_BIT_NV:        boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_EXTERNAL_STORAGE_BIT_NVX:      boolean read self.val and $2000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'MAP_READ_BIT+';
      if self.val and UInt32($0001) = UInt32($0001) then res += 'MAP_READ_BIT_EXT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'MAP_WRITE_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'MAP_WRITE_BIT_EXT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MAP_PERSISTENT_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MAP_PERSISTENT_BIT_EXT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'MAP_COHERENT_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'MAP_COHERENT_BIT_EXT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'DYNAMIC_STORAGE_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'DYNAMIC_STORAGE_BIT_EXT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'CLIENT_STORAGE_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'CLIENT_STORAGE_BIT_EXT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'SPARSE_STORAGE_BIT_ARB+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'LGPU_SEPARATE_STORAGE_BIT_NVX+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'PER_GPU_STORAGE_BIT_NV+';
      if self.val and UInt32($2000) = UInt32($2000) then res += 'EXTERNAL_STORAGE_BIT_NVX+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  BufferStorageTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ARRAY_BUFFER              := new BufferStorageTarget($8892);
    private static _ELEMENT_ARRAY_BUFFER      := new BufferStorageTarget($8893);
    private static _PIXEL_PACK_BUFFER         := new BufferStorageTarget($88EB);
    private static _PIXEL_UNPACK_BUFFER       := new BufferStorageTarget($88EC);
    private static _UNIFORM_BUFFER            := new BufferStorageTarget($8A11);
    private static _TEXTURE_BUFFER            := new BufferStorageTarget($8C2A);
    private static _TRANSFORM_FEEDBACK_BUFFER := new BufferStorageTarget($8C8E);
    private static _COPY_READ_BUFFER          := new BufferStorageTarget($8F36);
    private static _COPY_WRITE_BUFFER         := new BufferStorageTarget($8F37);
    private static _DRAW_INDIRECT_BUFFER      := new BufferStorageTarget($8F3F);
    private static _SHADER_STORAGE_BUFFER     := new BufferStorageTarget($90D2);
    private static _DISPATCH_INDIRECT_BUFFER  := new BufferStorageTarget($90EE);
    private static _QUERY_BUFFER              := new BufferStorageTarget($9192);
    private static _ATOMIC_COUNTER_BUFFER     := new BufferStorageTarget($92C0);
    
    public static property ARRAY_BUFFER:              BufferStorageTarget read _ARRAY_BUFFER;
    public static property ELEMENT_ARRAY_BUFFER:      BufferStorageTarget read _ELEMENT_ARRAY_BUFFER;
    public static property PIXEL_PACK_BUFFER:         BufferStorageTarget read _PIXEL_PACK_BUFFER;
    public static property PIXEL_UNPACK_BUFFER:       BufferStorageTarget read _PIXEL_UNPACK_BUFFER;
    public static property UNIFORM_BUFFER:            BufferStorageTarget read _UNIFORM_BUFFER;
    public static property TEXTURE_BUFFER:            BufferStorageTarget read _TEXTURE_BUFFER;
    public static property TRANSFORM_FEEDBACK_BUFFER: BufferStorageTarget read _TRANSFORM_FEEDBACK_BUFFER;
    public static property COPY_READ_BUFFER:          BufferStorageTarget read _COPY_READ_BUFFER;
    public static property COPY_WRITE_BUFFER:         BufferStorageTarget read _COPY_WRITE_BUFFER;
    public static property DRAW_INDIRECT_BUFFER:      BufferStorageTarget read _DRAW_INDIRECT_BUFFER;
    public static property SHADER_STORAGE_BUFFER:     BufferStorageTarget read _SHADER_STORAGE_BUFFER;
    public static property DISPATCH_INDIRECT_BUFFER:  BufferStorageTarget read _DISPATCH_INDIRECT_BUFFER;
    public static property QUERY_BUFFER:              BufferStorageTarget read _QUERY_BUFFER;
    public static property ATOMIC_COUNTER_BUFFER:     BufferStorageTarget read _ATOMIC_COUNTER_BUFFER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8892) then Result := 'ARRAY_BUFFER' else
      if self.val = UInt32($8893) then Result := 'ELEMENT_ARRAY_BUFFER' else
      if self.val = UInt32($88EB) then Result := 'PIXEL_PACK_BUFFER' else
      if self.val = UInt32($88EC) then Result := 'PIXEL_UNPACK_BUFFER' else
      if self.val = UInt32($8A11) then Result := 'UNIFORM_BUFFER' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($8F36) then Result := 'COPY_READ_BUFFER' else
      if self.val = UInt32($8F37) then Result := 'COPY_WRITE_BUFFER' else
      if self.val = UInt32($8F3F) then Result := 'DRAW_INDIRECT_BUFFER' else
      if self.val = UInt32($90D2) then Result := 'SHADER_STORAGE_BUFFER' else
      if self.val = UInt32($90EE) then Result := 'DISPATCH_INDIRECT_BUFFER' else
      if self.val = UInt32($9192) then Result := 'QUERY_BUFFER' else
      if self.val = UInt32($92C0) then Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ClearBufferMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DEPTH_BUFFER_BIT       := new ClearBufferMask($0100);
    private static _ACCUM_BUFFER_BIT       := new ClearBufferMask($0200);
    private static _STENCIL_BUFFER_BIT     := new ClearBufferMask($0400);
    private static _COLOR_BUFFER_BIT       := new ClearBufferMask($4000);
    private static _COVERAGE_BUFFER_BIT_NV := new ClearBufferMask($8000);
    
    public static property DEPTH_BUFFER_BIT:       ClearBufferMask read _DEPTH_BUFFER_BIT;
    public static property ACCUM_BUFFER_BIT:       ClearBufferMask read _ACCUM_BUFFER_BIT;
    public static property STENCIL_BUFFER_BIT:     ClearBufferMask read _STENCIL_BUFFER_BIT;
    public static property COLOR_BUFFER_BIT:       ClearBufferMask read _COLOR_BUFFER_BIT;
    public static property COVERAGE_BUFFER_BIT_NV: ClearBufferMask read _COVERAGE_BUFFER_BIT_NV;
    
    public static function operator or(f1,f2: ClearBufferMask) := new ClearBufferMask(f1.val or f2.val);
    
    public property HAS_FLAG_DEPTH_BUFFER_BIT:       boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_ACCUM_BUFFER_BIT:       boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_STENCIL_BUFFER_BIT:     boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_COLOR_BUFFER_BIT:       boolean read self.val and $4000 <> 0;
    public property HAS_FLAG_COVERAGE_BUFFER_BIT_NV: boolean read self.val and $8000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0100) = UInt32($0100) then res += 'DEPTH_BUFFER_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'ACCUM_BUFFER_BIT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'STENCIL_BUFFER_BIT+';
      if self.val and UInt32($4000) = UInt32($4000) then res += 'COLOR_BUFFER_BIT+';
      if self.val and UInt32($8000) = UInt32($8000) then res += 'COVERAGE_BUFFER_BIT_NV+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  ClientAttribMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CLIENT_PIXEL_STORE_BIT  := new ClientAttribMask($0001);
    private static _CLIENT_VERTEX_ARRAY_BIT := new ClientAttribMask($0002);
    private static _CLIENT_ALL_ATTRIB_BITS  := new ClientAttribMask($FFFFFFFF);
    
    public static property CLIENT_PIXEL_STORE_BIT:  ClientAttribMask read _CLIENT_PIXEL_STORE_BIT;
    public static property CLIENT_VERTEX_ARRAY_BIT: ClientAttribMask read _CLIENT_VERTEX_ARRAY_BIT;
    public static property CLIENT_ALL_ATTRIB_BITS:  ClientAttribMask read _CLIENT_ALL_ATTRIB_BITS;
    
    public static function operator or(f1,f2: ClientAttribMask) := new ClientAttribMask(f1.val or f2.val);
    
    public property HAS_FLAG_CLIENT_PIXEL_STORE_BIT:  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_CLIENT_VERTEX_ARRAY_BIT: boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_CLIENT_ALL_ATTRIB_BITS:  boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'CLIENT_PIXEL_STORE_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'CLIENT_VERTEX_ARRAY_BIT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'CLIENT_ALL_ATTRIB_BITS+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  ClipControlDepth = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NEGATIVE_ONE_TO_ONE := new ClipControlDepth($935E);
    private static _ZERO_TO_ONE         := new ClipControlDepth($935F);
    
    public static property NEGATIVE_ONE_TO_ONE: ClipControlDepth read _NEGATIVE_ONE_TO_ONE;
    public static property ZERO_TO_ONE:         ClipControlDepth read _ZERO_TO_ONE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($935E) then Result := 'NEGATIVE_ONE_TO_ONE' else
      if self.val = UInt32($935F) then Result := 'ZERO_TO_ONE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ClipControlOrigin = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _LOWER_LEFT := new ClipControlOrigin($8CA1);
    private static _UPPER_LEFT := new ClipControlOrigin($8CA2);
    
    public static property LOWER_LEFT: ClipControlOrigin read _LOWER_LEFT;
    public static property UPPER_LEFT: ClipControlOrigin read _UPPER_LEFT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8CA1) then Result := 'LOWER_LEFT' else
      if self.val = UInt32($8CA2) then Result := 'UPPER_LEFT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ClipPlaneName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CLIP_DISTANCE0 := new ClipPlaneName($3000);
    private static _CLIP_PLANE0    := new ClipPlaneName($3000);
    private static _CLIP_DISTANCE1 := new ClipPlaneName($3001);
    private static _CLIP_PLANE1    := new ClipPlaneName($3001);
    private static _CLIP_DISTANCE2 := new ClipPlaneName($3002);
    private static _CLIP_PLANE2    := new ClipPlaneName($3002);
    private static _CLIP_DISTANCE3 := new ClipPlaneName($3003);
    private static _CLIP_PLANE3    := new ClipPlaneName($3003);
    private static _CLIP_DISTANCE4 := new ClipPlaneName($3004);
    private static _CLIP_PLANE4    := new ClipPlaneName($3004);
    private static _CLIP_DISTANCE5 := new ClipPlaneName($3005);
    private static _CLIP_PLANE5    := new ClipPlaneName($3005);
    private static _CLIP_DISTANCE6 := new ClipPlaneName($3006);
    private static _CLIP_DISTANCE7 := new ClipPlaneName($3007);
    
    public static property CLIP_DISTANCE0: ClipPlaneName read _CLIP_DISTANCE0;
    public static property CLIP_PLANE0:    ClipPlaneName read _CLIP_PLANE0;
    public static property CLIP_DISTANCE1: ClipPlaneName read _CLIP_DISTANCE1;
    public static property CLIP_PLANE1:    ClipPlaneName read _CLIP_PLANE1;
    public static property CLIP_DISTANCE2: ClipPlaneName read _CLIP_DISTANCE2;
    public static property CLIP_PLANE2:    ClipPlaneName read _CLIP_PLANE2;
    public static property CLIP_DISTANCE3: ClipPlaneName read _CLIP_DISTANCE3;
    public static property CLIP_PLANE3:    ClipPlaneName read _CLIP_PLANE3;
    public static property CLIP_DISTANCE4: ClipPlaneName read _CLIP_DISTANCE4;
    public static property CLIP_PLANE4:    ClipPlaneName read _CLIP_PLANE4;
    public static property CLIP_DISTANCE5: ClipPlaneName read _CLIP_DISTANCE5;
    public static property CLIP_PLANE5:    ClipPlaneName read _CLIP_PLANE5;
    public static property CLIP_DISTANCE6: ClipPlaneName read _CLIP_DISTANCE6;
    public static property CLIP_DISTANCE7: ClipPlaneName read _CLIP_DISTANCE7;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($3000) then Result := 'CLIP_DISTANCE0' else
      if self.val = UInt32($3000) then Result := 'CLIP_PLANE0' else
      if self.val = UInt32($3001) then Result := 'CLIP_DISTANCE1' else
      if self.val = UInt32($3001) then Result := 'CLIP_PLANE1' else
      if self.val = UInt32($3002) then Result := 'CLIP_DISTANCE2' else
      if self.val = UInt32($3002) then Result := 'CLIP_PLANE2' else
      if self.val = UInt32($3003) then Result := 'CLIP_DISTANCE3' else
      if self.val = UInt32($3003) then Result := 'CLIP_PLANE3' else
      if self.val = UInt32($3004) then Result := 'CLIP_DISTANCE4' else
      if self.val = UInt32($3004) then Result := 'CLIP_PLANE4' else
      if self.val = UInt32($3005) then Result := 'CLIP_DISTANCE5' else
      if self.val = UInt32($3005) then Result := 'CLIP_PLANE5' else
      if self.val = UInt32($3006) then Result := 'CLIP_DISTANCE6' else
      if self.val = UInt32($3007) then Result := 'CLIP_DISTANCE7' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ColorBuffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE               := new ColorBuffer($0000);
    private static _FRONT_LEFT         := new ColorBuffer($0400);
    private static _FRONT_RIGHT        := new ColorBuffer($0401);
    private static _BACK_LEFT          := new ColorBuffer($0402);
    private static _BACK_RIGHT         := new ColorBuffer($0403);
    private static _FRONT              := new ColorBuffer($0404);
    private static _BACK               := new ColorBuffer($0405);
    private static _LEFT               := new ColorBuffer($0406);
    private static _RIGHT              := new ColorBuffer($0407);
    private static _FRONT_AND_BACK     := new ColorBuffer($0408);
    private static _COLOR_ATTACHMENT0  := new ColorBuffer($8CE0);
    private static _COLOR_ATTACHMENT1  := new ColorBuffer($8CE1);
    private static _COLOR_ATTACHMENT2  := new ColorBuffer($8CE2);
    private static _COLOR_ATTACHMENT3  := new ColorBuffer($8CE3);
    private static _COLOR_ATTACHMENT4  := new ColorBuffer($8CE4);
    private static _COLOR_ATTACHMENT5  := new ColorBuffer($8CE5);
    private static _COLOR_ATTACHMENT6  := new ColorBuffer($8CE6);
    private static _COLOR_ATTACHMENT7  := new ColorBuffer($8CE7);
    private static _COLOR_ATTACHMENT8  := new ColorBuffer($8CE8);
    private static _COLOR_ATTACHMENT9  := new ColorBuffer($8CE9);
    private static _COLOR_ATTACHMENT10 := new ColorBuffer($8CEA);
    private static _COLOR_ATTACHMENT11 := new ColorBuffer($8CEB);
    private static _COLOR_ATTACHMENT12 := new ColorBuffer($8CEC);
    private static _COLOR_ATTACHMENT13 := new ColorBuffer($8CED);
    private static _COLOR_ATTACHMENT14 := new ColorBuffer($8CEE);
    private static _COLOR_ATTACHMENT15 := new ColorBuffer($8CEF);
    private static _COLOR_ATTACHMENT16 := new ColorBuffer($8CF0);
    private static _COLOR_ATTACHMENT17 := new ColorBuffer($8CF1);
    private static _COLOR_ATTACHMENT18 := new ColorBuffer($8CF2);
    private static _COLOR_ATTACHMENT19 := new ColorBuffer($8CF3);
    private static _COLOR_ATTACHMENT20 := new ColorBuffer($8CF4);
    private static _COLOR_ATTACHMENT21 := new ColorBuffer($8CF5);
    private static _COLOR_ATTACHMENT22 := new ColorBuffer($8CF6);
    private static _COLOR_ATTACHMENT23 := new ColorBuffer($8CF7);
    private static _COLOR_ATTACHMENT24 := new ColorBuffer($8CF8);
    private static _COLOR_ATTACHMENT25 := new ColorBuffer($8CF9);
    private static _COLOR_ATTACHMENT26 := new ColorBuffer($8CFA);
    private static _COLOR_ATTACHMENT27 := new ColorBuffer($8CFB);
    private static _COLOR_ATTACHMENT28 := new ColorBuffer($8CFC);
    private static _COLOR_ATTACHMENT29 := new ColorBuffer($8CFD);
    private static _COLOR_ATTACHMENT30 := new ColorBuffer($8CFE);
    private static _COLOR_ATTACHMENT31 := new ColorBuffer($8CFF);
    
    public static property NONE:               ColorBuffer read _NONE;
    public static property FRONT_LEFT:         ColorBuffer read _FRONT_LEFT;
    public static property FRONT_RIGHT:        ColorBuffer read _FRONT_RIGHT;
    public static property BACK_LEFT:          ColorBuffer read _BACK_LEFT;
    public static property BACK_RIGHT:         ColorBuffer read _BACK_RIGHT;
    public static property FRONT:              ColorBuffer read _FRONT;
    public static property BACK:               ColorBuffer read _BACK;
    public static property LEFT:               ColorBuffer read _LEFT;
    public static property RIGHT:              ColorBuffer read _RIGHT;
    public static property FRONT_AND_BACK:     ColorBuffer read _FRONT_AND_BACK;
    public static property COLOR_ATTACHMENT0:  ColorBuffer read _COLOR_ATTACHMENT0;
    public static property COLOR_ATTACHMENT1:  ColorBuffer read _COLOR_ATTACHMENT1;
    public static property COLOR_ATTACHMENT2:  ColorBuffer read _COLOR_ATTACHMENT2;
    public static property COLOR_ATTACHMENT3:  ColorBuffer read _COLOR_ATTACHMENT3;
    public static property COLOR_ATTACHMENT4:  ColorBuffer read _COLOR_ATTACHMENT4;
    public static property COLOR_ATTACHMENT5:  ColorBuffer read _COLOR_ATTACHMENT5;
    public static property COLOR_ATTACHMENT6:  ColorBuffer read _COLOR_ATTACHMENT6;
    public static property COLOR_ATTACHMENT7:  ColorBuffer read _COLOR_ATTACHMENT7;
    public static property COLOR_ATTACHMENT8:  ColorBuffer read _COLOR_ATTACHMENT8;
    public static property COLOR_ATTACHMENT9:  ColorBuffer read _COLOR_ATTACHMENT9;
    public static property COLOR_ATTACHMENT10: ColorBuffer read _COLOR_ATTACHMENT10;
    public static property COLOR_ATTACHMENT11: ColorBuffer read _COLOR_ATTACHMENT11;
    public static property COLOR_ATTACHMENT12: ColorBuffer read _COLOR_ATTACHMENT12;
    public static property COLOR_ATTACHMENT13: ColorBuffer read _COLOR_ATTACHMENT13;
    public static property COLOR_ATTACHMENT14: ColorBuffer read _COLOR_ATTACHMENT14;
    public static property COLOR_ATTACHMENT15: ColorBuffer read _COLOR_ATTACHMENT15;
    public static property COLOR_ATTACHMENT16: ColorBuffer read _COLOR_ATTACHMENT16;
    public static property COLOR_ATTACHMENT17: ColorBuffer read _COLOR_ATTACHMENT17;
    public static property COLOR_ATTACHMENT18: ColorBuffer read _COLOR_ATTACHMENT18;
    public static property COLOR_ATTACHMENT19: ColorBuffer read _COLOR_ATTACHMENT19;
    public static property COLOR_ATTACHMENT20: ColorBuffer read _COLOR_ATTACHMENT20;
    public static property COLOR_ATTACHMENT21: ColorBuffer read _COLOR_ATTACHMENT21;
    public static property COLOR_ATTACHMENT22: ColorBuffer read _COLOR_ATTACHMENT22;
    public static property COLOR_ATTACHMENT23: ColorBuffer read _COLOR_ATTACHMENT23;
    public static property COLOR_ATTACHMENT24: ColorBuffer read _COLOR_ATTACHMENT24;
    public static property COLOR_ATTACHMENT25: ColorBuffer read _COLOR_ATTACHMENT25;
    public static property COLOR_ATTACHMENT26: ColorBuffer read _COLOR_ATTACHMENT26;
    public static property COLOR_ATTACHMENT27: ColorBuffer read _COLOR_ATTACHMENT27;
    public static property COLOR_ATTACHMENT28: ColorBuffer read _COLOR_ATTACHMENT28;
    public static property COLOR_ATTACHMENT29: ColorBuffer read _COLOR_ATTACHMENT29;
    public static property COLOR_ATTACHMENT30: ColorBuffer read _COLOR_ATTACHMENT30;
    public static property COLOR_ATTACHMENT31: ColorBuffer read _COLOR_ATTACHMENT31;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($0400) then Result := 'FRONT_LEFT' else
      if self.val = UInt32($0401) then Result := 'FRONT_RIGHT' else
      if self.val = UInt32($0402) then Result := 'BACK_LEFT' else
      if self.val = UInt32($0403) then Result := 'BACK_RIGHT' else
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0406) then Result := 'LEFT' else
      if self.val = UInt32($0407) then Result := 'RIGHT' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ColorMaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _AMBIENT             := new ColorMaterialParameter($1200);
    private static _DIFFUSE             := new ColorMaterialParameter($1201);
    private static _SPECULAR            := new ColorMaterialParameter($1202);
    private static _EMISSION            := new ColorMaterialParameter($1600);
    private static _AMBIENT_AND_DIFFUSE := new ColorMaterialParameter($1602);
    
    public static property AMBIENT:             ColorMaterialParameter read _AMBIENT;
    public static property DIFFUSE:             ColorMaterialParameter read _DIFFUSE;
    public static property SPECULAR:            ColorMaterialParameter read _SPECULAR;
    public static property EMISSION:            ColorMaterialParameter read _EMISSION;
    public static property AMBIENT_AND_DIFFUSE: ColorMaterialParameter read _AMBIENT_AND_DIFFUSE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1200) then Result := 'AMBIENT' else
      if self.val = UInt32($1201) then Result := 'DIFFUSE' else
      if self.val = UInt32($1202) then Result := 'SPECULAR' else
      if self.val = UInt32($1600) then Result := 'EMISSION' else
      if self.val = UInt32($1602) then Result := 'AMBIENT_AND_DIFFUSE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ColorPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE           := new ColorPointerType($1400);
    private static _UNSIGNED_BYTE  := new ColorPointerType($1401);
    private static _UNSIGNED_SHORT := new ColorPointerType($1403);
    private static _UNSIGNED_INT   := new ColorPointerType($1405);
    
    public static property BYTE:           ColorPointerType read _BYTE;
    public static property UNSIGNED_BYTE:  ColorPointerType read _UNSIGNED_BYTE;
    public static property UNSIGNED_SHORT: ColorPointerType read _UNSIGNED_SHORT;
    public static property UNSIGNED_INT:   ColorPointerType read _UNSIGNED_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ColorTableTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COLOR_TABLE                   := new ColorTableTarget($80D0);
    private static _POST_CONVOLUTION_COLOR_TABLE  := new ColorTableTarget($80D1);
    private static _POST_COLOR_MATRIX_COLOR_TABLE := new ColorTableTarget($80D2);
    
    public static property COLOR_TABLE:                   ColorTableTarget read _COLOR_TABLE;
    public static property POST_CONVOLUTION_COLOR_TABLE:  ColorTableTarget read _POST_CONVOLUTION_COLOR_TABLE;
    public static property POST_COLOR_MATRIX_COLOR_TABLE: ColorTableTarget read _POST_COLOR_MATRIX_COLOR_TABLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ConditionalRenderMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _QUERY_WAIT                       := new ConditionalRenderMode($8E13);
    private static _QUERY_NO_WAIT                    := new ConditionalRenderMode($8E14);
    private static _QUERY_BY_REGION_WAIT             := new ConditionalRenderMode($8E15);
    private static _QUERY_BY_REGION_NO_WAIT          := new ConditionalRenderMode($8E16);
    private static _QUERY_WAIT_INVERTED              := new ConditionalRenderMode($8E17);
    private static _QUERY_NO_WAIT_INVERTED           := new ConditionalRenderMode($8E18);
    private static _QUERY_BY_REGION_WAIT_INVERTED    := new ConditionalRenderMode($8E19);
    private static _QUERY_BY_REGION_NO_WAIT_INVERTED := new ConditionalRenderMode($8E1A);
    
    public static property QUERY_WAIT:                       ConditionalRenderMode read _QUERY_WAIT;
    public static property QUERY_NO_WAIT:                    ConditionalRenderMode read _QUERY_NO_WAIT;
    public static property QUERY_BY_REGION_WAIT:             ConditionalRenderMode read _QUERY_BY_REGION_WAIT;
    public static property QUERY_BY_REGION_NO_WAIT:          ConditionalRenderMode read _QUERY_BY_REGION_NO_WAIT;
    public static property QUERY_WAIT_INVERTED:              ConditionalRenderMode read _QUERY_WAIT_INVERTED;
    public static property QUERY_NO_WAIT_INVERTED:           ConditionalRenderMode read _QUERY_NO_WAIT_INVERTED;
    public static property QUERY_BY_REGION_WAIT_INVERTED:    ConditionalRenderMode read _QUERY_BY_REGION_WAIT_INVERTED;
    public static property QUERY_BY_REGION_NO_WAIT_INVERTED: ConditionalRenderMode read _QUERY_BY_REGION_NO_WAIT_INVERTED;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E13) then Result := 'QUERY_WAIT' else
      if self.val = UInt32($8E14) then Result := 'QUERY_NO_WAIT' else
      if self.val = UInt32($8E15) then Result := 'QUERY_BY_REGION_WAIT' else
      if self.val = UInt32($8E16) then Result := 'QUERY_BY_REGION_NO_WAIT' else
      if self.val = UInt32($8E17) then Result := 'QUERY_WAIT_INVERTED' else
      if self.val = UInt32($8E18) then Result := 'QUERY_NO_WAIT_INVERTED' else
      if self.val = UInt32($8E19) then Result := 'QUERY_BY_REGION_WAIT_INVERTED' else
      if self.val = UInt32($8E1A) then Result := 'QUERY_BY_REGION_NO_WAIT_INVERTED' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ConvolutionTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CONVOLUTION_1D := new ConvolutionTarget($8010);
    private static _CONVOLUTION_2D := new ConvolutionTarget($8011);
    
    public static property CONVOLUTION_1D: ConvolutionTarget read _CONVOLUTION_1D;
    public static property CONVOLUTION_2D: ConvolutionTarget read _CONVOLUTION_2D;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CopyBufferSubDataTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ARRAY_BUFFER              := new CopyBufferSubDataTarget($8892);
    private static _ELEMENT_ARRAY_BUFFER      := new CopyBufferSubDataTarget($8893);
    private static _PIXEL_PACK_BUFFER         := new CopyBufferSubDataTarget($88EB);
    private static _PIXEL_UNPACK_BUFFER       := new CopyBufferSubDataTarget($88EC);
    private static _UNIFORM_BUFFER            := new CopyBufferSubDataTarget($8A11);
    private static _TEXTURE_BUFFER            := new CopyBufferSubDataTarget($8C2A);
    private static _TRANSFORM_FEEDBACK_BUFFER := new CopyBufferSubDataTarget($8C8E);
    private static _COPY_READ_BUFFER          := new CopyBufferSubDataTarget($8F36);
    private static _COPY_WRITE_BUFFER         := new CopyBufferSubDataTarget($8F37);
    private static _DRAW_INDIRECT_BUFFER      := new CopyBufferSubDataTarget($8F3F);
    private static _SHADER_STORAGE_BUFFER     := new CopyBufferSubDataTarget($90D2);
    private static _DISPATCH_INDIRECT_BUFFER  := new CopyBufferSubDataTarget($90EE);
    private static _QUERY_BUFFER              := new CopyBufferSubDataTarget($9192);
    private static _ATOMIC_COUNTER_BUFFER     := new CopyBufferSubDataTarget($92C0);
    
    public static property ARRAY_BUFFER:              CopyBufferSubDataTarget read _ARRAY_BUFFER;
    public static property ELEMENT_ARRAY_BUFFER:      CopyBufferSubDataTarget read _ELEMENT_ARRAY_BUFFER;
    public static property PIXEL_PACK_BUFFER:         CopyBufferSubDataTarget read _PIXEL_PACK_BUFFER;
    public static property PIXEL_UNPACK_BUFFER:       CopyBufferSubDataTarget read _PIXEL_UNPACK_BUFFER;
    public static property UNIFORM_BUFFER:            CopyBufferSubDataTarget read _UNIFORM_BUFFER;
    public static property TEXTURE_BUFFER:            CopyBufferSubDataTarget read _TEXTURE_BUFFER;
    public static property TRANSFORM_FEEDBACK_BUFFER: CopyBufferSubDataTarget read _TRANSFORM_FEEDBACK_BUFFER;
    public static property COPY_READ_BUFFER:          CopyBufferSubDataTarget read _COPY_READ_BUFFER;
    public static property COPY_WRITE_BUFFER:         CopyBufferSubDataTarget read _COPY_WRITE_BUFFER;
    public static property DRAW_INDIRECT_BUFFER:      CopyBufferSubDataTarget read _DRAW_INDIRECT_BUFFER;
    public static property SHADER_STORAGE_BUFFER:     CopyBufferSubDataTarget read _SHADER_STORAGE_BUFFER;
    public static property DISPATCH_INDIRECT_BUFFER:  CopyBufferSubDataTarget read _DISPATCH_INDIRECT_BUFFER;
    public static property QUERY_BUFFER:              CopyBufferSubDataTarget read _QUERY_BUFFER;
    public static property ATOMIC_COUNTER_BUFFER:     CopyBufferSubDataTarget read _ATOMIC_COUNTER_BUFFER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8892) then Result := 'ARRAY_BUFFER' else
      if self.val = UInt32($8893) then Result := 'ELEMENT_ARRAY_BUFFER' else
      if self.val = UInt32($88EB) then Result := 'PIXEL_PACK_BUFFER' else
      if self.val = UInt32($88EC) then Result := 'PIXEL_UNPACK_BUFFER' else
      if self.val = UInt32($8A11) then Result := 'UNIFORM_BUFFER' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($8F36) then Result := 'COPY_READ_BUFFER' else
      if self.val = UInt32($8F37) then Result := 'COPY_WRITE_BUFFER' else
      if self.val = UInt32($8F3F) then Result := 'DRAW_INDIRECT_BUFFER' else
      if self.val = UInt32($90D2) then Result := 'SHADER_STORAGE_BUFFER' else
      if self.val = UInt32($90EE) then Result := 'DISPATCH_INDIRECT_BUFFER' else
      if self.val = UInt32($9192) then Result := 'QUERY_BUFFER' else
      if self.val = UInt32($92C0) then Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CopyImageSubDataTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_1D                   := new CopyImageSubDataTarget($0DE0);
    private static _TEXTURE_2D                   := new CopyImageSubDataTarget($0DE1);
    private static _TEXTURE_3D                   := new CopyImageSubDataTarget($806F);
    private static _TEXTURE_RECTANGLE            := new CopyImageSubDataTarget($84F5);
    private static _TEXTURE_CUBE_MAP             := new CopyImageSubDataTarget($8513);
    private static _TEXTURE_1D_ARRAY             := new CopyImageSubDataTarget($8C18);
    private static _TEXTURE_2D_ARRAY             := new CopyImageSubDataTarget($8C1A);
    private static _RENDERBUFFER                 := new CopyImageSubDataTarget($8D41);
    private static _TEXTURE_CUBE_MAP_ARRAY       := new CopyImageSubDataTarget($9009);
    private static _TEXTURE_2D_MULTISAMPLE       := new CopyImageSubDataTarget($9100);
    private static _TEXTURE_2D_MULTISAMPLE_ARRAY := new CopyImageSubDataTarget($9102);
    
    public static property TEXTURE_1D:                   CopyImageSubDataTarget read _TEXTURE_1D;
    public static property TEXTURE_2D:                   CopyImageSubDataTarget read _TEXTURE_2D;
    public static property TEXTURE_3D:                   CopyImageSubDataTarget read _TEXTURE_3D;
    public static property TEXTURE_RECTANGLE:            CopyImageSubDataTarget read _TEXTURE_RECTANGLE;
    public static property TEXTURE_CUBE_MAP:             CopyImageSubDataTarget read _TEXTURE_CUBE_MAP;
    public static property TEXTURE_1D_ARRAY:             CopyImageSubDataTarget read _TEXTURE_1D_ARRAY;
    public static property TEXTURE_2D_ARRAY:             CopyImageSubDataTarget read _TEXTURE_2D_ARRAY;
    public static property RENDERBUFFER:                 CopyImageSubDataTarget read _RENDERBUFFER;
    public static property TEXTURE_CUBE_MAP_ARRAY:       CopyImageSubDataTarget read _TEXTURE_CUBE_MAP_ARRAY;
    public static property TEXTURE_2D_MULTISAMPLE:       CopyImageSubDataTarget read _TEXTURE_2D_MULTISAMPLE;
    public static property TEXTURE_2D_MULTISAMPLE_ARRAY: CopyImageSubDataTarget read _TEXTURE_2D_MULTISAMPLE_ARRAY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D' else
      if self.val = UInt32($84F5) then Result := 'TEXTURE_RECTANGLE' else
      if self.val = UInt32($8513) then Result := 'TEXTURE_CUBE_MAP' else
      if self.val = UInt32($8C18) then Result := 'TEXTURE_1D_ARRAY' else
      if self.val = UInt32($8C1A) then Result := 'TEXTURE_2D_ARRAY' else
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER' else
      if self.val = UInt32($9009) then Result := 'TEXTURE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9100) then Result := 'TEXTURE_2D_MULTISAMPLE' else
      if self.val = UInt32($9102) then Result := 'TEXTURE_2D_MULTISAMPLE_ARRAY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CullFaceMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRONT          := new CullFaceMode($0404);
    private static _BACK           := new CullFaceMode($0405);
    private static _FRONT_AND_BACK := new CullFaceMode($0408);
    
    public static property FRONT:          CullFaceMode read _FRONT;
    public static property BACK:           CullFaceMode read _BACK;
    public static property FRONT_AND_BACK: CullFaceMode read _FRONT_AND_BACK;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
        Result := self.val.ToString;
    end;
    
  end;
  
  DebugSeverity = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DONT_CARE                   := new DebugSeverity($1100);
    private static _DEBUG_SEVERITY_NOTIFICATION := new DebugSeverity($826B);
    private static _DEBUG_SEVERITY_HIGH         := new DebugSeverity($9146);
    private static _DEBUG_SEVERITY_MEDIUM       := new DebugSeverity($9147);
    private static _DEBUG_SEVERITY_LOW          := new DebugSeverity($9148);
    
    public static property DONT_CARE:                   DebugSeverity read _DONT_CARE;
    public static property DEBUG_SEVERITY_NOTIFICATION: DebugSeverity read _DEBUG_SEVERITY_NOTIFICATION;
    public static property DEBUG_SEVERITY_HIGH:         DebugSeverity read _DEBUG_SEVERITY_HIGH;
    public static property DEBUG_SEVERITY_MEDIUM:       DebugSeverity read _DEBUG_SEVERITY_MEDIUM;
    public static property DEBUG_SEVERITY_LOW:          DebugSeverity read _DEBUG_SEVERITY_LOW;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($826B) then Result := 'DEBUG_SEVERITY_NOTIFICATION' else
      if self.val = UInt32($9146) then Result := 'DEBUG_SEVERITY_HIGH' else
      if self.val = UInt32($9147) then Result := 'DEBUG_SEVERITY_MEDIUM' else
      if self.val = UInt32($9148) then Result := 'DEBUG_SEVERITY_LOW' else
        Result := self.val.ToString;
    end;
    
  end;
  
  DebugSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DONT_CARE                    := new DebugSource($1100);
    private static _DEBUG_SOURCE_API             := new DebugSource($8246);
    private static _DEBUG_SOURCE_WINDOW_SYSTEM   := new DebugSource($8247);
    private static _DEBUG_SOURCE_SHADER_COMPILER := new DebugSource($8248);
    private static _DEBUG_SOURCE_THIRD_PARTY     := new DebugSource($8249);
    private static _DEBUG_SOURCE_APPLICATION     := new DebugSource($824A);
    private static _DEBUG_SOURCE_OTHER           := new DebugSource($824B);
    
    public static property DONT_CARE:                    DebugSource read _DONT_CARE;
    public static property DEBUG_SOURCE_API:             DebugSource read _DEBUG_SOURCE_API;
    public static property DEBUG_SOURCE_WINDOW_SYSTEM:   DebugSource read _DEBUG_SOURCE_WINDOW_SYSTEM;
    public static property DEBUG_SOURCE_SHADER_COMPILER: DebugSource read _DEBUG_SOURCE_SHADER_COMPILER;
    public static property DEBUG_SOURCE_THIRD_PARTY:     DebugSource read _DEBUG_SOURCE_THIRD_PARTY;
    public static property DEBUG_SOURCE_APPLICATION:     DebugSource read _DEBUG_SOURCE_APPLICATION;
    public static property DEBUG_SOURCE_OTHER:           DebugSource read _DEBUG_SOURCE_OTHER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($8246) then Result := 'DEBUG_SOURCE_API' else
      if self.val = UInt32($8247) then Result := 'DEBUG_SOURCE_WINDOW_SYSTEM' else
      if self.val = UInt32($8248) then Result := 'DEBUG_SOURCE_SHADER_COMPILER' else
      if self.val = UInt32($8249) then Result := 'DEBUG_SOURCE_THIRD_PARTY' else
      if self.val = UInt32($824A) then Result := 'DEBUG_SOURCE_APPLICATION' else
      if self.val = UInt32($824B) then Result := 'DEBUG_SOURCE_OTHER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  DebugType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DONT_CARE                      := new DebugType($1100);
    private static _DEBUG_TYPE_ERROR               := new DebugType($824C);
    private static _DEBUG_TYPE_DEPRECATED_BEHAVIOR := new DebugType($824D);
    private static _DEBUG_TYPE_UNDEFINED_BEHAVIOR  := new DebugType($824E);
    private static _DEBUG_TYPE_PORTABILITY         := new DebugType($824F);
    private static _DEBUG_TYPE_PERFORMANCE         := new DebugType($8250);
    private static _DEBUG_TYPE_OTHER               := new DebugType($8251);
    private static _DEBUG_TYPE_MARKER              := new DebugType($8268);
    private static _DEBUG_TYPE_PUSH_GROUP          := new DebugType($8269);
    private static _DEBUG_TYPE_POP_GROUP           := new DebugType($826A);
    
    public static property DONT_CARE:                      DebugType read _DONT_CARE;
    public static property DEBUG_TYPE_ERROR:               DebugType read _DEBUG_TYPE_ERROR;
    public static property DEBUG_TYPE_DEPRECATED_BEHAVIOR: DebugType read _DEBUG_TYPE_DEPRECATED_BEHAVIOR;
    public static property DEBUG_TYPE_UNDEFINED_BEHAVIOR:  DebugType read _DEBUG_TYPE_UNDEFINED_BEHAVIOR;
    public static property DEBUG_TYPE_PORTABILITY:         DebugType read _DEBUG_TYPE_PORTABILITY;
    public static property DEBUG_TYPE_PERFORMANCE:         DebugType read _DEBUG_TYPE_PERFORMANCE;
    public static property DEBUG_TYPE_OTHER:               DebugType read _DEBUG_TYPE_OTHER;
    public static property DEBUG_TYPE_MARKER:              DebugType read _DEBUG_TYPE_MARKER;
    public static property DEBUG_TYPE_PUSH_GROUP:          DebugType read _DEBUG_TYPE_PUSH_GROUP;
    public static property DEBUG_TYPE_POP_GROUP:           DebugType read _DEBUG_TYPE_POP_GROUP;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($824C) then Result := 'DEBUG_TYPE_ERROR' else
      if self.val = UInt32($824D) then Result := 'DEBUG_TYPE_DEPRECATED_BEHAVIOR' else
      if self.val = UInt32($824E) then Result := 'DEBUG_TYPE_UNDEFINED_BEHAVIOR' else
      if self.val = UInt32($824F) then Result := 'DEBUG_TYPE_PORTABILITY' else
      if self.val = UInt32($8250) then Result := 'DEBUG_TYPE_PERFORMANCE' else
      if self.val = UInt32($8251) then Result := 'DEBUG_TYPE_OTHER' else
      if self.val = UInt32($8268) then Result := 'DEBUG_TYPE_MARKER' else
      if self.val = UInt32($8269) then Result := 'DEBUG_TYPE_PUSH_GROUP' else
      if self.val = UInt32($826A) then Result := 'DEBUG_TYPE_POP_GROUP' else
        Result := self.val.ToString;
    end;
    
  end;
  
  DepthFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NEVER    := new DepthFunction($0200);
    private static _LESS     := new DepthFunction($0201);
    private static _EQUAL    := new DepthFunction($0202);
    private static _LEQUAL   := new DepthFunction($0203);
    private static _GREATER  := new DepthFunction($0204);
    private static _NOTEQUAL := new DepthFunction($0205);
    private static _GEQUAL   := new DepthFunction($0206);
    private static _ALWAYS   := new DepthFunction($0207);
    
    public static property NEVER:    DepthFunction read _NEVER;
    public static property LESS:     DepthFunction read _LESS;
    public static property EQUAL:    DepthFunction read _EQUAL;
    public static property LEQUAL:   DepthFunction read _LEQUAL;
    public static property GREATER:  DepthFunction read _GREATER;
    public static property NOTEQUAL: DepthFunction read _NOTEQUAL;
    public static property GEQUAL:   DepthFunction read _GEQUAL;
    public static property ALWAYS:   DepthFunction read _ALWAYS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  DrawBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE               := new DrawBufferMode($0000);
    private static _NONE_OES           := new DrawBufferMode($0000);
    private static _FRONT_LEFT         := new DrawBufferMode($0400);
    private static _FRONT_RIGHT        := new DrawBufferMode($0401);
    private static _BACK_LEFT          := new DrawBufferMode($0402);
    private static _BACK_RIGHT         := new DrawBufferMode($0403);
    private static _FRONT              := new DrawBufferMode($0404);
    private static _BACK               := new DrawBufferMode($0405);
    private static _LEFT               := new DrawBufferMode($0406);
    private static _RIGHT              := new DrawBufferMode($0407);
    private static _FRONT_AND_BACK     := new DrawBufferMode($0408);
    private static _AUX0               := new DrawBufferMode($0409);
    private static _AUX1               := new DrawBufferMode($040A);
    private static _AUX2               := new DrawBufferMode($040B);
    private static _AUX3               := new DrawBufferMode($040C);
    private static _COLOR_ATTACHMENT0  := new DrawBufferMode($8CE0);
    private static _COLOR_ATTACHMENT1  := new DrawBufferMode($8CE1);
    private static _COLOR_ATTACHMENT2  := new DrawBufferMode($8CE2);
    private static _COLOR_ATTACHMENT3  := new DrawBufferMode($8CE3);
    private static _COLOR_ATTACHMENT4  := new DrawBufferMode($8CE4);
    private static _COLOR_ATTACHMENT5  := new DrawBufferMode($8CE5);
    private static _COLOR_ATTACHMENT6  := new DrawBufferMode($8CE6);
    private static _COLOR_ATTACHMENT7  := new DrawBufferMode($8CE7);
    private static _COLOR_ATTACHMENT8  := new DrawBufferMode($8CE8);
    private static _COLOR_ATTACHMENT9  := new DrawBufferMode($8CE9);
    private static _COLOR_ATTACHMENT10 := new DrawBufferMode($8CEA);
    private static _COLOR_ATTACHMENT11 := new DrawBufferMode($8CEB);
    private static _COLOR_ATTACHMENT12 := new DrawBufferMode($8CEC);
    private static _COLOR_ATTACHMENT13 := new DrawBufferMode($8CED);
    private static _COLOR_ATTACHMENT14 := new DrawBufferMode($8CEE);
    private static _COLOR_ATTACHMENT15 := new DrawBufferMode($8CEF);
    private static _COLOR_ATTACHMENT16 := new DrawBufferMode($8CF0);
    private static _COLOR_ATTACHMENT17 := new DrawBufferMode($8CF1);
    private static _COLOR_ATTACHMENT18 := new DrawBufferMode($8CF2);
    private static _COLOR_ATTACHMENT19 := new DrawBufferMode($8CF3);
    private static _COLOR_ATTACHMENT20 := new DrawBufferMode($8CF4);
    private static _COLOR_ATTACHMENT21 := new DrawBufferMode($8CF5);
    private static _COLOR_ATTACHMENT22 := new DrawBufferMode($8CF6);
    private static _COLOR_ATTACHMENT23 := new DrawBufferMode($8CF7);
    private static _COLOR_ATTACHMENT24 := new DrawBufferMode($8CF8);
    private static _COLOR_ATTACHMENT25 := new DrawBufferMode($8CF9);
    private static _COLOR_ATTACHMENT26 := new DrawBufferMode($8CFA);
    private static _COLOR_ATTACHMENT27 := new DrawBufferMode($8CFB);
    private static _COLOR_ATTACHMENT28 := new DrawBufferMode($8CFC);
    private static _COLOR_ATTACHMENT29 := new DrawBufferMode($8CFD);
    private static _COLOR_ATTACHMENT30 := new DrawBufferMode($8CFE);
    private static _COLOR_ATTACHMENT31 := new DrawBufferMode($8CFF);
    
    public static property NONE:               DrawBufferMode read _NONE;
    public static property NONE_OES:           DrawBufferMode read _NONE_OES;
    public static property FRONT_LEFT:         DrawBufferMode read _FRONT_LEFT;
    public static property FRONT_RIGHT:        DrawBufferMode read _FRONT_RIGHT;
    public static property BACK_LEFT:          DrawBufferMode read _BACK_LEFT;
    public static property BACK_RIGHT:         DrawBufferMode read _BACK_RIGHT;
    public static property FRONT:              DrawBufferMode read _FRONT;
    public static property BACK:               DrawBufferMode read _BACK;
    public static property LEFT:               DrawBufferMode read _LEFT;
    public static property RIGHT:              DrawBufferMode read _RIGHT;
    public static property FRONT_AND_BACK:     DrawBufferMode read _FRONT_AND_BACK;
    public static property AUX0:               DrawBufferMode read _AUX0;
    public static property AUX1:               DrawBufferMode read _AUX1;
    public static property AUX2:               DrawBufferMode read _AUX2;
    public static property AUX3:               DrawBufferMode read _AUX3;
    public static property COLOR_ATTACHMENT0:  DrawBufferMode read _COLOR_ATTACHMENT0;
    public static property COLOR_ATTACHMENT1:  DrawBufferMode read _COLOR_ATTACHMENT1;
    public static property COLOR_ATTACHMENT2:  DrawBufferMode read _COLOR_ATTACHMENT2;
    public static property COLOR_ATTACHMENT3:  DrawBufferMode read _COLOR_ATTACHMENT3;
    public static property COLOR_ATTACHMENT4:  DrawBufferMode read _COLOR_ATTACHMENT4;
    public static property COLOR_ATTACHMENT5:  DrawBufferMode read _COLOR_ATTACHMENT5;
    public static property COLOR_ATTACHMENT6:  DrawBufferMode read _COLOR_ATTACHMENT6;
    public static property COLOR_ATTACHMENT7:  DrawBufferMode read _COLOR_ATTACHMENT7;
    public static property COLOR_ATTACHMENT8:  DrawBufferMode read _COLOR_ATTACHMENT8;
    public static property COLOR_ATTACHMENT9:  DrawBufferMode read _COLOR_ATTACHMENT9;
    public static property COLOR_ATTACHMENT10: DrawBufferMode read _COLOR_ATTACHMENT10;
    public static property COLOR_ATTACHMENT11: DrawBufferMode read _COLOR_ATTACHMENT11;
    public static property COLOR_ATTACHMENT12: DrawBufferMode read _COLOR_ATTACHMENT12;
    public static property COLOR_ATTACHMENT13: DrawBufferMode read _COLOR_ATTACHMENT13;
    public static property COLOR_ATTACHMENT14: DrawBufferMode read _COLOR_ATTACHMENT14;
    public static property COLOR_ATTACHMENT15: DrawBufferMode read _COLOR_ATTACHMENT15;
    public static property COLOR_ATTACHMENT16: DrawBufferMode read _COLOR_ATTACHMENT16;
    public static property COLOR_ATTACHMENT17: DrawBufferMode read _COLOR_ATTACHMENT17;
    public static property COLOR_ATTACHMENT18: DrawBufferMode read _COLOR_ATTACHMENT18;
    public static property COLOR_ATTACHMENT19: DrawBufferMode read _COLOR_ATTACHMENT19;
    public static property COLOR_ATTACHMENT20: DrawBufferMode read _COLOR_ATTACHMENT20;
    public static property COLOR_ATTACHMENT21: DrawBufferMode read _COLOR_ATTACHMENT21;
    public static property COLOR_ATTACHMENT22: DrawBufferMode read _COLOR_ATTACHMENT22;
    public static property COLOR_ATTACHMENT23: DrawBufferMode read _COLOR_ATTACHMENT23;
    public static property COLOR_ATTACHMENT24: DrawBufferMode read _COLOR_ATTACHMENT24;
    public static property COLOR_ATTACHMENT25: DrawBufferMode read _COLOR_ATTACHMENT25;
    public static property COLOR_ATTACHMENT26: DrawBufferMode read _COLOR_ATTACHMENT26;
    public static property COLOR_ATTACHMENT27: DrawBufferMode read _COLOR_ATTACHMENT27;
    public static property COLOR_ATTACHMENT28: DrawBufferMode read _COLOR_ATTACHMENT28;
    public static property COLOR_ATTACHMENT29: DrawBufferMode read _COLOR_ATTACHMENT29;
    public static property COLOR_ATTACHMENT30: DrawBufferMode read _COLOR_ATTACHMENT30;
    public static property COLOR_ATTACHMENT31: DrawBufferMode read _COLOR_ATTACHMENT31;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($0000) then Result := 'NONE_OES' else
      if self.val = UInt32($0400) then Result := 'FRONT_LEFT' else
      if self.val = UInt32($0401) then Result := 'FRONT_RIGHT' else
      if self.val = UInt32($0402) then Result := 'BACK_LEFT' else
      if self.val = UInt32($0403) then Result := 'BACK_RIGHT' else
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0406) then Result := 'LEFT' else
      if self.val = UInt32($0407) then Result := 'RIGHT' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
      if self.val = UInt32($0409) then Result := 'AUX0' else
      if self.val = UInt32($040A) then Result := 'AUX1' else
      if self.val = UInt32($040B) then Result := 'AUX2' else
      if self.val = UInt32($040C) then Result := 'AUX3' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
        Result := self.val.ToString;
    end;
    
  end;
  
  DrawElementsType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNSIGNED_BYTE  := new DrawElementsType($1401);
    private static _UNSIGNED_SHORT := new DrawElementsType($1403);
    private static _UNSIGNED_INT   := new DrawElementsType($1405);
    
    public static property UNSIGNED_BYTE:  DrawElementsType read _UNSIGNED_BYTE;
    public static property UNSIGNED_SHORT: DrawElementsType read _UNSIGNED_SHORT;
    public static property UNSIGNED_INT:   DrawElementsType read _UNSIGNED_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  EnableCap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _POINT_SMOOTH                            := new EnableCap($0B10);
    private static _LINE_SMOOTH                             := new EnableCap($0B20);
    private static _LINE_STIPPLE                            := new EnableCap($0B24);
    private static _POLYGON_SMOOTH                          := new EnableCap($0B41);
    private static _POLYGON_STIPPLE                         := new EnableCap($0B42);
    private static _CULL_FACE                               := new EnableCap($0B44);
    private static _LIGHTING                                := new EnableCap($0B50);
    private static _COLOR_MATERIAL                          := new EnableCap($0B57);
    private static _FOG                                     := new EnableCap($0B60);
    private static _DEPTH_TEST                              := new EnableCap($0B71);
    private static _STENCIL_TEST                            := new EnableCap($0B90);
    private static _NORMALIZE                               := new EnableCap($0BA1);
    private static _ALPHA_TEST                              := new EnableCap($0BC0);
    private static _DITHER                                  := new EnableCap($0BD0);
    private static _BLEND                                   := new EnableCap($0BE2);
    private static _INDEX_LOGIC_OP                          := new EnableCap($0BF1);
    private static _COLOR_LOGIC_OP                          := new EnableCap($0BF2);
    private static _SCISSOR_TEST                            := new EnableCap($0C11);
    private static _TEXTURE_GEN_S                           := new EnableCap($0C60);
    private static _TEXTURE_GEN_T                           := new EnableCap($0C61);
    private static _TEXTURE_GEN_R                           := new EnableCap($0C62);
    private static _TEXTURE_GEN_Q                           := new EnableCap($0C63);
    private static _AUTO_NORMAL                             := new EnableCap($0D80);
    private static _MAP1_COLOR_4                            := new EnableCap($0D90);
    private static _MAP1_INDEX                              := new EnableCap($0D91);
    private static _MAP1_NORMAL                             := new EnableCap($0D92);
    private static _MAP1_TEXTURE_COORD_1                    := new EnableCap($0D93);
    private static _MAP1_TEXTURE_COORD_2                    := new EnableCap($0D94);
    private static _MAP1_TEXTURE_COORD_3                    := new EnableCap($0D95);
    private static _MAP1_TEXTURE_COORD_4                    := new EnableCap($0D96);
    private static _MAP1_VERTEX_3                           := new EnableCap($0D97);
    private static _MAP1_VERTEX_4                           := new EnableCap($0D98);
    private static _MAP2_COLOR_4                            := new EnableCap($0DB0);
    private static _MAP2_INDEX                              := new EnableCap($0DB1);
    private static _MAP2_NORMAL                             := new EnableCap($0DB2);
    private static _MAP2_TEXTURE_COORD_1                    := new EnableCap($0DB3);
    private static _MAP2_TEXTURE_COORD_2                    := new EnableCap($0DB4);
    private static _MAP2_TEXTURE_COORD_3                    := new EnableCap($0DB5);
    private static _MAP2_TEXTURE_COORD_4                    := new EnableCap($0DB6);
    private static _MAP2_VERTEX_3                           := new EnableCap($0DB7);
    private static _MAP2_VERTEX_4                           := new EnableCap($0DB8);
    private static _TEXTURE_1D                              := new EnableCap($0DE0);
    private static _TEXTURE_2D                              := new EnableCap($0DE1);
    private static _POLYGON_OFFSET_POINT                    := new EnableCap($2A01);
    private static _POLYGON_OFFSET_LINE                     := new EnableCap($2A02);
    private static _CLIP_DISTANCE0                          := new EnableCap($3000);
    private static _CLIP_PLANE0                             := new EnableCap($3000);
    private static _CLIP_DISTANCE1                          := new EnableCap($3001);
    private static _CLIP_PLANE1                             := new EnableCap($3001);
    private static _CLIP_DISTANCE2                          := new EnableCap($3002);
    private static _CLIP_PLANE2                             := new EnableCap($3002);
    private static _CLIP_DISTANCE3                          := new EnableCap($3003);
    private static _CLIP_PLANE3                             := new EnableCap($3003);
    private static _CLIP_DISTANCE4                          := new EnableCap($3004);
    private static _CLIP_PLANE4                             := new EnableCap($3004);
    private static _CLIP_DISTANCE5                          := new EnableCap($3005);
    private static _CLIP_PLANE5                             := new EnableCap($3005);
    private static _CLIP_DISTANCE6                          := new EnableCap($3006);
    private static _CLIP_DISTANCE7                          := new EnableCap($3007);
    private static _LIGHT0                                  := new EnableCap($4000);
    private static _LIGHT1                                  := new EnableCap($4001);
    private static _LIGHT2                                  := new EnableCap($4002);
    private static _LIGHT3                                  := new EnableCap($4003);
    private static _LIGHT4                                  := new EnableCap($4004);
    private static _LIGHT5                                  := new EnableCap($4005);
    private static _LIGHT6                                  := new EnableCap($4006);
    private static _LIGHT7                                  := new EnableCap($4007);
    private static _CONVOLUTION_1D_EXT                      := new EnableCap($8010);
    private static _CONVOLUTION_2D_EXT                      := new EnableCap($8011);
    private static _SEPARABLE_2D_EXT                        := new EnableCap($8012);
    private static _HISTOGRAM_EXT                           := new EnableCap($8024);
    private static _MINMAX_EXT                              := new EnableCap($802E);
    private static _POLYGON_OFFSET_FILL                     := new EnableCap($8037);
    private static _RESCALE_NORMAL_EXT                      := new EnableCap($803A);
    private static _TEXTURE_3D_EXT                          := new EnableCap($806F);
    private static _VERTEX_ARRAY                            := new EnableCap($8074);
    private static _NORMAL_ARRAY                            := new EnableCap($8075);
    private static _COLOR_ARRAY                             := new EnableCap($8076);
    private static _INDEX_ARRAY                             := new EnableCap($8077);
    private static _TEXTURE_COORD_ARRAY                     := new EnableCap($8078);
    private static _EDGE_FLAG_ARRAY                         := new EnableCap($8079);
    private static _INTERLACE_SGIX                          := new EnableCap($8094);
    private static _MULTISAMPLE                             := new EnableCap($809D);
    private static _MULTISAMPLE_SGIS                        := new EnableCap($809D);
    private static _SAMPLE_ALPHA_TO_COVERAGE                := new EnableCap($809E);
    private static _SAMPLE_ALPHA_TO_MASK_SGIS               := new EnableCap($809E);
    private static _SAMPLE_ALPHA_TO_ONE                     := new EnableCap($809F);
    private static _SAMPLE_ALPHA_TO_ONE_SGIS                := new EnableCap($809F);
    private static _SAMPLE_COVERAGE                         := new EnableCap($80A0);
    private static _SAMPLE_MASK_SGIS                        := new EnableCap($80A0);
    private static _TEXTURE_COLOR_TABLE_SGI                 := new EnableCap($80BC);
    private static _COLOR_TABLE_SGI                         := new EnableCap($80D0);
    private static _POST_CONVOLUTION_COLOR_TABLE_SGI        := new EnableCap($80D1);
    private static _POST_COLOR_MATRIX_COLOR_TABLE_SGI       := new EnableCap($80D2);
    private static _TEXTURE_4D_SGIS                         := new EnableCap($8134);
    private static _PIXEL_TEX_GEN_SGIX                      := new EnableCap($8139);
    private static _SPRITE_SGIX                             := new EnableCap($8148);
    private static _REFERENCE_PLANE_SGIX                    := new EnableCap($817D);
    private static _IR_INSTRUMENT1_SGIX                     := new EnableCap($817F);
    private static _CALLIGRAPHIC_FRAGMENT_SGIX              := new EnableCap($8183);
    private static _FRAMEZOOM_SGIX                          := new EnableCap($818B);
    private static _FOG_OFFSET_SGIX                         := new EnableCap($8198);
    private static _SHARED_TEXTURE_PALETTE_EXT              := new EnableCap($81FB);
    private static _DEBUG_OUTPUT_SYNCHRONOUS                := new EnableCap($8242);
    private static _ASYNC_HISTOGRAM_SGIX                    := new EnableCap($832C);
    private static _PIXEL_TEXTURE_SGIS                      := new EnableCap($8353);
    private static _ASYNC_TEX_IMAGE_SGIX                    := new EnableCap($835C);
    private static _ASYNC_DRAW_PIXELS_SGIX                  := new EnableCap($835D);
    private static _ASYNC_READ_PIXELS_SGIX                  := new EnableCap($835E);
    private static _FRAGMENT_LIGHTING_SGIX                  := new EnableCap($8400);
    private static _FRAGMENT_COLOR_MATERIAL_SGIX            := new EnableCap($8401);
    private static _FRAGMENT_LIGHT0_SGIX                    := new EnableCap($840C);
    private static _FRAGMENT_LIGHT1_SGIX                    := new EnableCap($840D);
    private static _FRAGMENT_LIGHT2_SGIX                    := new EnableCap($840E);
    private static _FRAGMENT_LIGHT3_SGIX                    := new EnableCap($840F);
    private static _FRAGMENT_LIGHT4_SGIX                    := new EnableCap($8410);
    private static _FRAGMENT_LIGHT5_SGIX                    := new EnableCap($8411);
    private static _FRAGMENT_LIGHT6_SGIX                    := new EnableCap($8412);
    private static _FRAGMENT_LIGHT7_SGIX                    := new EnableCap($8413);
    private static _PROGRAM_POINT_SIZE                      := new EnableCap($8642);
    private static _DEPTH_CLAMP                             := new EnableCap($864F);
    private static _TEXTURE_CUBE_MAP_SEAMLESS               := new EnableCap($884F);
    private static _SAMPLE_SHADING                          := new EnableCap($8C36);
    private static _RASTERIZER_DISCARD                      := new EnableCap($8C89);
    private static _PRIMITIVE_RESTART_FIXED_INDEX           := new EnableCap($8D69);
    private static _FRAMEBUFFER_SRGB                        := new EnableCap($8DB9);
    private static _SAMPLE_MASK                             := new EnableCap($8E51);
    private static _PRIMITIVE_RESTART                       := new EnableCap($8F9D);
    private static _DEBUG_OUTPUT                            := new EnableCap($92E0);
    private static _SHADING_RATE_PRESERVE_ASPECT_RATIO_QCOM := new EnableCap($96A5);
    
    public static property POINT_SMOOTH:                            EnableCap read _POINT_SMOOTH;
    public static property LINE_SMOOTH:                             EnableCap read _LINE_SMOOTH;
    public static property LINE_STIPPLE:                            EnableCap read _LINE_STIPPLE;
    public static property POLYGON_SMOOTH:                          EnableCap read _POLYGON_SMOOTH;
    public static property POLYGON_STIPPLE:                         EnableCap read _POLYGON_STIPPLE;
    public static property CULL_FACE:                               EnableCap read _CULL_FACE;
    public static property LIGHTING:                                EnableCap read _LIGHTING;
    public static property COLOR_MATERIAL:                          EnableCap read _COLOR_MATERIAL;
    public static property FOG:                                     EnableCap read _FOG;
    public static property DEPTH_TEST:                              EnableCap read _DEPTH_TEST;
    public static property STENCIL_TEST:                            EnableCap read _STENCIL_TEST;
    public static property NORMALIZE:                               EnableCap read _NORMALIZE;
    public static property ALPHA_TEST:                              EnableCap read _ALPHA_TEST;
    public static property DITHER:                                  EnableCap read _DITHER;
    public static property BLEND:                                   EnableCap read _BLEND;
    public static property INDEX_LOGIC_OP:                          EnableCap read _INDEX_LOGIC_OP;
    public static property COLOR_LOGIC_OP:                          EnableCap read _COLOR_LOGIC_OP;
    public static property SCISSOR_TEST:                            EnableCap read _SCISSOR_TEST;
    public static property TEXTURE_GEN_S:                           EnableCap read _TEXTURE_GEN_S;
    public static property TEXTURE_GEN_T:                           EnableCap read _TEXTURE_GEN_T;
    public static property TEXTURE_GEN_R:                           EnableCap read _TEXTURE_GEN_R;
    public static property TEXTURE_GEN_Q:                           EnableCap read _TEXTURE_GEN_Q;
    public static property AUTO_NORMAL:                             EnableCap read _AUTO_NORMAL;
    public static property MAP1_COLOR_4:                            EnableCap read _MAP1_COLOR_4;
    public static property MAP1_INDEX:                              EnableCap read _MAP1_INDEX;
    public static property MAP1_NORMAL:                             EnableCap read _MAP1_NORMAL;
    public static property MAP1_TEXTURE_COORD_1:                    EnableCap read _MAP1_TEXTURE_COORD_1;
    public static property MAP1_TEXTURE_COORD_2:                    EnableCap read _MAP1_TEXTURE_COORD_2;
    public static property MAP1_TEXTURE_COORD_3:                    EnableCap read _MAP1_TEXTURE_COORD_3;
    public static property MAP1_TEXTURE_COORD_4:                    EnableCap read _MAP1_TEXTURE_COORD_4;
    public static property MAP1_VERTEX_3:                           EnableCap read _MAP1_VERTEX_3;
    public static property MAP1_VERTEX_4:                           EnableCap read _MAP1_VERTEX_4;
    public static property MAP2_COLOR_4:                            EnableCap read _MAP2_COLOR_4;
    public static property MAP2_INDEX:                              EnableCap read _MAP2_INDEX;
    public static property MAP2_NORMAL:                             EnableCap read _MAP2_NORMAL;
    public static property MAP2_TEXTURE_COORD_1:                    EnableCap read _MAP2_TEXTURE_COORD_1;
    public static property MAP2_TEXTURE_COORD_2:                    EnableCap read _MAP2_TEXTURE_COORD_2;
    public static property MAP2_TEXTURE_COORD_3:                    EnableCap read _MAP2_TEXTURE_COORD_3;
    public static property MAP2_TEXTURE_COORD_4:                    EnableCap read _MAP2_TEXTURE_COORD_4;
    public static property MAP2_VERTEX_3:                           EnableCap read _MAP2_VERTEX_3;
    public static property MAP2_VERTEX_4:                           EnableCap read _MAP2_VERTEX_4;
    public static property TEXTURE_1D:                              EnableCap read _TEXTURE_1D;
    public static property TEXTURE_2D:                              EnableCap read _TEXTURE_2D;
    public static property POLYGON_OFFSET_POINT:                    EnableCap read _POLYGON_OFFSET_POINT;
    public static property POLYGON_OFFSET_LINE:                     EnableCap read _POLYGON_OFFSET_LINE;
    public static property CLIP_DISTANCE0:                          EnableCap read _CLIP_DISTANCE0;
    public static property CLIP_PLANE0:                             EnableCap read _CLIP_PLANE0;
    public static property CLIP_DISTANCE1:                          EnableCap read _CLIP_DISTANCE1;
    public static property CLIP_PLANE1:                             EnableCap read _CLIP_PLANE1;
    public static property CLIP_DISTANCE2:                          EnableCap read _CLIP_DISTANCE2;
    public static property CLIP_PLANE2:                             EnableCap read _CLIP_PLANE2;
    public static property CLIP_DISTANCE3:                          EnableCap read _CLIP_DISTANCE3;
    public static property CLIP_PLANE3:                             EnableCap read _CLIP_PLANE3;
    public static property CLIP_DISTANCE4:                          EnableCap read _CLIP_DISTANCE4;
    public static property CLIP_PLANE4:                             EnableCap read _CLIP_PLANE4;
    public static property CLIP_DISTANCE5:                          EnableCap read _CLIP_DISTANCE5;
    public static property CLIP_PLANE5:                             EnableCap read _CLIP_PLANE5;
    public static property CLIP_DISTANCE6:                          EnableCap read _CLIP_DISTANCE6;
    public static property CLIP_DISTANCE7:                          EnableCap read _CLIP_DISTANCE7;
    public static property LIGHT0:                                  EnableCap read _LIGHT0;
    public static property LIGHT1:                                  EnableCap read _LIGHT1;
    public static property LIGHT2:                                  EnableCap read _LIGHT2;
    public static property LIGHT3:                                  EnableCap read _LIGHT3;
    public static property LIGHT4:                                  EnableCap read _LIGHT4;
    public static property LIGHT5:                                  EnableCap read _LIGHT5;
    public static property LIGHT6:                                  EnableCap read _LIGHT6;
    public static property LIGHT7:                                  EnableCap read _LIGHT7;
    public static property CONVOLUTION_1D_EXT:                      EnableCap read _CONVOLUTION_1D_EXT;
    public static property CONVOLUTION_2D_EXT:                      EnableCap read _CONVOLUTION_2D_EXT;
    public static property SEPARABLE_2D_EXT:                        EnableCap read _SEPARABLE_2D_EXT;
    public static property HISTOGRAM_EXT:                           EnableCap read _HISTOGRAM_EXT;
    public static property MINMAX_EXT:                              EnableCap read _MINMAX_EXT;
    public static property POLYGON_OFFSET_FILL:                     EnableCap read _POLYGON_OFFSET_FILL;
    public static property RESCALE_NORMAL_EXT:                      EnableCap read _RESCALE_NORMAL_EXT;
    public static property TEXTURE_3D_EXT:                          EnableCap read _TEXTURE_3D_EXT;
    public static property VERTEX_ARRAY:                            EnableCap read _VERTEX_ARRAY;
    public static property NORMAL_ARRAY:                            EnableCap read _NORMAL_ARRAY;
    public static property COLOR_ARRAY:                             EnableCap read _COLOR_ARRAY;
    public static property INDEX_ARRAY:                             EnableCap read _INDEX_ARRAY;
    public static property TEXTURE_COORD_ARRAY:                     EnableCap read _TEXTURE_COORD_ARRAY;
    public static property EDGE_FLAG_ARRAY:                         EnableCap read _EDGE_FLAG_ARRAY;
    public static property INTERLACE_SGIX:                          EnableCap read _INTERLACE_SGIX;
    public static property MULTISAMPLE:                             EnableCap read _MULTISAMPLE;
    public static property MULTISAMPLE_SGIS:                        EnableCap read _MULTISAMPLE_SGIS;
    public static property SAMPLE_ALPHA_TO_COVERAGE:                EnableCap read _SAMPLE_ALPHA_TO_COVERAGE;
    public static property SAMPLE_ALPHA_TO_MASK_SGIS:               EnableCap read _SAMPLE_ALPHA_TO_MASK_SGIS;
    public static property SAMPLE_ALPHA_TO_ONE:                     EnableCap read _SAMPLE_ALPHA_TO_ONE;
    public static property SAMPLE_ALPHA_TO_ONE_SGIS:                EnableCap read _SAMPLE_ALPHA_TO_ONE_SGIS;
    public static property SAMPLE_COVERAGE:                         EnableCap read _SAMPLE_COVERAGE;
    public static property SAMPLE_MASK_SGIS:                        EnableCap read _SAMPLE_MASK_SGIS;
    public static property TEXTURE_COLOR_TABLE_SGI:                 EnableCap read _TEXTURE_COLOR_TABLE_SGI;
    public static property COLOR_TABLE_SGI:                         EnableCap read _COLOR_TABLE_SGI;
    public static property POST_CONVOLUTION_COLOR_TABLE_SGI:        EnableCap read _POST_CONVOLUTION_COLOR_TABLE_SGI;
    public static property POST_COLOR_MATRIX_COLOR_TABLE_SGI:       EnableCap read _POST_COLOR_MATRIX_COLOR_TABLE_SGI;
    public static property TEXTURE_4D_SGIS:                         EnableCap read _TEXTURE_4D_SGIS;
    public static property PIXEL_TEX_GEN_SGIX:                      EnableCap read _PIXEL_TEX_GEN_SGIX;
    public static property SPRITE_SGIX:                             EnableCap read _SPRITE_SGIX;
    public static property REFERENCE_PLANE_SGIX:                    EnableCap read _REFERENCE_PLANE_SGIX;
    public static property IR_INSTRUMENT1_SGIX:                     EnableCap read _IR_INSTRUMENT1_SGIX;
    public static property CALLIGRAPHIC_FRAGMENT_SGIX:              EnableCap read _CALLIGRAPHIC_FRAGMENT_SGIX;
    public static property FRAMEZOOM_SGIX:                          EnableCap read _FRAMEZOOM_SGIX;
    public static property FOG_OFFSET_SGIX:                         EnableCap read _FOG_OFFSET_SGIX;
    public static property SHARED_TEXTURE_PALETTE_EXT:              EnableCap read _SHARED_TEXTURE_PALETTE_EXT;
    public static property DEBUG_OUTPUT_SYNCHRONOUS:                EnableCap read _DEBUG_OUTPUT_SYNCHRONOUS;
    public static property ASYNC_HISTOGRAM_SGIX:                    EnableCap read _ASYNC_HISTOGRAM_SGIX;
    public static property PIXEL_TEXTURE_SGIS:                      EnableCap read _PIXEL_TEXTURE_SGIS;
    public static property ASYNC_TEX_IMAGE_SGIX:                    EnableCap read _ASYNC_TEX_IMAGE_SGIX;
    public static property ASYNC_DRAW_PIXELS_SGIX:                  EnableCap read _ASYNC_DRAW_PIXELS_SGIX;
    public static property ASYNC_READ_PIXELS_SGIX:                  EnableCap read _ASYNC_READ_PIXELS_SGIX;
    public static property FRAGMENT_LIGHTING_SGIX:                  EnableCap read _FRAGMENT_LIGHTING_SGIX;
    public static property FRAGMENT_COLOR_MATERIAL_SGIX:            EnableCap read _FRAGMENT_COLOR_MATERIAL_SGIX;
    public static property FRAGMENT_LIGHT0_SGIX:                    EnableCap read _FRAGMENT_LIGHT0_SGIX;
    public static property FRAGMENT_LIGHT1_SGIX:                    EnableCap read _FRAGMENT_LIGHT1_SGIX;
    public static property FRAGMENT_LIGHT2_SGIX:                    EnableCap read _FRAGMENT_LIGHT2_SGIX;
    public static property FRAGMENT_LIGHT3_SGIX:                    EnableCap read _FRAGMENT_LIGHT3_SGIX;
    public static property FRAGMENT_LIGHT4_SGIX:                    EnableCap read _FRAGMENT_LIGHT4_SGIX;
    public static property FRAGMENT_LIGHT5_SGIX:                    EnableCap read _FRAGMENT_LIGHT5_SGIX;
    public static property FRAGMENT_LIGHT6_SGIX:                    EnableCap read _FRAGMENT_LIGHT6_SGIX;
    public static property FRAGMENT_LIGHT7_SGIX:                    EnableCap read _FRAGMENT_LIGHT7_SGIX;
    public static property PROGRAM_POINT_SIZE:                      EnableCap read _PROGRAM_POINT_SIZE;
    public static property DEPTH_CLAMP:                             EnableCap read _DEPTH_CLAMP;
    public static property TEXTURE_CUBE_MAP_SEAMLESS:               EnableCap read _TEXTURE_CUBE_MAP_SEAMLESS;
    public static property SAMPLE_SHADING:                          EnableCap read _SAMPLE_SHADING;
    public static property RASTERIZER_DISCARD:                      EnableCap read _RASTERIZER_DISCARD;
    public static property PRIMITIVE_RESTART_FIXED_INDEX:           EnableCap read _PRIMITIVE_RESTART_FIXED_INDEX;
    public static property FRAMEBUFFER_SRGB:                        EnableCap read _FRAMEBUFFER_SRGB;
    public static property SAMPLE_MASK:                             EnableCap read _SAMPLE_MASK;
    public static property PRIMITIVE_RESTART:                       EnableCap read _PRIMITIVE_RESTART;
    public static property DEBUG_OUTPUT:                            EnableCap read _DEBUG_OUTPUT;
    public static property SHADING_RATE_PRESERVE_ASPECT_RATIO_QCOM: EnableCap read _SHADING_RATE_PRESERVE_ASPECT_RATIO_QCOM;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B10) then Result := 'POINT_SMOOTH' else
      if self.val = UInt32($0B20) then Result := 'LINE_SMOOTH' else
      if self.val = UInt32($0B24) then Result := 'LINE_STIPPLE' else
      if self.val = UInt32($0B41) then Result := 'POLYGON_SMOOTH' else
      if self.val = UInt32($0B42) then Result := 'POLYGON_STIPPLE' else
      if self.val = UInt32($0B44) then Result := 'CULL_FACE' else
      if self.val = UInt32($0B50) then Result := 'LIGHTING' else
      if self.val = UInt32($0B57) then Result := 'COLOR_MATERIAL' else
      if self.val = UInt32($0B60) then Result := 'FOG' else
      if self.val = UInt32($0B71) then Result := 'DEPTH_TEST' else
      if self.val = UInt32($0B90) then Result := 'STENCIL_TEST' else
      if self.val = UInt32($0BA1) then Result := 'NORMALIZE' else
      if self.val = UInt32($0BC0) then Result := 'ALPHA_TEST' else
      if self.val = UInt32($0BD0) then Result := 'DITHER' else
      if self.val = UInt32($0BE2) then Result := 'BLEND' else
      if self.val = UInt32($0BF1) then Result := 'INDEX_LOGIC_OP' else
      if self.val = UInt32($0BF2) then Result := 'COLOR_LOGIC_OP' else
      if self.val = UInt32($0C11) then Result := 'SCISSOR_TEST' else
      if self.val = UInt32($0C60) then Result := 'TEXTURE_GEN_S' else
      if self.val = UInt32($0C61) then Result := 'TEXTURE_GEN_T' else
      if self.val = UInt32($0C62) then Result := 'TEXTURE_GEN_R' else
      if self.val = UInt32($0C63) then Result := 'TEXTURE_GEN_Q' else
      if self.val = UInt32($0D80) then Result := 'AUTO_NORMAL' else
      if self.val = UInt32($0D90) then Result := 'MAP1_COLOR_4' else
      if self.val = UInt32($0D91) then Result := 'MAP1_INDEX' else
      if self.val = UInt32($0D92) then Result := 'MAP1_NORMAL' else
      if self.val = UInt32($0D93) then Result := 'MAP1_TEXTURE_COORD_1' else
      if self.val = UInt32($0D94) then Result := 'MAP1_TEXTURE_COORD_2' else
      if self.val = UInt32($0D95) then Result := 'MAP1_TEXTURE_COORD_3' else
      if self.val = UInt32($0D96) then Result := 'MAP1_TEXTURE_COORD_4' else
      if self.val = UInt32($0D97) then Result := 'MAP1_VERTEX_3' else
      if self.val = UInt32($0D98) then Result := 'MAP1_VERTEX_4' else
      if self.val = UInt32($0DB0) then Result := 'MAP2_COLOR_4' else
      if self.val = UInt32($0DB1) then Result := 'MAP2_INDEX' else
      if self.val = UInt32($0DB2) then Result := 'MAP2_NORMAL' else
      if self.val = UInt32($0DB3) then Result := 'MAP2_TEXTURE_COORD_1' else
      if self.val = UInt32($0DB4) then Result := 'MAP2_TEXTURE_COORD_2' else
      if self.val = UInt32($0DB5) then Result := 'MAP2_TEXTURE_COORD_3' else
      if self.val = UInt32($0DB6) then Result := 'MAP2_TEXTURE_COORD_4' else
      if self.val = UInt32($0DB7) then Result := 'MAP2_VERTEX_3' else
      if self.val = UInt32($0DB8) then Result := 'MAP2_VERTEX_4' else
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($2A01) then Result := 'POLYGON_OFFSET_POINT' else
      if self.val = UInt32($2A02) then Result := 'POLYGON_OFFSET_LINE' else
      if self.val = UInt32($3000) then Result := 'CLIP_DISTANCE0' else
      if self.val = UInt32($3000) then Result := 'CLIP_PLANE0' else
      if self.val = UInt32($3001) then Result := 'CLIP_DISTANCE1' else
      if self.val = UInt32($3001) then Result := 'CLIP_PLANE1' else
      if self.val = UInt32($3002) then Result := 'CLIP_DISTANCE2' else
      if self.val = UInt32($3002) then Result := 'CLIP_PLANE2' else
      if self.val = UInt32($3003) then Result := 'CLIP_DISTANCE3' else
      if self.val = UInt32($3003) then Result := 'CLIP_PLANE3' else
      if self.val = UInt32($3004) then Result := 'CLIP_DISTANCE4' else
      if self.val = UInt32($3004) then Result := 'CLIP_PLANE4' else
      if self.val = UInt32($3005) then Result := 'CLIP_DISTANCE5' else
      if self.val = UInt32($3005) then Result := 'CLIP_PLANE5' else
      if self.val = UInt32($3006) then Result := 'CLIP_DISTANCE6' else
      if self.val = UInt32($3007) then Result := 'CLIP_DISTANCE7' else
      if self.val = UInt32($4000) then Result := 'LIGHT0' else
      if self.val = UInt32($4001) then Result := 'LIGHT1' else
      if self.val = UInt32($4002) then Result := 'LIGHT2' else
      if self.val = UInt32($4003) then Result := 'LIGHT3' else
      if self.val = UInt32($4004) then Result := 'LIGHT4' else
      if self.val = UInt32($4005) then Result := 'LIGHT5' else
      if self.val = UInt32($4006) then Result := 'LIGHT6' else
      if self.val = UInt32($4007) then Result := 'LIGHT7' else
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D_EXT' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D_EXT' else
      if self.val = UInt32($8012) then Result := 'SEPARABLE_2D_EXT' else
      if self.val = UInt32($8024) then Result := 'HISTOGRAM_EXT' else
      if self.val = UInt32($802E) then Result := 'MINMAX_EXT' else
      if self.val = UInt32($8037) then Result := 'POLYGON_OFFSET_FILL' else
      if self.val = UInt32($803A) then Result := 'RESCALE_NORMAL_EXT' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D_EXT' else
      if self.val = UInt32($8074) then Result := 'VERTEX_ARRAY' else
      if self.val = UInt32($8075) then Result := 'NORMAL_ARRAY' else
      if self.val = UInt32($8076) then Result := 'COLOR_ARRAY' else
      if self.val = UInt32($8077) then Result := 'INDEX_ARRAY' else
      if self.val = UInt32($8078) then Result := 'TEXTURE_COORD_ARRAY' else
      if self.val = UInt32($8079) then Result := 'EDGE_FLAG_ARRAY' else
      if self.val = UInt32($8094) then Result := 'INTERLACE_SGIX' else
      if self.val = UInt32($809D) then Result := 'MULTISAMPLE' else
      if self.val = UInt32($809D) then Result := 'MULTISAMPLE_SGIS' else
      if self.val = UInt32($809E) then Result := 'SAMPLE_ALPHA_TO_COVERAGE' else
      if self.val = UInt32($809E) then Result := 'SAMPLE_ALPHA_TO_MASK_SGIS' else
      if self.val = UInt32($809F) then Result := 'SAMPLE_ALPHA_TO_ONE' else
      if self.val = UInt32($809F) then Result := 'SAMPLE_ALPHA_TO_ONE_SGIS' else
      if self.val = UInt32($80A0) then Result := 'SAMPLE_COVERAGE' else
      if self.val = UInt32($80A0) then Result := 'SAMPLE_MASK_SGIS' else
      if self.val = UInt32($80BC) then Result := 'TEXTURE_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE_SGI' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE_SGI' else
      if self.val = UInt32($8134) then Result := 'TEXTURE_4D_SGIS' else
      if self.val = UInt32($8139) then Result := 'PIXEL_TEX_GEN_SGIX' else
      if self.val = UInt32($8148) then Result := 'SPRITE_SGIX' else
      if self.val = UInt32($817D) then Result := 'REFERENCE_PLANE_SGIX' else
      if self.val = UInt32($817F) then Result := 'IR_INSTRUMENT1_SGIX' else
      if self.val = UInt32($8183) then Result := 'CALLIGRAPHIC_FRAGMENT_SGIX' else
      if self.val = UInt32($818B) then Result := 'FRAMEZOOM_SGIX' else
      if self.val = UInt32($8198) then Result := 'FOG_OFFSET_SGIX' else
      if self.val = UInt32($81FB) then Result := 'SHARED_TEXTURE_PALETTE_EXT' else
      if self.val = UInt32($8242) then Result := 'DEBUG_OUTPUT_SYNCHRONOUS' else
      if self.val = UInt32($832C) then Result := 'ASYNC_HISTOGRAM_SGIX' else
      if self.val = UInt32($8353) then Result := 'PIXEL_TEXTURE_SGIS' else
      if self.val = UInt32($835C) then Result := 'ASYNC_TEX_IMAGE_SGIX' else
      if self.val = UInt32($835D) then Result := 'ASYNC_DRAW_PIXELS_SGIX' else
      if self.val = UInt32($835E) then Result := 'ASYNC_READ_PIXELS_SGIX' else
      if self.val = UInt32($8400) then Result := 'FRAGMENT_LIGHTING_SGIX' else
      if self.val = UInt32($8401) then Result := 'FRAGMENT_COLOR_MATERIAL_SGIX' else
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0_SGIX' else
      if self.val = UInt32($840D) then Result := 'FRAGMENT_LIGHT1_SGIX' else
      if self.val = UInt32($840E) then Result := 'FRAGMENT_LIGHT2_SGIX' else
      if self.val = UInt32($840F) then Result := 'FRAGMENT_LIGHT3_SGIX' else
      if self.val = UInt32($8410) then Result := 'FRAGMENT_LIGHT4_SGIX' else
      if self.val = UInt32($8411) then Result := 'FRAGMENT_LIGHT5_SGIX' else
      if self.val = UInt32($8412) then Result := 'FRAGMENT_LIGHT6_SGIX' else
      if self.val = UInt32($8413) then Result := 'FRAGMENT_LIGHT7_SGIX' else
      if self.val = UInt32($8642) then Result := 'PROGRAM_POINT_SIZE' else
      if self.val = UInt32($864F) then Result := 'DEPTH_CLAMP' else
      if self.val = UInt32($884F) then Result := 'TEXTURE_CUBE_MAP_SEAMLESS' else
      if self.val = UInt32($8C36) then Result := 'SAMPLE_SHADING' else
      if self.val = UInt32($8C89) then Result := 'RASTERIZER_DISCARD' else
      if self.val = UInt32($8D69) then Result := 'PRIMITIVE_RESTART_FIXED_INDEX' else
      if self.val = UInt32($8DB9) then Result := 'FRAMEBUFFER_SRGB' else
      if self.val = UInt32($8E51) then Result := 'SAMPLE_MASK' else
      if self.val = UInt32($8F9D) then Result := 'PRIMITIVE_RESTART' else
      if self.val = UInt32($92E0) then Result := 'DEBUG_OUTPUT' else
      if self.val = UInt32($96A5) then Result := 'SHADING_RATE_PRESERVE_ASPECT_RATIO_QCOM' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ErrorCode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NO_ERROR                          := new ErrorCode($0000);
    private static _INVALID_ENUM                      := new ErrorCode($0500);
    private static _INVALID_VALUE                     := new ErrorCode($0501);
    private static _INVALID_OPERATION                 := new ErrorCode($0502);
    private static _STACK_OVERFLOW                    := new ErrorCode($0503);
    private static _STACK_UNDERFLOW                   := new ErrorCode($0504);
    private static _OUT_OF_MEMORY                     := new ErrorCode($0505);
    private static _INVALID_FRAMEBUFFER_OPERATION     := new ErrorCode($0506);
    private static _INVALID_FRAMEBUFFER_OPERATION_EXT := new ErrorCode($0506);
    private static _INVALID_FRAMEBUFFER_OPERATION_OES := new ErrorCode($0506);
    private static _TABLE_TOO_LARGE                   := new ErrorCode($8031);
    private static _TABLE_TOO_LARGE_EXT               := new ErrorCode($8031);
    private static _TEXTURE_TOO_LARGE_EXT             := new ErrorCode($8065);
    
    public static property NO_ERROR:                          ErrorCode read _NO_ERROR;
    public static property INVALID_ENUM:                      ErrorCode read _INVALID_ENUM;
    public static property INVALID_VALUE:                     ErrorCode read _INVALID_VALUE;
    public static property INVALID_OPERATION:                 ErrorCode read _INVALID_OPERATION;
    public static property STACK_OVERFLOW:                    ErrorCode read _STACK_OVERFLOW;
    public static property STACK_UNDERFLOW:                   ErrorCode read _STACK_UNDERFLOW;
    public static property OUT_OF_MEMORY:                     ErrorCode read _OUT_OF_MEMORY;
    public static property INVALID_FRAMEBUFFER_OPERATION:     ErrorCode read _INVALID_FRAMEBUFFER_OPERATION;
    public static property INVALID_FRAMEBUFFER_OPERATION_EXT: ErrorCode read _INVALID_FRAMEBUFFER_OPERATION_EXT;
    public static property INVALID_FRAMEBUFFER_OPERATION_OES: ErrorCode read _INVALID_FRAMEBUFFER_OPERATION_OES;
    public static property TABLE_TOO_LARGE:                   ErrorCode read _TABLE_TOO_LARGE;
    public static property TABLE_TOO_LARGE_EXT:               ErrorCode read _TABLE_TOO_LARGE_EXT;
    public static property TEXTURE_TOO_LARGE_EXT:             ErrorCode read _TEXTURE_TOO_LARGE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NO_ERROR' else
      if self.val = UInt32($0500) then Result := 'INVALID_ENUM' else
      if self.val = UInt32($0501) then Result := 'INVALID_VALUE' else
      if self.val = UInt32($0502) then Result := 'INVALID_OPERATION' else
      if self.val = UInt32($0503) then Result := 'STACK_OVERFLOW' else
      if self.val = UInt32($0504) then Result := 'STACK_UNDERFLOW' else
      if self.val = UInt32($0505) then Result := 'OUT_OF_MEMORY' else
      if self.val = UInt32($0506) then Result := 'INVALID_FRAMEBUFFER_OPERATION' else
      if self.val = UInt32($0506) then Result := 'INVALID_FRAMEBUFFER_OPERATION_EXT' else
      if self.val = UInt32($0506) then Result := 'INVALID_FRAMEBUFFER_OPERATION_OES' else
      if self.val = UInt32($8031) then Result := 'TABLE_TOO_LARGE' else
      if self.val = UInt32($8031) then Result := 'TABLE_TOO_LARGE_EXT' else
      if self.val = UInt32($8065) then Result := 'TEXTURE_TOO_LARGE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ExternalHandleType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _HANDLE_TYPE_OPAQUE_FD_EXT        := new ExternalHandleType($9586);
    private static _HANDLE_TYPE_OPAQUE_WIN32_EXT     := new ExternalHandleType($9587);
    private static _HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT := new ExternalHandleType($9588);
    private static _HANDLE_TYPE_D3D12_TILEPOOL_EXT   := new ExternalHandleType($9589);
    private static _HANDLE_TYPE_D3D12_RESOURCE_EXT   := new ExternalHandleType($958A);
    private static _HANDLE_TYPE_D3D11_IMAGE_EXT      := new ExternalHandleType($958B);
    private static _HANDLE_TYPE_D3D11_IMAGE_KMT_EXT  := new ExternalHandleType($958C);
    private static _HANDLE_TYPE_D3D12_FENCE_EXT      := new ExternalHandleType($9594);
    
    public static property HANDLE_TYPE_OPAQUE_FD_EXT:        ExternalHandleType read _HANDLE_TYPE_OPAQUE_FD_EXT;
    public static property HANDLE_TYPE_OPAQUE_WIN32_EXT:     ExternalHandleType read _HANDLE_TYPE_OPAQUE_WIN32_EXT;
    public static property HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT: ExternalHandleType read _HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT;
    public static property HANDLE_TYPE_D3D12_TILEPOOL_EXT:   ExternalHandleType read _HANDLE_TYPE_D3D12_TILEPOOL_EXT;
    public static property HANDLE_TYPE_D3D12_RESOURCE_EXT:   ExternalHandleType read _HANDLE_TYPE_D3D12_RESOURCE_EXT;
    public static property HANDLE_TYPE_D3D11_IMAGE_EXT:      ExternalHandleType read _HANDLE_TYPE_D3D11_IMAGE_EXT;
    public static property HANDLE_TYPE_D3D11_IMAGE_KMT_EXT:  ExternalHandleType read _HANDLE_TYPE_D3D11_IMAGE_KMT_EXT;
    public static property HANDLE_TYPE_D3D12_FENCE_EXT:      ExternalHandleType read _HANDLE_TYPE_D3D12_FENCE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9586) then Result := 'HANDLE_TYPE_OPAQUE_FD_EXT' else
      if self.val = UInt32($9587) then Result := 'HANDLE_TYPE_OPAQUE_WIN32_EXT' else
      if self.val = UInt32($9588) then Result := 'HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT' else
      if self.val = UInt32($9589) then Result := 'HANDLE_TYPE_D3D12_TILEPOOL_EXT' else
      if self.val = UInt32($958A) then Result := 'HANDLE_TYPE_D3D12_RESOURCE_EXT' else
      if self.val = UInt32($958B) then Result := 'HANDLE_TYPE_D3D11_IMAGE_EXT' else
      if self.val = UInt32($958C) then Result := 'HANDLE_TYPE_D3D11_IMAGE_KMT_EXT' else
      if self.val = UInt32($9594) then Result := 'HANDLE_TYPE_D3D12_FENCE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FeedbackType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _GL_2D               := new FeedbackType($0600);
    private static _GL_3D               := new FeedbackType($0601);
    private static _GL_3D_COLOR         := new FeedbackType($0602);
    private static _GL_3D_COLOR_TEXTURE := new FeedbackType($0603);
    private static _GL_4D_COLOR_TEXTURE := new FeedbackType($0604);
    
    public static property GL_2D:               FeedbackType read _GL_2D;
    public static property GL_3D:               FeedbackType read _GL_3D;
    public static property GL_3D_COLOR:         FeedbackType read _GL_3D_COLOR;
    public static property GL_3D_COLOR_TEXTURE: FeedbackType read _GL_3D_COLOR_TEXTURE;
    public static property GL_4D_COLOR_TEXTURE: FeedbackType read _GL_4D_COLOR_TEXTURE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0600) then Result := 'GL_2D' else
      if self.val = UInt32($0601) then Result := 'GL_3D' else
      if self.val = UInt32($0602) then Result := 'GL_3D_COLOR' else
      if self.val = UInt32($0603) then Result := 'GL_3D_COLOR_TEXTURE' else
      if self.val = UInt32($0604) then Result := 'GL_4D_COLOR_TEXTURE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FogCoordinatePointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FLOAT  := new FogCoordinatePointerType($1406);
    private static _DOUBLE := new FogCoordinatePointerType($140A);
    
    public static property FLOAT:  FogCoordinatePointerType read _FLOAT;
    public static property DOUBLE: FogCoordinatePointerType read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FogParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FOG_INDEX             := new FogParameter($0B61);
    private static _FOG_DENSITY           := new FogParameter($0B62);
    private static _FOG_START             := new FogParameter($0B63);
    private static _FOG_END               := new FogParameter($0B64);
    private static _FOG_MODE              := new FogParameter($0B65);
    private static _FOG_COLOR             := new FogParameter($0B66);
    private static _FOG_OFFSET_VALUE_SGIX := new FogParameter($8199);
    
    public static property FOG_INDEX:             FogParameter read _FOG_INDEX;
    public static property FOG_DENSITY:           FogParameter read _FOG_DENSITY;
    public static property FOG_START:             FogParameter read _FOG_START;
    public static property FOG_END:               FogParameter read _FOG_END;
    public static property FOG_MODE:              FogParameter read _FOG_MODE;
    public static property FOG_COLOR:             FogParameter read _FOG_COLOR;
    public static property FOG_OFFSET_VALUE_SGIX: FogParameter read _FOG_OFFSET_VALUE_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B61) then Result := 'FOG_INDEX' else
      if self.val = UInt32($0B62) then Result := 'FOG_DENSITY' else
      if self.val = UInt32($0B63) then Result := 'FOG_START' else
      if self.val = UInt32($0B64) then Result := 'FOG_END' else
      if self.val = UInt32($0B65) then Result := 'FOG_MODE' else
      if self.val = UInt32($0B66) then Result := 'FOG_COLOR' else
      if self.val = UInt32($8199) then Result := 'FOG_OFFSET_VALUE_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FogPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FOG_INDEX     := new FogPName($0B61);
    private static _FOG_DENSITY   := new FogPName($0B62);
    private static _FOG_START     := new FogPName($0B63);
    private static _FOG_END       := new FogPName($0B64);
    private static _FOG_MODE      := new FogPName($0B65);
    private static _FOG_COORD_SRC := new FogPName($8450);
    
    public static property FOG_INDEX:     FogPName read _FOG_INDEX;
    public static property FOG_DENSITY:   FogPName read _FOG_DENSITY;
    public static property FOG_START:     FogPName read _FOG_START;
    public static property FOG_END:       FogPName read _FOG_END;
    public static property FOG_MODE:      FogPName read _FOG_MODE;
    public static property FOG_COORD_SRC: FogPName read _FOG_COORD_SRC;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B61) then Result := 'FOG_INDEX' else
      if self.val = UInt32($0B62) then Result := 'FOG_DENSITY' else
      if self.val = UInt32($0B63) then Result := 'FOG_START' else
      if self.val = UInt32($0B64) then Result := 'FOG_END' else
      if self.val = UInt32($0B65) then Result := 'FOG_MODE' else
      if self.val = UInt32($8450) then Result := 'FOG_COORD_SRC' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FramebufferAttachment = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COLOR_ATTACHMENT0  := new FramebufferAttachment($8CE0);
    private static _COLOR_ATTACHMENT1  := new FramebufferAttachment($8CE1);
    private static _COLOR_ATTACHMENT2  := new FramebufferAttachment($8CE2);
    private static _COLOR_ATTACHMENT3  := new FramebufferAttachment($8CE3);
    private static _COLOR_ATTACHMENT4  := new FramebufferAttachment($8CE4);
    private static _COLOR_ATTACHMENT5  := new FramebufferAttachment($8CE5);
    private static _COLOR_ATTACHMENT6  := new FramebufferAttachment($8CE6);
    private static _COLOR_ATTACHMENT7  := new FramebufferAttachment($8CE7);
    private static _COLOR_ATTACHMENT8  := new FramebufferAttachment($8CE8);
    private static _COLOR_ATTACHMENT9  := new FramebufferAttachment($8CE9);
    private static _COLOR_ATTACHMENT10 := new FramebufferAttachment($8CEA);
    private static _COLOR_ATTACHMENT11 := new FramebufferAttachment($8CEB);
    private static _COLOR_ATTACHMENT12 := new FramebufferAttachment($8CEC);
    private static _COLOR_ATTACHMENT13 := new FramebufferAttachment($8CED);
    private static _COLOR_ATTACHMENT14 := new FramebufferAttachment($8CEE);
    private static _COLOR_ATTACHMENT15 := new FramebufferAttachment($8CEF);
    private static _COLOR_ATTACHMENT16 := new FramebufferAttachment($8CF0);
    private static _COLOR_ATTACHMENT17 := new FramebufferAttachment($8CF1);
    private static _COLOR_ATTACHMENT18 := new FramebufferAttachment($8CF2);
    private static _COLOR_ATTACHMENT19 := new FramebufferAttachment($8CF3);
    private static _COLOR_ATTACHMENT20 := new FramebufferAttachment($8CF4);
    private static _COLOR_ATTACHMENT21 := new FramebufferAttachment($8CF5);
    private static _COLOR_ATTACHMENT22 := new FramebufferAttachment($8CF6);
    private static _COLOR_ATTACHMENT23 := new FramebufferAttachment($8CF7);
    private static _COLOR_ATTACHMENT24 := new FramebufferAttachment($8CF8);
    private static _COLOR_ATTACHMENT25 := new FramebufferAttachment($8CF9);
    private static _COLOR_ATTACHMENT26 := new FramebufferAttachment($8CFA);
    private static _COLOR_ATTACHMENT27 := new FramebufferAttachment($8CFB);
    private static _COLOR_ATTACHMENT28 := new FramebufferAttachment($8CFC);
    private static _COLOR_ATTACHMENT29 := new FramebufferAttachment($8CFD);
    private static _COLOR_ATTACHMENT30 := new FramebufferAttachment($8CFE);
    private static _COLOR_ATTACHMENT31 := new FramebufferAttachment($8CFF);
    private static _STENCIL_ATTACHMENT := new FramebufferAttachment($8D20);
    
    public static property COLOR_ATTACHMENT0:  FramebufferAttachment read _COLOR_ATTACHMENT0;
    public static property COLOR_ATTACHMENT1:  FramebufferAttachment read _COLOR_ATTACHMENT1;
    public static property COLOR_ATTACHMENT2:  FramebufferAttachment read _COLOR_ATTACHMENT2;
    public static property COLOR_ATTACHMENT3:  FramebufferAttachment read _COLOR_ATTACHMENT3;
    public static property COLOR_ATTACHMENT4:  FramebufferAttachment read _COLOR_ATTACHMENT4;
    public static property COLOR_ATTACHMENT5:  FramebufferAttachment read _COLOR_ATTACHMENT5;
    public static property COLOR_ATTACHMENT6:  FramebufferAttachment read _COLOR_ATTACHMENT6;
    public static property COLOR_ATTACHMENT7:  FramebufferAttachment read _COLOR_ATTACHMENT7;
    public static property COLOR_ATTACHMENT8:  FramebufferAttachment read _COLOR_ATTACHMENT8;
    public static property COLOR_ATTACHMENT9:  FramebufferAttachment read _COLOR_ATTACHMENT9;
    public static property COLOR_ATTACHMENT10: FramebufferAttachment read _COLOR_ATTACHMENT10;
    public static property COLOR_ATTACHMENT11: FramebufferAttachment read _COLOR_ATTACHMENT11;
    public static property COLOR_ATTACHMENT12: FramebufferAttachment read _COLOR_ATTACHMENT12;
    public static property COLOR_ATTACHMENT13: FramebufferAttachment read _COLOR_ATTACHMENT13;
    public static property COLOR_ATTACHMENT14: FramebufferAttachment read _COLOR_ATTACHMENT14;
    public static property COLOR_ATTACHMENT15: FramebufferAttachment read _COLOR_ATTACHMENT15;
    public static property COLOR_ATTACHMENT16: FramebufferAttachment read _COLOR_ATTACHMENT16;
    public static property COLOR_ATTACHMENT17: FramebufferAttachment read _COLOR_ATTACHMENT17;
    public static property COLOR_ATTACHMENT18: FramebufferAttachment read _COLOR_ATTACHMENT18;
    public static property COLOR_ATTACHMENT19: FramebufferAttachment read _COLOR_ATTACHMENT19;
    public static property COLOR_ATTACHMENT20: FramebufferAttachment read _COLOR_ATTACHMENT20;
    public static property COLOR_ATTACHMENT21: FramebufferAttachment read _COLOR_ATTACHMENT21;
    public static property COLOR_ATTACHMENT22: FramebufferAttachment read _COLOR_ATTACHMENT22;
    public static property COLOR_ATTACHMENT23: FramebufferAttachment read _COLOR_ATTACHMENT23;
    public static property COLOR_ATTACHMENT24: FramebufferAttachment read _COLOR_ATTACHMENT24;
    public static property COLOR_ATTACHMENT25: FramebufferAttachment read _COLOR_ATTACHMENT25;
    public static property COLOR_ATTACHMENT26: FramebufferAttachment read _COLOR_ATTACHMENT26;
    public static property COLOR_ATTACHMENT27: FramebufferAttachment read _COLOR_ATTACHMENT27;
    public static property COLOR_ATTACHMENT28: FramebufferAttachment read _COLOR_ATTACHMENT28;
    public static property COLOR_ATTACHMENT29: FramebufferAttachment read _COLOR_ATTACHMENT29;
    public static property COLOR_ATTACHMENT30: FramebufferAttachment read _COLOR_ATTACHMENT30;
    public static property COLOR_ATTACHMENT31: FramebufferAttachment read _COLOR_ATTACHMENT31;
    public static property STENCIL_ATTACHMENT: FramebufferAttachment read _STENCIL_ATTACHMENT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
      if self.val = UInt32($8D20) then Result := 'STENCIL_ATTACHMENT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FramebufferAttachmentParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING              := new FramebufferAttachmentParameterName($8210);
    private static _FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT          := new FramebufferAttachmentParameterName($8210);
    private static _FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE              := new FramebufferAttachmentParameterName($8211);
    private static _FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT          := new FramebufferAttachmentParameterName($8211);
    private static _FRAMEBUFFER_ATTACHMENT_RED_SIZE                    := new FramebufferAttachmentParameterName($8212);
    private static _FRAMEBUFFER_ATTACHMENT_GREEN_SIZE                  := new FramebufferAttachmentParameterName($8213);
    private static _FRAMEBUFFER_ATTACHMENT_BLUE_SIZE                   := new FramebufferAttachmentParameterName($8214);
    private static _FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE                  := new FramebufferAttachmentParameterName($8215);
    private static _FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE                  := new FramebufferAttachmentParameterName($8216);
    private static _FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE                := new FramebufferAttachmentParameterName($8217);
    private static _FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE                 := new FramebufferAttachmentParameterName($8CD0);
    private static _FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT             := new FramebufferAttachmentParameterName($8CD0);
    private static _FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES             := new FramebufferAttachmentParameterName($8CD0);
    private static _FRAMEBUFFER_ATTACHMENT_OBJECT_NAME                 := new FramebufferAttachmentParameterName($8CD1);
    private static _FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT             := new FramebufferAttachmentParameterName($8CD1);
    private static _FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES             := new FramebufferAttachmentParameterName($8CD1);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL               := new FramebufferAttachmentParameterName($8CD2);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT           := new FramebufferAttachmentParameterName($8CD2);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES           := new FramebufferAttachmentParameterName($8CD2);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE       := new FramebufferAttachmentParameterName($8CD3);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT   := new FramebufferAttachmentParameterName($8CD3);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES   := new FramebufferAttachmentParameterName($8CD3);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT      := new FramebufferAttachmentParameterName($8CD4);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES      := new FramebufferAttachmentParameterName($8CD4);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER               := new FramebufferAttachmentParameterName($8CD4);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT           := new FramebufferAttachmentParameterName($8CD4);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT         := new FramebufferAttachmentParameterName($8D6C);
    private static _FRAMEBUFFER_ATTACHMENT_LAYERED                     := new FramebufferAttachmentParameterName($8DA7);
    private static _FRAMEBUFFER_ATTACHMENT_LAYERED_ARB                 := new FramebufferAttachmentParameterName($8DA7);
    private static _FRAMEBUFFER_ATTACHMENT_LAYERED_EXT                 := new FramebufferAttachmentParameterName($8DA7);
    private static _FRAMEBUFFER_ATTACHMENT_LAYERED_OES                 := new FramebufferAttachmentParameterName($8DA7);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG           := new FramebufferAttachmentParameterName($913F);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR       := new FramebufferAttachmentParameterName($9630);
    private static _FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR := new FramebufferAttachmentParameterName($9632);
    
    public static property FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:              FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING;
    public static property FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT:          FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:              FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE;
    public static property FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT:          FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_RED_SIZE:                    FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_RED_SIZE;
    public static property FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:                  FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_GREEN_SIZE;
    public static property FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:                   FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_BLUE_SIZE;
    public static property FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:                  FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE;
    public static property FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:                  FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE;
    public static property FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:                FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE;
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:                 FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT:             FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES:             FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES;
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:                 FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT:             FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES:             FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:               FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT:           FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES:           FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:       FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT:   FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES:   FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT:      FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES:      FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:               FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT:           FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT:         FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_LAYERED:                     FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_LAYERED;
    public static property FRAMEBUFFER_ATTACHMENT_LAYERED_ARB:                 FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_LAYERED_ARB;
    public static property FRAMEBUFFER_ATTACHMENT_LAYERED_EXT:                 FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_LAYERED_EXT;
    public static property FRAMEBUFFER_ATTACHMENT_LAYERED_OES:                 FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_LAYERED_OES;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG:           FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR:       FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR;
    public static property FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR: FramebufferAttachmentParameterName read _FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8210) then Result := 'FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING' else
      if self.val = UInt32($8210) then Result := 'FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT' else
      if self.val = UInt32($8211) then Result := 'FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE' else
      if self.val = UInt32($8211) then Result := 'FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT' else
      if self.val = UInt32($8212) then Result := 'FRAMEBUFFER_ATTACHMENT_RED_SIZE' else
      if self.val = UInt32($8213) then Result := 'FRAMEBUFFER_ATTACHMENT_GREEN_SIZE' else
      if self.val = UInt32($8214) then Result := 'FRAMEBUFFER_ATTACHMENT_BLUE_SIZE' else
      if self.val = UInt32($8215) then Result := 'FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE' else
      if self.val = UInt32($8216) then Result := 'FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE' else
      if self.val = UInt32($8217) then Result := 'FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE' else
      if self.val = UInt32($8CD0) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE' else
      if self.val = UInt32($8CD0) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT' else
      if self.val = UInt32($8CD0) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES' else
      if self.val = UInt32($8CD1) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME' else
      if self.val = UInt32($8CD1) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT' else
      if self.val = UInt32($8CD1) then Result := 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES' else
      if self.val = UInt32($8CD2) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL' else
      if self.val = UInt32($8CD2) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT' else
      if self.val = UInt32($8CD2) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES' else
      if self.val = UInt32($8CD3) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE' else
      if self.val = UInt32($8CD3) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT' else
      if self.val = UInt32($8CD3) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES' else
      if self.val = UInt32($8CD4) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT' else
      if self.val = UInt32($8CD4) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES' else
      if self.val = UInt32($8CD4) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER' else
      if self.val = UInt32($8CD4) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT' else
      if self.val = UInt32($8D6C) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT' else
      if self.val = UInt32($8DA7) then Result := 'FRAMEBUFFER_ATTACHMENT_LAYERED' else
      if self.val = UInt32($8DA7) then Result := 'FRAMEBUFFER_ATTACHMENT_LAYERED_ARB' else
      if self.val = UInt32($8DA7) then Result := 'FRAMEBUFFER_ATTACHMENT_LAYERED_EXT' else
      if self.val = UInt32($8DA7) then Result := 'FRAMEBUFFER_ATTACHMENT_LAYERED_OES' else
      if self.val = UInt32($913F) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG' else
      if self.val = UInt32($9630) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR' else
      if self.val = UInt32($9632) then Result := 'FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FramebufferParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRAMEBUFFER_DEFAULT_WIDTH                  := new FramebufferParameterName($9310);
    private static _FRAMEBUFFER_DEFAULT_HEIGHT                 := new FramebufferParameterName($9311);
    private static _FRAMEBUFFER_DEFAULT_LAYERS                 := new FramebufferParameterName($9312);
    private static _FRAMEBUFFER_DEFAULT_SAMPLES                := new FramebufferParameterName($9313);
    private static _FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS := new FramebufferParameterName($9314);
    
    public static property FRAMEBUFFER_DEFAULT_WIDTH:                  FramebufferParameterName read _FRAMEBUFFER_DEFAULT_WIDTH;
    public static property FRAMEBUFFER_DEFAULT_HEIGHT:                 FramebufferParameterName read _FRAMEBUFFER_DEFAULT_HEIGHT;
    public static property FRAMEBUFFER_DEFAULT_LAYERS:                 FramebufferParameterName read _FRAMEBUFFER_DEFAULT_LAYERS;
    public static property FRAMEBUFFER_DEFAULT_SAMPLES:                FramebufferParameterName read _FRAMEBUFFER_DEFAULT_SAMPLES;
    public static property FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: FramebufferParameterName read _FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9310) then Result := 'FRAMEBUFFER_DEFAULT_WIDTH' else
      if self.val = UInt32($9311) then Result := 'FRAMEBUFFER_DEFAULT_HEIGHT' else
      if self.val = UInt32($9312) then Result := 'FRAMEBUFFER_DEFAULT_LAYERS' else
      if self.val = UInt32($9313) then Result := 'FRAMEBUFFER_DEFAULT_SAMPLES' else
      if self.val = UInt32($9314) then Result := 'FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FramebufferStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRAMEBUFFER_UNDEFINED                     := new FramebufferStatus($8219);
    private static _FRAMEBUFFER_COMPLETE                      := new FramebufferStatus($8CD5);
    private static _FRAMEBUFFER_INCOMPLETE_ATTACHMENT         := new FramebufferStatus($8CD6);
    private static _FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT := new FramebufferStatus($8CD7);
    private static _FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER        := new FramebufferStatus($8CDB);
    private static _FRAMEBUFFER_INCOMPLETE_READ_BUFFER        := new FramebufferStatus($8CDC);
    private static _FRAMEBUFFER_UNSUPPORTED                   := new FramebufferStatus($8CDD);
    private static _FRAMEBUFFER_INCOMPLETE_MULTISAMPLE        := new FramebufferStatus($8D56);
    private static _FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS      := new FramebufferStatus($8DA8);
    
    public static property FRAMEBUFFER_UNDEFINED:                     FramebufferStatus read _FRAMEBUFFER_UNDEFINED;
    public static property FRAMEBUFFER_COMPLETE:                      FramebufferStatus read _FRAMEBUFFER_COMPLETE;
    public static property FRAMEBUFFER_INCOMPLETE_ATTACHMENT:         FramebufferStatus read _FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
    public static property FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: FramebufferStatus read _FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
    public static property FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:        FramebufferStatus read _FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER;
    public static property FRAMEBUFFER_INCOMPLETE_READ_BUFFER:        FramebufferStatus read _FRAMEBUFFER_INCOMPLETE_READ_BUFFER;
    public static property FRAMEBUFFER_UNSUPPORTED:                   FramebufferStatus read _FRAMEBUFFER_UNSUPPORTED;
    public static property FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:        FramebufferStatus read _FRAMEBUFFER_INCOMPLETE_MULTISAMPLE;
    public static property FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:      FramebufferStatus read _FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8219) then Result := 'FRAMEBUFFER_UNDEFINED' else
      if self.val = UInt32($8CD5) then Result := 'FRAMEBUFFER_COMPLETE' else
      if self.val = UInt32($8CD6) then Result := 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT' else
      if self.val = UInt32($8CD7) then Result := 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT' else
      if self.val = UInt32($8CDB) then Result := 'FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER' else
      if self.val = UInt32($8CDC) then Result := 'FRAMEBUFFER_INCOMPLETE_READ_BUFFER' else
      if self.val = UInt32($8CDD) then Result := 'FRAMEBUFFER_UNSUPPORTED' else
      if self.val = UInt32($8D56) then Result := 'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE' else
      if self.val = UInt32($8DA8) then Result := 'FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FramebufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _READ_FRAMEBUFFER := new FramebufferTarget($8CA8);
    private static _DRAW_FRAMEBUFFER := new FramebufferTarget($8CA9);
    private static _FRAMEBUFFER      := new FramebufferTarget($8D40);
    private static _FRAMEBUFFER_OES  := new FramebufferTarget($8D40);
    
    public static property READ_FRAMEBUFFER: FramebufferTarget read _READ_FRAMEBUFFER;
    public static property DRAW_FRAMEBUFFER: FramebufferTarget read _DRAW_FRAMEBUFFER;
    public static property FRAMEBUFFER:      FramebufferTarget read _FRAMEBUFFER;
    public static property FRAMEBUFFER_OES:  FramebufferTarget read _FRAMEBUFFER_OES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8CA8) then Result := 'READ_FRAMEBUFFER' else
      if self.val = UInt32($8CA9) then Result := 'DRAW_FRAMEBUFFER' else
      if self.val = UInt32($8D40) then Result := 'FRAMEBUFFER' else
      if self.val = UInt32($8D40) then Result := 'FRAMEBUFFER_OES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FrontFaceDirection = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CW  := new FrontFaceDirection($0900);
    private static _CCW := new FrontFaceDirection($0901);
    
    public static property CW:  FrontFaceDirection read _CW;
    public static property CCW: FrontFaceDirection read _CCW;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0900) then Result := 'CW' else
      if self.val = UInt32($0901) then Result := 'CCW' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetFramebufferParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DOUBLEBUFFER                               := new GetFramebufferParameter($0C32);
    private static _STEREO                                     := new GetFramebufferParameter($0C33);
    private static _SAMPLE_BUFFERS                             := new GetFramebufferParameter($80A8);
    private static _SAMPLES                                    := new GetFramebufferParameter($80A9);
    private static _IMPLEMENTATION_COLOR_READ_TYPE             := new GetFramebufferParameter($8B9A);
    private static _IMPLEMENTATION_COLOR_READ_FORMAT           := new GetFramebufferParameter($8B9B);
    private static _FRAMEBUFFER_DEFAULT_WIDTH                  := new GetFramebufferParameter($9310);
    private static _FRAMEBUFFER_DEFAULT_HEIGHT                 := new GetFramebufferParameter($9311);
    private static _FRAMEBUFFER_DEFAULT_LAYERS                 := new GetFramebufferParameter($9312);
    private static _FRAMEBUFFER_DEFAULT_SAMPLES                := new GetFramebufferParameter($9313);
    private static _FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS := new GetFramebufferParameter($9314);
    
    public static property DOUBLEBUFFER:                               GetFramebufferParameter read _DOUBLEBUFFER;
    public static property STEREO:                                     GetFramebufferParameter read _STEREO;
    public static property SAMPLE_BUFFERS:                             GetFramebufferParameter read _SAMPLE_BUFFERS;
    public static property SAMPLES:                                    GetFramebufferParameter read _SAMPLES;
    public static property IMPLEMENTATION_COLOR_READ_TYPE:             GetFramebufferParameter read _IMPLEMENTATION_COLOR_READ_TYPE;
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:           GetFramebufferParameter read _IMPLEMENTATION_COLOR_READ_FORMAT;
    public static property FRAMEBUFFER_DEFAULT_WIDTH:                  GetFramebufferParameter read _FRAMEBUFFER_DEFAULT_WIDTH;
    public static property FRAMEBUFFER_DEFAULT_HEIGHT:                 GetFramebufferParameter read _FRAMEBUFFER_DEFAULT_HEIGHT;
    public static property FRAMEBUFFER_DEFAULT_LAYERS:                 GetFramebufferParameter read _FRAMEBUFFER_DEFAULT_LAYERS;
    public static property FRAMEBUFFER_DEFAULT_SAMPLES:                GetFramebufferParameter read _FRAMEBUFFER_DEFAULT_SAMPLES;
    public static property FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: GetFramebufferParameter read _FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0C32) then Result := 'DOUBLEBUFFER' else
      if self.val = UInt32($0C33) then Result := 'STEREO' else
      if self.val = UInt32($80A8) then Result := 'SAMPLE_BUFFERS' else
      if self.val = UInt32($80A9) then Result := 'SAMPLES' else
      if self.val = UInt32($8B9A) then Result := 'IMPLEMENTATION_COLOR_READ_TYPE' else
      if self.val = UInt32($8B9B) then Result := 'IMPLEMENTATION_COLOR_READ_FORMAT' else
      if self.val = UInt32($9310) then Result := 'FRAMEBUFFER_DEFAULT_WIDTH' else
      if self.val = UInt32($9311) then Result := 'FRAMEBUFFER_DEFAULT_HEIGHT' else
      if self.val = UInt32($9312) then Result := 'FRAMEBUFFER_DEFAULT_LAYERS' else
      if self.val = UInt32($9313) then Result := 'FRAMEBUFFER_DEFAULT_SAMPLES' else
      if self.val = UInt32($9314) then Result := 'FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetMapQuery = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COEFF  := new GetMapQuery($0A00);
    private static _ORDER  := new GetMapQuery($0A01);
    private static _DOMAIN := new GetMapQuery($0A02);
    
    public static property COEFF:  GetMapQuery read _COEFF;
    public static property ORDER:  GetMapQuery read _ORDER;
    public static property DOMAIN: GetMapQuery read _DOMAIN;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0A00) then Result := 'COEFF' else
      if self.val = UInt32($0A01) then Result := 'ORDER' else
      if self.val = UInt32($0A02) then Result := 'DOMAIN' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CURRENT_COLOR                                  := new GetPName($0B00);
    private static _CURRENT_INDEX                                  := new GetPName($0B01);
    private static _CURRENT_NORMAL                                 := new GetPName($0B02);
    private static _CURRENT_TEXTURE_COORDS                         := new GetPName($0B03);
    private static _CURRENT_RASTER_COLOR                           := new GetPName($0B04);
    private static _CURRENT_RASTER_INDEX                           := new GetPName($0B05);
    private static _CURRENT_RASTER_TEXTURE_COORDS                  := new GetPName($0B06);
    private static _CURRENT_RASTER_POSITION                        := new GetPName($0B07);
    private static _CURRENT_RASTER_POSITION_VALID                  := new GetPName($0B08);
    private static _CURRENT_RASTER_DISTANCE                        := new GetPName($0B09);
    private static _POINT_SMOOTH                                   := new GetPName($0B10);
    private static _POINT_SIZE                                     := new GetPName($0B11);
    private static _POINT_SIZE_RANGE                               := new GetPName($0B12);
    private static _SMOOTH_POINT_SIZE_RANGE                        := new GetPName($0B12);
    private static _POINT_SIZE_GRANULARITY                         := new GetPName($0B13);
    private static _SMOOTH_POINT_SIZE_GRANULARITY                  := new GetPName($0B13);
    private static _LINE_SMOOTH                                    := new GetPName($0B20);
    private static _LINE_WIDTH                                     := new GetPName($0B21);
    private static _LINE_WIDTH_RANGE                               := new GetPName($0B22);
    private static _SMOOTH_LINE_WIDTH_RANGE                        := new GetPName($0B22);
    private static _LINE_WIDTH_GRANULARITY                         := new GetPName($0B23);
    private static _SMOOTH_LINE_WIDTH_GRANULARITY                  := new GetPName($0B23);
    private static _LINE_STIPPLE                                   := new GetPName($0B24);
    private static _LINE_STIPPLE_PATTERN                           := new GetPName($0B25);
    private static _LINE_STIPPLE_REPEAT                            := new GetPName($0B26);
    private static _LIST_MODE                                      := new GetPName($0B30);
    private static _MAX_LIST_NESTING                               := new GetPName($0B31);
    private static _LIST_BASE                                      := new GetPName($0B32);
    private static _LIST_INDEX                                     := new GetPName($0B33);
    private static _POLYGON_MODE                                   := new GetPName($0B40);
    private static _POLYGON_SMOOTH                                 := new GetPName($0B41);
    private static _POLYGON_STIPPLE                                := new GetPName($0B42);
    private static _EDGE_FLAG                                      := new GetPName($0B43);
    private static _CULL_FACE                                      := new GetPName($0B44);
    private static _CULL_FACE_MODE                                 := new GetPName($0B45);
    private static _FRONT_FACE                                     := new GetPName($0B46);
    private static _LIGHTING                                       := new GetPName($0B50);
    private static _LIGHT_MODEL_LOCAL_VIEWER                       := new GetPName($0B51);
    private static _LIGHT_MODEL_TWO_SIDE                           := new GetPName($0B52);
    private static _LIGHT_MODEL_AMBIENT                            := new GetPName($0B53);
    private static _SHADE_MODEL                                    := new GetPName($0B54);
    private static _COLOR_MATERIAL_FACE                            := new GetPName($0B55);
    private static _COLOR_MATERIAL_PARAMETER                       := new GetPName($0B56);
    private static _COLOR_MATERIAL                                 := new GetPName($0B57);
    private static _FOG                                            := new GetPName($0B60);
    private static _FOG_INDEX                                      := new GetPName($0B61);
    private static _FOG_DENSITY                                    := new GetPName($0B62);
    private static _FOG_START                                      := new GetPName($0B63);
    private static _FOG_END                                        := new GetPName($0B64);
    private static _FOG_MODE                                       := new GetPName($0B65);
    private static _FOG_COLOR                                      := new GetPName($0B66);
    private static _DEPTH_RANGE                                    := new GetPName($0B70);
    private static _DEPTH_TEST                                     := new GetPName($0B71);
    private static _DEPTH_WRITEMASK                                := new GetPName($0B72);
    private static _DEPTH_CLEAR_VALUE                              := new GetPName($0B73);
    private static _DEPTH_FUNC                                     := new GetPName($0B74);
    private static _ACCUM_CLEAR_VALUE                              := new GetPName($0B80);
    private static _STENCIL_TEST                                   := new GetPName($0B90);
    private static _STENCIL_CLEAR_VALUE                            := new GetPName($0B91);
    private static _STENCIL_FUNC                                   := new GetPName($0B92);
    private static _STENCIL_VALUE_MASK                             := new GetPName($0B93);
    private static _STENCIL_FAIL                                   := new GetPName($0B94);
    private static _STENCIL_PASS_DEPTH_FAIL                        := new GetPName($0B95);
    private static _STENCIL_PASS_DEPTH_PASS                        := new GetPName($0B96);
    private static _STENCIL_REF                                    := new GetPName($0B97);
    private static _STENCIL_WRITEMASK                              := new GetPName($0B98);
    private static _MATRIX_MODE                                    := new GetPName($0BA0);
    private static _NORMALIZE                                      := new GetPName($0BA1);
    private static _VIEWPORT                                       := new GetPName($0BA2);
    private static _MODELVIEW_STACK_DEPTH                          := new GetPName($0BA3);
    private static _MODELVIEW0_STACK_DEPTH_EXT                     := new GetPName($0BA3);
    private static _PROJECTION_STACK_DEPTH                         := new GetPName($0BA4);
    private static _TEXTURE_STACK_DEPTH                            := new GetPName($0BA5);
    private static _MODELVIEW_MATRIX                               := new GetPName($0BA6);
    private static _MODELVIEW0_MATRIX_EXT                          := new GetPName($0BA6);
    private static _PROJECTION_MATRIX                              := new GetPName($0BA7);
    private static _TEXTURE_MATRIX                                 := new GetPName($0BA8);
    private static _ATTRIB_STACK_DEPTH                             := new GetPName($0BB0);
    private static _CLIENT_ATTRIB_STACK_DEPTH                      := new GetPName($0BB1);
    private static _ALPHA_TEST                                     := new GetPName($0BC0);
    private static _ALPHA_TEST_QCOM                                := new GetPName($0BC0);
    private static _ALPHA_TEST_FUNC                                := new GetPName($0BC1);
    private static _ALPHA_TEST_FUNC_QCOM                           := new GetPName($0BC1);
    private static _ALPHA_TEST_REF                                 := new GetPName($0BC2);
    private static _ALPHA_TEST_REF_QCOM                            := new GetPName($0BC2);
    private static _DITHER                                         := new GetPName($0BD0);
    private static _BLEND_DST                                      := new GetPName($0BE0);
    private static _BLEND_SRC                                      := new GetPName($0BE1);
    private static _BLEND                                          := new GetPName($0BE2);
    private static _LOGIC_OP_MODE                                  := new GetPName($0BF0);
    private static _INDEX_LOGIC_OP                                 := new GetPName($0BF1);
    private static _LOGIC_OP                                       := new GetPName($0BF1);
    private static _COLOR_LOGIC_OP                                 := new GetPName($0BF2);
    private static _AUX_BUFFERS                                    := new GetPName($0C00);
    private static _DRAW_BUFFER                                    := new GetPName($0C01);
    private static _DRAW_BUFFER_EXT                                := new GetPName($0C01);
    private static _READ_BUFFER                                    := new GetPName($0C02);
    private static _READ_BUFFER_EXT                                := new GetPName($0C02);
    private static _READ_BUFFER_NV                                 := new GetPName($0C02);
    private static _SCISSOR_BOX                                    := new GetPName($0C10);
    private static _SCISSOR_TEST                                   := new GetPName($0C11);
    private static _INDEX_CLEAR_VALUE                              := new GetPName($0C20);
    private static _INDEX_WRITEMASK                                := new GetPName($0C21);
    private static _COLOR_CLEAR_VALUE                              := new GetPName($0C22);
    private static _COLOR_WRITEMASK                                := new GetPName($0C23);
    private static _INDEX_MODE                                     := new GetPName($0C30);
    private static _RGBA_MODE                                      := new GetPName($0C31);
    private static _DOUBLEBUFFER                                   := new GetPName($0C32);
    private static _STEREO                                         := new GetPName($0C33);
    private static _RENDER_MODE                                    := new GetPName($0C40);
    private static _PERSPECTIVE_CORRECTION_HINT                    := new GetPName($0C50);
    private static _POINT_SMOOTH_HINT                              := new GetPName($0C51);
    private static _LINE_SMOOTH_HINT                               := new GetPName($0C52);
    private static _POLYGON_SMOOTH_HINT                            := new GetPName($0C53);
    private static _FOG_HINT                                       := new GetPName($0C54);
    private static _TEXTURE_GEN_S                                  := new GetPName($0C60);
    private static _TEXTURE_GEN_T                                  := new GetPName($0C61);
    private static _TEXTURE_GEN_R                                  := new GetPName($0C62);
    private static _TEXTURE_GEN_Q                                  := new GetPName($0C63);
    private static _PIXEL_MAP_I_TO_I_SIZE                          := new GetPName($0CB0);
    private static _PIXEL_MAP_S_TO_S_SIZE                          := new GetPName($0CB1);
    private static _PIXEL_MAP_I_TO_R_SIZE                          := new GetPName($0CB2);
    private static _PIXEL_MAP_I_TO_G_SIZE                          := new GetPName($0CB3);
    private static _PIXEL_MAP_I_TO_B_SIZE                          := new GetPName($0CB4);
    private static _PIXEL_MAP_I_TO_A_SIZE                          := new GetPName($0CB5);
    private static _PIXEL_MAP_R_TO_R_SIZE                          := new GetPName($0CB6);
    private static _PIXEL_MAP_G_TO_G_SIZE                          := new GetPName($0CB7);
    private static _PIXEL_MAP_B_TO_B_SIZE                          := new GetPName($0CB8);
    private static _PIXEL_MAP_A_TO_A_SIZE                          := new GetPName($0CB9);
    private static _UNPACK_SWAP_BYTES                              := new GetPName($0CF0);
    private static _UNPACK_LSB_FIRST                               := new GetPName($0CF1);
    private static _UNPACK_ROW_LENGTH                              := new GetPName($0CF2);
    private static _UNPACK_SKIP_ROWS                               := new GetPName($0CF3);
    private static _UNPACK_SKIP_PIXELS                             := new GetPName($0CF4);
    private static _UNPACK_ALIGNMENT                               := new GetPName($0CF5);
    private static _PACK_SWAP_BYTES                                := new GetPName($0D00);
    private static _PACK_LSB_FIRST                                 := new GetPName($0D01);
    private static _PACK_ROW_LENGTH                                := new GetPName($0D02);
    private static _PACK_SKIP_ROWS                                 := new GetPName($0D03);
    private static _PACK_SKIP_PIXELS                               := new GetPName($0D04);
    private static _PACK_ALIGNMENT                                 := new GetPName($0D05);
    private static _MAP_COLOR                                      := new GetPName($0D10);
    private static _MAP_STENCIL                                    := new GetPName($0D11);
    private static _INDEX_SHIFT                                    := new GetPName($0D12);
    private static _INDEX_OFFSET                                   := new GetPName($0D13);
    private static _RED_SCALE                                      := new GetPName($0D14);
    private static _RED_BIAS                                       := new GetPName($0D15);
    private static _ZOOM_X                                         := new GetPName($0D16);
    private static _ZOOM_Y                                         := new GetPName($0D17);
    private static _GREEN_SCALE                                    := new GetPName($0D18);
    private static _GREEN_BIAS                                     := new GetPName($0D19);
    private static _BLUE_SCALE                                     := new GetPName($0D1A);
    private static _BLUE_BIAS                                      := new GetPName($0D1B);
    private static _ALPHA_SCALE                                    := new GetPName($0D1C);
    private static _ALPHA_BIAS                                     := new GetPName($0D1D);
    private static _DEPTH_SCALE                                    := new GetPName($0D1E);
    private static _DEPTH_BIAS                                     := new GetPName($0D1F);
    private static _MAX_EVAL_ORDER                                 := new GetPName($0D30);
    private static _MAX_LIGHTS                                     := new GetPName($0D31);
    private static _MAX_CLIP_DISTANCES                             := new GetPName($0D32);
    private static _MAX_CLIP_PLANES                                := new GetPName($0D32);
    private static _MAX_TEXTURE_SIZE                               := new GetPName($0D33);
    private static _MAX_PIXEL_MAP_TABLE                            := new GetPName($0D34);
    private static _MAX_ATTRIB_STACK_DEPTH                         := new GetPName($0D35);
    private static _MAX_MODELVIEW_STACK_DEPTH                      := new GetPName($0D36);
    private static _MAX_NAME_STACK_DEPTH                           := new GetPName($0D37);
    private static _MAX_PROJECTION_STACK_DEPTH                     := new GetPName($0D38);
    private static _MAX_TEXTURE_STACK_DEPTH                        := new GetPName($0D39);
    private static _MAX_VIEWPORT_DIMS                              := new GetPName($0D3A);
    private static _MAX_CLIENT_ATTRIB_STACK_DEPTH                  := new GetPName($0D3B);
    private static _SUBPIXEL_BITS                                  := new GetPName($0D50);
    private static _INDEX_BITS                                     := new GetPName($0D51);
    private static _RED_BITS                                       := new GetPName($0D52);
    private static _GREEN_BITS                                     := new GetPName($0D53);
    private static _BLUE_BITS                                      := new GetPName($0D54);
    private static _ALPHA_BITS                                     := new GetPName($0D55);
    private static _DEPTH_BITS                                     := new GetPName($0D56);
    private static _STENCIL_BITS                                   := new GetPName($0D57);
    private static _ACCUM_RED_BITS                                 := new GetPName($0D58);
    private static _ACCUM_GREEN_BITS                               := new GetPName($0D59);
    private static _ACCUM_BLUE_BITS                                := new GetPName($0D5A);
    private static _ACCUM_ALPHA_BITS                               := new GetPName($0D5B);
    private static _NAME_STACK_DEPTH                               := new GetPName($0D70);
    private static _AUTO_NORMAL                                    := new GetPName($0D80);
    private static _MAP1_COLOR_4                                   := new GetPName($0D90);
    private static _MAP1_INDEX                                     := new GetPName($0D91);
    private static _MAP1_NORMAL                                    := new GetPName($0D92);
    private static _MAP1_TEXTURE_COORD_1                           := new GetPName($0D93);
    private static _MAP1_TEXTURE_COORD_2                           := new GetPName($0D94);
    private static _MAP1_TEXTURE_COORD_3                           := new GetPName($0D95);
    private static _MAP1_TEXTURE_COORD_4                           := new GetPName($0D96);
    private static _MAP1_VERTEX_3                                  := new GetPName($0D97);
    private static _MAP1_VERTEX_4                                  := new GetPName($0D98);
    private static _MAP2_COLOR_4                                   := new GetPName($0DB0);
    private static _MAP2_INDEX                                     := new GetPName($0DB1);
    private static _MAP2_NORMAL                                    := new GetPName($0DB2);
    private static _MAP2_TEXTURE_COORD_1                           := new GetPName($0DB3);
    private static _MAP2_TEXTURE_COORD_2                           := new GetPName($0DB4);
    private static _MAP2_TEXTURE_COORD_3                           := new GetPName($0DB5);
    private static _MAP2_TEXTURE_COORD_4                           := new GetPName($0DB6);
    private static _MAP2_VERTEX_3                                  := new GetPName($0DB7);
    private static _MAP2_VERTEX_4                                  := new GetPName($0DB8);
    private static _MAP1_GRID_DOMAIN                               := new GetPName($0DD0);
    private static _MAP1_GRID_SEGMENTS                             := new GetPName($0DD1);
    private static _MAP2_GRID_DOMAIN                               := new GetPName($0DD2);
    private static _MAP2_GRID_SEGMENTS                             := new GetPName($0DD3);
    private static _TEXTURE_1D                                     := new GetPName($0DE0);
    private static _TEXTURE_2D                                     := new GetPName($0DE1);
    private static _FEEDBACK_BUFFER_SIZE                           := new GetPName($0DF1);
    private static _FEEDBACK_BUFFER_TYPE                           := new GetPName($0DF2);
    private static _SELECTION_BUFFER_SIZE                          := new GetPName($0DF4);
    private static _POLYGON_OFFSET_UNITS                           := new GetPName($2A00);
    private static _POLYGON_OFFSET_POINT                           := new GetPName($2A01);
    private static _POLYGON_OFFSET_LINE                            := new GetPName($2A02);
    private static _CLIP_PLANE0                                    := new GetPName($3000);
    private static _CLIP_PLANE1                                    := new GetPName($3001);
    private static _CLIP_PLANE2                                    := new GetPName($3002);
    private static _CLIP_PLANE3                                    := new GetPName($3003);
    private static _CLIP_PLANE4                                    := new GetPName($3004);
    private static _CLIP_PLANE5                                    := new GetPName($3005);
    private static _LIGHT0                                         := new GetPName($4000);
    private static _LIGHT1                                         := new GetPName($4001);
    private static _LIGHT2                                         := new GetPName($4002);
    private static _LIGHT3                                         := new GetPName($4003);
    private static _LIGHT4                                         := new GetPName($4004);
    private static _LIGHT5                                         := new GetPName($4005);
    private static _LIGHT6                                         := new GetPName($4006);
    private static _LIGHT7                                         := new GetPName($4007);
    private static _BLEND_COLOR                                    := new GetPName($8005);
    private static _BLEND_COLOR_EXT                                := new GetPName($8005);
    private static _BLEND_EQUATION_EXT                             := new GetPName($8009);
    private static _BLEND_EQUATION_RGB                             := new GetPName($8009);
    private static _PACK_CMYK_HINT_EXT                             := new GetPName($800E);
    private static _UNPACK_CMYK_HINT_EXT                           := new GetPName($800F);
    private static _CONVOLUTION_1D_EXT                             := new GetPName($8010);
    private static _CONVOLUTION_2D_EXT                             := new GetPName($8011);
    private static _SEPARABLE_2D_EXT                               := new GetPName($8012);
    private static _POST_CONVOLUTION_RED_SCALE_EXT                 := new GetPName($801C);
    private static _POST_CONVOLUTION_GREEN_SCALE_EXT               := new GetPName($801D);
    private static _POST_CONVOLUTION_BLUE_SCALE_EXT                := new GetPName($801E);
    private static _POST_CONVOLUTION_ALPHA_SCALE_EXT               := new GetPName($801F);
    private static _POST_CONVOLUTION_RED_BIAS_EXT                  := new GetPName($8020);
    private static _POST_CONVOLUTION_GREEN_BIAS_EXT                := new GetPName($8021);
    private static _POST_CONVOLUTION_BLUE_BIAS_EXT                 := new GetPName($8022);
    private static _POST_CONVOLUTION_ALPHA_BIAS_EXT                := new GetPName($8023);
    private static _HISTOGRAM_EXT                                  := new GetPName($8024);
    private static _MINMAX_EXT                                     := new GetPName($802E);
    private static _POLYGON_OFFSET_FILL                            := new GetPName($8037);
    private static _POLYGON_OFFSET_FACTOR                          := new GetPName($8038);
    private static _POLYGON_OFFSET_BIAS_EXT                        := new GetPName($8039);
    private static _RESCALE_NORMAL_EXT                             := new GetPName($803A);
    private static _TEXTURE_BINDING_1D                             := new GetPName($8068);
    private static _TEXTURE_BINDING_2D                             := new GetPName($8069);
    private static _TEXTURE_3D_BINDING_EXT                         := new GetPName($806A);
    private static _TEXTURE_BINDING_3D                             := new GetPName($806A);
    private static _PACK_SKIP_IMAGES                               := new GetPName($806B);
    private static _PACK_SKIP_IMAGES_EXT                           := new GetPName($806B);
    private static _PACK_IMAGE_HEIGHT                              := new GetPName($806C);
    private static _PACK_IMAGE_HEIGHT_EXT                          := new GetPName($806C);
    private static _UNPACK_SKIP_IMAGES                             := new GetPName($806D);
    private static _UNPACK_SKIP_IMAGES_EXT                         := new GetPName($806D);
    private static _UNPACK_IMAGE_HEIGHT                            := new GetPName($806E);
    private static _UNPACK_IMAGE_HEIGHT_EXT                        := new GetPName($806E);
    private static _TEXTURE_3D_EXT                                 := new GetPName($806F);
    private static _MAX_3D_TEXTURE_SIZE                            := new GetPName($8073);
    private static _MAX_3D_TEXTURE_SIZE_EXT                        := new GetPName($8073);
    private static _VERTEX_ARRAY                                   := new GetPName($8074);
    private static _NORMAL_ARRAY                                   := new GetPName($8075);
    private static _COLOR_ARRAY                                    := new GetPName($8076);
    private static _INDEX_ARRAY                                    := new GetPName($8077);
    private static _TEXTURE_COORD_ARRAY                            := new GetPName($8078);
    private static _EDGE_FLAG_ARRAY                                := new GetPName($8079);
    private static _VERTEX_ARRAY_SIZE                              := new GetPName($807A);
    private static _VERTEX_ARRAY_TYPE                              := new GetPName($807B);
    private static _VERTEX_ARRAY_STRIDE                            := new GetPName($807C);
    private static _VERTEX_ARRAY_COUNT_EXT                         := new GetPName($807D);
    private static _NORMAL_ARRAY_TYPE                              := new GetPName($807E);
    private static _NORMAL_ARRAY_STRIDE                            := new GetPName($807F);
    private static _NORMAL_ARRAY_COUNT_EXT                         := new GetPName($8080);
    private static _COLOR_ARRAY_SIZE                               := new GetPName($8081);
    private static _COLOR_ARRAY_TYPE                               := new GetPName($8082);
    private static _COLOR_ARRAY_STRIDE                             := new GetPName($8083);
    private static _COLOR_ARRAY_COUNT_EXT                          := new GetPName($8084);
    private static _INDEX_ARRAY_TYPE                               := new GetPName($8085);
    private static _INDEX_ARRAY_STRIDE                             := new GetPName($8086);
    private static _INDEX_ARRAY_COUNT_EXT                          := new GetPName($8087);
    private static _TEXTURE_COORD_ARRAY_SIZE                       := new GetPName($8088);
    private static _TEXTURE_COORD_ARRAY_TYPE                       := new GetPName($8089);
    private static _TEXTURE_COORD_ARRAY_STRIDE                     := new GetPName($808A);
    private static _TEXTURE_COORD_ARRAY_COUNT_EXT                  := new GetPName($808B);
    private static _EDGE_FLAG_ARRAY_STRIDE                         := new GetPName($808C);
    private static _EDGE_FLAG_ARRAY_COUNT_EXT                      := new GetPName($808D);
    private static _INTERLACE_SGIX                                 := new GetPName($8094);
    private static _DETAIL_TEXTURE_2D_BINDING_SGIS                 := new GetPName($8096);
    private static _MULTISAMPLE_SGIS                               := new GetPName($809D);
    private static _SAMPLE_ALPHA_TO_MASK_SGIS                      := new GetPName($809E);
    private static _SAMPLE_ALPHA_TO_ONE_SGIS                       := new GetPName($809F);
    private static _SAMPLE_MASK_SGIS                               := new GetPName($80A0);
    private static _SAMPLE_BUFFERS                                 := new GetPName($80A8);
    private static _SAMPLE_BUFFERS_SGIS                            := new GetPName($80A8);
    private static _SAMPLES                                        := new GetPName($80A9);
    private static _SAMPLES_SGIS                                   := new GetPName($80A9);
    private static _SAMPLE_COVERAGE_VALUE                          := new GetPName($80AA);
    private static _SAMPLE_MASK_VALUE_SGIS                         := new GetPName($80AA);
    private static _SAMPLE_COVERAGE_INVERT                         := new GetPName($80AB);
    private static _SAMPLE_MASK_INVERT_SGIS                        := new GetPName($80AB);
    private static _SAMPLE_PATTERN_SGIS                            := new GetPName($80AC);
    private static _COLOR_MATRIX_SGI                               := new GetPName($80B1);
    private static _COLOR_MATRIX_STACK_DEPTH_SGI                   := new GetPName($80B2);
    private static _MAX_COLOR_MATRIX_STACK_DEPTH_SGI               := new GetPName($80B3);
    private static _POST_COLOR_MATRIX_RED_SCALE_SGI                := new GetPName($80B4);
    private static _POST_COLOR_MATRIX_GREEN_SCALE_SGI              := new GetPName($80B5);
    private static _POST_COLOR_MATRIX_BLUE_SCALE_SGI               := new GetPName($80B6);
    private static _POST_COLOR_MATRIX_ALPHA_SCALE_SGI              := new GetPName($80B7);
    private static _POST_COLOR_MATRIX_RED_BIAS_SGI                 := new GetPName($80B8);
    private static _POST_COLOR_MATRIX_GREEN_BIAS_SGI               := new GetPName($80B9);
    private static _POST_COLOR_MATRIX_BLUE_BIAS_SGI                := new GetPName($80BA);
    private static _POST_COLOR_MATRIX_ALPHA_BIAS_SGI               := new GetPName($80BB);
    private static _TEXTURE_COLOR_TABLE_SGI                        := new GetPName($80BC);
    private static _BLEND_DST_RGB                                  := new GetPName($80C8);
    private static _BLEND_SRC_RGB                                  := new GetPName($80C9);
    private static _BLEND_DST_ALPHA                                := new GetPName($80CA);
    private static _BLEND_SRC_ALPHA                                := new GetPName($80CB);
    private static _COLOR_TABLE_SGI                                := new GetPName($80D0);
    private static _POST_CONVOLUTION_COLOR_TABLE_SGI               := new GetPName($80D1);
    private static _POST_COLOR_MATRIX_COLOR_TABLE_SGI              := new GetPName($80D2);
    private static _MAX_ELEMENTS_VERTICES                          := new GetPName($80E8);
    private static _MAX_ELEMENTS_INDICES                           := new GetPName($80E9);
    private static _POINT_SIZE_MIN_SGIS                            := new GetPName($8126);
    private static _POINT_SIZE_MAX_SGIS                            := new GetPName($8127);
    private static _POINT_FADE_THRESHOLD_SIZE                      := new GetPName($8128);
    private static _POINT_FADE_THRESHOLD_SIZE_SGIS                 := new GetPName($8128);
    private static _DISTANCE_ATTENUATION_SGIS                      := new GetPName($8129);
    private static _FOG_FUNC_POINTS_SGIS                           := new GetPName($812B);
    private static _MAX_FOG_FUNC_POINTS_SGIS                       := new GetPName($812C);
    private static _PACK_SKIP_VOLUMES_SGIS                         := new GetPName($8130);
    private static _PACK_IMAGE_DEPTH_SGIS                          := new GetPName($8131);
    private static _UNPACK_SKIP_VOLUMES_SGIS                       := new GetPName($8132);
    private static _UNPACK_IMAGE_DEPTH_SGIS                        := new GetPName($8133);
    private static _TEXTURE_4D_SGIS                                := new GetPName($8134);
    private static _MAX_4D_TEXTURE_SIZE_SGIS                       := new GetPName($8138);
    private static _PIXEL_TEX_GEN_SGIX                             := new GetPName($8139);
    private static _PIXEL_TILE_BEST_ALIGNMENT_SGIX                 := new GetPName($813E);
    private static _PIXEL_TILE_CACHE_INCREMENT_SGIX                := new GetPName($813F);
    private static _PIXEL_TILE_WIDTH_SGIX                          := new GetPName($8140);
    private static _PIXEL_TILE_HEIGHT_SGIX                         := new GetPName($8141);
    private static _PIXEL_TILE_GRID_WIDTH_SGIX                     := new GetPName($8142);
    private static _PIXEL_TILE_GRID_HEIGHT_SGIX                    := new GetPName($8143);
    private static _PIXEL_TILE_GRID_DEPTH_SGIX                     := new GetPName($8144);
    private static _PIXEL_TILE_CACHE_SIZE_SGIX                     := new GetPName($8145);
    private static _SPRITE_SGIX                                    := new GetPName($8148);
    private static _SPRITE_MODE_SGIX                               := new GetPName($8149);
    private static _SPRITE_AXIS_SGIX                               := new GetPName($814A);
    private static _SPRITE_TRANSLATION_SGIX                        := new GetPName($814B);
    private static _TEXTURE_4D_BINDING_SGIS                        := new GetPName($814F);
    private static _MAX_CLIPMAP_DEPTH_SGIX                         := new GetPName($8177);
    private static _MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX                 := new GetPName($8178);
    private static _POST_TEXTURE_FILTER_BIAS_RANGE_SGIX            := new GetPName($817B);
    private static _POST_TEXTURE_FILTER_SCALE_RANGE_SGIX           := new GetPName($817C);
    private static _REFERENCE_PLANE_SGIX                           := new GetPName($817D);
    private static _REFERENCE_PLANE_EQUATION_SGIX                  := new GetPName($817E);
    private static _IR_INSTRUMENT1_SGIX                            := new GetPName($817F);
    private static _INSTRUMENT_MEASUREMENTS_SGIX                   := new GetPName($8181);
    private static _CALLIGRAPHIC_FRAGMENT_SGIX                     := new GetPName($8183);
    private static _FRAMEZOOM_SGIX                                 := new GetPName($818B);
    private static _FRAMEZOOM_FACTOR_SGIX                          := new GetPName($818C);
    private static _MAX_FRAMEZOOM_FACTOR_SGIX                      := new GetPName($818D);
    private static _GENERATE_MIPMAP_HINT_SGIS                      := new GetPName($8192);
    private static _DEFORMATIONS_MASK_SGIX                         := new GetPName($8196);
    private static _FOG_OFFSET_SGIX                                := new GetPName($8198);
    private static _FOG_OFFSET_VALUE_SGIX                          := new GetPName($8199);
    private static _LIGHT_MODEL_COLOR_CONTROL                      := new GetPName($81F8);
    private static _SHARED_TEXTURE_PALETTE_EXT                     := new GetPName($81FB);
    private static _MAJOR_VERSION                                  := new GetPName($821B);
    private static _MINOR_VERSION                                  := new GetPName($821C);
    private static _NUM_EXTENSIONS                                 := new GetPName($821D);
    private static _CONTEXT_FLAGS                                  := new GetPName($821E);
    private static _PROGRAM_PIPELINE_BINDING                       := new GetPName($825A);
    private static _MAX_VIEWPORTS                                  := new GetPName($825B);
    private static _VIEWPORT_SUBPIXEL_BITS                         := new GetPName($825C);
    private static _VIEWPORT_BOUNDS_RANGE                          := new GetPName($825D);
    private static _LAYER_PROVOKING_VERTEX                         := new GetPName($825E);
    private static _VIEWPORT_INDEX_PROVOKING_VERTEX                := new GetPName($825F);
    private static _MAX_COMPUTE_UNIFORM_COMPONENTS                 := new GetPName($8263);
    private static _MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS             := new GetPName($8264);
    private static _MAX_COMPUTE_ATOMIC_COUNTERS                    := new GetPName($8265);
    private static _MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS        := new GetPName($8266);
    private static _MAX_DEBUG_GROUP_STACK_DEPTH                    := new GetPName($826C);
    private static _DEBUG_GROUP_STACK_DEPTH                        := new GetPName($826D);
    private static _MAX_UNIFORM_LOCATIONS                          := new GetPName($826E);
    private static _VERTEX_BINDING_DIVISOR                         := new GetPName($82D6);
    private static _VERTEX_BINDING_OFFSET                          := new GetPName($82D7);
    private static _VERTEX_BINDING_STRIDE                          := new GetPName($82D8);
    private static _MAX_VERTEX_ATTRIB_RELATIVE_OFFSET              := new GetPName($82D9);
    private static _MAX_VERTEX_ATTRIB_BINDINGS                     := new GetPName($82DA);
    private static _MAX_LABEL_LENGTH                               := new GetPName($82E8);
    private static _CONVOLUTION_HINT_SGIX                          := new GetPName($8316);
    private static _ASYNC_MARKER_SGIX                              := new GetPName($8329);
    private static _PIXEL_TEX_GEN_MODE_SGIX                        := new GetPName($832B);
    private static _ASYNC_HISTOGRAM_SGIX                           := new GetPName($832C);
    private static _MAX_ASYNC_HISTOGRAM_SGIX                       := new GetPName($832D);
    private static _PIXEL_TEXTURE_SGIS                             := new GetPName($8353);
    private static _ASYNC_TEX_IMAGE_SGIX                           := new GetPName($835C);
    private static _ASYNC_DRAW_PIXELS_SGIX                         := new GetPName($835D);
    private static _ASYNC_READ_PIXELS_SGIX                         := new GetPName($835E);
    private static _MAX_ASYNC_TEX_IMAGE_SGIX                       := new GetPName($835F);
    private static _MAX_ASYNC_DRAW_PIXELS_SGIX                     := new GetPName($8360);
    private static _MAX_ASYNC_READ_PIXELS_SGIX                     := new GetPName($8361);
    private static _VERTEX_PRECLIP_SGIX                            := new GetPName($83EE);
    private static _VERTEX_PRECLIP_HINT_SGIX                       := new GetPName($83EF);
    private static _FRAGMENT_LIGHTING_SGIX                         := new GetPName($8400);
    private static _FRAGMENT_COLOR_MATERIAL_SGIX                   := new GetPName($8401);
    private static _FRAGMENT_COLOR_MATERIAL_FACE_SGIX              := new GetPName($8402);
    private static _FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX         := new GetPName($8403);
    private static _MAX_FRAGMENT_LIGHTS_SGIX                       := new GetPName($8404);
    private static _MAX_ACTIVE_LIGHTS_SGIX                         := new GetPName($8405);
    private static _LIGHT_ENV_MODE_SGIX                            := new GetPName($8407);
    private static _FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX         := new GetPName($8408);
    private static _FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX             := new GetPName($8409);
    private static _FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX              := new GetPName($840A);
    private static _FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX := new GetPName($840B);
    private static _FRAGMENT_LIGHT0_SGIX                           := new GetPName($840C);
    private static _PACK_RESAMPLE_SGIX                             := new GetPName($842E);
    private static _UNPACK_RESAMPLE_SGIX                           := new GetPName($842F);
    private static _ALIASED_POINT_SIZE_RANGE                       := new GetPName($846D);
    private static _ALIASED_LINE_WIDTH_RANGE                       := new GetPName($846E);
    private static _ACTIVE_TEXTURE                                 := new GetPName($84E0);
    private static _MAX_RENDERBUFFER_SIZE                          := new GetPName($84E8);
    private static _TEXTURE_COMPRESSION_HINT                       := new GetPName($84EF);
    private static _TEXTURE_BINDING_RECTANGLE                      := new GetPName($84F6);
    private static _MAX_RECTANGLE_TEXTURE_SIZE                     := new GetPName($84F8);
    private static _MAX_TEXTURE_LOD_BIAS                           := new GetPName($84FD);
    private static _TEXTURE_BINDING_CUBE_MAP                       := new GetPName($8514);
    private static _MAX_CUBE_MAP_TEXTURE_SIZE                      := new GetPName($851C);
    private static _PACK_SUBSAMPLE_RATE_SGIX                       := new GetPName($85A0);
    private static _UNPACK_SUBSAMPLE_RATE_SGIX                     := new GetPName($85A1);
    private static _VERTEX_ARRAY_BINDING                           := new GetPName($85B5);
    private static _PROGRAM_POINT_SIZE                             := new GetPName($8642);
    private static _NUM_COMPRESSED_TEXTURE_FORMATS                 := new GetPName($86A2);
    private static _COMPRESSED_TEXTURE_FORMATS                     := new GetPName($86A3);
    private static _NUM_PROGRAM_BINARY_FORMATS                     := new GetPName($87FE);
    private static _PROGRAM_BINARY_FORMATS                         := new GetPName($87FF);
    private static _STENCIL_BACK_FUNC                              := new GetPName($8800);
    private static _STENCIL_BACK_FAIL                              := new GetPName($8801);
    private static _STENCIL_BACK_PASS_DEPTH_FAIL                   := new GetPName($8802);
    private static _STENCIL_BACK_PASS_DEPTH_PASS                   := new GetPName($8803);
    private static _MAX_DRAW_BUFFERS                               := new GetPName($8824);
    private static _BLEND_EQUATION_ALPHA                           := new GetPName($883D);
    private static _MAX_VERTEX_ATTRIBS                             := new GetPName($8869);
    private static _MAX_TEXTURE_IMAGE_UNITS                        := new GetPName($8872);
    private static _ARRAY_BUFFER_BINDING                           := new GetPName($8894);
    private static _ELEMENT_ARRAY_BUFFER_BINDING                   := new GetPName($8895);
    private static _PIXEL_PACK_BUFFER_BINDING                      := new GetPName($88ED);
    private static _PIXEL_UNPACK_BUFFER_BINDING                    := new GetPName($88EF);
    private static _MAX_DUAL_SOURCE_DRAW_BUFFERS                   := new GetPName($88FC);
    private static _MAX_ARRAY_TEXTURE_LAYERS                       := new GetPName($88FF);
    private static _MIN_PROGRAM_TEXEL_OFFSET                       := new GetPName($8904);
    private static _MAX_PROGRAM_TEXEL_OFFSET                       := new GetPName($8905);
    private static _SAMPLER_BINDING                                := new GetPName($8919);
    private static _UNIFORM_BUFFER_BINDING                         := new GetPName($8A28);
    private static _UNIFORM_BUFFER_START                           := new GetPName($8A29);
    private static _UNIFORM_BUFFER_SIZE                            := new GetPName($8A2A);
    private static _MAX_VERTEX_UNIFORM_BLOCKS                      := new GetPName($8A2B);
    private static _MAX_GEOMETRY_UNIFORM_BLOCKS                    := new GetPName($8A2C);
    private static _MAX_FRAGMENT_UNIFORM_BLOCKS                    := new GetPName($8A2D);
    private static _MAX_COMBINED_UNIFORM_BLOCKS                    := new GetPName($8A2E);
    private static _MAX_UNIFORM_BUFFER_BINDINGS                    := new GetPName($8A2F);
    private static _MAX_UNIFORM_BLOCK_SIZE                         := new GetPName($8A30);
    private static _MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS         := new GetPName($8A31);
    private static _MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS       := new GetPName($8A32);
    private static _MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS       := new GetPName($8A33);
    private static _UNIFORM_BUFFER_OFFSET_ALIGNMENT                := new GetPName($8A34);
    private static _MAX_FRAGMENT_UNIFORM_COMPONENTS                := new GetPName($8B49);
    private static _MAX_VERTEX_UNIFORM_COMPONENTS                  := new GetPName($8B4A);
    private static _MAX_VARYING_COMPONENTS                         := new GetPName($8B4B);
    private static _MAX_VARYING_FLOATS                             := new GetPName($8B4B);
    private static _MAX_VERTEX_TEXTURE_IMAGE_UNITS                 := new GetPName($8B4C);
    private static _MAX_COMBINED_TEXTURE_IMAGE_UNITS               := new GetPName($8B4D);
    private static _FRAGMENT_SHADER_DERIVATIVE_HINT                := new GetPName($8B8B);
    private static _CURRENT_PROGRAM                                := new GetPName($8B8D);
    private static _IMPLEMENTATION_COLOR_READ_TYPE                 := new GetPName($8B9A);
    private static _IMPLEMENTATION_COLOR_READ_FORMAT               := new GetPName($8B9B);
    private static _TEXTURE_BINDING_1D_ARRAY                       := new GetPName($8C1C);
    private static _TEXTURE_BINDING_2D_ARRAY                       := new GetPName($8C1D);
    private static _MAX_GEOMETRY_TEXTURE_IMAGE_UNITS               := new GetPName($8C29);
    private static _MAX_TEXTURE_BUFFER_SIZE                        := new GetPName($8C2B);
    private static _TEXTURE_BINDING_BUFFER                         := new GetPName($8C2C);
    private static _TRANSFORM_FEEDBACK_BUFFER_START                := new GetPName($8C84);
    private static _TRANSFORM_FEEDBACK_BUFFER_SIZE                 := new GetPName($8C85);
    private static _TRANSFORM_FEEDBACK_BUFFER_BINDING              := new GetPName($8C8F);
    private static _MOTION_ESTIMATION_SEARCH_BLOCK_X_QCOM          := new GetPName($8C90);
    private static _MOTION_ESTIMATION_SEARCH_BLOCK_Y_QCOM          := new GetPName($8C91);
    private static _STENCIL_BACK_REF                               := new GetPName($8CA3);
    private static _STENCIL_BACK_VALUE_MASK                        := new GetPName($8CA4);
    private static _STENCIL_BACK_WRITEMASK                         := new GetPName($8CA5);
    private static _DRAW_FRAMEBUFFER_BINDING                       := new GetPName($8CA6);
    private static _RENDERBUFFER_BINDING                           := new GetPName($8CA7);
    private static _READ_FRAMEBUFFER_BINDING                       := new GetPName($8CAA);
    private static _MAX_ELEMENT_INDEX                              := new GetPName($8D6B);
    private static _MAX_GEOMETRY_UNIFORM_COMPONENTS                := new GetPName($8DDF);
    private static _NUM_SHADER_BINARY_FORMATS                      := new GetPName($8DF9);
    private static _SHADER_COMPILER                                := new GetPName($8DFA);
    private static _MAX_VERTEX_UNIFORM_VECTORS                     := new GetPName($8DFB);
    private static _MAX_VARYING_VECTORS                            := new GetPName($8DFC);
    private static _MAX_FRAGMENT_UNIFORM_VECTORS                   := new GetPName($8DFD);
    private static _TIMESTAMP                                      := new GetPName($8E28);
    private static _PROVOKING_VERTEX                               := new GetPName($8E4F);
    private static _MAX_SAMPLE_MASK_WORDS                          := new GetPName($8E59);
    private static _MAX_TESS_CONTROL_UNIFORM_BLOCKS                := new GetPName($8E89);
    private static _MAX_TESS_EVALUATION_UNIFORM_BLOCKS             := new GetPName($8E8A);
    private static _PRIMITIVE_RESTART_INDEX                        := new GetPName($8F9E);
    private static _MIN_MAP_BUFFER_ALIGNMENT                       := new GetPName($90BC);
    private static _SHADER_STORAGE_BUFFER_BINDING                  := new GetPName($90D3);
    private static _SHADER_STORAGE_BUFFER_START                    := new GetPName($90D4);
    private static _SHADER_STORAGE_BUFFER_SIZE                     := new GetPName($90D5);
    private static _MAX_VERTEX_SHADER_STORAGE_BLOCKS               := new GetPName($90D6);
    private static _MAX_GEOMETRY_SHADER_STORAGE_BLOCKS             := new GetPName($90D7);
    private static _MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS         := new GetPName($90D8);
    private static _MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS      := new GetPName($90D9);
    private static _MAX_FRAGMENT_SHADER_STORAGE_BLOCKS             := new GetPName($90DA);
    private static _MAX_COMPUTE_SHADER_STORAGE_BLOCKS              := new GetPName($90DB);
    private static _MAX_COMBINED_SHADER_STORAGE_BLOCKS             := new GetPName($90DC);
    private static _MAX_SHADER_STORAGE_BUFFER_BINDINGS             := new GetPName($90DD);
    private static _SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT         := new GetPName($90DF);
    private static _MAX_COMPUTE_WORK_GROUP_INVOCATIONS             := new GetPName($90EB);
    private static _DISPATCH_INDIRECT_BUFFER_BINDING               := new GetPName($90EF);
    private static _TEXTURE_BINDING_2D_MULTISAMPLE                 := new GetPName($9104);
    private static _TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY           := new GetPName($9105);
    private static _MAX_COLOR_TEXTURE_SAMPLES                      := new GetPName($910E);
    private static _MAX_DEPTH_TEXTURE_SAMPLES                      := new GetPName($910F);
    private static _MAX_INTEGER_SAMPLES                            := new GetPName($9110);
    private static _MAX_SERVER_WAIT_TIMEOUT                        := new GetPName($9111);
    private static _MAX_VERTEX_OUTPUT_COMPONENTS                   := new GetPName($9122);
    private static _MAX_GEOMETRY_INPUT_COMPONENTS                  := new GetPName($9123);
    private static _MAX_GEOMETRY_OUTPUT_COMPONENTS                 := new GetPName($9124);
    private static _MAX_FRAGMENT_INPUT_COMPONENTS                  := new GetPName($9125);
    private static _CONTEXT_PROFILE_MASK                           := new GetPName($9126);
    private static _TEXTURE_BUFFER_OFFSET_ALIGNMENT                := new GetPName($919F);
    private static _MAX_COMPUTE_UNIFORM_BLOCKS                     := new GetPName($91BB);
    private static _MAX_COMPUTE_TEXTURE_IMAGE_UNITS                := new GetPName($91BC);
    private static _MAX_COMPUTE_WORK_GROUP_COUNT                   := new GetPName($91BE);
    private static _MAX_COMPUTE_WORK_GROUP_SIZE                    := new GetPName($91BF);
    private static _MAX_VERTEX_ATOMIC_COUNTERS                     := new GetPName($92D2);
    private static _MAX_TESS_CONTROL_ATOMIC_COUNTERS               := new GetPName($92D3);
    private static _MAX_TESS_EVALUATION_ATOMIC_COUNTERS            := new GetPName($92D4);
    private static _MAX_GEOMETRY_ATOMIC_COUNTERS                   := new GetPName($92D5);
    private static _MAX_FRAGMENT_ATOMIC_COUNTERS                   := new GetPName($92D6);
    private static _MAX_COMBINED_ATOMIC_COUNTERS                   := new GetPName($92D7);
    private static _MAX_FRAMEBUFFER_WIDTH                          := new GetPName($9315);
    private static _MAX_FRAMEBUFFER_HEIGHT                         := new GetPName($9316);
    private static _MAX_FRAMEBUFFER_LAYERS                         := new GetPName($9317);
    private static _MAX_FRAMEBUFFER_SAMPLES                        := new GetPName($9318);
    private static _NUM_DEVICE_UUIDS_EXT                           := new GetPName($9596);
    private static _DEVICE_UUID_EXT                                := new GetPName($9597);
    private static _DRIVER_UUID_EXT                                := new GetPName($9598);
    private static _DEVICE_LUID_EXT                                := new GetPName($9599);
    private static _DEVICE_NODE_MASK_EXT                           := new GetPName($959A);
    private static _SHADING_RATE_QCOM                              := new GetPName($96A4);
    
    public static property CURRENT_COLOR:                                  GetPName read _CURRENT_COLOR;
    public static property CURRENT_INDEX:                                  GetPName read _CURRENT_INDEX;
    public static property CURRENT_NORMAL:                                 GetPName read _CURRENT_NORMAL;
    public static property CURRENT_TEXTURE_COORDS:                         GetPName read _CURRENT_TEXTURE_COORDS;
    public static property CURRENT_RASTER_COLOR:                           GetPName read _CURRENT_RASTER_COLOR;
    public static property CURRENT_RASTER_INDEX:                           GetPName read _CURRENT_RASTER_INDEX;
    public static property CURRENT_RASTER_TEXTURE_COORDS:                  GetPName read _CURRENT_RASTER_TEXTURE_COORDS;
    public static property CURRENT_RASTER_POSITION:                        GetPName read _CURRENT_RASTER_POSITION;
    public static property CURRENT_RASTER_POSITION_VALID:                  GetPName read _CURRENT_RASTER_POSITION_VALID;
    public static property CURRENT_RASTER_DISTANCE:                        GetPName read _CURRENT_RASTER_DISTANCE;
    public static property POINT_SMOOTH:                                   GetPName read _POINT_SMOOTH;
    public static property POINT_SIZE:                                     GetPName read _POINT_SIZE;
    public static property POINT_SIZE_RANGE:                               GetPName read _POINT_SIZE_RANGE;
    public static property SMOOTH_POINT_SIZE_RANGE:                        GetPName read _SMOOTH_POINT_SIZE_RANGE;
    public static property POINT_SIZE_GRANULARITY:                         GetPName read _POINT_SIZE_GRANULARITY;
    public static property SMOOTH_POINT_SIZE_GRANULARITY:                  GetPName read _SMOOTH_POINT_SIZE_GRANULARITY;
    public static property LINE_SMOOTH:                                    GetPName read _LINE_SMOOTH;
    public static property LINE_WIDTH:                                     GetPName read _LINE_WIDTH;
    public static property LINE_WIDTH_RANGE:                               GetPName read _LINE_WIDTH_RANGE;
    public static property SMOOTH_LINE_WIDTH_RANGE:                        GetPName read _SMOOTH_LINE_WIDTH_RANGE;
    public static property LINE_WIDTH_GRANULARITY:                         GetPName read _LINE_WIDTH_GRANULARITY;
    public static property SMOOTH_LINE_WIDTH_GRANULARITY:                  GetPName read _SMOOTH_LINE_WIDTH_GRANULARITY;
    public static property LINE_STIPPLE:                                   GetPName read _LINE_STIPPLE;
    public static property LINE_STIPPLE_PATTERN:                           GetPName read _LINE_STIPPLE_PATTERN;
    public static property LINE_STIPPLE_REPEAT:                            GetPName read _LINE_STIPPLE_REPEAT;
    public static property LIST_MODE:                                      GetPName read _LIST_MODE;
    public static property MAX_LIST_NESTING:                               GetPName read _MAX_LIST_NESTING;
    public static property LIST_BASE:                                      GetPName read _LIST_BASE;
    public static property LIST_INDEX:                                     GetPName read _LIST_INDEX;
    public static property POLYGON_MODE:                                   GetPName read _POLYGON_MODE;
    public static property POLYGON_SMOOTH:                                 GetPName read _POLYGON_SMOOTH;
    public static property POLYGON_STIPPLE:                                GetPName read _POLYGON_STIPPLE;
    public static property EDGE_FLAG:                                      GetPName read _EDGE_FLAG;
    public static property CULL_FACE:                                      GetPName read _CULL_FACE;
    public static property CULL_FACE_MODE:                                 GetPName read _CULL_FACE_MODE;
    public static property FRONT_FACE:                                     GetPName read _FRONT_FACE;
    public static property LIGHTING:                                       GetPName read _LIGHTING;
    public static property LIGHT_MODEL_LOCAL_VIEWER:                       GetPName read _LIGHT_MODEL_LOCAL_VIEWER;
    public static property LIGHT_MODEL_TWO_SIDE:                           GetPName read _LIGHT_MODEL_TWO_SIDE;
    public static property LIGHT_MODEL_AMBIENT:                            GetPName read _LIGHT_MODEL_AMBIENT;
    public static property SHADE_MODEL:                                    GetPName read _SHADE_MODEL;
    public static property COLOR_MATERIAL_FACE:                            GetPName read _COLOR_MATERIAL_FACE;
    public static property COLOR_MATERIAL_PARAMETER:                       GetPName read _COLOR_MATERIAL_PARAMETER;
    public static property COLOR_MATERIAL:                                 GetPName read _COLOR_MATERIAL;
    public static property FOG:                                            GetPName read _FOG;
    public static property FOG_INDEX:                                      GetPName read _FOG_INDEX;
    public static property FOG_DENSITY:                                    GetPName read _FOG_DENSITY;
    public static property FOG_START:                                      GetPName read _FOG_START;
    public static property FOG_END:                                        GetPName read _FOG_END;
    public static property FOG_MODE:                                       GetPName read _FOG_MODE;
    public static property FOG_COLOR:                                      GetPName read _FOG_COLOR;
    public static property DEPTH_RANGE:                                    GetPName read _DEPTH_RANGE;
    public static property DEPTH_TEST:                                     GetPName read _DEPTH_TEST;
    public static property DEPTH_WRITEMASK:                                GetPName read _DEPTH_WRITEMASK;
    public static property DEPTH_CLEAR_VALUE:                              GetPName read _DEPTH_CLEAR_VALUE;
    public static property DEPTH_FUNC:                                     GetPName read _DEPTH_FUNC;
    public static property ACCUM_CLEAR_VALUE:                              GetPName read _ACCUM_CLEAR_VALUE;
    public static property STENCIL_TEST:                                   GetPName read _STENCIL_TEST;
    public static property STENCIL_CLEAR_VALUE:                            GetPName read _STENCIL_CLEAR_VALUE;
    public static property STENCIL_FUNC:                                   GetPName read _STENCIL_FUNC;
    public static property STENCIL_VALUE_MASK:                             GetPName read _STENCIL_VALUE_MASK;
    public static property STENCIL_FAIL:                                   GetPName read _STENCIL_FAIL;
    public static property STENCIL_PASS_DEPTH_FAIL:                        GetPName read _STENCIL_PASS_DEPTH_FAIL;
    public static property STENCIL_PASS_DEPTH_PASS:                        GetPName read _STENCIL_PASS_DEPTH_PASS;
    public static property STENCIL_REF:                                    GetPName read _STENCIL_REF;
    public static property STENCIL_WRITEMASK:                              GetPName read _STENCIL_WRITEMASK;
    public static property MATRIX_MODE:                                    GetPName read _MATRIX_MODE;
    public static property NORMALIZE:                                      GetPName read _NORMALIZE;
    public static property VIEWPORT:                                       GetPName read _VIEWPORT;
    public static property MODELVIEW_STACK_DEPTH:                          GetPName read _MODELVIEW_STACK_DEPTH;
    public static property MODELVIEW0_STACK_DEPTH_EXT:                     GetPName read _MODELVIEW0_STACK_DEPTH_EXT;
    public static property PROJECTION_STACK_DEPTH:                         GetPName read _PROJECTION_STACK_DEPTH;
    public static property TEXTURE_STACK_DEPTH:                            GetPName read _TEXTURE_STACK_DEPTH;
    public static property MODELVIEW_MATRIX:                               GetPName read _MODELVIEW_MATRIX;
    public static property MODELVIEW0_MATRIX_EXT:                          GetPName read _MODELVIEW0_MATRIX_EXT;
    public static property PROJECTION_MATRIX:                              GetPName read _PROJECTION_MATRIX;
    public static property TEXTURE_MATRIX:                                 GetPName read _TEXTURE_MATRIX;
    public static property ATTRIB_STACK_DEPTH:                             GetPName read _ATTRIB_STACK_DEPTH;
    public static property CLIENT_ATTRIB_STACK_DEPTH:                      GetPName read _CLIENT_ATTRIB_STACK_DEPTH;
    public static property ALPHA_TEST:                                     GetPName read _ALPHA_TEST;
    public static property ALPHA_TEST_QCOM:                                GetPName read _ALPHA_TEST_QCOM;
    public static property ALPHA_TEST_FUNC:                                GetPName read _ALPHA_TEST_FUNC;
    public static property ALPHA_TEST_FUNC_QCOM:                           GetPName read _ALPHA_TEST_FUNC_QCOM;
    public static property ALPHA_TEST_REF:                                 GetPName read _ALPHA_TEST_REF;
    public static property ALPHA_TEST_REF_QCOM:                            GetPName read _ALPHA_TEST_REF_QCOM;
    public static property DITHER:                                         GetPName read _DITHER;
    public static property BLEND_DST:                                      GetPName read _BLEND_DST;
    public static property BLEND_SRC:                                      GetPName read _BLEND_SRC;
    public static property BLEND:                                          GetPName read _BLEND;
    public static property LOGIC_OP_MODE:                                  GetPName read _LOGIC_OP_MODE;
    public static property INDEX_LOGIC_OP:                                 GetPName read _INDEX_LOGIC_OP;
    public static property LOGIC_OP:                                       GetPName read _LOGIC_OP;
    public static property COLOR_LOGIC_OP:                                 GetPName read _COLOR_LOGIC_OP;
    public static property AUX_BUFFERS:                                    GetPName read _AUX_BUFFERS;
    public static property DRAW_BUFFER:                                    GetPName read _DRAW_BUFFER;
    public static property DRAW_BUFFER_EXT:                                GetPName read _DRAW_BUFFER_EXT;
    public static property READ_BUFFER:                                    GetPName read _READ_BUFFER;
    public static property READ_BUFFER_EXT:                                GetPName read _READ_BUFFER_EXT;
    public static property READ_BUFFER_NV:                                 GetPName read _READ_BUFFER_NV;
    public static property SCISSOR_BOX:                                    GetPName read _SCISSOR_BOX;
    public static property SCISSOR_TEST:                                   GetPName read _SCISSOR_TEST;
    public static property INDEX_CLEAR_VALUE:                              GetPName read _INDEX_CLEAR_VALUE;
    public static property INDEX_WRITEMASK:                                GetPName read _INDEX_WRITEMASK;
    public static property COLOR_CLEAR_VALUE:                              GetPName read _COLOR_CLEAR_VALUE;
    public static property COLOR_WRITEMASK:                                GetPName read _COLOR_WRITEMASK;
    public static property INDEX_MODE:                                     GetPName read _INDEX_MODE;
    public static property RGBA_MODE:                                      GetPName read _RGBA_MODE;
    public static property DOUBLEBUFFER:                                   GetPName read _DOUBLEBUFFER;
    public static property STEREO:                                         GetPName read _STEREO;
    public static property RENDER_MODE:                                    GetPName read _RENDER_MODE;
    public static property PERSPECTIVE_CORRECTION_HINT:                    GetPName read _PERSPECTIVE_CORRECTION_HINT;
    public static property POINT_SMOOTH_HINT:                              GetPName read _POINT_SMOOTH_HINT;
    public static property LINE_SMOOTH_HINT:                               GetPName read _LINE_SMOOTH_HINT;
    public static property POLYGON_SMOOTH_HINT:                            GetPName read _POLYGON_SMOOTH_HINT;
    public static property FOG_HINT:                                       GetPName read _FOG_HINT;
    public static property TEXTURE_GEN_S:                                  GetPName read _TEXTURE_GEN_S;
    public static property TEXTURE_GEN_T:                                  GetPName read _TEXTURE_GEN_T;
    public static property TEXTURE_GEN_R:                                  GetPName read _TEXTURE_GEN_R;
    public static property TEXTURE_GEN_Q:                                  GetPName read _TEXTURE_GEN_Q;
    public static property PIXEL_MAP_I_TO_I_SIZE:                          GetPName read _PIXEL_MAP_I_TO_I_SIZE;
    public static property PIXEL_MAP_S_TO_S_SIZE:                          GetPName read _PIXEL_MAP_S_TO_S_SIZE;
    public static property PIXEL_MAP_I_TO_R_SIZE:                          GetPName read _PIXEL_MAP_I_TO_R_SIZE;
    public static property PIXEL_MAP_I_TO_G_SIZE:                          GetPName read _PIXEL_MAP_I_TO_G_SIZE;
    public static property PIXEL_MAP_I_TO_B_SIZE:                          GetPName read _PIXEL_MAP_I_TO_B_SIZE;
    public static property PIXEL_MAP_I_TO_A_SIZE:                          GetPName read _PIXEL_MAP_I_TO_A_SIZE;
    public static property PIXEL_MAP_R_TO_R_SIZE:                          GetPName read _PIXEL_MAP_R_TO_R_SIZE;
    public static property PIXEL_MAP_G_TO_G_SIZE:                          GetPName read _PIXEL_MAP_G_TO_G_SIZE;
    public static property PIXEL_MAP_B_TO_B_SIZE:                          GetPName read _PIXEL_MAP_B_TO_B_SIZE;
    public static property PIXEL_MAP_A_TO_A_SIZE:                          GetPName read _PIXEL_MAP_A_TO_A_SIZE;
    public static property UNPACK_SWAP_BYTES:                              GetPName read _UNPACK_SWAP_BYTES;
    public static property UNPACK_LSB_FIRST:                               GetPName read _UNPACK_LSB_FIRST;
    public static property UNPACK_ROW_LENGTH:                              GetPName read _UNPACK_ROW_LENGTH;
    public static property UNPACK_SKIP_ROWS:                               GetPName read _UNPACK_SKIP_ROWS;
    public static property UNPACK_SKIP_PIXELS:                             GetPName read _UNPACK_SKIP_PIXELS;
    public static property UNPACK_ALIGNMENT:                               GetPName read _UNPACK_ALIGNMENT;
    public static property PACK_SWAP_BYTES:                                GetPName read _PACK_SWAP_BYTES;
    public static property PACK_LSB_FIRST:                                 GetPName read _PACK_LSB_FIRST;
    public static property PACK_ROW_LENGTH:                                GetPName read _PACK_ROW_LENGTH;
    public static property PACK_SKIP_ROWS:                                 GetPName read _PACK_SKIP_ROWS;
    public static property PACK_SKIP_PIXELS:                               GetPName read _PACK_SKIP_PIXELS;
    public static property PACK_ALIGNMENT:                                 GetPName read _PACK_ALIGNMENT;
    public static property MAP_COLOR:                                      GetPName read _MAP_COLOR;
    public static property MAP_STENCIL:                                    GetPName read _MAP_STENCIL;
    public static property INDEX_SHIFT:                                    GetPName read _INDEX_SHIFT;
    public static property INDEX_OFFSET:                                   GetPName read _INDEX_OFFSET;
    public static property RED_SCALE:                                      GetPName read _RED_SCALE;
    public static property RED_BIAS:                                       GetPName read _RED_BIAS;
    public static property ZOOM_X:                                         GetPName read _ZOOM_X;
    public static property ZOOM_Y:                                         GetPName read _ZOOM_Y;
    public static property GREEN_SCALE:                                    GetPName read _GREEN_SCALE;
    public static property GREEN_BIAS:                                     GetPName read _GREEN_BIAS;
    public static property BLUE_SCALE:                                     GetPName read _BLUE_SCALE;
    public static property BLUE_BIAS:                                      GetPName read _BLUE_BIAS;
    public static property ALPHA_SCALE:                                    GetPName read _ALPHA_SCALE;
    public static property ALPHA_BIAS:                                     GetPName read _ALPHA_BIAS;
    public static property DEPTH_SCALE:                                    GetPName read _DEPTH_SCALE;
    public static property DEPTH_BIAS:                                     GetPName read _DEPTH_BIAS;
    public static property MAX_EVAL_ORDER:                                 GetPName read _MAX_EVAL_ORDER;
    public static property MAX_LIGHTS:                                     GetPName read _MAX_LIGHTS;
    public static property MAX_CLIP_DISTANCES:                             GetPName read _MAX_CLIP_DISTANCES;
    public static property MAX_CLIP_PLANES:                                GetPName read _MAX_CLIP_PLANES;
    public static property MAX_TEXTURE_SIZE:                               GetPName read _MAX_TEXTURE_SIZE;
    public static property MAX_PIXEL_MAP_TABLE:                            GetPName read _MAX_PIXEL_MAP_TABLE;
    public static property MAX_ATTRIB_STACK_DEPTH:                         GetPName read _MAX_ATTRIB_STACK_DEPTH;
    public static property MAX_MODELVIEW_STACK_DEPTH:                      GetPName read _MAX_MODELVIEW_STACK_DEPTH;
    public static property MAX_NAME_STACK_DEPTH:                           GetPName read _MAX_NAME_STACK_DEPTH;
    public static property MAX_PROJECTION_STACK_DEPTH:                     GetPName read _MAX_PROJECTION_STACK_DEPTH;
    public static property MAX_TEXTURE_STACK_DEPTH:                        GetPName read _MAX_TEXTURE_STACK_DEPTH;
    public static property MAX_VIEWPORT_DIMS:                              GetPName read _MAX_VIEWPORT_DIMS;
    public static property MAX_CLIENT_ATTRIB_STACK_DEPTH:                  GetPName read _MAX_CLIENT_ATTRIB_STACK_DEPTH;
    public static property SUBPIXEL_BITS:                                  GetPName read _SUBPIXEL_BITS;
    public static property INDEX_BITS:                                     GetPName read _INDEX_BITS;
    public static property RED_BITS:                                       GetPName read _RED_BITS;
    public static property GREEN_BITS:                                     GetPName read _GREEN_BITS;
    public static property BLUE_BITS:                                      GetPName read _BLUE_BITS;
    public static property ALPHA_BITS:                                     GetPName read _ALPHA_BITS;
    public static property DEPTH_BITS:                                     GetPName read _DEPTH_BITS;
    public static property STENCIL_BITS:                                   GetPName read _STENCIL_BITS;
    public static property ACCUM_RED_BITS:                                 GetPName read _ACCUM_RED_BITS;
    public static property ACCUM_GREEN_BITS:                               GetPName read _ACCUM_GREEN_BITS;
    public static property ACCUM_BLUE_BITS:                                GetPName read _ACCUM_BLUE_BITS;
    public static property ACCUM_ALPHA_BITS:                               GetPName read _ACCUM_ALPHA_BITS;
    public static property NAME_STACK_DEPTH:                               GetPName read _NAME_STACK_DEPTH;
    public static property AUTO_NORMAL:                                    GetPName read _AUTO_NORMAL;
    public static property MAP1_COLOR_4:                                   GetPName read _MAP1_COLOR_4;
    public static property MAP1_INDEX:                                     GetPName read _MAP1_INDEX;
    public static property MAP1_NORMAL:                                    GetPName read _MAP1_NORMAL;
    public static property MAP1_TEXTURE_COORD_1:                           GetPName read _MAP1_TEXTURE_COORD_1;
    public static property MAP1_TEXTURE_COORD_2:                           GetPName read _MAP1_TEXTURE_COORD_2;
    public static property MAP1_TEXTURE_COORD_3:                           GetPName read _MAP1_TEXTURE_COORD_3;
    public static property MAP1_TEXTURE_COORD_4:                           GetPName read _MAP1_TEXTURE_COORD_4;
    public static property MAP1_VERTEX_3:                                  GetPName read _MAP1_VERTEX_3;
    public static property MAP1_VERTEX_4:                                  GetPName read _MAP1_VERTEX_4;
    public static property MAP2_COLOR_4:                                   GetPName read _MAP2_COLOR_4;
    public static property MAP2_INDEX:                                     GetPName read _MAP2_INDEX;
    public static property MAP2_NORMAL:                                    GetPName read _MAP2_NORMAL;
    public static property MAP2_TEXTURE_COORD_1:                           GetPName read _MAP2_TEXTURE_COORD_1;
    public static property MAP2_TEXTURE_COORD_2:                           GetPName read _MAP2_TEXTURE_COORD_2;
    public static property MAP2_TEXTURE_COORD_3:                           GetPName read _MAP2_TEXTURE_COORD_3;
    public static property MAP2_TEXTURE_COORD_4:                           GetPName read _MAP2_TEXTURE_COORD_4;
    public static property MAP2_VERTEX_3:                                  GetPName read _MAP2_VERTEX_3;
    public static property MAP2_VERTEX_4:                                  GetPName read _MAP2_VERTEX_4;
    public static property MAP1_GRID_DOMAIN:                               GetPName read _MAP1_GRID_DOMAIN;
    public static property MAP1_GRID_SEGMENTS:                             GetPName read _MAP1_GRID_SEGMENTS;
    public static property MAP2_GRID_DOMAIN:                               GetPName read _MAP2_GRID_DOMAIN;
    public static property MAP2_GRID_SEGMENTS:                             GetPName read _MAP2_GRID_SEGMENTS;
    public static property TEXTURE_1D:                                     GetPName read _TEXTURE_1D;
    public static property TEXTURE_2D:                                     GetPName read _TEXTURE_2D;
    public static property FEEDBACK_BUFFER_SIZE:                           GetPName read _FEEDBACK_BUFFER_SIZE;
    public static property FEEDBACK_BUFFER_TYPE:                           GetPName read _FEEDBACK_BUFFER_TYPE;
    public static property SELECTION_BUFFER_SIZE:                          GetPName read _SELECTION_BUFFER_SIZE;
    public static property POLYGON_OFFSET_UNITS:                           GetPName read _POLYGON_OFFSET_UNITS;
    public static property POLYGON_OFFSET_POINT:                           GetPName read _POLYGON_OFFSET_POINT;
    public static property POLYGON_OFFSET_LINE:                            GetPName read _POLYGON_OFFSET_LINE;
    public static property CLIP_PLANE0:                                    GetPName read _CLIP_PLANE0;
    public static property CLIP_PLANE1:                                    GetPName read _CLIP_PLANE1;
    public static property CLIP_PLANE2:                                    GetPName read _CLIP_PLANE2;
    public static property CLIP_PLANE3:                                    GetPName read _CLIP_PLANE3;
    public static property CLIP_PLANE4:                                    GetPName read _CLIP_PLANE4;
    public static property CLIP_PLANE5:                                    GetPName read _CLIP_PLANE5;
    public static property LIGHT0:                                         GetPName read _LIGHT0;
    public static property LIGHT1:                                         GetPName read _LIGHT1;
    public static property LIGHT2:                                         GetPName read _LIGHT2;
    public static property LIGHT3:                                         GetPName read _LIGHT3;
    public static property LIGHT4:                                         GetPName read _LIGHT4;
    public static property LIGHT5:                                         GetPName read _LIGHT5;
    public static property LIGHT6:                                         GetPName read _LIGHT6;
    public static property LIGHT7:                                         GetPName read _LIGHT7;
    public static property BLEND_COLOR:                                    GetPName read _BLEND_COLOR;
    public static property BLEND_COLOR_EXT:                                GetPName read _BLEND_COLOR_EXT;
    public static property BLEND_EQUATION_EXT:                             GetPName read _BLEND_EQUATION_EXT;
    public static property BLEND_EQUATION_RGB:                             GetPName read _BLEND_EQUATION_RGB;
    public static property PACK_CMYK_HINT_EXT:                             GetPName read _PACK_CMYK_HINT_EXT;
    public static property UNPACK_CMYK_HINT_EXT:                           GetPName read _UNPACK_CMYK_HINT_EXT;
    public static property CONVOLUTION_1D_EXT:                             GetPName read _CONVOLUTION_1D_EXT;
    public static property CONVOLUTION_2D_EXT:                             GetPName read _CONVOLUTION_2D_EXT;
    public static property SEPARABLE_2D_EXT:                               GetPName read _SEPARABLE_2D_EXT;
    public static property POST_CONVOLUTION_RED_SCALE_EXT:                 GetPName read _POST_CONVOLUTION_RED_SCALE_EXT;
    public static property POST_CONVOLUTION_GREEN_SCALE_EXT:               GetPName read _POST_CONVOLUTION_GREEN_SCALE_EXT;
    public static property POST_CONVOLUTION_BLUE_SCALE_EXT:                GetPName read _POST_CONVOLUTION_BLUE_SCALE_EXT;
    public static property POST_CONVOLUTION_ALPHA_SCALE_EXT:               GetPName read _POST_CONVOLUTION_ALPHA_SCALE_EXT;
    public static property POST_CONVOLUTION_RED_BIAS_EXT:                  GetPName read _POST_CONVOLUTION_RED_BIAS_EXT;
    public static property POST_CONVOLUTION_GREEN_BIAS_EXT:                GetPName read _POST_CONVOLUTION_GREEN_BIAS_EXT;
    public static property POST_CONVOLUTION_BLUE_BIAS_EXT:                 GetPName read _POST_CONVOLUTION_BLUE_BIAS_EXT;
    public static property POST_CONVOLUTION_ALPHA_BIAS_EXT:                GetPName read _POST_CONVOLUTION_ALPHA_BIAS_EXT;
    public static property HISTOGRAM_EXT:                                  GetPName read _HISTOGRAM_EXT;
    public static property MINMAX_EXT:                                     GetPName read _MINMAX_EXT;
    public static property POLYGON_OFFSET_FILL:                            GetPName read _POLYGON_OFFSET_FILL;
    public static property POLYGON_OFFSET_FACTOR:                          GetPName read _POLYGON_OFFSET_FACTOR;
    public static property POLYGON_OFFSET_BIAS_EXT:                        GetPName read _POLYGON_OFFSET_BIAS_EXT;
    public static property RESCALE_NORMAL_EXT:                             GetPName read _RESCALE_NORMAL_EXT;
    public static property TEXTURE_BINDING_1D:                             GetPName read _TEXTURE_BINDING_1D;
    public static property TEXTURE_BINDING_2D:                             GetPName read _TEXTURE_BINDING_2D;
    public static property TEXTURE_3D_BINDING_EXT:                         GetPName read _TEXTURE_3D_BINDING_EXT;
    public static property TEXTURE_BINDING_3D:                             GetPName read _TEXTURE_BINDING_3D;
    public static property PACK_SKIP_IMAGES:                               GetPName read _PACK_SKIP_IMAGES;
    public static property PACK_SKIP_IMAGES_EXT:                           GetPName read _PACK_SKIP_IMAGES_EXT;
    public static property PACK_IMAGE_HEIGHT:                              GetPName read _PACK_IMAGE_HEIGHT;
    public static property PACK_IMAGE_HEIGHT_EXT:                          GetPName read _PACK_IMAGE_HEIGHT_EXT;
    public static property UNPACK_SKIP_IMAGES:                             GetPName read _UNPACK_SKIP_IMAGES;
    public static property UNPACK_SKIP_IMAGES_EXT:                         GetPName read _UNPACK_SKIP_IMAGES_EXT;
    public static property UNPACK_IMAGE_HEIGHT:                            GetPName read _UNPACK_IMAGE_HEIGHT;
    public static property UNPACK_IMAGE_HEIGHT_EXT:                        GetPName read _UNPACK_IMAGE_HEIGHT_EXT;
    public static property TEXTURE_3D_EXT:                                 GetPName read _TEXTURE_3D_EXT;
    public static property MAX_3D_TEXTURE_SIZE:                            GetPName read _MAX_3D_TEXTURE_SIZE;
    public static property MAX_3D_TEXTURE_SIZE_EXT:                        GetPName read _MAX_3D_TEXTURE_SIZE_EXT;
    public static property VERTEX_ARRAY:                                   GetPName read _VERTEX_ARRAY;
    public static property NORMAL_ARRAY:                                   GetPName read _NORMAL_ARRAY;
    public static property COLOR_ARRAY:                                    GetPName read _COLOR_ARRAY;
    public static property INDEX_ARRAY:                                    GetPName read _INDEX_ARRAY;
    public static property TEXTURE_COORD_ARRAY:                            GetPName read _TEXTURE_COORD_ARRAY;
    public static property EDGE_FLAG_ARRAY:                                GetPName read _EDGE_FLAG_ARRAY;
    public static property VERTEX_ARRAY_SIZE:                              GetPName read _VERTEX_ARRAY_SIZE;
    public static property VERTEX_ARRAY_TYPE:                              GetPName read _VERTEX_ARRAY_TYPE;
    public static property VERTEX_ARRAY_STRIDE:                            GetPName read _VERTEX_ARRAY_STRIDE;
    public static property VERTEX_ARRAY_COUNT_EXT:                         GetPName read _VERTEX_ARRAY_COUNT_EXT;
    public static property NORMAL_ARRAY_TYPE:                              GetPName read _NORMAL_ARRAY_TYPE;
    public static property NORMAL_ARRAY_STRIDE:                            GetPName read _NORMAL_ARRAY_STRIDE;
    public static property NORMAL_ARRAY_COUNT_EXT:                         GetPName read _NORMAL_ARRAY_COUNT_EXT;
    public static property COLOR_ARRAY_SIZE:                               GetPName read _COLOR_ARRAY_SIZE;
    public static property COLOR_ARRAY_TYPE:                               GetPName read _COLOR_ARRAY_TYPE;
    public static property COLOR_ARRAY_STRIDE:                             GetPName read _COLOR_ARRAY_STRIDE;
    public static property COLOR_ARRAY_COUNT_EXT:                          GetPName read _COLOR_ARRAY_COUNT_EXT;
    public static property INDEX_ARRAY_TYPE:                               GetPName read _INDEX_ARRAY_TYPE;
    public static property INDEX_ARRAY_STRIDE:                             GetPName read _INDEX_ARRAY_STRIDE;
    public static property INDEX_ARRAY_COUNT_EXT:                          GetPName read _INDEX_ARRAY_COUNT_EXT;
    public static property TEXTURE_COORD_ARRAY_SIZE:                       GetPName read _TEXTURE_COORD_ARRAY_SIZE;
    public static property TEXTURE_COORD_ARRAY_TYPE:                       GetPName read _TEXTURE_COORD_ARRAY_TYPE;
    public static property TEXTURE_COORD_ARRAY_STRIDE:                     GetPName read _TEXTURE_COORD_ARRAY_STRIDE;
    public static property TEXTURE_COORD_ARRAY_COUNT_EXT:                  GetPName read _TEXTURE_COORD_ARRAY_COUNT_EXT;
    public static property EDGE_FLAG_ARRAY_STRIDE:                         GetPName read _EDGE_FLAG_ARRAY_STRIDE;
    public static property EDGE_FLAG_ARRAY_COUNT_EXT:                      GetPName read _EDGE_FLAG_ARRAY_COUNT_EXT;
    public static property INTERLACE_SGIX:                                 GetPName read _INTERLACE_SGIX;
    public static property DETAIL_TEXTURE_2D_BINDING_SGIS:                 GetPName read _DETAIL_TEXTURE_2D_BINDING_SGIS;
    public static property MULTISAMPLE_SGIS:                               GetPName read _MULTISAMPLE_SGIS;
    public static property SAMPLE_ALPHA_TO_MASK_SGIS:                      GetPName read _SAMPLE_ALPHA_TO_MASK_SGIS;
    public static property SAMPLE_ALPHA_TO_ONE_SGIS:                       GetPName read _SAMPLE_ALPHA_TO_ONE_SGIS;
    public static property SAMPLE_MASK_SGIS:                               GetPName read _SAMPLE_MASK_SGIS;
    public static property SAMPLE_BUFFERS:                                 GetPName read _SAMPLE_BUFFERS;
    public static property SAMPLE_BUFFERS_SGIS:                            GetPName read _SAMPLE_BUFFERS_SGIS;
    public static property SAMPLES:                                        GetPName read _SAMPLES;
    public static property SAMPLES_SGIS:                                   GetPName read _SAMPLES_SGIS;
    public static property SAMPLE_COVERAGE_VALUE:                          GetPName read _SAMPLE_COVERAGE_VALUE;
    public static property SAMPLE_MASK_VALUE_SGIS:                         GetPName read _SAMPLE_MASK_VALUE_SGIS;
    public static property SAMPLE_COVERAGE_INVERT:                         GetPName read _SAMPLE_COVERAGE_INVERT;
    public static property SAMPLE_MASK_INVERT_SGIS:                        GetPName read _SAMPLE_MASK_INVERT_SGIS;
    public static property SAMPLE_PATTERN_SGIS:                            GetPName read _SAMPLE_PATTERN_SGIS;
    public static property COLOR_MATRIX_SGI:                               GetPName read _COLOR_MATRIX_SGI;
    public static property COLOR_MATRIX_STACK_DEPTH_SGI:                   GetPName read _COLOR_MATRIX_STACK_DEPTH_SGI;
    public static property MAX_COLOR_MATRIX_STACK_DEPTH_SGI:               GetPName read _MAX_COLOR_MATRIX_STACK_DEPTH_SGI;
    public static property POST_COLOR_MATRIX_RED_SCALE_SGI:                GetPName read _POST_COLOR_MATRIX_RED_SCALE_SGI;
    public static property POST_COLOR_MATRIX_GREEN_SCALE_SGI:              GetPName read _POST_COLOR_MATRIX_GREEN_SCALE_SGI;
    public static property POST_COLOR_MATRIX_BLUE_SCALE_SGI:               GetPName read _POST_COLOR_MATRIX_BLUE_SCALE_SGI;
    public static property POST_COLOR_MATRIX_ALPHA_SCALE_SGI:              GetPName read _POST_COLOR_MATRIX_ALPHA_SCALE_SGI;
    public static property POST_COLOR_MATRIX_RED_BIAS_SGI:                 GetPName read _POST_COLOR_MATRIX_RED_BIAS_SGI;
    public static property POST_COLOR_MATRIX_GREEN_BIAS_SGI:               GetPName read _POST_COLOR_MATRIX_GREEN_BIAS_SGI;
    public static property POST_COLOR_MATRIX_BLUE_BIAS_SGI:                GetPName read _POST_COLOR_MATRIX_BLUE_BIAS_SGI;
    public static property POST_COLOR_MATRIX_ALPHA_BIAS_SGI:               GetPName read _POST_COLOR_MATRIX_ALPHA_BIAS_SGI;
    public static property TEXTURE_COLOR_TABLE_SGI:                        GetPName read _TEXTURE_COLOR_TABLE_SGI;
    public static property BLEND_DST_RGB:                                  GetPName read _BLEND_DST_RGB;
    public static property BLEND_SRC_RGB:                                  GetPName read _BLEND_SRC_RGB;
    public static property BLEND_DST_ALPHA:                                GetPName read _BLEND_DST_ALPHA;
    public static property BLEND_SRC_ALPHA:                                GetPName read _BLEND_SRC_ALPHA;
    public static property COLOR_TABLE_SGI:                                GetPName read _COLOR_TABLE_SGI;
    public static property POST_CONVOLUTION_COLOR_TABLE_SGI:               GetPName read _POST_CONVOLUTION_COLOR_TABLE_SGI;
    public static property POST_COLOR_MATRIX_COLOR_TABLE_SGI:              GetPName read _POST_COLOR_MATRIX_COLOR_TABLE_SGI;
    public static property MAX_ELEMENTS_VERTICES:                          GetPName read _MAX_ELEMENTS_VERTICES;
    public static property MAX_ELEMENTS_INDICES:                           GetPName read _MAX_ELEMENTS_INDICES;
    public static property POINT_SIZE_MIN_SGIS:                            GetPName read _POINT_SIZE_MIN_SGIS;
    public static property POINT_SIZE_MAX_SGIS:                            GetPName read _POINT_SIZE_MAX_SGIS;
    public static property POINT_FADE_THRESHOLD_SIZE:                      GetPName read _POINT_FADE_THRESHOLD_SIZE;
    public static property POINT_FADE_THRESHOLD_SIZE_SGIS:                 GetPName read _POINT_FADE_THRESHOLD_SIZE_SGIS;
    public static property DISTANCE_ATTENUATION_SGIS:                      GetPName read _DISTANCE_ATTENUATION_SGIS;
    public static property FOG_FUNC_POINTS_SGIS:                           GetPName read _FOG_FUNC_POINTS_SGIS;
    public static property MAX_FOG_FUNC_POINTS_SGIS:                       GetPName read _MAX_FOG_FUNC_POINTS_SGIS;
    public static property PACK_SKIP_VOLUMES_SGIS:                         GetPName read _PACK_SKIP_VOLUMES_SGIS;
    public static property PACK_IMAGE_DEPTH_SGIS:                          GetPName read _PACK_IMAGE_DEPTH_SGIS;
    public static property UNPACK_SKIP_VOLUMES_SGIS:                       GetPName read _UNPACK_SKIP_VOLUMES_SGIS;
    public static property UNPACK_IMAGE_DEPTH_SGIS:                        GetPName read _UNPACK_IMAGE_DEPTH_SGIS;
    public static property TEXTURE_4D_SGIS:                                GetPName read _TEXTURE_4D_SGIS;
    public static property MAX_4D_TEXTURE_SIZE_SGIS:                       GetPName read _MAX_4D_TEXTURE_SIZE_SGIS;
    public static property PIXEL_TEX_GEN_SGIX:                             GetPName read _PIXEL_TEX_GEN_SGIX;
    public static property PIXEL_TILE_BEST_ALIGNMENT_SGIX:                 GetPName read _PIXEL_TILE_BEST_ALIGNMENT_SGIX;
    public static property PIXEL_TILE_CACHE_INCREMENT_SGIX:                GetPName read _PIXEL_TILE_CACHE_INCREMENT_SGIX;
    public static property PIXEL_TILE_WIDTH_SGIX:                          GetPName read _PIXEL_TILE_WIDTH_SGIX;
    public static property PIXEL_TILE_HEIGHT_SGIX:                         GetPName read _PIXEL_TILE_HEIGHT_SGIX;
    public static property PIXEL_TILE_GRID_WIDTH_SGIX:                     GetPName read _PIXEL_TILE_GRID_WIDTH_SGIX;
    public static property PIXEL_TILE_GRID_HEIGHT_SGIX:                    GetPName read _PIXEL_TILE_GRID_HEIGHT_SGIX;
    public static property PIXEL_TILE_GRID_DEPTH_SGIX:                     GetPName read _PIXEL_TILE_GRID_DEPTH_SGIX;
    public static property PIXEL_TILE_CACHE_SIZE_SGIX:                     GetPName read _PIXEL_TILE_CACHE_SIZE_SGIX;
    public static property SPRITE_SGIX:                                    GetPName read _SPRITE_SGIX;
    public static property SPRITE_MODE_SGIX:                               GetPName read _SPRITE_MODE_SGIX;
    public static property SPRITE_AXIS_SGIX:                               GetPName read _SPRITE_AXIS_SGIX;
    public static property SPRITE_TRANSLATION_SGIX:                        GetPName read _SPRITE_TRANSLATION_SGIX;
    public static property TEXTURE_4D_BINDING_SGIS:                        GetPName read _TEXTURE_4D_BINDING_SGIS;
    public static property MAX_CLIPMAP_DEPTH_SGIX:                         GetPName read _MAX_CLIPMAP_DEPTH_SGIX;
    public static property MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX:                 GetPName read _MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX;
    public static property POST_TEXTURE_FILTER_BIAS_RANGE_SGIX:            GetPName read _POST_TEXTURE_FILTER_BIAS_RANGE_SGIX;
    public static property POST_TEXTURE_FILTER_SCALE_RANGE_SGIX:           GetPName read _POST_TEXTURE_FILTER_SCALE_RANGE_SGIX;
    public static property REFERENCE_PLANE_SGIX:                           GetPName read _REFERENCE_PLANE_SGIX;
    public static property REFERENCE_PLANE_EQUATION_SGIX:                  GetPName read _REFERENCE_PLANE_EQUATION_SGIX;
    public static property IR_INSTRUMENT1_SGIX:                            GetPName read _IR_INSTRUMENT1_SGIX;
    public static property INSTRUMENT_MEASUREMENTS_SGIX:                   GetPName read _INSTRUMENT_MEASUREMENTS_SGIX;
    public static property CALLIGRAPHIC_FRAGMENT_SGIX:                     GetPName read _CALLIGRAPHIC_FRAGMENT_SGIX;
    public static property FRAMEZOOM_SGIX:                                 GetPName read _FRAMEZOOM_SGIX;
    public static property FRAMEZOOM_FACTOR_SGIX:                          GetPName read _FRAMEZOOM_FACTOR_SGIX;
    public static property MAX_FRAMEZOOM_FACTOR_SGIX:                      GetPName read _MAX_FRAMEZOOM_FACTOR_SGIX;
    public static property GENERATE_MIPMAP_HINT_SGIS:                      GetPName read _GENERATE_MIPMAP_HINT_SGIS;
    public static property DEFORMATIONS_MASK_SGIX:                         GetPName read _DEFORMATIONS_MASK_SGIX;
    public static property FOG_OFFSET_SGIX:                                GetPName read _FOG_OFFSET_SGIX;
    public static property FOG_OFFSET_VALUE_SGIX:                          GetPName read _FOG_OFFSET_VALUE_SGIX;
    public static property LIGHT_MODEL_COLOR_CONTROL:                      GetPName read _LIGHT_MODEL_COLOR_CONTROL;
    public static property SHARED_TEXTURE_PALETTE_EXT:                     GetPName read _SHARED_TEXTURE_PALETTE_EXT;
    public static property MAJOR_VERSION:                                  GetPName read _MAJOR_VERSION;
    public static property MINOR_VERSION:                                  GetPName read _MINOR_VERSION;
    public static property NUM_EXTENSIONS:                                 GetPName read _NUM_EXTENSIONS;
    public static property CONTEXT_FLAGS:                                  GetPName read _CONTEXT_FLAGS;
    public static property PROGRAM_PIPELINE_BINDING:                       GetPName read _PROGRAM_PIPELINE_BINDING;
    public static property MAX_VIEWPORTS:                                  GetPName read _MAX_VIEWPORTS;
    public static property VIEWPORT_SUBPIXEL_BITS:                         GetPName read _VIEWPORT_SUBPIXEL_BITS;
    public static property VIEWPORT_BOUNDS_RANGE:                          GetPName read _VIEWPORT_BOUNDS_RANGE;
    public static property LAYER_PROVOKING_VERTEX:                         GetPName read _LAYER_PROVOKING_VERTEX;
    public static property VIEWPORT_INDEX_PROVOKING_VERTEX:                GetPName read _VIEWPORT_INDEX_PROVOKING_VERTEX;
    public static property MAX_COMPUTE_UNIFORM_COMPONENTS:                 GetPName read _MAX_COMPUTE_UNIFORM_COMPONENTS;
    public static property MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS:             GetPName read _MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS;
    public static property MAX_COMPUTE_ATOMIC_COUNTERS:                    GetPName read _MAX_COMPUTE_ATOMIC_COUNTERS;
    public static property MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS:        GetPName read _MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS;
    public static property MAX_DEBUG_GROUP_STACK_DEPTH:                    GetPName read _MAX_DEBUG_GROUP_STACK_DEPTH;
    public static property DEBUG_GROUP_STACK_DEPTH:                        GetPName read _DEBUG_GROUP_STACK_DEPTH;
    public static property MAX_UNIFORM_LOCATIONS:                          GetPName read _MAX_UNIFORM_LOCATIONS;
    public static property VERTEX_BINDING_DIVISOR:                         GetPName read _VERTEX_BINDING_DIVISOR;
    public static property VERTEX_BINDING_OFFSET:                          GetPName read _VERTEX_BINDING_OFFSET;
    public static property VERTEX_BINDING_STRIDE:                          GetPName read _VERTEX_BINDING_STRIDE;
    public static property MAX_VERTEX_ATTRIB_RELATIVE_OFFSET:              GetPName read _MAX_VERTEX_ATTRIB_RELATIVE_OFFSET;
    public static property MAX_VERTEX_ATTRIB_BINDINGS:                     GetPName read _MAX_VERTEX_ATTRIB_BINDINGS;
    public static property MAX_LABEL_LENGTH:                               GetPName read _MAX_LABEL_LENGTH;
    public static property CONVOLUTION_HINT_SGIX:                          GetPName read _CONVOLUTION_HINT_SGIX;
    public static property ASYNC_MARKER_SGIX:                              GetPName read _ASYNC_MARKER_SGIX;
    public static property PIXEL_TEX_GEN_MODE_SGIX:                        GetPName read _PIXEL_TEX_GEN_MODE_SGIX;
    public static property ASYNC_HISTOGRAM_SGIX:                           GetPName read _ASYNC_HISTOGRAM_SGIX;
    public static property MAX_ASYNC_HISTOGRAM_SGIX:                       GetPName read _MAX_ASYNC_HISTOGRAM_SGIX;
    public static property PIXEL_TEXTURE_SGIS:                             GetPName read _PIXEL_TEXTURE_SGIS;
    public static property ASYNC_TEX_IMAGE_SGIX:                           GetPName read _ASYNC_TEX_IMAGE_SGIX;
    public static property ASYNC_DRAW_PIXELS_SGIX:                         GetPName read _ASYNC_DRAW_PIXELS_SGIX;
    public static property ASYNC_READ_PIXELS_SGIX:                         GetPName read _ASYNC_READ_PIXELS_SGIX;
    public static property MAX_ASYNC_TEX_IMAGE_SGIX:                       GetPName read _MAX_ASYNC_TEX_IMAGE_SGIX;
    public static property MAX_ASYNC_DRAW_PIXELS_SGIX:                     GetPName read _MAX_ASYNC_DRAW_PIXELS_SGIX;
    public static property MAX_ASYNC_READ_PIXELS_SGIX:                     GetPName read _MAX_ASYNC_READ_PIXELS_SGIX;
    public static property VERTEX_PRECLIP_SGIX:                            GetPName read _VERTEX_PRECLIP_SGIX;
    public static property VERTEX_PRECLIP_HINT_SGIX:                       GetPName read _VERTEX_PRECLIP_HINT_SGIX;
    public static property FRAGMENT_LIGHTING_SGIX:                         GetPName read _FRAGMENT_LIGHTING_SGIX;
    public static property FRAGMENT_COLOR_MATERIAL_SGIX:                   GetPName read _FRAGMENT_COLOR_MATERIAL_SGIX;
    public static property FRAGMENT_COLOR_MATERIAL_FACE_SGIX:              GetPName read _FRAGMENT_COLOR_MATERIAL_FACE_SGIX;
    public static property FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX:         GetPName read _FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX;
    public static property MAX_FRAGMENT_LIGHTS_SGIX:                       GetPName read _MAX_FRAGMENT_LIGHTS_SGIX;
    public static property MAX_ACTIVE_LIGHTS_SGIX:                         GetPName read _MAX_ACTIVE_LIGHTS_SGIX;
    public static property LIGHT_ENV_MODE_SGIX:                            GetPName read _LIGHT_ENV_MODE_SGIX;
    public static property FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX:         GetPName read _FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX;
    public static property FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX:             GetPName read _FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX;
    public static property FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX:              GetPName read _FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX;
    public static property FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX: GetPName read _FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX;
    public static property FRAGMENT_LIGHT0_SGIX:                           GetPName read _FRAGMENT_LIGHT0_SGIX;
    public static property PACK_RESAMPLE_SGIX:                             GetPName read _PACK_RESAMPLE_SGIX;
    public static property UNPACK_RESAMPLE_SGIX:                           GetPName read _UNPACK_RESAMPLE_SGIX;
    public static property ALIASED_POINT_SIZE_RANGE:                       GetPName read _ALIASED_POINT_SIZE_RANGE;
    public static property ALIASED_LINE_WIDTH_RANGE:                       GetPName read _ALIASED_LINE_WIDTH_RANGE;
    public static property ACTIVE_TEXTURE:                                 GetPName read _ACTIVE_TEXTURE;
    public static property MAX_RENDERBUFFER_SIZE:                          GetPName read _MAX_RENDERBUFFER_SIZE;
    public static property TEXTURE_COMPRESSION_HINT:                       GetPName read _TEXTURE_COMPRESSION_HINT;
    public static property TEXTURE_BINDING_RECTANGLE:                      GetPName read _TEXTURE_BINDING_RECTANGLE;
    public static property MAX_RECTANGLE_TEXTURE_SIZE:                     GetPName read _MAX_RECTANGLE_TEXTURE_SIZE;
    public static property MAX_TEXTURE_LOD_BIAS:                           GetPName read _MAX_TEXTURE_LOD_BIAS;
    public static property TEXTURE_BINDING_CUBE_MAP:                       GetPName read _TEXTURE_BINDING_CUBE_MAP;
    public static property MAX_CUBE_MAP_TEXTURE_SIZE:                      GetPName read _MAX_CUBE_MAP_TEXTURE_SIZE;
    public static property PACK_SUBSAMPLE_RATE_SGIX:                       GetPName read _PACK_SUBSAMPLE_RATE_SGIX;
    public static property UNPACK_SUBSAMPLE_RATE_SGIX:                     GetPName read _UNPACK_SUBSAMPLE_RATE_SGIX;
    public static property VERTEX_ARRAY_BINDING:                           GetPName read _VERTEX_ARRAY_BINDING;
    public static property PROGRAM_POINT_SIZE:                             GetPName read _PROGRAM_POINT_SIZE;
    public static property NUM_COMPRESSED_TEXTURE_FORMATS:                 GetPName read _NUM_COMPRESSED_TEXTURE_FORMATS;
    public static property COMPRESSED_TEXTURE_FORMATS:                     GetPName read _COMPRESSED_TEXTURE_FORMATS;
    public static property NUM_PROGRAM_BINARY_FORMATS:                     GetPName read _NUM_PROGRAM_BINARY_FORMATS;
    public static property PROGRAM_BINARY_FORMATS:                         GetPName read _PROGRAM_BINARY_FORMATS;
    public static property STENCIL_BACK_FUNC:                              GetPName read _STENCIL_BACK_FUNC;
    public static property STENCIL_BACK_FAIL:                              GetPName read _STENCIL_BACK_FAIL;
    public static property STENCIL_BACK_PASS_DEPTH_FAIL:                   GetPName read _STENCIL_BACK_PASS_DEPTH_FAIL;
    public static property STENCIL_BACK_PASS_DEPTH_PASS:                   GetPName read _STENCIL_BACK_PASS_DEPTH_PASS;
    public static property MAX_DRAW_BUFFERS:                               GetPName read _MAX_DRAW_BUFFERS;
    public static property BLEND_EQUATION_ALPHA:                           GetPName read _BLEND_EQUATION_ALPHA;
    public static property MAX_VERTEX_ATTRIBS:                             GetPName read _MAX_VERTEX_ATTRIBS;
    public static property MAX_TEXTURE_IMAGE_UNITS:                        GetPName read _MAX_TEXTURE_IMAGE_UNITS;
    public static property ARRAY_BUFFER_BINDING:                           GetPName read _ARRAY_BUFFER_BINDING;
    public static property ELEMENT_ARRAY_BUFFER_BINDING:                   GetPName read _ELEMENT_ARRAY_BUFFER_BINDING;
    public static property PIXEL_PACK_BUFFER_BINDING:                      GetPName read _PIXEL_PACK_BUFFER_BINDING;
    public static property PIXEL_UNPACK_BUFFER_BINDING:                    GetPName read _PIXEL_UNPACK_BUFFER_BINDING;
    public static property MAX_DUAL_SOURCE_DRAW_BUFFERS:                   GetPName read _MAX_DUAL_SOURCE_DRAW_BUFFERS;
    public static property MAX_ARRAY_TEXTURE_LAYERS:                       GetPName read _MAX_ARRAY_TEXTURE_LAYERS;
    public static property MIN_PROGRAM_TEXEL_OFFSET:                       GetPName read _MIN_PROGRAM_TEXEL_OFFSET;
    public static property MAX_PROGRAM_TEXEL_OFFSET:                       GetPName read _MAX_PROGRAM_TEXEL_OFFSET;
    public static property SAMPLER_BINDING:                                GetPName read _SAMPLER_BINDING;
    public static property UNIFORM_BUFFER_BINDING:                         GetPName read _UNIFORM_BUFFER_BINDING;
    public static property UNIFORM_BUFFER_START:                           GetPName read _UNIFORM_BUFFER_START;
    public static property UNIFORM_BUFFER_SIZE:                            GetPName read _UNIFORM_BUFFER_SIZE;
    public static property MAX_VERTEX_UNIFORM_BLOCKS:                      GetPName read _MAX_VERTEX_UNIFORM_BLOCKS;
    public static property MAX_GEOMETRY_UNIFORM_BLOCKS:                    GetPName read _MAX_GEOMETRY_UNIFORM_BLOCKS;
    public static property MAX_FRAGMENT_UNIFORM_BLOCKS:                    GetPName read _MAX_FRAGMENT_UNIFORM_BLOCKS;
    public static property MAX_COMBINED_UNIFORM_BLOCKS:                    GetPName read _MAX_COMBINED_UNIFORM_BLOCKS;
    public static property MAX_UNIFORM_BUFFER_BINDINGS:                    GetPName read _MAX_UNIFORM_BUFFER_BINDINGS;
    public static property MAX_UNIFORM_BLOCK_SIZE:                         GetPName read _MAX_UNIFORM_BLOCK_SIZE;
    public static property MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:         GetPName read _MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS;
    public static property MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS:       GetPName read _MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS;
    public static property MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:       GetPName read _MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS;
    public static property UNIFORM_BUFFER_OFFSET_ALIGNMENT:                GetPName read _UNIFORM_BUFFER_OFFSET_ALIGNMENT;
    public static property MAX_FRAGMENT_UNIFORM_COMPONENTS:                GetPName read _MAX_FRAGMENT_UNIFORM_COMPONENTS;
    public static property MAX_VERTEX_UNIFORM_COMPONENTS:                  GetPName read _MAX_VERTEX_UNIFORM_COMPONENTS;
    public static property MAX_VARYING_COMPONENTS:                         GetPName read _MAX_VARYING_COMPONENTS;
    public static property MAX_VARYING_FLOATS:                             GetPName read _MAX_VARYING_FLOATS;
    public static property MAX_VERTEX_TEXTURE_IMAGE_UNITS:                 GetPName read _MAX_VERTEX_TEXTURE_IMAGE_UNITS;
    public static property MAX_COMBINED_TEXTURE_IMAGE_UNITS:               GetPName read _MAX_COMBINED_TEXTURE_IMAGE_UNITS;
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT:                GetPName read _FRAGMENT_SHADER_DERIVATIVE_HINT;
    public static property CURRENT_PROGRAM:                                GetPName read _CURRENT_PROGRAM;
    public static property IMPLEMENTATION_COLOR_READ_TYPE:                 GetPName read _IMPLEMENTATION_COLOR_READ_TYPE;
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:               GetPName read _IMPLEMENTATION_COLOR_READ_FORMAT;
    public static property TEXTURE_BINDING_1D_ARRAY:                       GetPName read _TEXTURE_BINDING_1D_ARRAY;
    public static property TEXTURE_BINDING_2D_ARRAY:                       GetPName read _TEXTURE_BINDING_2D_ARRAY;
    public static property MAX_GEOMETRY_TEXTURE_IMAGE_UNITS:               GetPName read _MAX_GEOMETRY_TEXTURE_IMAGE_UNITS;
    public static property MAX_TEXTURE_BUFFER_SIZE:                        GetPName read _MAX_TEXTURE_BUFFER_SIZE;
    public static property TEXTURE_BINDING_BUFFER:                         GetPName read _TEXTURE_BINDING_BUFFER;
    public static property TRANSFORM_FEEDBACK_BUFFER_START:                GetPName read _TRANSFORM_FEEDBACK_BUFFER_START;
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:                 GetPName read _TRANSFORM_FEEDBACK_BUFFER_SIZE;
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING:              GetPName read _TRANSFORM_FEEDBACK_BUFFER_BINDING;
    public static property MOTION_ESTIMATION_SEARCH_BLOCK_X_QCOM:          GetPName read _MOTION_ESTIMATION_SEARCH_BLOCK_X_QCOM;
    public static property MOTION_ESTIMATION_SEARCH_BLOCK_Y_QCOM:          GetPName read _MOTION_ESTIMATION_SEARCH_BLOCK_Y_QCOM;
    public static property STENCIL_BACK_REF:                               GetPName read _STENCIL_BACK_REF;
    public static property STENCIL_BACK_VALUE_MASK:                        GetPName read _STENCIL_BACK_VALUE_MASK;
    public static property STENCIL_BACK_WRITEMASK:                         GetPName read _STENCIL_BACK_WRITEMASK;
    public static property DRAW_FRAMEBUFFER_BINDING:                       GetPName read _DRAW_FRAMEBUFFER_BINDING;
    public static property RENDERBUFFER_BINDING:                           GetPName read _RENDERBUFFER_BINDING;
    public static property READ_FRAMEBUFFER_BINDING:                       GetPName read _READ_FRAMEBUFFER_BINDING;
    public static property MAX_ELEMENT_INDEX:                              GetPName read _MAX_ELEMENT_INDEX;
    public static property MAX_GEOMETRY_UNIFORM_COMPONENTS:                GetPName read _MAX_GEOMETRY_UNIFORM_COMPONENTS;
    public static property NUM_SHADER_BINARY_FORMATS:                      GetPName read _NUM_SHADER_BINARY_FORMATS;
    public static property SHADER_COMPILER:                                GetPName read _SHADER_COMPILER;
    public static property MAX_VERTEX_UNIFORM_VECTORS:                     GetPName read _MAX_VERTEX_UNIFORM_VECTORS;
    public static property MAX_VARYING_VECTORS:                            GetPName read _MAX_VARYING_VECTORS;
    public static property MAX_FRAGMENT_UNIFORM_VECTORS:                   GetPName read _MAX_FRAGMENT_UNIFORM_VECTORS;
    public static property TIMESTAMP:                                      GetPName read _TIMESTAMP;
    public static property PROVOKING_VERTEX:                               GetPName read _PROVOKING_VERTEX;
    public static property MAX_SAMPLE_MASK_WORDS:                          GetPName read _MAX_SAMPLE_MASK_WORDS;
    public static property MAX_TESS_CONTROL_UNIFORM_BLOCKS:                GetPName read _MAX_TESS_CONTROL_UNIFORM_BLOCKS;
    public static property MAX_TESS_EVALUATION_UNIFORM_BLOCKS:             GetPName read _MAX_TESS_EVALUATION_UNIFORM_BLOCKS;
    public static property PRIMITIVE_RESTART_INDEX:                        GetPName read _PRIMITIVE_RESTART_INDEX;
    public static property MIN_MAP_BUFFER_ALIGNMENT:                       GetPName read _MIN_MAP_BUFFER_ALIGNMENT;
    public static property SHADER_STORAGE_BUFFER_BINDING:                  GetPName read _SHADER_STORAGE_BUFFER_BINDING;
    public static property SHADER_STORAGE_BUFFER_START:                    GetPName read _SHADER_STORAGE_BUFFER_START;
    public static property SHADER_STORAGE_BUFFER_SIZE:                     GetPName read _SHADER_STORAGE_BUFFER_SIZE;
    public static property MAX_VERTEX_SHADER_STORAGE_BLOCKS:               GetPName read _MAX_VERTEX_SHADER_STORAGE_BLOCKS;
    public static property MAX_GEOMETRY_SHADER_STORAGE_BLOCKS:             GetPName read _MAX_GEOMETRY_SHADER_STORAGE_BLOCKS;
    public static property MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS:         GetPName read _MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS;
    public static property MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS:      GetPName read _MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS;
    public static property MAX_FRAGMENT_SHADER_STORAGE_BLOCKS:             GetPName read _MAX_FRAGMENT_SHADER_STORAGE_BLOCKS;
    public static property MAX_COMPUTE_SHADER_STORAGE_BLOCKS:              GetPName read _MAX_COMPUTE_SHADER_STORAGE_BLOCKS;
    public static property MAX_COMBINED_SHADER_STORAGE_BLOCKS:             GetPName read _MAX_COMBINED_SHADER_STORAGE_BLOCKS;
    public static property MAX_SHADER_STORAGE_BUFFER_BINDINGS:             GetPName read _MAX_SHADER_STORAGE_BUFFER_BINDINGS;
    public static property SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:         GetPName read _SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT;
    public static property MAX_COMPUTE_WORK_GROUP_INVOCATIONS:             GetPName read _MAX_COMPUTE_WORK_GROUP_INVOCATIONS;
    public static property DISPATCH_INDIRECT_BUFFER_BINDING:               GetPName read _DISPATCH_INDIRECT_BUFFER_BINDING;
    public static property TEXTURE_BINDING_2D_MULTISAMPLE:                 GetPName read _TEXTURE_BINDING_2D_MULTISAMPLE;
    public static property TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:           GetPName read _TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY;
    public static property MAX_COLOR_TEXTURE_SAMPLES:                      GetPName read _MAX_COLOR_TEXTURE_SAMPLES;
    public static property MAX_DEPTH_TEXTURE_SAMPLES:                      GetPName read _MAX_DEPTH_TEXTURE_SAMPLES;
    public static property MAX_INTEGER_SAMPLES:                            GetPName read _MAX_INTEGER_SAMPLES;
    public static property MAX_SERVER_WAIT_TIMEOUT:                        GetPName read _MAX_SERVER_WAIT_TIMEOUT;
    public static property MAX_VERTEX_OUTPUT_COMPONENTS:                   GetPName read _MAX_VERTEX_OUTPUT_COMPONENTS;
    public static property MAX_GEOMETRY_INPUT_COMPONENTS:                  GetPName read _MAX_GEOMETRY_INPUT_COMPONENTS;
    public static property MAX_GEOMETRY_OUTPUT_COMPONENTS:                 GetPName read _MAX_GEOMETRY_OUTPUT_COMPONENTS;
    public static property MAX_FRAGMENT_INPUT_COMPONENTS:                  GetPName read _MAX_FRAGMENT_INPUT_COMPONENTS;
    public static property CONTEXT_PROFILE_MASK:                           GetPName read _CONTEXT_PROFILE_MASK;
    public static property TEXTURE_BUFFER_OFFSET_ALIGNMENT:                GetPName read _TEXTURE_BUFFER_OFFSET_ALIGNMENT;
    public static property MAX_COMPUTE_UNIFORM_BLOCKS:                     GetPName read _MAX_COMPUTE_UNIFORM_BLOCKS;
    public static property MAX_COMPUTE_TEXTURE_IMAGE_UNITS:                GetPName read _MAX_COMPUTE_TEXTURE_IMAGE_UNITS;
    public static property MAX_COMPUTE_WORK_GROUP_COUNT:                   GetPName read _MAX_COMPUTE_WORK_GROUP_COUNT;
    public static property MAX_COMPUTE_WORK_GROUP_SIZE:                    GetPName read _MAX_COMPUTE_WORK_GROUP_SIZE;
    public static property MAX_VERTEX_ATOMIC_COUNTERS:                     GetPName read _MAX_VERTEX_ATOMIC_COUNTERS;
    public static property MAX_TESS_CONTROL_ATOMIC_COUNTERS:               GetPName read _MAX_TESS_CONTROL_ATOMIC_COUNTERS;
    public static property MAX_TESS_EVALUATION_ATOMIC_COUNTERS:            GetPName read _MAX_TESS_EVALUATION_ATOMIC_COUNTERS;
    public static property MAX_GEOMETRY_ATOMIC_COUNTERS:                   GetPName read _MAX_GEOMETRY_ATOMIC_COUNTERS;
    public static property MAX_FRAGMENT_ATOMIC_COUNTERS:                   GetPName read _MAX_FRAGMENT_ATOMIC_COUNTERS;
    public static property MAX_COMBINED_ATOMIC_COUNTERS:                   GetPName read _MAX_COMBINED_ATOMIC_COUNTERS;
    public static property MAX_FRAMEBUFFER_WIDTH:                          GetPName read _MAX_FRAMEBUFFER_WIDTH;
    public static property MAX_FRAMEBUFFER_HEIGHT:                         GetPName read _MAX_FRAMEBUFFER_HEIGHT;
    public static property MAX_FRAMEBUFFER_LAYERS:                         GetPName read _MAX_FRAMEBUFFER_LAYERS;
    public static property MAX_FRAMEBUFFER_SAMPLES:                        GetPName read _MAX_FRAMEBUFFER_SAMPLES;
    public static property NUM_DEVICE_UUIDS_EXT:                           GetPName read _NUM_DEVICE_UUIDS_EXT;
    public static property DEVICE_UUID_EXT:                                GetPName read _DEVICE_UUID_EXT;
    public static property DRIVER_UUID_EXT:                                GetPName read _DRIVER_UUID_EXT;
    public static property DEVICE_LUID_EXT:                                GetPName read _DEVICE_LUID_EXT;
    public static property DEVICE_NODE_MASK_EXT:                           GetPName read _DEVICE_NODE_MASK_EXT;
    public static property SHADING_RATE_QCOM:                              GetPName read _SHADING_RATE_QCOM;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B00) then Result := 'CURRENT_COLOR' else
      if self.val = UInt32($0B01) then Result := 'CURRENT_INDEX' else
      if self.val = UInt32($0B02) then Result := 'CURRENT_NORMAL' else
      if self.val = UInt32($0B03) then Result := 'CURRENT_TEXTURE_COORDS' else
      if self.val = UInt32($0B04) then Result := 'CURRENT_RASTER_COLOR' else
      if self.val = UInt32($0B05) then Result := 'CURRENT_RASTER_INDEX' else
      if self.val = UInt32($0B06) then Result := 'CURRENT_RASTER_TEXTURE_COORDS' else
      if self.val = UInt32($0B07) then Result := 'CURRENT_RASTER_POSITION' else
      if self.val = UInt32($0B08) then Result := 'CURRENT_RASTER_POSITION_VALID' else
      if self.val = UInt32($0B09) then Result := 'CURRENT_RASTER_DISTANCE' else
      if self.val = UInt32($0B10) then Result := 'POINT_SMOOTH' else
      if self.val = UInt32($0B11) then Result := 'POINT_SIZE' else
      if self.val = UInt32($0B12) then Result := 'POINT_SIZE_RANGE' else
      if self.val = UInt32($0B12) then Result := 'SMOOTH_POINT_SIZE_RANGE' else
      if self.val = UInt32($0B13) then Result := 'POINT_SIZE_GRANULARITY' else
      if self.val = UInt32($0B13) then Result := 'SMOOTH_POINT_SIZE_GRANULARITY' else
      if self.val = UInt32($0B20) then Result := 'LINE_SMOOTH' else
      if self.val = UInt32($0B21) then Result := 'LINE_WIDTH' else
      if self.val = UInt32($0B22) then Result := 'LINE_WIDTH_RANGE' else
      if self.val = UInt32($0B22) then Result := 'SMOOTH_LINE_WIDTH_RANGE' else
      if self.val = UInt32($0B23) then Result := 'LINE_WIDTH_GRANULARITY' else
      if self.val = UInt32($0B23) then Result := 'SMOOTH_LINE_WIDTH_GRANULARITY' else
      if self.val = UInt32($0B24) then Result := 'LINE_STIPPLE' else
      if self.val = UInt32($0B25) then Result := 'LINE_STIPPLE_PATTERN' else
      if self.val = UInt32($0B26) then Result := 'LINE_STIPPLE_REPEAT' else
      if self.val = UInt32($0B30) then Result := 'LIST_MODE' else
      if self.val = UInt32($0B31) then Result := 'MAX_LIST_NESTING' else
      if self.val = UInt32($0B32) then Result := 'LIST_BASE' else
      if self.val = UInt32($0B33) then Result := 'LIST_INDEX' else
      if self.val = UInt32($0B40) then Result := 'POLYGON_MODE' else
      if self.val = UInt32($0B41) then Result := 'POLYGON_SMOOTH' else
      if self.val = UInt32($0B42) then Result := 'POLYGON_STIPPLE' else
      if self.val = UInt32($0B43) then Result := 'EDGE_FLAG' else
      if self.val = UInt32($0B44) then Result := 'CULL_FACE' else
      if self.val = UInt32($0B45) then Result := 'CULL_FACE_MODE' else
      if self.val = UInt32($0B46) then Result := 'FRONT_FACE' else
      if self.val = UInt32($0B50) then Result := 'LIGHTING' else
      if self.val = UInt32($0B51) then Result := 'LIGHT_MODEL_LOCAL_VIEWER' else
      if self.val = UInt32($0B52) then Result := 'LIGHT_MODEL_TWO_SIDE' else
      if self.val = UInt32($0B53) then Result := 'LIGHT_MODEL_AMBIENT' else
      if self.val = UInt32($0B54) then Result := 'SHADE_MODEL' else
      if self.val = UInt32($0B55) then Result := 'COLOR_MATERIAL_FACE' else
      if self.val = UInt32($0B56) then Result := 'COLOR_MATERIAL_PARAMETER' else
      if self.val = UInt32($0B57) then Result := 'COLOR_MATERIAL' else
      if self.val = UInt32($0B60) then Result := 'FOG' else
      if self.val = UInt32($0B61) then Result := 'FOG_INDEX' else
      if self.val = UInt32($0B62) then Result := 'FOG_DENSITY' else
      if self.val = UInt32($0B63) then Result := 'FOG_START' else
      if self.val = UInt32($0B64) then Result := 'FOG_END' else
      if self.val = UInt32($0B65) then Result := 'FOG_MODE' else
      if self.val = UInt32($0B66) then Result := 'FOG_COLOR' else
      if self.val = UInt32($0B70) then Result := 'DEPTH_RANGE' else
      if self.val = UInt32($0B71) then Result := 'DEPTH_TEST' else
      if self.val = UInt32($0B72) then Result := 'DEPTH_WRITEMASK' else
      if self.val = UInt32($0B73) then Result := 'DEPTH_CLEAR_VALUE' else
      if self.val = UInt32($0B74) then Result := 'DEPTH_FUNC' else
      if self.val = UInt32($0B80) then Result := 'ACCUM_CLEAR_VALUE' else
      if self.val = UInt32($0B90) then Result := 'STENCIL_TEST' else
      if self.val = UInt32($0B91) then Result := 'STENCIL_CLEAR_VALUE' else
      if self.val = UInt32($0B92) then Result := 'STENCIL_FUNC' else
      if self.val = UInt32($0B93) then Result := 'STENCIL_VALUE_MASK' else
      if self.val = UInt32($0B94) then Result := 'STENCIL_FAIL' else
      if self.val = UInt32($0B95) then Result := 'STENCIL_PASS_DEPTH_FAIL' else
      if self.val = UInt32($0B96) then Result := 'STENCIL_PASS_DEPTH_PASS' else
      if self.val = UInt32($0B97) then Result := 'STENCIL_REF' else
      if self.val = UInt32($0B98) then Result := 'STENCIL_WRITEMASK' else
      if self.val = UInt32($0BA0) then Result := 'MATRIX_MODE' else
      if self.val = UInt32($0BA1) then Result := 'NORMALIZE' else
      if self.val = UInt32($0BA2) then Result := 'VIEWPORT' else
      if self.val = UInt32($0BA3) then Result := 'MODELVIEW_STACK_DEPTH' else
      if self.val = UInt32($0BA3) then Result := 'MODELVIEW0_STACK_DEPTH_EXT' else
      if self.val = UInt32($0BA4) then Result := 'PROJECTION_STACK_DEPTH' else
      if self.val = UInt32($0BA5) then Result := 'TEXTURE_STACK_DEPTH' else
      if self.val = UInt32($0BA6) then Result := 'MODELVIEW_MATRIX' else
      if self.val = UInt32($0BA6) then Result := 'MODELVIEW0_MATRIX_EXT' else
      if self.val = UInt32($0BA7) then Result := 'PROJECTION_MATRIX' else
      if self.val = UInt32($0BA8) then Result := 'TEXTURE_MATRIX' else
      if self.val = UInt32($0BB0) then Result := 'ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0BB1) then Result := 'CLIENT_ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0BC0) then Result := 'ALPHA_TEST' else
      if self.val = UInt32($0BC0) then Result := 'ALPHA_TEST_QCOM' else
      if self.val = UInt32($0BC1) then Result := 'ALPHA_TEST_FUNC' else
      if self.val = UInt32($0BC1) then Result := 'ALPHA_TEST_FUNC_QCOM' else
      if self.val = UInt32($0BC2) then Result := 'ALPHA_TEST_REF' else
      if self.val = UInt32($0BC2) then Result := 'ALPHA_TEST_REF_QCOM' else
      if self.val = UInt32($0BD0) then Result := 'DITHER' else
      if self.val = UInt32($0BE0) then Result := 'BLEND_DST' else
      if self.val = UInt32($0BE1) then Result := 'BLEND_SRC' else
      if self.val = UInt32($0BE2) then Result := 'BLEND' else
      if self.val = UInt32($0BF0) then Result := 'LOGIC_OP_MODE' else
      if self.val = UInt32($0BF1) then Result := 'INDEX_LOGIC_OP' else
      if self.val = UInt32($0BF1) then Result := 'LOGIC_OP' else
      if self.val = UInt32($0BF2) then Result := 'COLOR_LOGIC_OP' else
      if self.val = UInt32($0C00) then Result := 'AUX_BUFFERS' else
      if self.val = UInt32($0C01) then Result := 'DRAW_BUFFER' else
      if self.val = UInt32($0C01) then Result := 'DRAW_BUFFER_EXT' else
      if self.val = UInt32($0C02) then Result := 'READ_BUFFER' else
      if self.val = UInt32($0C02) then Result := 'READ_BUFFER_EXT' else
      if self.val = UInt32($0C02) then Result := 'READ_BUFFER_NV' else
      if self.val = UInt32($0C10) then Result := 'SCISSOR_BOX' else
      if self.val = UInt32($0C11) then Result := 'SCISSOR_TEST' else
      if self.val = UInt32($0C20) then Result := 'INDEX_CLEAR_VALUE' else
      if self.val = UInt32($0C21) then Result := 'INDEX_WRITEMASK' else
      if self.val = UInt32($0C22) then Result := 'COLOR_CLEAR_VALUE' else
      if self.val = UInt32($0C23) then Result := 'COLOR_WRITEMASK' else
      if self.val = UInt32($0C30) then Result := 'INDEX_MODE' else
      if self.val = UInt32($0C31) then Result := 'RGBA_MODE' else
      if self.val = UInt32($0C32) then Result := 'DOUBLEBUFFER' else
      if self.val = UInt32($0C33) then Result := 'STEREO' else
      if self.val = UInt32($0C40) then Result := 'RENDER_MODE' else
      if self.val = UInt32($0C50) then Result := 'PERSPECTIVE_CORRECTION_HINT' else
      if self.val = UInt32($0C51) then Result := 'POINT_SMOOTH_HINT' else
      if self.val = UInt32($0C52) then Result := 'LINE_SMOOTH_HINT' else
      if self.val = UInt32($0C53) then Result := 'POLYGON_SMOOTH_HINT' else
      if self.val = UInt32($0C54) then Result := 'FOG_HINT' else
      if self.val = UInt32($0C60) then Result := 'TEXTURE_GEN_S' else
      if self.val = UInt32($0C61) then Result := 'TEXTURE_GEN_T' else
      if self.val = UInt32($0C62) then Result := 'TEXTURE_GEN_R' else
      if self.val = UInt32($0C63) then Result := 'TEXTURE_GEN_Q' else
      if self.val = UInt32($0CB0) then Result := 'PIXEL_MAP_I_TO_I_SIZE' else
      if self.val = UInt32($0CB1) then Result := 'PIXEL_MAP_S_TO_S_SIZE' else
      if self.val = UInt32($0CB2) then Result := 'PIXEL_MAP_I_TO_R_SIZE' else
      if self.val = UInt32($0CB3) then Result := 'PIXEL_MAP_I_TO_G_SIZE' else
      if self.val = UInt32($0CB4) then Result := 'PIXEL_MAP_I_TO_B_SIZE' else
      if self.val = UInt32($0CB5) then Result := 'PIXEL_MAP_I_TO_A_SIZE' else
      if self.val = UInt32($0CB6) then Result := 'PIXEL_MAP_R_TO_R_SIZE' else
      if self.val = UInt32($0CB7) then Result := 'PIXEL_MAP_G_TO_G_SIZE' else
      if self.val = UInt32($0CB8) then Result := 'PIXEL_MAP_B_TO_B_SIZE' else
      if self.val = UInt32($0CB9) then Result := 'PIXEL_MAP_A_TO_A_SIZE' else
      if self.val = UInt32($0CF0) then Result := 'UNPACK_SWAP_BYTES' else
      if self.val = UInt32($0CF1) then Result := 'UNPACK_LSB_FIRST' else
      if self.val = UInt32($0CF2) then Result := 'UNPACK_ROW_LENGTH' else
      if self.val = UInt32($0CF3) then Result := 'UNPACK_SKIP_ROWS' else
      if self.val = UInt32($0CF4) then Result := 'UNPACK_SKIP_PIXELS' else
      if self.val = UInt32($0CF5) then Result := 'UNPACK_ALIGNMENT' else
      if self.val = UInt32($0D00) then Result := 'PACK_SWAP_BYTES' else
      if self.val = UInt32($0D01) then Result := 'PACK_LSB_FIRST' else
      if self.val = UInt32($0D02) then Result := 'PACK_ROW_LENGTH' else
      if self.val = UInt32($0D03) then Result := 'PACK_SKIP_ROWS' else
      if self.val = UInt32($0D04) then Result := 'PACK_SKIP_PIXELS' else
      if self.val = UInt32($0D05) then Result := 'PACK_ALIGNMENT' else
      if self.val = UInt32($0D10) then Result := 'MAP_COLOR' else
      if self.val = UInt32($0D11) then Result := 'MAP_STENCIL' else
      if self.val = UInt32($0D12) then Result := 'INDEX_SHIFT' else
      if self.val = UInt32($0D13) then Result := 'INDEX_OFFSET' else
      if self.val = UInt32($0D14) then Result := 'RED_SCALE' else
      if self.val = UInt32($0D15) then Result := 'RED_BIAS' else
      if self.val = UInt32($0D16) then Result := 'ZOOM_X' else
      if self.val = UInt32($0D17) then Result := 'ZOOM_Y' else
      if self.val = UInt32($0D18) then Result := 'GREEN_SCALE' else
      if self.val = UInt32($0D19) then Result := 'GREEN_BIAS' else
      if self.val = UInt32($0D1A) then Result := 'BLUE_SCALE' else
      if self.val = UInt32($0D1B) then Result := 'BLUE_BIAS' else
      if self.val = UInt32($0D1C) then Result := 'ALPHA_SCALE' else
      if self.val = UInt32($0D1D) then Result := 'ALPHA_BIAS' else
      if self.val = UInt32($0D1E) then Result := 'DEPTH_SCALE' else
      if self.val = UInt32($0D1F) then Result := 'DEPTH_BIAS' else
      if self.val = UInt32($0D30) then Result := 'MAX_EVAL_ORDER' else
      if self.val = UInt32($0D31) then Result := 'MAX_LIGHTS' else
      if self.val = UInt32($0D32) then Result := 'MAX_CLIP_DISTANCES' else
      if self.val = UInt32($0D32) then Result := 'MAX_CLIP_PLANES' else
      if self.val = UInt32($0D33) then Result := 'MAX_TEXTURE_SIZE' else
      if self.val = UInt32($0D34) then Result := 'MAX_PIXEL_MAP_TABLE' else
      if self.val = UInt32($0D35) then Result := 'MAX_ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0D36) then Result := 'MAX_MODELVIEW_STACK_DEPTH' else
      if self.val = UInt32($0D37) then Result := 'MAX_NAME_STACK_DEPTH' else
      if self.val = UInt32($0D38) then Result := 'MAX_PROJECTION_STACK_DEPTH' else
      if self.val = UInt32($0D39) then Result := 'MAX_TEXTURE_STACK_DEPTH' else
      if self.val = UInt32($0D3A) then Result := 'MAX_VIEWPORT_DIMS' else
      if self.val = UInt32($0D3B) then Result := 'MAX_CLIENT_ATTRIB_STACK_DEPTH' else
      if self.val = UInt32($0D50) then Result := 'SUBPIXEL_BITS' else
      if self.val = UInt32($0D51) then Result := 'INDEX_BITS' else
      if self.val = UInt32($0D52) then Result := 'RED_BITS' else
      if self.val = UInt32($0D53) then Result := 'GREEN_BITS' else
      if self.val = UInt32($0D54) then Result := 'BLUE_BITS' else
      if self.val = UInt32($0D55) then Result := 'ALPHA_BITS' else
      if self.val = UInt32($0D56) then Result := 'DEPTH_BITS' else
      if self.val = UInt32($0D57) then Result := 'STENCIL_BITS' else
      if self.val = UInt32($0D58) then Result := 'ACCUM_RED_BITS' else
      if self.val = UInt32($0D59) then Result := 'ACCUM_GREEN_BITS' else
      if self.val = UInt32($0D5A) then Result := 'ACCUM_BLUE_BITS' else
      if self.val = UInt32($0D5B) then Result := 'ACCUM_ALPHA_BITS' else
      if self.val = UInt32($0D70) then Result := 'NAME_STACK_DEPTH' else
      if self.val = UInt32($0D80) then Result := 'AUTO_NORMAL' else
      if self.val = UInt32($0D90) then Result := 'MAP1_COLOR_4' else
      if self.val = UInt32($0D91) then Result := 'MAP1_INDEX' else
      if self.val = UInt32($0D92) then Result := 'MAP1_NORMAL' else
      if self.val = UInt32($0D93) then Result := 'MAP1_TEXTURE_COORD_1' else
      if self.val = UInt32($0D94) then Result := 'MAP1_TEXTURE_COORD_2' else
      if self.val = UInt32($0D95) then Result := 'MAP1_TEXTURE_COORD_3' else
      if self.val = UInt32($0D96) then Result := 'MAP1_TEXTURE_COORD_4' else
      if self.val = UInt32($0D97) then Result := 'MAP1_VERTEX_3' else
      if self.val = UInt32($0D98) then Result := 'MAP1_VERTEX_4' else
      if self.val = UInt32($0DB0) then Result := 'MAP2_COLOR_4' else
      if self.val = UInt32($0DB1) then Result := 'MAP2_INDEX' else
      if self.val = UInt32($0DB2) then Result := 'MAP2_NORMAL' else
      if self.val = UInt32($0DB3) then Result := 'MAP2_TEXTURE_COORD_1' else
      if self.val = UInt32($0DB4) then Result := 'MAP2_TEXTURE_COORD_2' else
      if self.val = UInt32($0DB5) then Result := 'MAP2_TEXTURE_COORD_3' else
      if self.val = UInt32($0DB6) then Result := 'MAP2_TEXTURE_COORD_4' else
      if self.val = UInt32($0DB7) then Result := 'MAP2_VERTEX_3' else
      if self.val = UInt32($0DB8) then Result := 'MAP2_VERTEX_4' else
      if self.val = UInt32($0DD0) then Result := 'MAP1_GRID_DOMAIN' else
      if self.val = UInt32($0DD1) then Result := 'MAP1_GRID_SEGMENTS' else
      if self.val = UInt32($0DD2) then Result := 'MAP2_GRID_DOMAIN' else
      if self.val = UInt32($0DD3) then Result := 'MAP2_GRID_SEGMENTS' else
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($0DF1) then Result := 'FEEDBACK_BUFFER_SIZE' else
      if self.val = UInt32($0DF2) then Result := 'FEEDBACK_BUFFER_TYPE' else
      if self.val = UInt32($0DF4) then Result := 'SELECTION_BUFFER_SIZE' else
      if self.val = UInt32($2A00) then Result := 'POLYGON_OFFSET_UNITS' else
      if self.val = UInt32($2A01) then Result := 'POLYGON_OFFSET_POINT' else
      if self.val = UInt32($2A02) then Result := 'POLYGON_OFFSET_LINE' else
      if self.val = UInt32($3000) then Result := 'CLIP_PLANE0' else
      if self.val = UInt32($3001) then Result := 'CLIP_PLANE1' else
      if self.val = UInt32($3002) then Result := 'CLIP_PLANE2' else
      if self.val = UInt32($3003) then Result := 'CLIP_PLANE3' else
      if self.val = UInt32($3004) then Result := 'CLIP_PLANE4' else
      if self.val = UInt32($3005) then Result := 'CLIP_PLANE5' else
      if self.val = UInt32($4000) then Result := 'LIGHT0' else
      if self.val = UInt32($4001) then Result := 'LIGHT1' else
      if self.val = UInt32($4002) then Result := 'LIGHT2' else
      if self.val = UInt32($4003) then Result := 'LIGHT3' else
      if self.val = UInt32($4004) then Result := 'LIGHT4' else
      if self.val = UInt32($4005) then Result := 'LIGHT5' else
      if self.val = UInt32($4006) then Result := 'LIGHT6' else
      if self.val = UInt32($4007) then Result := 'LIGHT7' else
      if self.val = UInt32($8005) then Result := 'BLEND_COLOR' else
      if self.val = UInt32($8005) then Result := 'BLEND_COLOR_EXT' else
      if self.val = UInt32($8009) then Result := 'BLEND_EQUATION_EXT' else
      if self.val = UInt32($8009) then Result := 'BLEND_EQUATION_RGB' else
      if self.val = UInt32($800E) then Result := 'PACK_CMYK_HINT_EXT' else
      if self.val = UInt32($800F) then Result := 'UNPACK_CMYK_HINT_EXT' else
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D_EXT' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D_EXT' else
      if self.val = UInt32($8012) then Result := 'SEPARABLE_2D_EXT' else
      if self.val = UInt32($801C) then Result := 'POST_CONVOLUTION_RED_SCALE_EXT' else
      if self.val = UInt32($801D) then Result := 'POST_CONVOLUTION_GREEN_SCALE_EXT' else
      if self.val = UInt32($801E) then Result := 'POST_CONVOLUTION_BLUE_SCALE_EXT' else
      if self.val = UInt32($801F) then Result := 'POST_CONVOLUTION_ALPHA_SCALE_EXT' else
      if self.val = UInt32($8020) then Result := 'POST_CONVOLUTION_RED_BIAS_EXT' else
      if self.val = UInt32($8021) then Result := 'POST_CONVOLUTION_GREEN_BIAS_EXT' else
      if self.val = UInt32($8022) then Result := 'POST_CONVOLUTION_BLUE_BIAS_EXT' else
      if self.val = UInt32($8023) then Result := 'POST_CONVOLUTION_ALPHA_BIAS_EXT' else
      if self.val = UInt32($8024) then Result := 'HISTOGRAM_EXT' else
      if self.val = UInt32($802E) then Result := 'MINMAX_EXT' else
      if self.val = UInt32($8037) then Result := 'POLYGON_OFFSET_FILL' else
      if self.val = UInt32($8038) then Result := 'POLYGON_OFFSET_FACTOR' else
      if self.val = UInt32($8039) then Result := 'POLYGON_OFFSET_BIAS_EXT' else
      if self.val = UInt32($803A) then Result := 'RESCALE_NORMAL_EXT' else
      if self.val = UInt32($8068) then Result := 'TEXTURE_BINDING_1D' else
      if self.val = UInt32($8069) then Result := 'TEXTURE_BINDING_2D' else
      if self.val = UInt32($806A) then Result := 'TEXTURE_3D_BINDING_EXT' else
      if self.val = UInt32($806A) then Result := 'TEXTURE_BINDING_3D' else
      if self.val = UInt32($806B) then Result := 'PACK_SKIP_IMAGES' else
      if self.val = UInt32($806B) then Result := 'PACK_SKIP_IMAGES_EXT' else
      if self.val = UInt32($806C) then Result := 'PACK_IMAGE_HEIGHT' else
      if self.val = UInt32($806C) then Result := 'PACK_IMAGE_HEIGHT_EXT' else
      if self.val = UInt32($806D) then Result := 'UNPACK_SKIP_IMAGES' else
      if self.val = UInt32($806D) then Result := 'UNPACK_SKIP_IMAGES_EXT' else
      if self.val = UInt32($806E) then Result := 'UNPACK_IMAGE_HEIGHT' else
      if self.val = UInt32($806E) then Result := 'UNPACK_IMAGE_HEIGHT_EXT' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D_EXT' else
      if self.val = UInt32($8073) then Result := 'MAX_3D_TEXTURE_SIZE' else
      if self.val = UInt32($8073) then Result := 'MAX_3D_TEXTURE_SIZE_EXT' else
      if self.val = UInt32($8074) then Result := 'VERTEX_ARRAY' else
      if self.val = UInt32($8075) then Result := 'NORMAL_ARRAY' else
      if self.val = UInt32($8076) then Result := 'COLOR_ARRAY' else
      if self.val = UInt32($8077) then Result := 'INDEX_ARRAY' else
      if self.val = UInt32($8078) then Result := 'TEXTURE_COORD_ARRAY' else
      if self.val = UInt32($8079) then Result := 'EDGE_FLAG_ARRAY' else
      if self.val = UInt32($807A) then Result := 'VERTEX_ARRAY_SIZE' else
      if self.val = UInt32($807B) then Result := 'VERTEX_ARRAY_TYPE' else
      if self.val = UInt32($807C) then Result := 'VERTEX_ARRAY_STRIDE' else
      if self.val = UInt32($807D) then Result := 'VERTEX_ARRAY_COUNT_EXT' else
      if self.val = UInt32($807E) then Result := 'NORMAL_ARRAY_TYPE' else
      if self.val = UInt32($807F) then Result := 'NORMAL_ARRAY_STRIDE' else
      if self.val = UInt32($8080) then Result := 'NORMAL_ARRAY_COUNT_EXT' else
      if self.val = UInt32($8081) then Result := 'COLOR_ARRAY_SIZE' else
      if self.val = UInt32($8082) then Result := 'COLOR_ARRAY_TYPE' else
      if self.val = UInt32($8083) then Result := 'COLOR_ARRAY_STRIDE' else
      if self.val = UInt32($8084) then Result := 'COLOR_ARRAY_COUNT_EXT' else
      if self.val = UInt32($8085) then Result := 'INDEX_ARRAY_TYPE' else
      if self.val = UInt32($8086) then Result := 'INDEX_ARRAY_STRIDE' else
      if self.val = UInt32($8087) then Result := 'INDEX_ARRAY_COUNT_EXT' else
      if self.val = UInt32($8088) then Result := 'TEXTURE_COORD_ARRAY_SIZE' else
      if self.val = UInt32($8089) then Result := 'TEXTURE_COORD_ARRAY_TYPE' else
      if self.val = UInt32($808A) then Result := 'TEXTURE_COORD_ARRAY_STRIDE' else
      if self.val = UInt32($808B) then Result := 'TEXTURE_COORD_ARRAY_COUNT_EXT' else
      if self.val = UInt32($808C) then Result := 'EDGE_FLAG_ARRAY_STRIDE' else
      if self.val = UInt32($808D) then Result := 'EDGE_FLAG_ARRAY_COUNT_EXT' else
      if self.val = UInt32($8094) then Result := 'INTERLACE_SGIX' else
      if self.val = UInt32($8096) then Result := 'DETAIL_TEXTURE_2D_BINDING_SGIS' else
      if self.val = UInt32($809D) then Result := 'MULTISAMPLE_SGIS' else
      if self.val = UInt32($809E) then Result := 'SAMPLE_ALPHA_TO_MASK_SGIS' else
      if self.val = UInt32($809F) then Result := 'SAMPLE_ALPHA_TO_ONE_SGIS' else
      if self.val = UInt32($80A0) then Result := 'SAMPLE_MASK_SGIS' else
      if self.val = UInt32($80A8) then Result := 'SAMPLE_BUFFERS' else
      if self.val = UInt32($80A8) then Result := 'SAMPLE_BUFFERS_SGIS' else
      if self.val = UInt32($80A9) then Result := 'SAMPLES' else
      if self.val = UInt32($80A9) then Result := 'SAMPLES_SGIS' else
      if self.val = UInt32($80AA) then Result := 'SAMPLE_COVERAGE_VALUE' else
      if self.val = UInt32($80AA) then Result := 'SAMPLE_MASK_VALUE_SGIS' else
      if self.val = UInt32($80AB) then Result := 'SAMPLE_COVERAGE_INVERT' else
      if self.val = UInt32($80AB) then Result := 'SAMPLE_MASK_INVERT_SGIS' else
      if self.val = UInt32($80AC) then Result := 'SAMPLE_PATTERN_SGIS' else
      if self.val = UInt32($80B1) then Result := 'COLOR_MATRIX_SGI' else
      if self.val = UInt32($80B2) then Result := 'COLOR_MATRIX_STACK_DEPTH_SGI' else
      if self.val = UInt32($80B3) then Result := 'MAX_COLOR_MATRIX_STACK_DEPTH_SGI' else
      if self.val = UInt32($80B4) then Result := 'POST_COLOR_MATRIX_RED_SCALE_SGI' else
      if self.val = UInt32($80B5) then Result := 'POST_COLOR_MATRIX_GREEN_SCALE_SGI' else
      if self.val = UInt32($80B6) then Result := 'POST_COLOR_MATRIX_BLUE_SCALE_SGI' else
      if self.val = UInt32($80B7) then Result := 'POST_COLOR_MATRIX_ALPHA_SCALE_SGI' else
      if self.val = UInt32($80B8) then Result := 'POST_COLOR_MATRIX_RED_BIAS_SGI' else
      if self.val = UInt32($80B9) then Result := 'POST_COLOR_MATRIX_GREEN_BIAS_SGI' else
      if self.val = UInt32($80BA) then Result := 'POST_COLOR_MATRIX_BLUE_BIAS_SGI' else
      if self.val = UInt32($80BB) then Result := 'POST_COLOR_MATRIX_ALPHA_BIAS_SGI' else
      if self.val = UInt32($80BC) then Result := 'TEXTURE_COLOR_TABLE_SGI' else
      if self.val = UInt32($80C8) then Result := 'BLEND_DST_RGB' else
      if self.val = UInt32($80C9) then Result := 'BLEND_SRC_RGB' else
      if self.val = UInt32($80CA) then Result := 'BLEND_DST_ALPHA' else
      if self.val = UInt32($80CB) then Result := 'BLEND_SRC_ALPHA' else
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE_SGI' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE_SGI' else
      if self.val = UInt32($80E8) then Result := 'MAX_ELEMENTS_VERTICES' else
      if self.val = UInt32($80E9) then Result := 'MAX_ELEMENTS_INDICES' else
      if self.val = UInt32($8126) then Result := 'POINT_SIZE_MIN_SGIS' else
      if self.val = UInt32($8127) then Result := 'POINT_SIZE_MAX_SGIS' else
      if self.val = UInt32($8128) then Result := 'POINT_FADE_THRESHOLD_SIZE' else
      if self.val = UInt32($8128) then Result := 'POINT_FADE_THRESHOLD_SIZE_SGIS' else
      if self.val = UInt32($8129) then Result := 'DISTANCE_ATTENUATION_SGIS' else
      if self.val = UInt32($812B) then Result := 'FOG_FUNC_POINTS_SGIS' else
      if self.val = UInt32($812C) then Result := 'MAX_FOG_FUNC_POINTS_SGIS' else
      if self.val = UInt32($8130) then Result := 'PACK_SKIP_VOLUMES_SGIS' else
      if self.val = UInt32($8131) then Result := 'PACK_IMAGE_DEPTH_SGIS' else
      if self.val = UInt32($8132) then Result := 'UNPACK_SKIP_VOLUMES_SGIS' else
      if self.val = UInt32($8133) then Result := 'UNPACK_IMAGE_DEPTH_SGIS' else
      if self.val = UInt32($8134) then Result := 'TEXTURE_4D_SGIS' else
      if self.val = UInt32($8138) then Result := 'MAX_4D_TEXTURE_SIZE_SGIS' else
      if self.val = UInt32($8139) then Result := 'PIXEL_TEX_GEN_SGIX' else
      if self.val = UInt32($813E) then Result := 'PIXEL_TILE_BEST_ALIGNMENT_SGIX' else
      if self.val = UInt32($813F) then Result := 'PIXEL_TILE_CACHE_INCREMENT_SGIX' else
      if self.val = UInt32($8140) then Result := 'PIXEL_TILE_WIDTH_SGIX' else
      if self.val = UInt32($8141) then Result := 'PIXEL_TILE_HEIGHT_SGIX' else
      if self.val = UInt32($8142) then Result := 'PIXEL_TILE_GRID_WIDTH_SGIX' else
      if self.val = UInt32($8143) then Result := 'PIXEL_TILE_GRID_HEIGHT_SGIX' else
      if self.val = UInt32($8144) then Result := 'PIXEL_TILE_GRID_DEPTH_SGIX' else
      if self.val = UInt32($8145) then Result := 'PIXEL_TILE_CACHE_SIZE_SGIX' else
      if self.val = UInt32($8148) then Result := 'SPRITE_SGIX' else
      if self.val = UInt32($8149) then Result := 'SPRITE_MODE_SGIX' else
      if self.val = UInt32($814A) then Result := 'SPRITE_AXIS_SGIX' else
      if self.val = UInt32($814B) then Result := 'SPRITE_TRANSLATION_SGIX' else
      if self.val = UInt32($814F) then Result := 'TEXTURE_4D_BINDING_SGIS' else
      if self.val = UInt32($8177) then Result := 'MAX_CLIPMAP_DEPTH_SGIX' else
      if self.val = UInt32($8178) then Result := 'MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX' else
      if self.val = UInt32($817B) then Result := 'POST_TEXTURE_FILTER_BIAS_RANGE_SGIX' else
      if self.val = UInt32($817C) then Result := 'POST_TEXTURE_FILTER_SCALE_RANGE_SGIX' else
      if self.val = UInt32($817D) then Result := 'REFERENCE_PLANE_SGIX' else
      if self.val = UInt32($817E) then Result := 'REFERENCE_PLANE_EQUATION_SGIX' else
      if self.val = UInt32($817F) then Result := 'IR_INSTRUMENT1_SGIX' else
      if self.val = UInt32($8181) then Result := 'INSTRUMENT_MEASUREMENTS_SGIX' else
      if self.val = UInt32($8183) then Result := 'CALLIGRAPHIC_FRAGMENT_SGIX' else
      if self.val = UInt32($818B) then Result := 'FRAMEZOOM_SGIX' else
      if self.val = UInt32($818C) then Result := 'FRAMEZOOM_FACTOR_SGIX' else
      if self.val = UInt32($818D) then Result := 'MAX_FRAMEZOOM_FACTOR_SGIX' else
      if self.val = UInt32($8192) then Result := 'GENERATE_MIPMAP_HINT_SGIS' else
      if self.val = UInt32($8196) then Result := 'DEFORMATIONS_MASK_SGIX' else
      if self.val = UInt32($8198) then Result := 'FOG_OFFSET_SGIX' else
      if self.val = UInt32($8199) then Result := 'FOG_OFFSET_VALUE_SGIX' else
      if self.val = UInt32($81F8) then Result := 'LIGHT_MODEL_COLOR_CONTROL' else
      if self.val = UInt32($81FB) then Result := 'SHARED_TEXTURE_PALETTE_EXT' else
      if self.val = UInt32($821B) then Result := 'MAJOR_VERSION' else
      if self.val = UInt32($821C) then Result := 'MINOR_VERSION' else
      if self.val = UInt32($821D) then Result := 'NUM_EXTENSIONS' else
      if self.val = UInt32($821E) then Result := 'CONTEXT_FLAGS' else
      if self.val = UInt32($825A) then Result := 'PROGRAM_PIPELINE_BINDING' else
      if self.val = UInt32($825B) then Result := 'MAX_VIEWPORTS' else
      if self.val = UInt32($825C) then Result := 'VIEWPORT_SUBPIXEL_BITS' else
      if self.val = UInt32($825D) then Result := 'VIEWPORT_BOUNDS_RANGE' else
      if self.val = UInt32($825E) then Result := 'LAYER_PROVOKING_VERTEX' else
      if self.val = UInt32($825F) then Result := 'VIEWPORT_INDEX_PROVOKING_VERTEX' else
      if self.val = UInt32($8263) then Result := 'MAX_COMPUTE_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8264) then Result := 'MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS' else
      if self.val = UInt32($8265) then Result := 'MAX_COMPUTE_ATOMIC_COUNTERS' else
      if self.val = UInt32($8266) then Result := 'MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS' else
      if self.val = UInt32($826C) then Result := 'MAX_DEBUG_GROUP_STACK_DEPTH' else
      if self.val = UInt32($826D) then Result := 'DEBUG_GROUP_STACK_DEPTH' else
      if self.val = UInt32($826E) then Result := 'MAX_UNIFORM_LOCATIONS' else
      if self.val = UInt32($82D6) then Result := 'VERTEX_BINDING_DIVISOR' else
      if self.val = UInt32($82D7) then Result := 'VERTEX_BINDING_OFFSET' else
      if self.val = UInt32($82D8) then Result := 'VERTEX_BINDING_STRIDE' else
      if self.val = UInt32($82D9) then Result := 'MAX_VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if self.val = UInt32($82DA) then Result := 'MAX_VERTEX_ATTRIB_BINDINGS' else
      if self.val = UInt32($82E8) then Result := 'MAX_LABEL_LENGTH' else
      if self.val = UInt32($8316) then Result := 'CONVOLUTION_HINT_SGIX' else
      if self.val = UInt32($8329) then Result := 'ASYNC_MARKER_SGIX' else
      if self.val = UInt32($832B) then Result := 'PIXEL_TEX_GEN_MODE_SGIX' else
      if self.val = UInt32($832C) then Result := 'ASYNC_HISTOGRAM_SGIX' else
      if self.val = UInt32($832D) then Result := 'MAX_ASYNC_HISTOGRAM_SGIX' else
      if self.val = UInt32($8353) then Result := 'PIXEL_TEXTURE_SGIS' else
      if self.val = UInt32($835C) then Result := 'ASYNC_TEX_IMAGE_SGIX' else
      if self.val = UInt32($835D) then Result := 'ASYNC_DRAW_PIXELS_SGIX' else
      if self.val = UInt32($835E) then Result := 'ASYNC_READ_PIXELS_SGIX' else
      if self.val = UInt32($835F) then Result := 'MAX_ASYNC_TEX_IMAGE_SGIX' else
      if self.val = UInt32($8360) then Result := 'MAX_ASYNC_DRAW_PIXELS_SGIX' else
      if self.val = UInt32($8361) then Result := 'MAX_ASYNC_READ_PIXELS_SGIX' else
      if self.val = UInt32($83EE) then Result := 'VERTEX_PRECLIP_SGIX' else
      if self.val = UInt32($83EF) then Result := 'VERTEX_PRECLIP_HINT_SGIX' else
      if self.val = UInt32($8400) then Result := 'FRAGMENT_LIGHTING_SGIX' else
      if self.val = UInt32($8401) then Result := 'FRAGMENT_COLOR_MATERIAL_SGIX' else
      if self.val = UInt32($8402) then Result := 'FRAGMENT_COLOR_MATERIAL_FACE_SGIX' else
      if self.val = UInt32($8403) then Result := 'FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX' else
      if self.val = UInt32($8404) then Result := 'MAX_FRAGMENT_LIGHTS_SGIX' else
      if self.val = UInt32($8405) then Result := 'MAX_ACTIVE_LIGHTS_SGIX' else
      if self.val = UInt32($8407) then Result := 'LIGHT_ENV_MODE_SGIX' else
      if self.val = UInt32($8408) then Result := 'FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX' else
      if self.val = UInt32($8409) then Result := 'FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX' else
      if self.val = UInt32($840A) then Result := 'FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX' else
      if self.val = UInt32($840B) then Result := 'FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX' else
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0_SGIX' else
      if self.val = UInt32($842E) then Result := 'PACK_RESAMPLE_SGIX' else
      if self.val = UInt32($842F) then Result := 'UNPACK_RESAMPLE_SGIX' else
      if self.val = UInt32($846D) then Result := 'ALIASED_POINT_SIZE_RANGE' else
      if self.val = UInt32($846E) then Result := 'ALIASED_LINE_WIDTH_RANGE' else
      if self.val = UInt32($84E0) then Result := 'ACTIVE_TEXTURE' else
      if self.val = UInt32($84E8) then Result := 'MAX_RENDERBUFFER_SIZE' else
      if self.val = UInt32($84EF) then Result := 'TEXTURE_COMPRESSION_HINT' else
      if self.val = UInt32($84F6) then Result := 'TEXTURE_BINDING_RECTANGLE' else
      if self.val = UInt32($84F8) then Result := 'MAX_RECTANGLE_TEXTURE_SIZE' else
      if self.val = UInt32($84FD) then Result := 'MAX_TEXTURE_LOD_BIAS' else
      if self.val = UInt32($8514) then Result := 'TEXTURE_BINDING_CUBE_MAP' else
      if self.val = UInt32($851C) then Result := 'MAX_CUBE_MAP_TEXTURE_SIZE' else
      if self.val = UInt32($85A0) then Result := 'PACK_SUBSAMPLE_RATE_SGIX' else
      if self.val = UInt32($85A1) then Result := 'UNPACK_SUBSAMPLE_RATE_SGIX' else
      if self.val = UInt32($85B5) then Result := 'VERTEX_ARRAY_BINDING' else
      if self.val = UInt32($8642) then Result := 'PROGRAM_POINT_SIZE' else
      if self.val = UInt32($86A2) then Result := 'NUM_COMPRESSED_TEXTURE_FORMATS' else
      if self.val = UInt32($86A3) then Result := 'COMPRESSED_TEXTURE_FORMATS' else
      if self.val = UInt32($87FE) then Result := 'NUM_PROGRAM_BINARY_FORMATS' else
      if self.val = UInt32($87FF) then Result := 'PROGRAM_BINARY_FORMATS' else
      if self.val = UInt32($8800) then Result := 'STENCIL_BACK_FUNC' else
      if self.val = UInt32($8801) then Result := 'STENCIL_BACK_FAIL' else
      if self.val = UInt32($8802) then Result := 'STENCIL_BACK_PASS_DEPTH_FAIL' else
      if self.val = UInt32($8803) then Result := 'STENCIL_BACK_PASS_DEPTH_PASS' else
      if self.val = UInt32($8824) then Result := 'MAX_DRAW_BUFFERS' else
      if self.val = UInt32($883D) then Result := 'BLEND_EQUATION_ALPHA' else
      if self.val = UInt32($8869) then Result := 'MAX_VERTEX_ATTRIBS' else
      if self.val = UInt32($8872) then Result := 'MAX_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8894) then Result := 'ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($8895) then Result := 'ELEMENT_ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($88ED) then Result := 'PIXEL_PACK_BUFFER_BINDING' else
      if self.val = UInt32($88EF) then Result := 'PIXEL_UNPACK_BUFFER_BINDING' else
      if self.val = UInt32($88FC) then Result := 'MAX_DUAL_SOURCE_DRAW_BUFFERS' else
      if self.val = UInt32($88FF) then Result := 'MAX_ARRAY_TEXTURE_LAYERS' else
      if self.val = UInt32($8904) then Result := 'MIN_PROGRAM_TEXEL_OFFSET' else
      if self.val = UInt32($8905) then Result := 'MAX_PROGRAM_TEXEL_OFFSET' else
      if self.val = UInt32($8919) then Result := 'SAMPLER_BINDING' else
      if self.val = UInt32($8A28) then Result := 'UNIFORM_BUFFER_BINDING' else
      if self.val = UInt32($8A29) then Result := 'UNIFORM_BUFFER_START' else
      if self.val = UInt32($8A2A) then Result := 'UNIFORM_BUFFER_SIZE' else
      if self.val = UInt32($8A2B) then Result := 'MAX_VERTEX_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2C) then Result := 'MAX_GEOMETRY_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2D) then Result := 'MAX_FRAGMENT_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2E) then Result := 'MAX_COMBINED_UNIFORM_BLOCKS' else
      if self.val = UInt32($8A2F) then Result := 'MAX_UNIFORM_BUFFER_BINDINGS' else
      if self.val = UInt32($8A30) then Result := 'MAX_UNIFORM_BLOCK_SIZE' else
      if self.val = UInt32($8A31) then Result := 'MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8A32) then Result := 'MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8A33) then Result := 'MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8A34) then Result := 'UNIFORM_BUFFER_OFFSET_ALIGNMENT' else
      if self.val = UInt32($8B49) then Result := 'MAX_FRAGMENT_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8B4A) then Result := 'MAX_VERTEX_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8B4B) then Result := 'MAX_VARYING_COMPONENTS' else
      if self.val = UInt32($8B4B) then Result := 'MAX_VARYING_FLOATS' else
      if self.val = UInt32($8B4C) then Result := 'MAX_VERTEX_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8B4D) then Result := 'MAX_COMBINED_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8B8B) then Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT' else
      if self.val = UInt32($8B8D) then Result := 'CURRENT_PROGRAM' else
      if self.val = UInt32($8B9A) then Result := 'IMPLEMENTATION_COLOR_READ_TYPE' else
      if self.val = UInt32($8B9B) then Result := 'IMPLEMENTATION_COLOR_READ_FORMAT' else
      if self.val = UInt32($8C1C) then Result := 'TEXTURE_BINDING_1D_ARRAY' else
      if self.val = UInt32($8C1D) then Result := 'TEXTURE_BINDING_2D_ARRAY' else
      if self.val = UInt32($8C29) then Result := 'MAX_GEOMETRY_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($8C2B) then Result := 'MAX_TEXTURE_BUFFER_SIZE' else
      if self.val = UInt32($8C2C) then Result := 'TEXTURE_BINDING_BUFFER' else
      if self.val = UInt32($8C84) then Result := 'TRANSFORM_FEEDBACK_BUFFER_START' else
      if self.val = UInt32($8C85) then Result := 'TRANSFORM_FEEDBACK_BUFFER_SIZE' else
      if self.val = UInt32($8C8F) then Result := 'TRANSFORM_FEEDBACK_BUFFER_BINDING' else
      if self.val = UInt32($8C90) then Result := 'MOTION_ESTIMATION_SEARCH_BLOCK_X_QCOM' else
      if self.val = UInt32($8C91) then Result := 'MOTION_ESTIMATION_SEARCH_BLOCK_Y_QCOM' else
      if self.val = UInt32($8CA3) then Result := 'STENCIL_BACK_REF' else
      if self.val = UInt32($8CA4) then Result := 'STENCIL_BACK_VALUE_MASK' else
      if self.val = UInt32($8CA5) then Result := 'STENCIL_BACK_WRITEMASK' else
      if self.val = UInt32($8CA6) then Result := 'DRAW_FRAMEBUFFER_BINDING' else
      if self.val = UInt32($8CA7) then Result := 'RENDERBUFFER_BINDING' else
      if self.val = UInt32($8CAA) then Result := 'READ_FRAMEBUFFER_BINDING' else
      if self.val = UInt32($8D6B) then Result := 'MAX_ELEMENT_INDEX' else
      if self.val = UInt32($8DDF) then Result := 'MAX_GEOMETRY_UNIFORM_COMPONENTS' else
      if self.val = UInt32($8DF9) then Result := 'NUM_SHADER_BINARY_FORMATS' else
      if self.val = UInt32($8DFA) then Result := 'SHADER_COMPILER' else
      if self.val = UInt32($8DFB) then Result := 'MAX_VERTEX_UNIFORM_VECTORS' else
      if self.val = UInt32($8DFC) then Result := 'MAX_VARYING_VECTORS' else
      if self.val = UInt32($8DFD) then Result := 'MAX_FRAGMENT_UNIFORM_VECTORS' else
      if self.val = UInt32($8E28) then Result := 'TIMESTAMP' else
      if self.val = UInt32($8E4F) then Result := 'PROVOKING_VERTEX' else
      if self.val = UInt32($8E59) then Result := 'MAX_SAMPLE_MASK_WORDS' else
      if self.val = UInt32($8E89) then Result := 'MAX_TESS_CONTROL_UNIFORM_BLOCKS' else
      if self.val = UInt32($8E8A) then Result := 'MAX_TESS_EVALUATION_UNIFORM_BLOCKS' else
      if self.val = UInt32($8F9E) then Result := 'PRIMITIVE_RESTART_INDEX' else
      if self.val = UInt32($90BC) then Result := 'MIN_MAP_BUFFER_ALIGNMENT' else
      if self.val = UInt32($90D3) then Result := 'SHADER_STORAGE_BUFFER_BINDING' else
      if self.val = UInt32($90D4) then Result := 'SHADER_STORAGE_BUFFER_START' else
      if self.val = UInt32($90D5) then Result := 'SHADER_STORAGE_BUFFER_SIZE' else
      if self.val = UInt32($90D6) then Result := 'MAX_VERTEX_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90D7) then Result := 'MAX_GEOMETRY_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90D8) then Result := 'MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90D9) then Result := 'MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DA) then Result := 'MAX_FRAGMENT_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DB) then Result := 'MAX_COMPUTE_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DC) then Result := 'MAX_COMBINED_SHADER_STORAGE_BLOCKS' else
      if self.val = UInt32($90DD) then Result := 'MAX_SHADER_STORAGE_BUFFER_BINDINGS' else
      if self.val = UInt32($90DF) then Result := 'SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT' else
      if self.val = UInt32($90EB) then Result := 'MAX_COMPUTE_WORK_GROUP_INVOCATIONS' else
      if self.val = UInt32($90EF) then Result := 'DISPATCH_INDIRECT_BUFFER_BINDING' else
      if self.val = UInt32($9104) then Result := 'TEXTURE_BINDING_2D_MULTISAMPLE' else
      if self.val = UInt32($9105) then Result := 'TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910E) then Result := 'MAX_COLOR_TEXTURE_SAMPLES' else
      if self.val = UInt32($910F) then Result := 'MAX_DEPTH_TEXTURE_SAMPLES' else
      if self.val = UInt32($9110) then Result := 'MAX_INTEGER_SAMPLES' else
      if self.val = UInt32($9111) then Result := 'MAX_SERVER_WAIT_TIMEOUT' else
      if self.val = UInt32($9122) then Result := 'MAX_VERTEX_OUTPUT_COMPONENTS' else
      if self.val = UInt32($9123) then Result := 'MAX_GEOMETRY_INPUT_COMPONENTS' else
      if self.val = UInt32($9124) then Result := 'MAX_GEOMETRY_OUTPUT_COMPONENTS' else
      if self.val = UInt32($9125) then Result := 'MAX_FRAGMENT_INPUT_COMPONENTS' else
      if self.val = UInt32($9126) then Result := 'CONTEXT_PROFILE_MASK' else
      if self.val = UInt32($919F) then Result := 'TEXTURE_BUFFER_OFFSET_ALIGNMENT' else
      if self.val = UInt32($91BB) then Result := 'MAX_COMPUTE_UNIFORM_BLOCKS' else
      if self.val = UInt32($91BC) then Result := 'MAX_COMPUTE_TEXTURE_IMAGE_UNITS' else
      if self.val = UInt32($91BE) then Result := 'MAX_COMPUTE_WORK_GROUP_COUNT' else
      if self.val = UInt32($91BF) then Result := 'MAX_COMPUTE_WORK_GROUP_SIZE' else
      if self.val = UInt32($92D2) then Result := 'MAX_VERTEX_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D3) then Result := 'MAX_TESS_CONTROL_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D4) then Result := 'MAX_TESS_EVALUATION_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D5) then Result := 'MAX_GEOMETRY_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D6) then Result := 'MAX_FRAGMENT_ATOMIC_COUNTERS' else
      if self.val = UInt32($92D7) then Result := 'MAX_COMBINED_ATOMIC_COUNTERS' else
      if self.val = UInt32($9315) then Result := 'MAX_FRAMEBUFFER_WIDTH' else
      if self.val = UInt32($9316) then Result := 'MAX_FRAMEBUFFER_HEIGHT' else
      if self.val = UInt32($9317) then Result := 'MAX_FRAMEBUFFER_LAYERS' else
      if self.val = UInt32($9318) then Result := 'MAX_FRAMEBUFFER_SAMPLES' else
      if self.val = UInt32($9596) then Result := 'NUM_DEVICE_UUIDS_EXT' else
      if self.val = UInt32($9597) then Result := 'DEVICE_UUID_EXT' else
      if self.val = UInt32($9598) then Result := 'DRIVER_UUID_EXT' else
      if self.val = UInt32($9599) then Result := 'DEVICE_LUID_EXT' else
      if self.val = UInt32($959A) then Result := 'DEVICE_NODE_MASK_EXT' else
      if self.val = UInt32($96A4) then Result := 'SHADING_RATE_QCOM' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetPointervPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FEEDBACK_BUFFER_POINTER         := new GetPointervPName($0DF0);
    private static _SELECTION_BUFFER_POINTER        := new GetPointervPName($0DF3);
    private static _VERTEX_ARRAY_POINTER            := new GetPointervPName($808E);
    private static _VERTEX_ARRAY_POINTER_EXT        := new GetPointervPName($808E);
    private static _NORMAL_ARRAY_POINTER            := new GetPointervPName($808F);
    private static _NORMAL_ARRAY_POINTER_EXT        := new GetPointervPName($808F);
    private static _COLOR_ARRAY_POINTER             := new GetPointervPName($8090);
    private static _COLOR_ARRAY_POINTER_EXT         := new GetPointervPName($8090);
    private static _INDEX_ARRAY_POINTER             := new GetPointervPName($8091);
    private static _INDEX_ARRAY_POINTER_EXT         := new GetPointervPName($8091);
    private static _TEXTURE_COORD_ARRAY_POINTER     := new GetPointervPName($8092);
    private static _TEXTURE_COORD_ARRAY_POINTER_EXT := new GetPointervPName($8092);
    private static _EDGE_FLAG_ARRAY_POINTER         := new GetPointervPName($8093);
    private static _EDGE_FLAG_ARRAY_POINTER_EXT     := new GetPointervPName($8093);
    private static _INSTRUMENT_BUFFER_POINTER_SGIX  := new GetPointervPName($8180);
    private static _DEBUG_CALLBACK_FUNCTION         := new GetPointervPName($8244);
    private static _DEBUG_CALLBACK_USER_PARAM       := new GetPointervPName($8245);
    
    public static property FEEDBACK_BUFFER_POINTER:         GetPointervPName read _FEEDBACK_BUFFER_POINTER;
    public static property SELECTION_BUFFER_POINTER:        GetPointervPName read _SELECTION_BUFFER_POINTER;
    public static property VERTEX_ARRAY_POINTER:            GetPointervPName read _VERTEX_ARRAY_POINTER;
    public static property VERTEX_ARRAY_POINTER_EXT:        GetPointervPName read _VERTEX_ARRAY_POINTER_EXT;
    public static property NORMAL_ARRAY_POINTER:            GetPointervPName read _NORMAL_ARRAY_POINTER;
    public static property NORMAL_ARRAY_POINTER_EXT:        GetPointervPName read _NORMAL_ARRAY_POINTER_EXT;
    public static property COLOR_ARRAY_POINTER:             GetPointervPName read _COLOR_ARRAY_POINTER;
    public static property COLOR_ARRAY_POINTER_EXT:         GetPointervPName read _COLOR_ARRAY_POINTER_EXT;
    public static property INDEX_ARRAY_POINTER:             GetPointervPName read _INDEX_ARRAY_POINTER;
    public static property INDEX_ARRAY_POINTER_EXT:         GetPointervPName read _INDEX_ARRAY_POINTER_EXT;
    public static property TEXTURE_COORD_ARRAY_POINTER:     GetPointervPName read _TEXTURE_COORD_ARRAY_POINTER;
    public static property TEXTURE_COORD_ARRAY_POINTER_EXT: GetPointervPName read _TEXTURE_COORD_ARRAY_POINTER_EXT;
    public static property EDGE_FLAG_ARRAY_POINTER:         GetPointervPName read _EDGE_FLAG_ARRAY_POINTER;
    public static property EDGE_FLAG_ARRAY_POINTER_EXT:     GetPointervPName read _EDGE_FLAG_ARRAY_POINTER_EXT;
    public static property INSTRUMENT_BUFFER_POINTER_SGIX:  GetPointervPName read _INSTRUMENT_BUFFER_POINTER_SGIX;
    public static property DEBUG_CALLBACK_FUNCTION:         GetPointervPName read _DEBUG_CALLBACK_FUNCTION;
    public static property DEBUG_CALLBACK_USER_PARAM:       GetPointervPName read _DEBUG_CALLBACK_USER_PARAM;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0DF0) then Result := 'FEEDBACK_BUFFER_POINTER' else
      if self.val = UInt32($0DF3) then Result := 'SELECTION_BUFFER_POINTER' else
      if self.val = UInt32($808E) then Result := 'VERTEX_ARRAY_POINTER' else
      if self.val = UInt32($808E) then Result := 'VERTEX_ARRAY_POINTER_EXT' else
      if self.val = UInt32($808F) then Result := 'NORMAL_ARRAY_POINTER' else
      if self.val = UInt32($808F) then Result := 'NORMAL_ARRAY_POINTER_EXT' else
      if self.val = UInt32($8090) then Result := 'COLOR_ARRAY_POINTER' else
      if self.val = UInt32($8090) then Result := 'COLOR_ARRAY_POINTER_EXT' else
      if self.val = UInt32($8091) then Result := 'INDEX_ARRAY_POINTER' else
      if self.val = UInt32($8091) then Result := 'INDEX_ARRAY_POINTER_EXT' else
      if self.val = UInt32($8092) then Result := 'TEXTURE_COORD_ARRAY_POINTER' else
      if self.val = UInt32($8092) then Result := 'TEXTURE_COORD_ARRAY_POINTER_EXT' else
      if self.val = UInt32($8093) then Result := 'EDGE_FLAG_ARRAY_POINTER' else
      if self.val = UInt32($8093) then Result := 'EDGE_FLAG_ARRAY_POINTER_EXT' else
      if self.val = UInt32($8180) then Result := 'INSTRUMENT_BUFFER_POINTER_SGIX' else
      if self.val = UInt32($8244) then Result := 'DEBUG_CALLBACK_FUNCTION' else
      if self.val = UInt32($8245) then Result := 'DEBUG_CALLBACK_USER_PARAM' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetTextureParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_WIDTH                        := new GetTextureParameter($1000);
    private static _TEXTURE_HEIGHT                       := new GetTextureParameter($1001);
    private static _TEXTURE_COMPONENTS                   := new GetTextureParameter($1003);
    private static _TEXTURE_INTERNAL_FORMAT              := new GetTextureParameter($1003);
    private static _TEXTURE_BORDER_COLOR                 := new GetTextureParameter($1004);
    private static _TEXTURE_BORDER_COLOR_NV              := new GetTextureParameter($1004);
    private static _TEXTURE_BORDER                       := new GetTextureParameter($1005);
    private static _TEXTURE_MAG_FILTER                   := new GetTextureParameter($2800);
    private static _TEXTURE_MIN_FILTER                   := new GetTextureParameter($2801);
    private static _TEXTURE_WRAP_S                       := new GetTextureParameter($2802);
    private static _TEXTURE_WRAP_T                       := new GetTextureParameter($2803);
    private static _TEXTURE_RED_SIZE                     := new GetTextureParameter($805C);
    private static _TEXTURE_GREEN_SIZE                   := new GetTextureParameter($805D);
    private static _TEXTURE_BLUE_SIZE                    := new GetTextureParameter($805E);
    private static _TEXTURE_ALPHA_SIZE                   := new GetTextureParameter($805F);
    private static _TEXTURE_LUMINANCE_SIZE               := new GetTextureParameter($8060);
    private static _TEXTURE_INTENSITY_SIZE               := new GetTextureParameter($8061);
    private static _TEXTURE_PRIORITY                     := new GetTextureParameter($8066);
    private static _TEXTURE_RESIDENT                     := new GetTextureParameter($8067);
    private static _TEXTURE_DEPTH_EXT                    := new GetTextureParameter($8071);
    private static _TEXTURE_WRAP_R_EXT                   := new GetTextureParameter($8072);
    private static _DETAIL_TEXTURE_LEVEL_SGIS            := new GetTextureParameter($809A);
    private static _DETAIL_TEXTURE_MODE_SGIS             := new GetTextureParameter($809B);
    private static _DETAIL_TEXTURE_FUNC_POINTS_SGIS      := new GetTextureParameter($809C);
    private static _SHARPEN_TEXTURE_FUNC_POINTS_SGIS     := new GetTextureParameter($80B0);
    private static _SHADOW_AMBIENT_SGIX                  := new GetTextureParameter($80BF);
    private static _DUAL_TEXTURE_SELECT_SGIS             := new GetTextureParameter($8124);
    private static _QUAD_TEXTURE_SELECT_SGIS             := new GetTextureParameter($8125);
    private static _TEXTURE_4DSIZE_SGIS                  := new GetTextureParameter($8136);
    private static _TEXTURE_WRAP_Q_SGIS                  := new GetTextureParameter($8137);
    private static _TEXTURE_MIN_LOD_SGIS                 := new GetTextureParameter($813A);
    private static _TEXTURE_MAX_LOD_SGIS                 := new GetTextureParameter($813B);
    private static _TEXTURE_BASE_LEVEL_SGIS              := new GetTextureParameter($813C);
    private static _TEXTURE_MAX_LEVEL_SGIS               := new GetTextureParameter($813D);
    private static _TEXTURE_FILTER4_SIZE_SGIS            := new GetTextureParameter($8147);
    private static _TEXTURE_CLIPMAP_CENTER_SGIX          := new GetTextureParameter($8171);
    private static _TEXTURE_CLIPMAP_FRAME_SGIX           := new GetTextureParameter($8172);
    private static _TEXTURE_CLIPMAP_OFFSET_SGIX          := new GetTextureParameter($8173);
    private static _TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX   := new GetTextureParameter($8174);
    private static _TEXTURE_CLIPMAP_LOD_OFFSET_SGIX      := new GetTextureParameter($8175);
    private static _TEXTURE_CLIPMAP_DEPTH_SGIX           := new GetTextureParameter($8176);
    private static _POST_TEXTURE_FILTER_BIAS_SGIX        := new GetTextureParameter($8179);
    private static _POST_TEXTURE_FILTER_SCALE_SGIX       := new GetTextureParameter($817A);
    private static _TEXTURE_LOD_BIAS_S_SGIX              := new GetTextureParameter($818E);
    private static _TEXTURE_LOD_BIAS_T_SGIX              := new GetTextureParameter($818F);
    private static _TEXTURE_LOD_BIAS_R_SGIX              := new GetTextureParameter($8190);
    private static _GENERATE_MIPMAP_SGIS                 := new GetTextureParameter($8191);
    private static _TEXTURE_COMPARE_SGIX                 := new GetTextureParameter($819A);
    private static _TEXTURE_COMPARE_OPERATOR_SGIX        := new GetTextureParameter($819B);
    private static _TEXTURE_LEQUAL_R_SGIX                := new GetTextureParameter($819C);
    private static _TEXTURE_GEQUAL_R_SGIX                := new GetTextureParameter($819D);
    private static _TEXTURE_MAX_CLAMP_S_SGIX             := new GetTextureParameter($8369);
    private static _TEXTURE_MAX_CLAMP_T_SGIX             := new GetTextureParameter($836A);
    private static _TEXTURE_MAX_CLAMP_R_SGIX             := new GetTextureParameter($836B);
    private static _TEXTURE_UNNORMALIZED_COORDINATES_ARM := new GetTextureParameter($8F6A);
    
    public static property TEXTURE_WIDTH:                        GetTextureParameter read _TEXTURE_WIDTH;
    public static property TEXTURE_HEIGHT:                       GetTextureParameter read _TEXTURE_HEIGHT;
    public static property TEXTURE_COMPONENTS:                   GetTextureParameter read _TEXTURE_COMPONENTS;
    public static property TEXTURE_INTERNAL_FORMAT:              GetTextureParameter read _TEXTURE_INTERNAL_FORMAT;
    public static property TEXTURE_BORDER_COLOR:                 GetTextureParameter read _TEXTURE_BORDER_COLOR;
    public static property TEXTURE_BORDER_COLOR_NV:              GetTextureParameter read _TEXTURE_BORDER_COLOR_NV;
    public static property TEXTURE_BORDER:                       GetTextureParameter read _TEXTURE_BORDER;
    public static property TEXTURE_MAG_FILTER:                   GetTextureParameter read _TEXTURE_MAG_FILTER;
    public static property TEXTURE_MIN_FILTER:                   GetTextureParameter read _TEXTURE_MIN_FILTER;
    public static property TEXTURE_WRAP_S:                       GetTextureParameter read _TEXTURE_WRAP_S;
    public static property TEXTURE_WRAP_T:                       GetTextureParameter read _TEXTURE_WRAP_T;
    public static property TEXTURE_RED_SIZE:                     GetTextureParameter read _TEXTURE_RED_SIZE;
    public static property TEXTURE_GREEN_SIZE:                   GetTextureParameter read _TEXTURE_GREEN_SIZE;
    public static property TEXTURE_BLUE_SIZE:                    GetTextureParameter read _TEXTURE_BLUE_SIZE;
    public static property TEXTURE_ALPHA_SIZE:                   GetTextureParameter read _TEXTURE_ALPHA_SIZE;
    public static property TEXTURE_LUMINANCE_SIZE:               GetTextureParameter read _TEXTURE_LUMINANCE_SIZE;
    public static property TEXTURE_INTENSITY_SIZE:               GetTextureParameter read _TEXTURE_INTENSITY_SIZE;
    public static property TEXTURE_PRIORITY:                     GetTextureParameter read _TEXTURE_PRIORITY;
    public static property TEXTURE_RESIDENT:                     GetTextureParameter read _TEXTURE_RESIDENT;
    public static property TEXTURE_DEPTH_EXT:                    GetTextureParameter read _TEXTURE_DEPTH_EXT;
    public static property TEXTURE_WRAP_R_EXT:                   GetTextureParameter read _TEXTURE_WRAP_R_EXT;
    public static property DETAIL_TEXTURE_LEVEL_SGIS:            GetTextureParameter read _DETAIL_TEXTURE_LEVEL_SGIS;
    public static property DETAIL_TEXTURE_MODE_SGIS:             GetTextureParameter read _DETAIL_TEXTURE_MODE_SGIS;
    public static property DETAIL_TEXTURE_FUNC_POINTS_SGIS:      GetTextureParameter read _DETAIL_TEXTURE_FUNC_POINTS_SGIS;
    public static property SHARPEN_TEXTURE_FUNC_POINTS_SGIS:     GetTextureParameter read _SHARPEN_TEXTURE_FUNC_POINTS_SGIS;
    public static property SHADOW_AMBIENT_SGIX:                  GetTextureParameter read _SHADOW_AMBIENT_SGIX;
    public static property DUAL_TEXTURE_SELECT_SGIS:             GetTextureParameter read _DUAL_TEXTURE_SELECT_SGIS;
    public static property QUAD_TEXTURE_SELECT_SGIS:             GetTextureParameter read _QUAD_TEXTURE_SELECT_SGIS;
    public static property TEXTURE_4DSIZE_SGIS:                  GetTextureParameter read _TEXTURE_4DSIZE_SGIS;
    public static property TEXTURE_WRAP_Q_SGIS:                  GetTextureParameter read _TEXTURE_WRAP_Q_SGIS;
    public static property TEXTURE_MIN_LOD_SGIS:                 GetTextureParameter read _TEXTURE_MIN_LOD_SGIS;
    public static property TEXTURE_MAX_LOD_SGIS:                 GetTextureParameter read _TEXTURE_MAX_LOD_SGIS;
    public static property TEXTURE_BASE_LEVEL_SGIS:              GetTextureParameter read _TEXTURE_BASE_LEVEL_SGIS;
    public static property TEXTURE_MAX_LEVEL_SGIS:               GetTextureParameter read _TEXTURE_MAX_LEVEL_SGIS;
    public static property TEXTURE_FILTER4_SIZE_SGIS:            GetTextureParameter read _TEXTURE_FILTER4_SIZE_SGIS;
    public static property TEXTURE_CLIPMAP_CENTER_SGIX:          GetTextureParameter read _TEXTURE_CLIPMAP_CENTER_SGIX;
    public static property TEXTURE_CLIPMAP_FRAME_SGIX:           GetTextureParameter read _TEXTURE_CLIPMAP_FRAME_SGIX;
    public static property TEXTURE_CLIPMAP_OFFSET_SGIX:          GetTextureParameter read _TEXTURE_CLIPMAP_OFFSET_SGIX;
    public static property TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX:   GetTextureParameter read _TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX;
    public static property TEXTURE_CLIPMAP_LOD_OFFSET_SGIX:      GetTextureParameter read _TEXTURE_CLIPMAP_LOD_OFFSET_SGIX;
    public static property TEXTURE_CLIPMAP_DEPTH_SGIX:           GetTextureParameter read _TEXTURE_CLIPMAP_DEPTH_SGIX;
    public static property POST_TEXTURE_FILTER_BIAS_SGIX:        GetTextureParameter read _POST_TEXTURE_FILTER_BIAS_SGIX;
    public static property POST_TEXTURE_FILTER_SCALE_SGIX:       GetTextureParameter read _POST_TEXTURE_FILTER_SCALE_SGIX;
    public static property TEXTURE_LOD_BIAS_S_SGIX:              GetTextureParameter read _TEXTURE_LOD_BIAS_S_SGIX;
    public static property TEXTURE_LOD_BIAS_T_SGIX:              GetTextureParameter read _TEXTURE_LOD_BIAS_T_SGIX;
    public static property TEXTURE_LOD_BIAS_R_SGIX:              GetTextureParameter read _TEXTURE_LOD_BIAS_R_SGIX;
    public static property GENERATE_MIPMAP_SGIS:                 GetTextureParameter read _GENERATE_MIPMAP_SGIS;
    public static property TEXTURE_COMPARE_SGIX:                 GetTextureParameter read _TEXTURE_COMPARE_SGIX;
    public static property TEXTURE_COMPARE_OPERATOR_SGIX:        GetTextureParameter read _TEXTURE_COMPARE_OPERATOR_SGIX;
    public static property TEXTURE_LEQUAL_R_SGIX:                GetTextureParameter read _TEXTURE_LEQUAL_R_SGIX;
    public static property TEXTURE_GEQUAL_R_SGIX:                GetTextureParameter read _TEXTURE_GEQUAL_R_SGIX;
    public static property TEXTURE_MAX_CLAMP_S_SGIX:             GetTextureParameter read _TEXTURE_MAX_CLAMP_S_SGIX;
    public static property TEXTURE_MAX_CLAMP_T_SGIX:             GetTextureParameter read _TEXTURE_MAX_CLAMP_T_SGIX;
    public static property TEXTURE_MAX_CLAMP_R_SGIX:             GetTextureParameter read _TEXTURE_MAX_CLAMP_R_SGIX;
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: GetTextureParameter read _TEXTURE_UNNORMALIZED_COORDINATES_ARM;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1000) then Result := 'TEXTURE_WIDTH' else
      if self.val = UInt32($1001) then Result := 'TEXTURE_HEIGHT' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_COMPONENTS' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_INTERNAL_FORMAT' else
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR' else
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR_NV' else
      if self.val = UInt32($1005) then Result := 'TEXTURE_BORDER' else
      if self.val = UInt32($2800) then Result := 'TEXTURE_MAG_FILTER' else
      if self.val = UInt32($2801) then Result := 'TEXTURE_MIN_FILTER' else
      if self.val = UInt32($2802) then Result := 'TEXTURE_WRAP_S' else
      if self.val = UInt32($2803) then Result := 'TEXTURE_WRAP_T' else
      if self.val = UInt32($805C) then Result := 'TEXTURE_RED_SIZE' else
      if self.val = UInt32($805D) then Result := 'TEXTURE_GREEN_SIZE' else
      if self.val = UInt32($805E) then Result := 'TEXTURE_BLUE_SIZE' else
      if self.val = UInt32($805F) then Result := 'TEXTURE_ALPHA_SIZE' else
      if self.val = UInt32($8060) then Result := 'TEXTURE_LUMINANCE_SIZE' else
      if self.val = UInt32($8061) then Result := 'TEXTURE_INTENSITY_SIZE' else
      if self.val = UInt32($8066) then Result := 'TEXTURE_PRIORITY' else
      if self.val = UInt32($8067) then Result := 'TEXTURE_RESIDENT' else
      if self.val = UInt32($8071) then Result := 'TEXTURE_DEPTH_EXT' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R_EXT' else
      if self.val = UInt32($809A) then Result := 'DETAIL_TEXTURE_LEVEL_SGIS' else
      if self.val = UInt32($809B) then Result := 'DETAIL_TEXTURE_MODE_SGIS' else
      if self.val = UInt32($809C) then Result := 'DETAIL_TEXTURE_FUNC_POINTS_SGIS' else
      if self.val = UInt32($80B0) then Result := 'SHARPEN_TEXTURE_FUNC_POINTS_SGIS' else
      if self.val = UInt32($80BF) then Result := 'SHADOW_AMBIENT_SGIX' else
      if self.val = UInt32($8124) then Result := 'DUAL_TEXTURE_SELECT_SGIS' else
      if self.val = UInt32($8125) then Result := 'QUAD_TEXTURE_SELECT_SGIS' else
      if self.val = UInt32($8136) then Result := 'TEXTURE_4DSIZE_SGIS' else
      if self.val = UInt32($8137) then Result := 'TEXTURE_WRAP_Q_SGIS' else
      if self.val = UInt32($813A) then Result := 'TEXTURE_MIN_LOD_SGIS' else
      if self.val = UInt32($813B) then Result := 'TEXTURE_MAX_LOD_SGIS' else
      if self.val = UInt32($813C) then Result := 'TEXTURE_BASE_LEVEL_SGIS' else
      if self.val = UInt32($813D) then Result := 'TEXTURE_MAX_LEVEL_SGIS' else
      if self.val = UInt32($8147) then Result := 'TEXTURE_FILTER4_SIZE_SGIS' else
      if self.val = UInt32($8171) then Result := 'TEXTURE_CLIPMAP_CENTER_SGIX' else
      if self.val = UInt32($8172) then Result := 'TEXTURE_CLIPMAP_FRAME_SGIX' else
      if self.val = UInt32($8173) then Result := 'TEXTURE_CLIPMAP_OFFSET_SGIX' else
      if self.val = UInt32($8174) then Result := 'TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX' else
      if self.val = UInt32($8175) then Result := 'TEXTURE_CLIPMAP_LOD_OFFSET_SGIX' else
      if self.val = UInt32($8176) then Result := 'TEXTURE_CLIPMAP_DEPTH_SGIX' else
      if self.val = UInt32($8179) then Result := 'POST_TEXTURE_FILTER_BIAS_SGIX' else
      if self.val = UInt32($817A) then Result := 'POST_TEXTURE_FILTER_SCALE_SGIX' else
      if self.val = UInt32($818E) then Result := 'TEXTURE_LOD_BIAS_S_SGIX' else
      if self.val = UInt32($818F) then Result := 'TEXTURE_LOD_BIAS_T_SGIX' else
      if self.val = UInt32($8190) then Result := 'TEXTURE_LOD_BIAS_R_SGIX' else
      if self.val = UInt32($8191) then Result := 'GENERATE_MIPMAP_SGIS' else
      if self.val = UInt32($819A) then Result := 'TEXTURE_COMPARE_SGIX' else
      if self.val = UInt32($819B) then Result := 'TEXTURE_COMPARE_OPERATOR_SGIX' else
      if self.val = UInt32($819C) then Result := 'TEXTURE_LEQUAL_R_SGIX' else
      if self.val = UInt32($819D) then Result := 'TEXTURE_GEQUAL_R_SGIX' else
      if self.val = UInt32($8369) then Result := 'TEXTURE_MAX_CLAMP_S_SGIX' else
      if self.val = UInt32($836A) then Result := 'TEXTURE_MAX_CLAMP_T_SGIX' else
      if self.val = UInt32($836B) then Result := 'TEXTURE_MAX_CLAMP_R_SGIX' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GraphicsResetStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NO_ERROR               := new GraphicsResetStatus($0000);
    private static _GUILTY_CONTEXT_RESET   := new GraphicsResetStatus($8253);
    private static _INNOCENT_CONTEXT_RESET := new GraphicsResetStatus($8254);
    private static _UNKNOWN_CONTEXT_RESET  := new GraphicsResetStatus($8255);
    
    public static property NO_ERROR:               GraphicsResetStatus read _NO_ERROR;
    public static property GUILTY_CONTEXT_RESET:   GraphicsResetStatus read _GUILTY_CONTEXT_RESET;
    public static property INNOCENT_CONTEXT_RESET: GraphicsResetStatus read _INNOCENT_CONTEXT_RESET;
    public static property UNKNOWN_CONTEXT_RESET:  GraphicsResetStatus read _UNKNOWN_CONTEXT_RESET;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NO_ERROR' else
      if self.val = UInt32($8253) then Result := 'GUILTY_CONTEXT_RESET' else
      if self.val = UInt32($8254) then Result := 'INNOCENT_CONTEXT_RESET' else
      if self.val = UInt32($8255) then Result := 'UNKNOWN_CONTEXT_RESET' else
        Result := self.val.ToString;
    end;
    
  end;
  
  HintMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DONT_CARE := new HintMode($1100);
    private static _FASTEST   := new HintMode($1101);
    private static _NICEST    := new HintMode($1102);
    
    public static property DONT_CARE: HintMode read _DONT_CARE;
    public static property FASTEST:   HintMode read _FASTEST;
    public static property NICEST:    HintMode read _NICEST;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1100) then Result := 'DONT_CARE' else
      if self.val = UInt32($1101) then Result := 'FASTEST' else
      if self.val = UInt32($1102) then Result := 'NICEST' else
        Result := self.val.ToString;
    end;
    
  end;
  
  HintTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PERSPECTIVE_CORRECTION_HINT         := new HintTarget($0C50);
    private static _POINT_SMOOTH_HINT                   := new HintTarget($0C51);
    private static _LINE_SMOOTH_HINT                    := new HintTarget($0C52);
    private static _POLYGON_SMOOTH_HINT                 := new HintTarget($0C53);
    private static _FOG_HINT                            := new HintTarget($0C54);
    private static _PACK_CMYK_HINT_EXT                  := new HintTarget($800E);
    private static _UNPACK_CMYK_HINT_EXT                := new HintTarget($800F);
    private static _PHONG_HINT_WIN                      := new HintTarget($80EB);
    private static _CLIP_VOLUME_CLIPPING_HINT_EXT       := new HintTarget($80F0);
    private static _TEXTURE_MULTI_BUFFER_HINT_SGIX      := new HintTarget($812E);
    private static _GENERATE_MIPMAP_HINT                := new HintTarget($8192);
    private static _GENERATE_MIPMAP_HINT_SGIS           := new HintTarget($8192);
    private static _PROGRAM_BINARY_RETRIEVABLE_HINT     := new HintTarget($8257);
    private static _CONVOLUTION_HINT_SGIX               := new HintTarget($8316);
    private static _SCALEBIAS_HINT_SGIX                 := new HintTarget($8322);
    private static _LINE_QUALITY_HINT_SGIX              := new HintTarget($835B);
    private static _VERTEX_PRECLIP_SGIX                 := new HintTarget($83EE);
    private static _VERTEX_PRECLIP_HINT_SGIX            := new HintTarget($83EF);
    private static _TEXTURE_COMPRESSION_HINT            := new HintTarget($84EF);
    private static _TEXTURE_COMPRESSION_HINT_ARB        := new HintTarget($84EF);
    private static _VERTEX_ARRAY_STORAGE_HINT_APPLE     := new HintTarget($851F);
    private static _MULTISAMPLE_FILTER_HINT_NV          := new HintTarget($8534);
    private static _TRANSFORM_HINT_APPLE                := new HintTarget($85B1);
    private static _TEXTURE_STORAGE_HINT_APPLE          := new HintTarget($85BC);
    private static _FRAGMENT_SHADER_DERIVATIVE_HINT     := new HintTarget($8B8B);
    private static _FRAGMENT_SHADER_DERIVATIVE_HINT_ARB := new HintTarget($8B8B);
    private static _FRAGMENT_SHADER_DERIVATIVE_HINT_OES := new HintTarget($8B8B);
    private static _BINNING_CONTROL_HINT_QCOM           := new HintTarget($8FB0);
    private static _PREFER_DOUBLEBUFFER_HINT_PGI        := new HintTarget($1A1F8);
    private static _CONSERVE_MEMORY_HINT_PGI            := new HintTarget($1A1FD);
    private static _RECLAIM_MEMORY_HINT_PGI             := new HintTarget($1A1FE);
    private static _NATIVE_GRAPHICS_BEGIN_HINT_PGI      := new HintTarget($1A203);
    private static _NATIVE_GRAPHICS_END_HINT_PGI        := new HintTarget($1A204);
    private static _ALWAYS_FAST_HINT_PGI                := new HintTarget($1A20C);
    private static _ALWAYS_SOFT_HINT_PGI                := new HintTarget($1A20D);
    private static _ALLOW_DRAW_OBJ_HINT_PGI             := new HintTarget($1A20E);
    private static _ALLOW_DRAW_WIN_HINT_PGI             := new HintTarget($1A20F);
    private static _ALLOW_DRAW_FRG_HINT_PGI             := new HintTarget($1A210);
    private static _ALLOW_DRAW_MEM_HINT_PGI             := new HintTarget($1A211);
    private static _STRICT_DEPTHFUNC_HINT_PGI           := new HintTarget($1A216);
    private static _STRICT_LIGHTING_HINT_PGI            := new HintTarget($1A217);
    private static _STRICT_SCISSOR_HINT_PGI             := new HintTarget($1A218);
    private static _FULL_STIPPLE_HINT_PGI               := new HintTarget($1A219);
    private static _CLIP_NEAR_HINT_PGI                  := new HintTarget($1A220);
    private static _CLIP_FAR_HINT_PGI                   := new HintTarget($1A221);
    private static _WIDE_LINE_HINT_PGI                  := new HintTarget($1A222);
    private static _BACK_NORMALS_HINT_PGI               := new HintTarget($1A223);
    private static _VERTEX_DATA_HINT_PGI                := new HintTarget($1A22A);
    private static _VERTEX_CONSISTENT_HINT_PGI          := new HintTarget($1A22B);
    private static _MATERIAL_SIDE_HINT_PGI              := new HintTarget($1A22C);
    private static _MAX_VERTEX_HINT_PGI                 := new HintTarget($1A22D);
    
    public static property PERSPECTIVE_CORRECTION_HINT:         HintTarget read _PERSPECTIVE_CORRECTION_HINT;
    public static property POINT_SMOOTH_HINT:                   HintTarget read _POINT_SMOOTH_HINT;
    public static property LINE_SMOOTH_HINT:                    HintTarget read _LINE_SMOOTH_HINT;
    public static property POLYGON_SMOOTH_HINT:                 HintTarget read _POLYGON_SMOOTH_HINT;
    public static property FOG_HINT:                            HintTarget read _FOG_HINT;
    public static property PACK_CMYK_HINT_EXT:                  HintTarget read _PACK_CMYK_HINT_EXT;
    public static property UNPACK_CMYK_HINT_EXT:                HintTarget read _UNPACK_CMYK_HINT_EXT;
    public static property PHONG_HINT_WIN:                      HintTarget read _PHONG_HINT_WIN;
    public static property CLIP_VOLUME_CLIPPING_HINT_EXT:       HintTarget read _CLIP_VOLUME_CLIPPING_HINT_EXT;
    public static property TEXTURE_MULTI_BUFFER_HINT_SGIX:      HintTarget read _TEXTURE_MULTI_BUFFER_HINT_SGIX;
    public static property GENERATE_MIPMAP_HINT:                HintTarget read _GENERATE_MIPMAP_HINT;
    public static property GENERATE_MIPMAP_HINT_SGIS:           HintTarget read _GENERATE_MIPMAP_HINT_SGIS;
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT:     HintTarget read _PROGRAM_BINARY_RETRIEVABLE_HINT;
    public static property CONVOLUTION_HINT_SGIX:               HintTarget read _CONVOLUTION_HINT_SGIX;
    public static property SCALEBIAS_HINT_SGIX:                 HintTarget read _SCALEBIAS_HINT_SGIX;
    public static property LINE_QUALITY_HINT_SGIX:              HintTarget read _LINE_QUALITY_HINT_SGIX;
    public static property VERTEX_PRECLIP_SGIX:                 HintTarget read _VERTEX_PRECLIP_SGIX;
    public static property VERTEX_PRECLIP_HINT_SGIX:            HintTarget read _VERTEX_PRECLIP_HINT_SGIX;
    public static property TEXTURE_COMPRESSION_HINT:            HintTarget read _TEXTURE_COMPRESSION_HINT;
    public static property TEXTURE_COMPRESSION_HINT_ARB:        HintTarget read _TEXTURE_COMPRESSION_HINT_ARB;
    public static property VERTEX_ARRAY_STORAGE_HINT_APPLE:     HintTarget read _VERTEX_ARRAY_STORAGE_HINT_APPLE;
    public static property MULTISAMPLE_FILTER_HINT_NV:          HintTarget read _MULTISAMPLE_FILTER_HINT_NV;
    public static property TRANSFORM_HINT_APPLE:                HintTarget read _TRANSFORM_HINT_APPLE;
    public static property TEXTURE_STORAGE_HINT_APPLE:          HintTarget read _TEXTURE_STORAGE_HINT_APPLE;
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT:     HintTarget read _FRAGMENT_SHADER_DERIVATIVE_HINT;
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT_ARB: HintTarget read _FRAGMENT_SHADER_DERIVATIVE_HINT_ARB;
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT_OES: HintTarget read _FRAGMENT_SHADER_DERIVATIVE_HINT_OES;
    public static property BINNING_CONTROL_HINT_QCOM:           HintTarget read _BINNING_CONTROL_HINT_QCOM;
    public static property PREFER_DOUBLEBUFFER_HINT_PGI:        HintTarget read _PREFER_DOUBLEBUFFER_HINT_PGI;
    public static property CONSERVE_MEMORY_HINT_PGI:            HintTarget read _CONSERVE_MEMORY_HINT_PGI;
    public static property RECLAIM_MEMORY_HINT_PGI:             HintTarget read _RECLAIM_MEMORY_HINT_PGI;
    public static property NATIVE_GRAPHICS_BEGIN_HINT_PGI:      HintTarget read _NATIVE_GRAPHICS_BEGIN_HINT_PGI;
    public static property NATIVE_GRAPHICS_END_HINT_PGI:        HintTarget read _NATIVE_GRAPHICS_END_HINT_PGI;
    public static property ALWAYS_FAST_HINT_PGI:                HintTarget read _ALWAYS_FAST_HINT_PGI;
    public static property ALWAYS_SOFT_HINT_PGI:                HintTarget read _ALWAYS_SOFT_HINT_PGI;
    public static property ALLOW_DRAW_OBJ_HINT_PGI:             HintTarget read _ALLOW_DRAW_OBJ_HINT_PGI;
    public static property ALLOW_DRAW_WIN_HINT_PGI:             HintTarget read _ALLOW_DRAW_WIN_HINT_PGI;
    public static property ALLOW_DRAW_FRG_HINT_PGI:             HintTarget read _ALLOW_DRAW_FRG_HINT_PGI;
    public static property ALLOW_DRAW_MEM_HINT_PGI:             HintTarget read _ALLOW_DRAW_MEM_HINT_PGI;
    public static property STRICT_DEPTHFUNC_HINT_PGI:           HintTarget read _STRICT_DEPTHFUNC_HINT_PGI;
    public static property STRICT_LIGHTING_HINT_PGI:            HintTarget read _STRICT_LIGHTING_HINT_PGI;
    public static property STRICT_SCISSOR_HINT_PGI:             HintTarget read _STRICT_SCISSOR_HINT_PGI;
    public static property FULL_STIPPLE_HINT_PGI:               HintTarget read _FULL_STIPPLE_HINT_PGI;
    public static property CLIP_NEAR_HINT_PGI:                  HintTarget read _CLIP_NEAR_HINT_PGI;
    public static property CLIP_FAR_HINT_PGI:                   HintTarget read _CLIP_FAR_HINT_PGI;
    public static property WIDE_LINE_HINT_PGI:                  HintTarget read _WIDE_LINE_HINT_PGI;
    public static property BACK_NORMALS_HINT_PGI:               HintTarget read _BACK_NORMALS_HINT_PGI;
    public static property VERTEX_DATA_HINT_PGI:                HintTarget read _VERTEX_DATA_HINT_PGI;
    public static property VERTEX_CONSISTENT_HINT_PGI:          HintTarget read _VERTEX_CONSISTENT_HINT_PGI;
    public static property MATERIAL_SIDE_HINT_PGI:              HintTarget read _MATERIAL_SIDE_HINT_PGI;
    public static property MAX_VERTEX_HINT_PGI:                 HintTarget read _MAX_VERTEX_HINT_PGI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0C50) then Result := 'PERSPECTIVE_CORRECTION_HINT' else
      if self.val = UInt32($0C51) then Result := 'POINT_SMOOTH_HINT' else
      if self.val = UInt32($0C52) then Result := 'LINE_SMOOTH_HINT' else
      if self.val = UInt32($0C53) then Result := 'POLYGON_SMOOTH_HINT' else
      if self.val = UInt32($0C54) then Result := 'FOG_HINT' else
      if self.val = UInt32($800E) then Result := 'PACK_CMYK_HINT_EXT' else
      if self.val = UInt32($800F) then Result := 'UNPACK_CMYK_HINT_EXT' else
      if self.val = UInt32($80EB) then Result := 'PHONG_HINT_WIN' else
      if self.val = UInt32($80F0) then Result := 'CLIP_VOLUME_CLIPPING_HINT_EXT' else
      if self.val = UInt32($812E) then Result := 'TEXTURE_MULTI_BUFFER_HINT_SGIX' else
      if self.val = UInt32($8192) then Result := 'GENERATE_MIPMAP_HINT' else
      if self.val = UInt32($8192) then Result := 'GENERATE_MIPMAP_HINT_SGIS' else
      if self.val = UInt32($8257) then Result := 'PROGRAM_BINARY_RETRIEVABLE_HINT' else
      if self.val = UInt32($8316) then Result := 'CONVOLUTION_HINT_SGIX' else
      if self.val = UInt32($8322) then Result := 'SCALEBIAS_HINT_SGIX' else
      if self.val = UInt32($835B) then Result := 'LINE_QUALITY_HINT_SGIX' else
      if self.val = UInt32($83EE) then Result := 'VERTEX_PRECLIP_SGIX' else
      if self.val = UInt32($83EF) then Result := 'VERTEX_PRECLIP_HINT_SGIX' else
      if self.val = UInt32($84EF) then Result := 'TEXTURE_COMPRESSION_HINT' else
      if self.val = UInt32($84EF) then Result := 'TEXTURE_COMPRESSION_HINT_ARB' else
      if self.val = UInt32($851F) then Result := 'VERTEX_ARRAY_STORAGE_HINT_APPLE' else
      if self.val = UInt32($8534) then Result := 'MULTISAMPLE_FILTER_HINT_NV' else
      if self.val = UInt32($85B1) then Result := 'TRANSFORM_HINT_APPLE' else
      if self.val = UInt32($85BC) then Result := 'TEXTURE_STORAGE_HINT_APPLE' else
      if self.val = UInt32($8B8B) then Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT' else
      if self.val = UInt32($8B8B) then Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT_ARB' else
      if self.val = UInt32($8B8B) then Result := 'FRAGMENT_SHADER_DERIVATIVE_HINT_OES' else
      if self.val = UInt32($8FB0) then Result := 'BINNING_CONTROL_HINT_QCOM' else
      if self.val = UInt32($1A1F8) then Result := 'PREFER_DOUBLEBUFFER_HINT_PGI' else
      if self.val = UInt32($1A1FD) then Result := 'CONSERVE_MEMORY_HINT_PGI' else
      if self.val = UInt32($1A1FE) then Result := 'RECLAIM_MEMORY_HINT_PGI' else
      if self.val = UInt32($1A203) then Result := 'NATIVE_GRAPHICS_BEGIN_HINT_PGI' else
      if self.val = UInt32($1A204) then Result := 'NATIVE_GRAPHICS_END_HINT_PGI' else
      if self.val = UInt32($1A20C) then Result := 'ALWAYS_FAST_HINT_PGI' else
      if self.val = UInt32($1A20D) then Result := 'ALWAYS_SOFT_HINT_PGI' else
      if self.val = UInt32($1A20E) then Result := 'ALLOW_DRAW_OBJ_HINT_PGI' else
      if self.val = UInt32($1A20F) then Result := 'ALLOW_DRAW_WIN_HINT_PGI' else
      if self.val = UInt32($1A210) then Result := 'ALLOW_DRAW_FRG_HINT_PGI' else
      if self.val = UInt32($1A211) then Result := 'ALLOW_DRAW_MEM_HINT_PGI' else
      if self.val = UInt32($1A216) then Result := 'STRICT_DEPTHFUNC_HINT_PGI' else
      if self.val = UInt32($1A217) then Result := 'STRICT_LIGHTING_HINT_PGI' else
      if self.val = UInt32($1A218) then Result := 'STRICT_SCISSOR_HINT_PGI' else
      if self.val = UInt32($1A219) then Result := 'FULL_STIPPLE_HINT_PGI' else
      if self.val = UInt32($1A220) then Result := 'CLIP_NEAR_HINT_PGI' else
      if self.val = UInt32($1A221) then Result := 'CLIP_FAR_HINT_PGI' else
      if self.val = UInt32($1A222) then Result := 'WIDE_LINE_HINT_PGI' else
      if self.val = UInt32($1A223) then Result := 'BACK_NORMALS_HINT_PGI' else
      if self.val = UInt32($1A22A) then Result := 'VERTEX_DATA_HINT_PGI' else
      if self.val = UInt32($1A22B) then Result := 'VERTEX_CONSISTENT_HINT_PGI' else
      if self.val = UInt32($1A22C) then Result := 'MATERIAL_SIDE_HINT_PGI' else
      if self.val = UInt32($1A22D) then Result := 'MAX_VERTEX_HINT_PGI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  IndexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SHORT  := new IndexPointerType($1402);
    private static _INT    := new IndexPointerType($1404);
    private static _FLOAT  := new IndexPointerType($1406);
    private static _DOUBLE := new IndexPointerType($140A);
    
    public static property SHORT:  IndexPointerType read _SHORT;
    public static property INT:    IndexPointerType read _INT;
    public static property FLOAT:  IndexPointerType read _FLOAT;
    public static property DOUBLE: IndexPointerType read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  InterleavedArrayFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _V2F             := new InterleavedArrayFormat($2A20);
    private static _V3F             := new InterleavedArrayFormat($2A21);
    private static _C4UB_V2F        := new InterleavedArrayFormat($2A22);
    private static _C4UB_V3F        := new InterleavedArrayFormat($2A23);
    private static _C3F_V3F         := new InterleavedArrayFormat($2A24);
    private static _N3F_V3F         := new InterleavedArrayFormat($2A25);
    private static _C4F_N3F_V3F     := new InterleavedArrayFormat($2A26);
    private static _T2F_V3F         := new InterleavedArrayFormat($2A27);
    private static _T4F_V4F         := new InterleavedArrayFormat($2A28);
    private static _T2F_C4UB_V3F    := new InterleavedArrayFormat($2A29);
    private static _T2F_C3F_V3F     := new InterleavedArrayFormat($2A2A);
    private static _T2F_N3F_V3F     := new InterleavedArrayFormat($2A2B);
    private static _T2F_C4F_N3F_V3F := new InterleavedArrayFormat($2A2C);
    private static _T4F_C4F_N3F_V4F := new InterleavedArrayFormat($2A2D);
    
    public static property V2F:             InterleavedArrayFormat read _V2F;
    public static property V3F:             InterleavedArrayFormat read _V3F;
    public static property C4UB_V2F:        InterleavedArrayFormat read _C4UB_V2F;
    public static property C4UB_V3F:        InterleavedArrayFormat read _C4UB_V3F;
    public static property C3F_V3F:         InterleavedArrayFormat read _C3F_V3F;
    public static property N3F_V3F:         InterleavedArrayFormat read _N3F_V3F;
    public static property C4F_N3F_V3F:     InterleavedArrayFormat read _C4F_N3F_V3F;
    public static property T2F_V3F:         InterleavedArrayFormat read _T2F_V3F;
    public static property T4F_V4F:         InterleavedArrayFormat read _T4F_V4F;
    public static property T2F_C4UB_V3F:    InterleavedArrayFormat read _T2F_C4UB_V3F;
    public static property T2F_C3F_V3F:     InterleavedArrayFormat read _T2F_C3F_V3F;
    public static property T2F_N3F_V3F:     InterleavedArrayFormat read _T2F_N3F_V3F;
    public static property T2F_C4F_N3F_V3F: InterleavedArrayFormat read _T2F_C4F_N3F_V3F;
    public static property T4F_C4F_N3F_V4F: InterleavedArrayFormat read _T4F_C4F_N3F_V4F;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2A20) then Result := 'V2F' else
      if self.val = UInt32($2A21) then Result := 'V3F' else
      if self.val = UInt32($2A22) then Result := 'C4UB_V2F' else
      if self.val = UInt32($2A23) then Result := 'C4UB_V3F' else
      if self.val = UInt32($2A24) then Result := 'C3F_V3F' else
      if self.val = UInt32($2A25) then Result := 'N3F_V3F' else
      if self.val = UInt32($2A26) then Result := 'C4F_N3F_V3F' else
      if self.val = UInt32($2A27) then Result := 'T2F_V3F' else
      if self.val = UInt32($2A28) then Result := 'T4F_V4F' else
      if self.val = UInt32($2A29) then Result := 'T2F_C4UB_V3F' else
      if self.val = UInt32($2A2A) then Result := 'T2F_C3F_V3F' else
      if self.val = UInt32($2A2B) then Result := 'T2F_N3F_V3F' else
      if self.val = UInt32($2A2C) then Result := 'T2F_C4F_N3F_V3F' else
      if self.val = UInt32($2A2D) then Result := 'T4F_C4F_N3F_V4F' else
        Result := self.val.ToString;
    end;
    
  end;
  
  InternalFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _STENCIL_INDEX                             := new InternalFormat($1901);
    private static _STENCIL_INDEX_OES                         := new InternalFormat($1901);
    private static _DEPTH_COMPONENT                           := new InternalFormat($1902);
    private static _RED                                       := new InternalFormat($1903);
    private static _RED_EXT                                   := new InternalFormat($1903);
    private static _RGB                                       := new InternalFormat($1907);
    private static _RGBA                                      := new InternalFormat($1908);
    private static _R3_G3_B2                                  := new InternalFormat($2A10);
    private static _ALPHA4                                    := new InternalFormat($803B);
    private static _ALPHA8                                    := new InternalFormat($803C);
    private static _ALPHA12                                   := new InternalFormat($803D);
    private static _ALPHA16                                   := new InternalFormat($803E);
    private static _LUMINANCE4                                := new InternalFormat($803F);
    private static _LUMINANCE8                                := new InternalFormat($8040);
    private static _LUMINANCE12                               := new InternalFormat($8041);
    private static _LUMINANCE16                               := new InternalFormat($8042);
    private static _LUMINANCE4_ALPHA4                         := new InternalFormat($8043);
    private static _LUMINANCE6_ALPHA2                         := new InternalFormat($8044);
    private static _LUMINANCE8_ALPHA8                         := new InternalFormat($8045);
    private static _LUMINANCE12_ALPHA4                        := new InternalFormat($8046);
    private static _LUMINANCE12_ALPHA12                       := new InternalFormat($8047);
    private static _LUMINANCE16_ALPHA16                       := new InternalFormat($8048);
    private static _INTENSITY                                 := new InternalFormat($8049);
    private static _INTENSITY4                                := new InternalFormat($804A);
    private static _INTENSITY8                                := new InternalFormat($804B);
    private static _INTENSITY12                               := new InternalFormat($804C);
    private static _INTENSITY16                               := new InternalFormat($804D);
    private static _RGB2_EXT                                  := new InternalFormat($804E);
    private static _RGB4                                      := new InternalFormat($804F);
    private static _RGB4_EXT                                  := new InternalFormat($804F);
    private static _RGB5                                      := new InternalFormat($8050);
    private static _RGB5_EXT                                  := new InternalFormat($8050);
    private static _RGB8                                      := new InternalFormat($8051);
    private static _RGB8_EXT                                  := new InternalFormat($8051);
    private static _RGB8_OES                                  := new InternalFormat($8051);
    private static _RGB10                                     := new InternalFormat($8052);
    private static _RGB10_EXT                                 := new InternalFormat($8052);
    private static _RGB12                                     := new InternalFormat($8053);
    private static _RGB12_EXT                                 := new InternalFormat($8053);
    private static _RGB16                                     := new InternalFormat($8054);
    private static _RGB16_EXT                                 := new InternalFormat($8054);
    private static _RGBA4                                     := new InternalFormat($8056);
    private static _RGBA4_EXT                                 := new InternalFormat($8056);
    private static _RGBA4_OES                                 := new InternalFormat($8056);
    private static _RGB5_A1                                   := new InternalFormat($8057);
    private static _RGB5_A1_EXT                               := new InternalFormat($8057);
    private static _RGB5_A1_OES                               := new InternalFormat($8057);
    private static _RGBA8                                     := new InternalFormat($8058);
    private static _RGBA8_EXT                                 := new InternalFormat($8058);
    private static _RGBA8_OES                                 := new InternalFormat($8058);
    private static _RGB10_A2                                  := new InternalFormat($8059);
    private static _RGB10_A2_EXT                              := new InternalFormat($8059);
    private static _RGBA12                                    := new InternalFormat($805A);
    private static _RGBA12_EXT                                := new InternalFormat($805A);
    private static _RGBA16                                    := new InternalFormat($805B);
    private static _RGBA16_EXT                                := new InternalFormat($805B);
    private static _DUAL_ALPHA4_SGIS                          := new InternalFormat($8110);
    private static _DUAL_ALPHA8_SGIS                          := new InternalFormat($8111);
    private static _DUAL_ALPHA12_SGIS                         := new InternalFormat($8112);
    private static _DUAL_ALPHA16_SGIS                         := new InternalFormat($8113);
    private static _DUAL_LUMINANCE4_SGIS                      := new InternalFormat($8114);
    private static _DUAL_LUMINANCE8_SGIS                      := new InternalFormat($8115);
    private static _DUAL_LUMINANCE12_SGIS                     := new InternalFormat($8116);
    private static _DUAL_LUMINANCE16_SGIS                     := new InternalFormat($8117);
    private static _DUAL_INTENSITY4_SGIS                      := new InternalFormat($8118);
    private static _DUAL_INTENSITY8_SGIS                      := new InternalFormat($8119);
    private static _DUAL_INTENSITY12_SGIS                     := new InternalFormat($811A);
    private static _DUAL_INTENSITY16_SGIS                     := new InternalFormat($811B);
    private static _DUAL_LUMINANCE_ALPHA4_SGIS                := new InternalFormat($811C);
    private static _DUAL_LUMINANCE_ALPHA8_SGIS                := new InternalFormat($811D);
    private static _QUAD_ALPHA4_SGIS                          := new InternalFormat($811E);
    private static _QUAD_ALPHA8_SGIS                          := new InternalFormat($811F);
    private static _QUAD_LUMINANCE4_SGIS                      := new InternalFormat($8120);
    private static _QUAD_LUMINANCE8_SGIS                      := new InternalFormat($8121);
    private static _QUAD_INTENSITY4_SGIS                      := new InternalFormat($8122);
    private static _QUAD_INTENSITY8_SGIS                      := new InternalFormat($8123);
    private static _DEPTH_COMPONENT16                         := new InternalFormat($81A5);
    private static _DEPTH_COMPONENT16_ARB                     := new InternalFormat($81A5);
    private static _DEPTH_COMPONENT16_OES                     := new InternalFormat($81A5);
    private static _DEPTH_COMPONENT16_SGIX                    := new InternalFormat($81A5);
    private static _DEPTH_COMPONENT24_ARB                     := new InternalFormat($81A6);
    private static _DEPTH_COMPONENT24_OES                     := new InternalFormat($81A6);
    private static _DEPTH_COMPONENT24_SGIX                    := new InternalFormat($81A6);
    private static _DEPTH_COMPONENT32_ARB                     := new InternalFormat($81A7);
    private static _DEPTH_COMPONENT32_OES                     := new InternalFormat($81A7);
    private static _DEPTH_COMPONENT32_SGIX                    := new InternalFormat($81A7);
    private static _COMPRESSED_RED                            := new InternalFormat($8225);
    private static _COMPRESSED_RG                             := new InternalFormat($8226);
    private static _RG                                        := new InternalFormat($8227);
    private static _R8                                        := new InternalFormat($8229);
    private static _R8_EXT                                    := new InternalFormat($8229);
    private static _R16                                       := new InternalFormat($822A);
    private static _R16_EXT                                   := new InternalFormat($822A);
    private static _RG8                                       := new InternalFormat($822B);
    private static _RG8_EXT                                   := new InternalFormat($822B);
    private static _RG16                                      := new InternalFormat($822C);
    private static _RG16_EXT                                  := new InternalFormat($822C);
    private static _R16F                                      := new InternalFormat($822D);
    private static _R16F_EXT                                  := new InternalFormat($822D);
    private static _R32F                                      := new InternalFormat($822E);
    private static _R32F_EXT                                  := new InternalFormat($822E);
    private static _RG16F                                     := new InternalFormat($822F);
    private static _RG16F_EXT                                 := new InternalFormat($822F);
    private static _RG32F                                     := new InternalFormat($8230);
    private static _RG32F_EXT                                 := new InternalFormat($8230);
    private static _R8I                                       := new InternalFormat($8231);
    private static _R8UI                                      := new InternalFormat($8232);
    private static _R16I                                      := new InternalFormat($8233);
    private static _R16UI                                     := new InternalFormat($8234);
    private static _R32I                                      := new InternalFormat($8235);
    private static _R32UI                                     := new InternalFormat($8236);
    private static _RG8I                                      := new InternalFormat($8237);
    private static _RG8UI                                     := new InternalFormat($8238);
    private static _RG16I                                     := new InternalFormat($8239);
    private static _RG16UI                                    := new InternalFormat($823A);
    private static _RG32I                                     := new InternalFormat($823B);
    private static _RG32UI                                    := new InternalFormat($823C);
    private static _COMPRESSED_RGB_S3TC_DXT1_EXT              := new InternalFormat($83F0);
    private static _COMPRESSED_RGBA_S3TC_DXT1_EXT             := new InternalFormat($83F1);
    private static _COMPRESSED_RGBA_S3TC_DXT3_EXT             := new InternalFormat($83F2);
    private static _COMPRESSED_RGBA_S3TC_DXT5_EXT             := new InternalFormat($83F3);
    private static _COMPRESSED_RGB                            := new InternalFormat($84ED);
    private static _COMPRESSED_RGBA                           := new InternalFormat($84EE);
    private static _DEPTH_STENCIL                             := new InternalFormat($84F9);
    private static _DEPTH_STENCIL_EXT                         := new InternalFormat($84F9);
    private static _DEPTH_STENCIL_NV                          := new InternalFormat($84F9);
    private static _DEPTH_STENCIL_OES                         := new InternalFormat($84F9);
    private static _DEPTH_STENCIL_MESA                        := new InternalFormat($8750);
    private static _RGBA32F                                   := new InternalFormat($8814);
    private static _RGBA32F_ARB                               := new InternalFormat($8814);
    private static _RGBA32F_EXT                               := new InternalFormat($8814);
    private static _RGB32F                                    := new InternalFormat($8815);
    private static _RGBA16F                                   := new InternalFormat($881A);
    private static _RGBA16F_ARB                               := new InternalFormat($881A);
    private static _RGBA16F_EXT                               := new InternalFormat($881A);
    private static _RGB16F                                    := new InternalFormat($881B);
    private static _RGB16F_ARB                                := new InternalFormat($881B);
    private static _RGB16F_EXT                                := new InternalFormat($881B);
    private static _DEPTH24_STENCIL8                          := new InternalFormat($88F0);
    private static _DEPTH24_STENCIL8_EXT                      := new InternalFormat($88F0);
    private static _DEPTH24_STENCIL8_OES                      := new InternalFormat($88F0);
    private static _R11F_G11F_B10F                            := new InternalFormat($8C3A);
    private static _R11F_G11F_B10F_APPLE                      := new InternalFormat($8C3A);
    private static _R11F_G11F_B10F_EXT                        := new InternalFormat($8C3A);
    private static _RGB9_E5                                   := new InternalFormat($8C3D);
    private static _RGB9_E5_APPLE                             := new InternalFormat($8C3D);
    private static _RGB9_E5_EXT                               := new InternalFormat($8C3D);
    private static _SRGB                                      := new InternalFormat($8C40);
    private static _SRGB_EXT                                  := new InternalFormat($8C40);
    private static _SRGB8                                     := new InternalFormat($8C41);
    private static _SRGB8_EXT                                 := new InternalFormat($8C41);
    private static _SRGB8_NV                                  := new InternalFormat($8C41);
    private static _SRGB_ALPHA                                := new InternalFormat($8C42);
    private static _SRGB_ALPHA_EXT                            := new InternalFormat($8C42);
    private static _SRGB8_ALPHA8                              := new InternalFormat($8C43);
    private static _SRGB8_ALPHA8_EXT                          := new InternalFormat($8C43);
    private static _COMPRESSED_SRGB                           := new InternalFormat($8C48);
    private static _COMPRESSED_SRGB_ALPHA                     := new InternalFormat($8C49);
    private static _COMPRESSED_SRGB_S3TC_DXT1_EXT             := new InternalFormat($8C4C);
    private static _COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT       := new InternalFormat($8C4D);
    private static _COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT       := new InternalFormat($8C4E);
    private static _COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT       := new InternalFormat($8C4F);
    private static _DEPTH_COMPONENT32F                        := new InternalFormat($8CAC);
    private static _DEPTH32F_STENCIL8                         := new InternalFormat($8CAD);
    private static _STENCIL_INDEX1                            := new InternalFormat($8D46);
    private static _STENCIL_INDEX1_EXT                        := new InternalFormat($8D46);
    private static _STENCIL_INDEX1_OES                        := new InternalFormat($8D46);
    private static _STENCIL_INDEX4                            := new InternalFormat($8D47);
    private static _STENCIL_INDEX4_EXT                        := new InternalFormat($8D47);
    private static _STENCIL_INDEX4_OES                        := new InternalFormat($8D47);
    private static _STENCIL_INDEX8                            := new InternalFormat($8D48);
    private static _STENCIL_INDEX8_EXT                        := new InternalFormat($8D48);
    private static _STENCIL_INDEX8_OES                        := new InternalFormat($8D48);
    private static _STENCIL_INDEX16                           := new InternalFormat($8D49);
    private static _STENCIL_INDEX16_EXT                       := new InternalFormat($8D49);
    private static _RGBA32UI                                  := new InternalFormat($8D70);
    private static _RGB32UI                                   := new InternalFormat($8D71);
    private static _RGBA16UI                                  := new InternalFormat($8D76);
    private static _RGB16UI                                   := new InternalFormat($8D77);
    private static _RGBA8UI                                   := new InternalFormat($8D7C);
    private static _RGB8UI                                    := new InternalFormat($8D7D);
    private static _RGBA32I                                   := new InternalFormat($8D82);
    private static _RGB32I                                    := new InternalFormat($8D83);
    private static _RGBA16I                                   := new InternalFormat($8D88);
    private static _RGB16I                                    := new InternalFormat($8D89);
    private static _RGBA8I                                    := new InternalFormat($8D8E);
    private static _RGB8I                                     := new InternalFormat($8D8F);
    private static _DEPTH_COMPONENT32F_NV                     := new InternalFormat($8DAB);
    private static _DEPTH32F_STENCIL8_NV                      := new InternalFormat($8DAC);
    private static _COMPRESSED_RED_RGTC1                      := new InternalFormat($8DBB);
    private static _COMPRESSED_RED_RGTC1_EXT                  := new InternalFormat($8DBB);
    private static _COMPRESSED_SIGNED_RED_RGTC1               := new InternalFormat($8DBC);
    private static _COMPRESSED_SIGNED_RED_RGTC1_EXT           := new InternalFormat($8DBC);
    private static _COMPRESSED_RG_RGTC2                       := new InternalFormat($8DBD);
    private static _COMPRESSED_SIGNED_RG_RGTC2                := new InternalFormat($8DBE);
    private static _COMPRESSED_RGBA_BPTC_UNORM                := new InternalFormat($8E8C);
    private static _COMPRESSED_SRGB_ALPHA_BPTC_UNORM          := new InternalFormat($8E8D);
    private static _COMPRESSED_RGB_BPTC_SIGNED_FLOAT          := new InternalFormat($8E8E);
    private static _COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT        := new InternalFormat($8E8F);
    private static _R8_SNORM                                  := new InternalFormat($8F94);
    private static _RG8_SNORM                                 := new InternalFormat($8F95);
    private static _RGB8_SNORM                                := new InternalFormat($8F96);
    private static _RGBA8_SNORM                               := new InternalFormat($8F97);
    private static _R16_SNORM                                 := new InternalFormat($8F98);
    private static _R16_SNORM_EXT                             := new InternalFormat($8F98);
    private static _RG16_SNORM                                := new InternalFormat($8F99);
    private static _RG16_SNORM_EXT                            := new InternalFormat($8F99);
    private static _RGB16_SNORM                               := new InternalFormat($8F9A);
    private static _RGB16_SNORM_EXT                           := new InternalFormat($8F9A);
    private static _RGB10_A2UI                                := new InternalFormat($906F);
    private static _COMPRESSED_R11_EAC                        := new InternalFormat($9270);
    private static _COMPRESSED_SIGNED_R11_EAC                 := new InternalFormat($9271);
    private static _COMPRESSED_RG11_EAC                       := new InternalFormat($9272);
    private static _COMPRESSED_SIGNED_RG11_EAC                := new InternalFormat($9273);
    private static _COMPRESSED_RGB8_ETC2                      := new InternalFormat($9274);
    private static _COMPRESSED_SRGB8_ETC2                     := new InternalFormat($9275);
    private static _COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  := new InternalFormat($9276);
    private static _COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 := new InternalFormat($9277);
    private static _COMPRESSED_RGBA8_ETC2_EAC                 := new InternalFormat($9278);
    private static _COMPRESSED_SRGB8_ALPHA8_ETC2_EAC          := new InternalFormat($9279);
    private static _COMPRESSED_RGBA_ASTC_4x4                  := new InternalFormat($93B0);
    private static _COMPRESSED_RGBA_ASTC_4x4_KHR              := new InternalFormat($93B0);
    private static _COMPRESSED_RGBA_ASTC_5x4                  := new InternalFormat($93B1);
    private static _COMPRESSED_RGBA_ASTC_5x4_KHR              := new InternalFormat($93B1);
    private static _COMPRESSED_RGBA_ASTC_5x5                  := new InternalFormat($93B2);
    private static _COMPRESSED_RGBA_ASTC_5x5_KHR              := new InternalFormat($93B2);
    private static _COMPRESSED_RGBA_ASTC_6x5                  := new InternalFormat($93B3);
    private static _COMPRESSED_RGBA_ASTC_6x5_KHR              := new InternalFormat($93B3);
    private static _COMPRESSED_RGBA_ASTC_6x6                  := new InternalFormat($93B4);
    private static _COMPRESSED_RGBA_ASTC_6x6_KHR              := new InternalFormat($93B4);
    private static _COMPRESSED_RGBA_ASTC_8x5                  := new InternalFormat($93B5);
    private static _COMPRESSED_RGBA_ASTC_8x5_KHR              := new InternalFormat($93B5);
    private static _COMPRESSED_RGBA_ASTC_8x6                  := new InternalFormat($93B6);
    private static _COMPRESSED_RGBA_ASTC_8x6_KHR              := new InternalFormat($93B6);
    private static _COMPRESSED_RGBA_ASTC_8x8                  := new InternalFormat($93B7);
    private static _COMPRESSED_RGBA_ASTC_8x8_KHR              := new InternalFormat($93B7);
    private static _COMPRESSED_RGBA_ASTC_10x5                 := new InternalFormat($93B8);
    private static _COMPRESSED_RGBA_ASTC_10x5_KHR             := new InternalFormat($93B8);
    private static _COMPRESSED_RGBA_ASTC_10x6                 := new InternalFormat($93B9);
    private static _COMPRESSED_RGBA_ASTC_10x6_KHR             := new InternalFormat($93B9);
    private static _COMPRESSED_RGBA_ASTC_10x8                 := new InternalFormat($93BA);
    private static _COMPRESSED_RGBA_ASTC_10x8_KHR             := new InternalFormat($93BA);
    private static _COMPRESSED_RGBA_ASTC_10x10                := new InternalFormat($93BB);
    private static _COMPRESSED_RGBA_ASTC_10x10_KHR            := new InternalFormat($93BB);
    private static _COMPRESSED_RGBA_ASTC_12x10                := new InternalFormat($93BC);
    private static _COMPRESSED_RGBA_ASTC_12x10_KHR            := new InternalFormat($93BC);
    private static _COMPRESSED_RGBA_ASTC_12x12                := new InternalFormat($93BD);
    private static _COMPRESSED_RGBA_ASTC_12x12_KHR            := new InternalFormat($93BD);
    private static _COMPRESSED_RGBA_ASTC_3x3x3_OES            := new InternalFormat($93C0);
    private static _COMPRESSED_RGBA_ASTC_4x3x3_OES            := new InternalFormat($93C1);
    private static _COMPRESSED_RGBA_ASTC_4x4x3_OES            := new InternalFormat($93C2);
    private static _COMPRESSED_RGBA_ASTC_4x4x4_OES            := new InternalFormat($93C3);
    private static _COMPRESSED_RGBA_ASTC_5x4x4_OES            := new InternalFormat($93C4);
    private static _COMPRESSED_RGBA_ASTC_5x5x4_OES            := new InternalFormat($93C5);
    private static _COMPRESSED_RGBA_ASTC_5x5x5_OES            := new InternalFormat($93C6);
    private static _COMPRESSED_RGBA_ASTC_6x5x5_OES            := new InternalFormat($93C7);
    private static _COMPRESSED_RGBA_ASTC_6x6x5_OES            := new InternalFormat($93C8);
    private static _COMPRESSED_RGBA_ASTC_6x6x6_OES            := new InternalFormat($93C9);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4          := new InternalFormat($93D0);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR      := new InternalFormat($93D0);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_5x4          := new InternalFormat($93D1);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR      := new InternalFormat($93D1);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5          := new InternalFormat($93D2);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR      := new InternalFormat($93D2);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_6x5          := new InternalFormat($93D3);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR      := new InternalFormat($93D3);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6          := new InternalFormat($93D4);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR      := new InternalFormat($93D4);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_8x5          := new InternalFormat($93D5);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR      := new InternalFormat($93D5);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_8x6          := new InternalFormat($93D6);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR      := new InternalFormat($93D6);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_8x8          := new InternalFormat($93D7);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR      := new InternalFormat($93D7);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x5         := new InternalFormat($93D8);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR     := new InternalFormat($93D8);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x6         := new InternalFormat($93D9);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR     := new InternalFormat($93D9);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x8         := new InternalFormat($93DA);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR     := new InternalFormat($93DA);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x10        := new InternalFormat($93DB);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR    := new InternalFormat($93DB);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_12x10        := new InternalFormat($93DC);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR    := new InternalFormat($93DC);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_12x12        := new InternalFormat($93DD);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR    := new InternalFormat($93DD);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES    := new InternalFormat($93E0);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES    := new InternalFormat($93E1);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES    := new InternalFormat($93E2);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES    := new InternalFormat($93E3);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES    := new InternalFormat($93E4);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES    := new InternalFormat($93E5);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES    := new InternalFormat($93E6);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES    := new InternalFormat($93E7);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES    := new InternalFormat($93E8);
    private static _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES    := new InternalFormat($93E9);
    
    public static property STENCIL_INDEX:                             InternalFormat read _STENCIL_INDEX;
    public static property STENCIL_INDEX_OES:                         InternalFormat read _STENCIL_INDEX_OES;
    public static property DEPTH_COMPONENT:                           InternalFormat read _DEPTH_COMPONENT;
    public static property RED:                                       InternalFormat read _RED;
    public static property RED_EXT:                                   InternalFormat read _RED_EXT;
    public static property RGB:                                       InternalFormat read _RGB;
    public static property RGBA:                                      InternalFormat read _RGBA;
    public static property R3_G3_B2:                                  InternalFormat read _R3_G3_B2;
    public static property ALPHA4:                                    InternalFormat read _ALPHA4;
    public static property ALPHA8:                                    InternalFormat read _ALPHA8;
    public static property ALPHA12:                                   InternalFormat read _ALPHA12;
    public static property ALPHA16:                                   InternalFormat read _ALPHA16;
    public static property LUMINANCE4:                                InternalFormat read _LUMINANCE4;
    public static property LUMINANCE8:                                InternalFormat read _LUMINANCE8;
    public static property LUMINANCE12:                               InternalFormat read _LUMINANCE12;
    public static property LUMINANCE16:                               InternalFormat read _LUMINANCE16;
    public static property LUMINANCE4_ALPHA4:                         InternalFormat read _LUMINANCE4_ALPHA4;
    public static property LUMINANCE6_ALPHA2:                         InternalFormat read _LUMINANCE6_ALPHA2;
    public static property LUMINANCE8_ALPHA8:                         InternalFormat read _LUMINANCE8_ALPHA8;
    public static property LUMINANCE12_ALPHA4:                        InternalFormat read _LUMINANCE12_ALPHA4;
    public static property LUMINANCE12_ALPHA12:                       InternalFormat read _LUMINANCE12_ALPHA12;
    public static property LUMINANCE16_ALPHA16:                       InternalFormat read _LUMINANCE16_ALPHA16;
    public static property INTENSITY:                                 InternalFormat read _INTENSITY;
    public static property INTENSITY4:                                InternalFormat read _INTENSITY4;
    public static property INTENSITY8:                                InternalFormat read _INTENSITY8;
    public static property INTENSITY12:                               InternalFormat read _INTENSITY12;
    public static property INTENSITY16:                               InternalFormat read _INTENSITY16;
    public static property RGB2_EXT:                                  InternalFormat read _RGB2_EXT;
    public static property RGB4:                                      InternalFormat read _RGB4;
    public static property RGB4_EXT:                                  InternalFormat read _RGB4_EXT;
    public static property RGB5:                                      InternalFormat read _RGB5;
    public static property RGB5_EXT:                                  InternalFormat read _RGB5_EXT;
    public static property RGB8:                                      InternalFormat read _RGB8;
    public static property RGB8_EXT:                                  InternalFormat read _RGB8_EXT;
    public static property RGB8_OES:                                  InternalFormat read _RGB8_OES;
    public static property RGB10:                                     InternalFormat read _RGB10;
    public static property RGB10_EXT:                                 InternalFormat read _RGB10_EXT;
    public static property RGB12:                                     InternalFormat read _RGB12;
    public static property RGB12_EXT:                                 InternalFormat read _RGB12_EXT;
    public static property RGB16:                                     InternalFormat read _RGB16;
    public static property RGB16_EXT:                                 InternalFormat read _RGB16_EXT;
    public static property RGBA4:                                     InternalFormat read _RGBA4;
    public static property RGBA4_EXT:                                 InternalFormat read _RGBA4_EXT;
    public static property RGBA4_OES:                                 InternalFormat read _RGBA4_OES;
    public static property RGB5_A1:                                   InternalFormat read _RGB5_A1;
    public static property RGB5_A1_EXT:                               InternalFormat read _RGB5_A1_EXT;
    public static property RGB5_A1_OES:                               InternalFormat read _RGB5_A1_OES;
    public static property RGBA8:                                     InternalFormat read _RGBA8;
    public static property RGBA8_EXT:                                 InternalFormat read _RGBA8_EXT;
    public static property RGBA8_OES:                                 InternalFormat read _RGBA8_OES;
    public static property RGB10_A2:                                  InternalFormat read _RGB10_A2;
    public static property RGB10_A2_EXT:                              InternalFormat read _RGB10_A2_EXT;
    public static property RGBA12:                                    InternalFormat read _RGBA12;
    public static property RGBA12_EXT:                                InternalFormat read _RGBA12_EXT;
    public static property RGBA16:                                    InternalFormat read _RGBA16;
    public static property RGBA16_EXT:                                InternalFormat read _RGBA16_EXT;
    public static property DUAL_ALPHA4_SGIS:                          InternalFormat read _DUAL_ALPHA4_SGIS;
    public static property DUAL_ALPHA8_SGIS:                          InternalFormat read _DUAL_ALPHA8_SGIS;
    public static property DUAL_ALPHA12_SGIS:                         InternalFormat read _DUAL_ALPHA12_SGIS;
    public static property DUAL_ALPHA16_SGIS:                         InternalFormat read _DUAL_ALPHA16_SGIS;
    public static property DUAL_LUMINANCE4_SGIS:                      InternalFormat read _DUAL_LUMINANCE4_SGIS;
    public static property DUAL_LUMINANCE8_SGIS:                      InternalFormat read _DUAL_LUMINANCE8_SGIS;
    public static property DUAL_LUMINANCE12_SGIS:                     InternalFormat read _DUAL_LUMINANCE12_SGIS;
    public static property DUAL_LUMINANCE16_SGIS:                     InternalFormat read _DUAL_LUMINANCE16_SGIS;
    public static property DUAL_INTENSITY4_SGIS:                      InternalFormat read _DUAL_INTENSITY4_SGIS;
    public static property DUAL_INTENSITY8_SGIS:                      InternalFormat read _DUAL_INTENSITY8_SGIS;
    public static property DUAL_INTENSITY12_SGIS:                     InternalFormat read _DUAL_INTENSITY12_SGIS;
    public static property DUAL_INTENSITY16_SGIS:                     InternalFormat read _DUAL_INTENSITY16_SGIS;
    public static property DUAL_LUMINANCE_ALPHA4_SGIS:                InternalFormat read _DUAL_LUMINANCE_ALPHA4_SGIS;
    public static property DUAL_LUMINANCE_ALPHA8_SGIS:                InternalFormat read _DUAL_LUMINANCE_ALPHA8_SGIS;
    public static property QUAD_ALPHA4_SGIS:                          InternalFormat read _QUAD_ALPHA4_SGIS;
    public static property QUAD_ALPHA8_SGIS:                          InternalFormat read _QUAD_ALPHA8_SGIS;
    public static property QUAD_LUMINANCE4_SGIS:                      InternalFormat read _QUAD_LUMINANCE4_SGIS;
    public static property QUAD_LUMINANCE8_SGIS:                      InternalFormat read _QUAD_LUMINANCE8_SGIS;
    public static property QUAD_INTENSITY4_SGIS:                      InternalFormat read _QUAD_INTENSITY4_SGIS;
    public static property QUAD_INTENSITY8_SGIS:                      InternalFormat read _QUAD_INTENSITY8_SGIS;
    public static property DEPTH_COMPONENT16:                         InternalFormat read _DEPTH_COMPONENT16;
    public static property DEPTH_COMPONENT16_ARB:                     InternalFormat read _DEPTH_COMPONENT16_ARB;
    public static property DEPTH_COMPONENT16_OES:                     InternalFormat read _DEPTH_COMPONENT16_OES;
    public static property DEPTH_COMPONENT16_SGIX:                    InternalFormat read _DEPTH_COMPONENT16_SGIX;
    public static property DEPTH_COMPONENT24_ARB:                     InternalFormat read _DEPTH_COMPONENT24_ARB;
    public static property DEPTH_COMPONENT24_OES:                     InternalFormat read _DEPTH_COMPONENT24_OES;
    public static property DEPTH_COMPONENT24_SGIX:                    InternalFormat read _DEPTH_COMPONENT24_SGIX;
    public static property DEPTH_COMPONENT32_ARB:                     InternalFormat read _DEPTH_COMPONENT32_ARB;
    public static property DEPTH_COMPONENT32_OES:                     InternalFormat read _DEPTH_COMPONENT32_OES;
    public static property DEPTH_COMPONENT32_SGIX:                    InternalFormat read _DEPTH_COMPONENT32_SGIX;
    public static property COMPRESSED_RED:                            InternalFormat read _COMPRESSED_RED;
    public static property COMPRESSED_RG:                             InternalFormat read _COMPRESSED_RG;
    public static property RG:                                        InternalFormat read _RG;
    public static property R8:                                        InternalFormat read _R8;
    public static property R8_EXT:                                    InternalFormat read _R8_EXT;
    public static property R16:                                       InternalFormat read _R16;
    public static property R16_EXT:                                   InternalFormat read _R16_EXT;
    public static property RG8:                                       InternalFormat read _RG8;
    public static property RG8_EXT:                                   InternalFormat read _RG8_EXT;
    public static property RG16:                                      InternalFormat read _RG16;
    public static property RG16_EXT:                                  InternalFormat read _RG16_EXT;
    public static property R16F:                                      InternalFormat read _R16F;
    public static property R16F_EXT:                                  InternalFormat read _R16F_EXT;
    public static property R32F:                                      InternalFormat read _R32F;
    public static property R32F_EXT:                                  InternalFormat read _R32F_EXT;
    public static property RG16F:                                     InternalFormat read _RG16F;
    public static property RG16F_EXT:                                 InternalFormat read _RG16F_EXT;
    public static property RG32F:                                     InternalFormat read _RG32F;
    public static property RG32F_EXT:                                 InternalFormat read _RG32F_EXT;
    public static property R8I:                                       InternalFormat read _R8I;
    public static property R8UI:                                      InternalFormat read _R8UI;
    public static property R16I:                                      InternalFormat read _R16I;
    public static property R16UI:                                     InternalFormat read _R16UI;
    public static property R32I:                                      InternalFormat read _R32I;
    public static property R32UI:                                     InternalFormat read _R32UI;
    public static property RG8I:                                      InternalFormat read _RG8I;
    public static property RG8UI:                                     InternalFormat read _RG8UI;
    public static property RG16I:                                     InternalFormat read _RG16I;
    public static property RG16UI:                                    InternalFormat read _RG16UI;
    public static property RG32I:                                     InternalFormat read _RG32I;
    public static property RG32UI:                                    InternalFormat read _RG32UI;
    public static property COMPRESSED_RGB_S3TC_DXT1_EXT:              InternalFormat read _COMPRESSED_RGB_S3TC_DXT1_EXT;
    public static property COMPRESSED_RGBA_S3TC_DXT1_EXT:             InternalFormat read _COMPRESSED_RGBA_S3TC_DXT1_EXT;
    public static property COMPRESSED_RGBA_S3TC_DXT3_EXT:             InternalFormat read _COMPRESSED_RGBA_S3TC_DXT3_EXT;
    public static property COMPRESSED_RGBA_S3TC_DXT5_EXT:             InternalFormat read _COMPRESSED_RGBA_S3TC_DXT5_EXT;
    public static property COMPRESSED_RGB:                            InternalFormat read _COMPRESSED_RGB;
    public static property COMPRESSED_RGBA:                           InternalFormat read _COMPRESSED_RGBA;
    public static property DEPTH_STENCIL:                             InternalFormat read _DEPTH_STENCIL;
    public static property DEPTH_STENCIL_EXT:                         InternalFormat read _DEPTH_STENCIL_EXT;
    public static property DEPTH_STENCIL_NV:                          InternalFormat read _DEPTH_STENCIL_NV;
    public static property DEPTH_STENCIL_OES:                         InternalFormat read _DEPTH_STENCIL_OES;
    public static property DEPTH_STENCIL_MESA:                        InternalFormat read _DEPTH_STENCIL_MESA;
    public static property RGBA32F:                                   InternalFormat read _RGBA32F;
    public static property RGBA32F_ARB:                               InternalFormat read _RGBA32F_ARB;
    public static property RGBA32F_EXT:                               InternalFormat read _RGBA32F_EXT;
    public static property RGB32F:                                    InternalFormat read _RGB32F;
    public static property RGBA16F:                                   InternalFormat read _RGBA16F;
    public static property RGBA16F_ARB:                               InternalFormat read _RGBA16F_ARB;
    public static property RGBA16F_EXT:                               InternalFormat read _RGBA16F_EXT;
    public static property RGB16F:                                    InternalFormat read _RGB16F;
    public static property RGB16F_ARB:                                InternalFormat read _RGB16F_ARB;
    public static property RGB16F_EXT:                                InternalFormat read _RGB16F_EXT;
    public static property DEPTH24_STENCIL8:                          InternalFormat read _DEPTH24_STENCIL8;
    public static property DEPTH24_STENCIL8_EXT:                      InternalFormat read _DEPTH24_STENCIL8_EXT;
    public static property DEPTH24_STENCIL8_OES:                      InternalFormat read _DEPTH24_STENCIL8_OES;
    public static property R11F_G11F_B10F:                            InternalFormat read _R11F_G11F_B10F;
    public static property R11F_G11F_B10F_APPLE:                      InternalFormat read _R11F_G11F_B10F_APPLE;
    public static property R11F_G11F_B10F_EXT:                        InternalFormat read _R11F_G11F_B10F_EXT;
    public static property RGB9_E5:                                   InternalFormat read _RGB9_E5;
    public static property RGB9_E5_APPLE:                             InternalFormat read _RGB9_E5_APPLE;
    public static property RGB9_E5_EXT:                               InternalFormat read _RGB9_E5_EXT;
    public static property SRGB:                                      InternalFormat read _SRGB;
    public static property SRGB_EXT:                                  InternalFormat read _SRGB_EXT;
    public static property SRGB8:                                     InternalFormat read _SRGB8;
    public static property SRGB8_EXT:                                 InternalFormat read _SRGB8_EXT;
    public static property SRGB8_NV:                                  InternalFormat read _SRGB8_NV;
    public static property SRGB_ALPHA:                                InternalFormat read _SRGB_ALPHA;
    public static property SRGB_ALPHA_EXT:                            InternalFormat read _SRGB_ALPHA_EXT;
    public static property SRGB8_ALPHA8:                              InternalFormat read _SRGB8_ALPHA8;
    public static property SRGB8_ALPHA8_EXT:                          InternalFormat read _SRGB8_ALPHA8_EXT;
    public static property COMPRESSED_SRGB:                           InternalFormat read _COMPRESSED_SRGB;
    public static property COMPRESSED_SRGB_ALPHA:                     InternalFormat read _COMPRESSED_SRGB_ALPHA;
    public static property COMPRESSED_SRGB_S3TC_DXT1_EXT:             InternalFormat read _COMPRESSED_SRGB_S3TC_DXT1_EXT;
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:       InternalFormat read _COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:       InternalFormat read _COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
    public static property COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:       InternalFormat read _COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    public static property DEPTH_COMPONENT32F:                        InternalFormat read _DEPTH_COMPONENT32F;
    public static property DEPTH32F_STENCIL8:                         InternalFormat read _DEPTH32F_STENCIL8;
    public static property STENCIL_INDEX1:                            InternalFormat read _STENCIL_INDEX1;
    public static property STENCIL_INDEX1_EXT:                        InternalFormat read _STENCIL_INDEX1_EXT;
    public static property STENCIL_INDEX1_OES:                        InternalFormat read _STENCIL_INDEX1_OES;
    public static property STENCIL_INDEX4:                            InternalFormat read _STENCIL_INDEX4;
    public static property STENCIL_INDEX4_EXT:                        InternalFormat read _STENCIL_INDEX4_EXT;
    public static property STENCIL_INDEX4_OES:                        InternalFormat read _STENCIL_INDEX4_OES;
    public static property STENCIL_INDEX8:                            InternalFormat read _STENCIL_INDEX8;
    public static property STENCIL_INDEX8_EXT:                        InternalFormat read _STENCIL_INDEX8_EXT;
    public static property STENCIL_INDEX8_OES:                        InternalFormat read _STENCIL_INDEX8_OES;
    public static property STENCIL_INDEX16:                           InternalFormat read _STENCIL_INDEX16;
    public static property STENCIL_INDEX16_EXT:                       InternalFormat read _STENCIL_INDEX16_EXT;
    public static property RGBA32UI:                                  InternalFormat read _RGBA32UI;
    public static property RGB32UI:                                   InternalFormat read _RGB32UI;
    public static property RGBA16UI:                                  InternalFormat read _RGBA16UI;
    public static property RGB16UI:                                   InternalFormat read _RGB16UI;
    public static property RGBA8UI:                                   InternalFormat read _RGBA8UI;
    public static property RGB8UI:                                    InternalFormat read _RGB8UI;
    public static property RGBA32I:                                   InternalFormat read _RGBA32I;
    public static property RGB32I:                                    InternalFormat read _RGB32I;
    public static property RGBA16I:                                   InternalFormat read _RGBA16I;
    public static property RGB16I:                                    InternalFormat read _RGB16I;
    public static property RGBA8I:                                    InternalFormat read _RGBA8I;
    public static property RGB8I:                                     InternalFormat read _RGB8I;
    public static property DEPTH_COMPONENT32F_NV:                     InternalFormat read _DEPTH_COMPONENT32F_NV;
    public static property DEPTH32F_STENCIL8_NV:                      InternalFormat read _DEPTH32F_STENCIL8_NV;
    public static property COMPRESSED_RED_RGTC1:                      InternalFormat read _COMPRESSED_RED_RGTC1;
    public static property COMPRESSED_RED_RGTC1_EXT:                  InternalFormat read _COMPRESSED_RED_RGTC1_EXT;
    public static property COMPRESSED_SIGNED_RED_RGTC1:               InternalFormat read _COMPRESSED_SIGNED_RED_RGTC1;
    public static property COMPRESSED_SIGNED_RED_RGTC1_EXT:           InternalFormat read _COMPRESSED_SIGNED_RED_RGTC1_EXT;
    public static property COMPRESSED_RG_RGTC2:                       InternalFormat read _COMPRESSED_RG_RGTC2;
    public static property COMPRESSED_SIGNED_RG_RGTC2:                InternalFormat read _COMPRESSED_SIGNED_RG_RGTC2;
    public static property COMPRESSED_RGBA_BPTC_UNORM:                InternalFormat read _COMPRESSED_RGBA_BPTC_UNORM;
    public static property COMPRESSED_SRGB_ALPHA_BPTC_UNORM:          InternalFormat read _COMPRESSED_SRGB_ALPHA_BPTC_UNORM;
    public static property COMPRESSED_RGB_BPTC_SIGNED_FLOAT:          InternalFormat read _COMPRESSED_RGB_BPTC_SIGNED_FLOAT;
    public static property COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:        InternalFormat read _COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT;
    public static property R8_SNORM:                                  InternalFormat read _R8_SNORM;
    public static property RG8_SNORM:                                 InternalFormat read _RG8_SNORM;
    public static property RGB8_SNORM:                                InternalFormat read _RGB8_SNORM;
    public static property RGBA8_SNORM:                               InternalFormat read _RGBA8_SNORM;
    public static property R16_SNORM:                                 InternalFormat read _R16_SNORM;
    public static property R16_SNORM_EXT:                             InternalFormat read _R16_SNORM_EXT;
    public static property RG16_SNORM:                                InternalFormat read _RG16_SNORM;
    public static property RG16_SNORM_EXT:                            InternalFormat read _RG16_SNORM_EXT;
    public static property RGB16_SNORM:                               InternalFormat read _RGB16_SNORM;
    public static property RGB16_SNORM_EXT:                           InternalFormat read _RGB16_SNORM_EXT;
    public static property RGB10_A2UI:                                InternalFormat read _RGB10_A2UI;
    public static property COMPRESSED_R11_EAC:                        InternalFormat read _COMPRESSED_R11_EAC;
    public static property COMPRESSED_SIGNED_R11_EAC:                 InternalFormat read _COMPRESSED_SIGNED_R11_EAC;
    public static property COMPRESSED_RG11_EAC:                       InternalFormat read _COMPRESSED_RG11_EAC;
    public static property COMPRESSED_SIGNED_RG11_EAC:                InternalFormat read _COMPRESSED_SIGNED_RG11_EAC;
    public static property COMPRESSED_RGB8_ETC2:                      InternalFormat read _COMPRESSED_RGB8_ETC2;
    public static property COMPRESSED_SRGB8_ETC2:                     InternalFormat read _COMPRESSED_SRGB8_ETC2;
    public static property COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:  InternalFormat read _COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
    public static property COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: InternalFormat read _COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
    public static property COMPRESSED_RGBA8_ETC2_EAC:                 InternalFormat read _COMPRESSED_RGBA8_ETC2_EAC;
    public static property COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
    public static property COMPRESSED_RGBA_ASTC_4x4:                  InternalFormat read _COMPRESSED_RGBA_ASTC_4x4;
    public static property COMPRESSED_RGBA_ASTC_4x4_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_4x4_KHR;
    public static property COMPRESSED_RGBA_ASTC_5x4:                  InternalFormat read _COMPRESSED_RGBA_ASTC_5x4;
    public static property COMPRESSED_RGBA_ASTC_5x4_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_5x4_KHR;
    public static property COMPRESSED_RGBA_ASTC_5x5:                  InternalFormat read _COMPRESSED_RGBA_ASTC_5x5;
    public static property COMPRESSED_RGBA_ASTC_5x5_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_5x5_KHR;
    public static property COMPRESSED_RGBA_ASTC_6x5:                  InternalFormat read _COMPRESSED_RGBA_ASTC_6x5;
    public static property COMPRESSED_RGBA_ASTC_6x5_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_6x5_KHR;
    public static property COMPRESSED_RGBA_ASTC_6x6:                  InternalFormat read _COMPRESSED_RGBA_ASTC_6x6;
    public static property COMPRESSED_RGBA_ASTC_6x6_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_6x6_KHR;
    public static property COMPRESSED_RGBA_ASTC_8x5:                  InternalFormat read _COMPRESSED_RGBA_ASTC_8x5;
    public static property COMPRESSED_RGBA_ASTC_8x5_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_8x5_KHR;
    public static property COMPRESSED_RGBA_ASTC_8x6:                  InternalFormat read _COMPRESSED_RGBA_ASTC_8x6;
    public static property COMPRESSED_RGBA_ASTC_8x6_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_8x6_KHR;
    public static property COMPRESSED_RGBA_ASTC_8x8:                  InternalFormat read _COMPRESSED_RGBA_ASTC_8x8;
    public static property COMPRESSED_RGBA_ASTC_8x8_KHR:              InternalFormat read _COMPRESSED_RGBA_ASTC_8x8_KHR;
    public static property COMPRESSED_RGBA_ASTC_10x5:                 InternalFormat read _COMPRESSED_RGBA_ASTC_10x5;
    public static property COMPRESSED_RGBA_ASTC_10x5_KHR:             InternalFormat read _COMPRESSED_RGBA_ASTC_10x5_KHR;
    public static property COMPRESSED_RGBA_ASTC_10x6:                 InternalFormat read _COMPRESSED_RGBA_ASTC_10x6;
    public static property COMPRESSED_RGBA_ASTC_10x6_KHR:             InternalFormat read _COMPRESSED_RGBA_ASTC_10x6_KHR;
    public static property COMPRESSED_RGBA_ASTC_10x8:                 InternalFormat read _COMPRESSED_RGBA_ASTC_10x8;
    public static property COMPRESSED_RGBA_ASTC_10x8_KHR:             InternalFormat read _COMPRESSED_RGBA_ASTC_10x8_KHR;
    public static property COMPRESSED_RGBA_ASTC_10x10:                InternalFormat read _COMPRESSED_RGBA_ASTC_10x10;
    public static property COMPRESSED_RGBA_ASTC_10x10_KHR:            InternalFormat read _COMPRESSED_RGBA_ASTC_10x10_KHR;
    public static property COMPRESSED_RGBA_ASTC_12x10:                InternalFormat read _COMPRESSED_RGBA_ASTC_12x10;
    public static property COMPRESSED_RGBA_ASTC_12x10_KHR:            InternalFormat read _COMPRESSED_RGBA_ASTC_12x10_KHR;
    public static property COMPRESSED_RGBA_ASTC_12x12:                InternalFormat read _COMPRESSED_RGBA_ASTC_12x12;
    public static property COMPRESSED_RGBA_ASTC_12x12_KHR:            InternalFormat read _COMPRESSED_RGBA_ASTC_12x12_KHR;
    public static property COMPRESSED_RGBA_ASTC_3x3x3_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_3x3x3_OES;
    public static property COMPRESSED_RGBA_ASTC_4x3x3_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_4x3x3_OES;
    public static property COMPRESSED_RGBA_ASTC_4x4x3_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_4x4x3_OES;
    public static property COMPRESSED_RGBA_ASTC_4x4x4_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_4x4x4_OES;
    public static property COMPRESSED_RGBA_ASTC_5x4x4_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_5x4x4_OES;
    public static property COMPRESSED_RGBA_ASTC_5x5x4_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_5x5x4_OES;
    public static property COMPRESSED_RGBA_ASTC_5x5x5_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_5x5x5_OES;
    public static property COMPRESSED_RGBA_ASTC_6x5x5_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_6x5x5_OES;
    public static property COMPRESSED_RGBA_ASTC_6x6x5_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_6x6x5_OES;
    public static property COMPRESSED_RGBA_ASTC_6x6x6_OES:            InternalFormat read _COMPRESSED_RGBA_ASTC_6x6x6_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_5x4;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_6x5;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x5:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_8x5;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x6:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_8x6;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x8:          InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_8x8;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:      InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x5:         InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x5;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:     InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x6:         InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x6;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:     InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x8:         InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x8;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:     InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x10:        InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x10;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x10:        InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_12x10;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x12:        InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_12x12;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES;
    public static property COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES:    InternalFormat read _COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1901) then Result := 'STENCIL_INDEX' else
      if self.val = UInt32($1901) then Result := 'STENCIL_INDEX_OES' else
      if self.val = UInt32($1902) then Result := 'DEPTH_COMPONENT' else
      if self.val = UInt32($1903) then Result := 'RED' else
      if self.val = UInt32($1903) then Result := 'RED_EXT' else
      if self.val = UInt32($1907) then Result := 'RGB' else
      if self.val = UInt32($1908) then Result := 'RGBA' else
      if self.val = UInt32($2A10) then Result := 'R3_G3_B2' else
      if self.val = UInt32($803B) then Result := 'ALPHA4' else
      if self.val = UInt32($803C) then Result := 'ALPHA8' else
      if self.val = UInt32($803D) then Result := 'ALPHA12' else
      if self.val = UInt32($803E) then Result := 'ALPHA16' else
      if self.val = UInt32($803F) then Result := 'LUMINANCE4' else
      if self.val = UInt32($8040) then Result := 'LUMINANCE8' else
      if self.val = UInt32($8041) then Result := 'LUMINANCE12' else
      if self.val = UInt32($8042) then Result := 'LUMINANCE16' else
      if self.val = UInt32($8043) then Result := 'LUMINANCE4_ALPHA4' else
      if self.val = UInt32($8044) then Result := 'LUMINANCE6_ALPHA2' else
      if self.val = UInt32($8045) then Result := 'LUMINANCE8_ALPHA8' else
      if self.val = UInt32($8046) then Result := 'LUMINANCE12_ALPHA4' else
      if self.val = UInt32($8047) then Result := 'LUMINANCE12_ALPHA12' else
      if self.val = UInt32($8048) then Result := 'LUMINANCE16_ALPHA16' else
      if self.val = UInt32($8049) then Result := 'INTENSITY' else
      if self.val = UInt32($804A) then Result := 'INTENSITY4' else
      if self.val = UInt32($804B) then Result := 'INTENSITY8' else
      if self.val = UInt32($804C) then Result := 'INTENSITY12' else
      if self.val = UInt32($804D) then Result := 'INTENSITY16' else
      if self.val = UInt32($804E) then Result := 'RGB2_EXT' else
      if self.val = UInt32($804F) then Result := 'RGB4' else
      if self.val = UInt32($804F) then Result := 'RGB4_EXT' else
      if self.val = UInt32($8050) then Result := 'RGB5' else
      if self.val = UInt32($8050) then Result := 'RGB5_EXT' else
      if self.val = UInt32($8051) then Result := 'RGB8' else
      if self.val = UInt32($8051) then Result := 'RGB8_EXT' else
      if self.val = UInt32($8051) then Result := 'RGB8_OES' else
      if self.val = UInt32($8052) then Result := 'RGB10' else
      if self.val = UInt32($8052) then Result := 'RGB10_EXT' else
      if self.val = UInt32($8053) then Result := 'RGB12' else
      if self.val = UInt32($8053) then Result := 'RGB12_EXT' else
      if self.val = UInt32($8054) then Result := 'RGB16' else
      if self.val = UInt32($8054) then Result := 'RGB16_EXT' else
      if self.val = UInt32($8056) then Result := 'RGBA4' else
      if self.val = UInt32($8056) then Result := 'RGBA4_EXT' else
      if self.val = UInt32($8056) then Result := 'RGBA4_OES' else
      if self.val = UInt32($8057) then Result := 'RGB5_A1' else
      if self.val = UInt32($8057) then Result := 'RGB5_A1_EXT' else
      if self.val = UInt32($8057) then Result := 'RGB5_A1_OES' else
      if self.val = UInt32($8058) then Result := 'RGBA8' else
      if self.val = UInt32($8058) then Result := 'RGBA8_EXT' else
      if self.val = UInt32($8058) then Result := 'RGBA8_OES' else
      if self.val = UInt32($8059) then Result := 'RGB10_A2' else
      if self.val = UInt32($8059) then Result := 'RGB10_A2_EXT' else
      if self.val = UInt32($805A) then Result := 'RGBA12' else
      if self.val = UInt32($805A) then Result := 'RGBA12_EXT' else
      if self.val = UInt32($805B) then Result := 'RGBA16' else
      if self.val = UInt32($805B) then Result := 'RGBA16_EXT' else
      if self.val = UInt32($8110) then Result := 'DUAL_ALPHA4_SGIS' else
      if self.val = UInt32($8111) then Result := 'DUAL_ALPHA8_SGIS' else
      if self.val = UInt32($8112) then Result := 'DUAL_ALPHA12_SGIS' else
      if self.val = UInt32($8113) then Result := 'DUAL_ALPHA16_SGIS' else
      if self.val = UInt32($8114) then Result := 'DUAL_LUMINANCE4_SGIS' else
      if self.val = UInt32($8115) then Result := 'DUAL_LUMINANCE8_SGIS' else
      if self.val = UInt32($8116) then Result := 'DUAL_LUMINANCE12_SGIS' else
      if self.val = UInt32($8117) then Result := 'DUAL_LUMINANCE16_SGIS' else
      if self.val = UInt32($8118) then Result := 'DUAL_INTENSITY4_SGIS' else
      if self.val = UInt32($8119) then Result := 'DUAL_INTENSITY8_SGIS' else
      if self.val = UInt32($811A) then Result := 'DUAL_INTENSITY12_SGIS' else
      if self.val = UInt32($811B) then Result := 'DUAL_INTENSITY16_SGIS' else
      if self.val = UInt32($811C) then Result := 'DUAL_LUMINANCE_ALPHA4_SGIS' else
      if self.val = UInt32($811D) then Result := 'DUAL_LUMINANCE_ALPHA8_SGIS' else
      if self.val = UInt32($811E) then Result := 'QUAD_ALPHA4_SGIS' else
      if self.val = UInt32($811F) then Result := 'QUAD_ALPHA8_SGIS' else
      if self.val = UInt32($8120) then Result := 'QUAD_LUMINANCE4_SGIS' else
      if self.val = UInt32($8121) then Result := 'QUAD_LUMINANCE8_SGIS' else
      if self.val = UInt32($8122) then Result := 'QUAD_INTENSITY4_SGIS' else
      if self.val = UInt32($8123) then Result := 'QUAD_INTENSITY8_SGIS' else
      if self.val = UInt32($81A5) then Result := 'DEPTH_COMPONENT16' else
      if self.val = UInt32($81A5) then Result := 'DEPTH_COMPONENT16_ARB' else
      if self.val = UInt32($81A5) then Result := 'DEPTH_COMPONENT16_OES' else
      if self.val = UInt32($81A5) then Result := 'DEPTH_COMPONENT16_SGIX' else
      if self.val = UInt32($81A6) then Result := 'DEPTH_COMPONENT24_ARB' else
      if self.val = UInt32($81A6) then Result := 'DEPTH_COMPONENT24_OES' else
      if self.val = UInt32($81A6) then Result := 'DEPTH_COMPONENT24_SGIX' else
      if self.val = UInt32($81A7) then Result := 'DEPTH_COMPONENT32_ARB' else
      if self.val = UInt32($81A7) then Result := 'DEPTH_COMPONENT32_OES' else
      if self.val = UInt32($81A7) then Result := 'DEPTH_COMPONENT32_SGIX' else
      if self.val = UInt32($8225) then Result := 'COMPRESSED_RED' else
      if self.val = UInt32($8226) then Result := 'COMPRESSED_RG' else
      if self.val = UInt32($8227) then Result := 'RG' else
      if self.val = UInt32($8229) then Result := 'R8' else
      if self.val = UInt32($8229) then Result := 'R8_EXT' else
      if self.val = UInt32($822A) then Result := 'R16' else
      if self.val = UInt32($822A) then Result := 'R16_EXT' else
      if self.val = UInt32($822B) then Result := 'RG8' else
      if self.val = UInt32($822B) then Result := 'RG8_EXT' else
      if self.val = UInt32($822C) then Result := 'RG16' else
      if self.val = UInt32($822C) then Result := 'RG16_EXT' else
      if self.val = UInt32($822D) then Result := 'R16F' else
      if self.val = UInt32($822D) then Result := 'R16F_EXT' else
      if self.val = UInt32($822E) then Result := 'R32F' else
      if self.val = UInt32($822E) then Result := 'R32F_EXT' else
      if self.val = UInt32($822F) then Result := 'RG16F' else
      if self.val = UInt32($822F) then Result := 'RG16F_EXT' else
      if self.val = UInt32($8230) then Result := 'RG32F' else
      if self.val = UInt32($8230) then Result := 'RG32F_EXT' else
      if self.val = UInt32($8231) then Result := 'R8I' else
      if self.val = UInt32($8232) then Result := 'R8UI' else
      if self.val = UInt32($8233) then Result := 'R16I' else
      if self.val = UInt32($8234) then Result := 'R16UI' else
      if self.val = UInt32($8235) then Result := 'R32I' else
      if self.val = UInt32($8236) then Result := 'R32UI' else
      if self.val = UInt32($8237) then Result := 'RG8I' else
      if self.val = UInt32($8238) then Result := 'RG8UI' else
      if self.val = UInt32($8239) then Result := 'RG16I' else
      if self.val = UInt32($823A) then Result := 'RG16UI' else
      if self.val = UInt32($823B) then Result := 'RG32I' else
      if self.val = UInt32($823C) then Result := 'RG32UI' else
      if self.val = UInt32($83F0) then Result := 'COMPRESSED_RGB_S3TC_DXT1_EXT' else
      if self.val = UInt32($83F1) then Result := 'COMPRESSED_RGBA_S3TC_DXT1_EXT' else
      if self.val = UInt32($83F2) then Result := 'COMPRESSED_RGBA_S3TC_DXT3_EXT' else
      if self.val = UInt32($83F3) then Result := 'COMPRESSED_RGBA_S3TC_DXT5_EXT' else
      if self.val = UInt32($84ED) then Result := 'COMPRESSED_RGB' else
      if self.val = UInt32($84EE) then Result := 'COMPRESSED_RGBA' else
      if self.val = UInt32($84F9) then Result := 'DEPTH_STENCIL' else
      if self.val = UInt32($84F9) then Result := 'DEPTH_STENCIL_EXT' else
      if self.val = UInt32($84F9) then Result := 'DEPTH_STENCIL_NV' else
      if self.val = UInt32($84F9) then Result := 'DEPTH_STENCIL_OES' else
      if self.val = UInt32($8750) then Result := 'DEPTH_STENCIL_MESA' else
      if self.val = UInt32($8814) then Result := 'RGBA32F' else
      if self.val = UInt32($8814) then Result := 'RGBA32F_ARB' else
      if self.val = UInt32($8814) then Result := 'RGBA32F_EXT' else
      if self.val = UInt32($8815) then Result := 'RGB32F' else
      if self.val = UInt32($881A) then Result := 'RGBA16F' else
      if self.val = UInt32($881A) then Result := 'RGBA16F_ARB' else
      if self.val = UInt32($881A) then Result := 'RGBA16F_EXT' else
      if self.val = UInt32($881B) then Result := 'RGB16F' else
      if self.val = UInt32($881B) then Result := 'RGB16F_ARB' else
      if self.val = UInt32($881B) then Result := 'RGB16F_EXT' else
      if self.val = UInt32($88F0) then Result := 'DEPTH24_STENCIL8' else
      if self.val = UInt32($88F0) then Result := 'DEPTH24_STENCIL8_EXT' else
      if self.val = UInt32($88F0) then Result := 'DEPTH24_STENCIL8_OES' else
      if self.val = UInt32($8C3A) then Result := 'R11F_G11F_B10F' else
      if self.val = UInt32($8C3A) then Result := 'R11F_G11F_B10F_APPLE' else
      if self.val = UInt32($8C3A) then Result := 'R11F_G11F_B10F_EXT' else
      if self.val = UInt32($8C3D) then Result := 'RGB9_E5' else
      if self.val = UInt32($8C3D) then Result := 'RGB9_E5_APPLE' else
      if self.val = UInt32($8C3D) then Result := 'RGB9_E5_EXT' else
      if self.val = UInt32($8C40) then Result := 'SRGB' else
      if self.val = UInt32($8C40) then Result := 'SRGB_EXT' else
      if self.val = UInt32($8C41) then Result := 'SRGB8' else
      if self.val = UInt32($8C41) then Result := 'SRGB8_EXT' else
      if self.val = UInt32($8C41) then Result := 'SRGB8_NV' else
      if self.val = UInt32($8C42) then Result := 'SRGB_ALPHA' else
      if self.val = UInt32($8C42) then Result := 'SRGB_ALPHA_EXT' else
      if self.val = UInt32($8C43) then Result := 'SRGB8_ALPHA8' else
      if self.val = UInt32($8C43) then Result := 'SRGB8_ALPHA8_EXT' else
      if self.val = UInt32($8C48) then Result := 'COMPRESSED_SRGB' else
      if self.val = UInt32($8C49) then Result := 'COMPRESSED_SRGB_ALPHA' else
      if self.val = UInt32($8C4C) then Result := 'COMPRESSED_SRGB_S3TC_DXT1_EXT' else
      if self.val = UInt32($8C4D) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT' else
      if self.val = UInt32($8C4E) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT' else
      if self.val = UInt32($8C4F) then Result := 'COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT' else
      if self.val = UInt32($8CAC) then Result := 'DEPTH_COMPONENT32F' else
      if self.val = UInt32($8CAD) then Result := 'DEPTH32F_STENCIL8' else
      if self.val = UInt32($8D46) then Result := 'STENCIL_INDEX1' else
      if self.val = UInt32($8D46) then Result := 'STENCIL_INDEX1_EXT' else
      if self.val = UInt32($8D46) then Result := 'STENCIL_INDEX1_OES' else
      if self.val = UInt32($8D47) then Result := 'STENCIL_INDEX4' else
      if self.val = UInt32($8D47) then Result := 'STENCIL_INDEX4_EXT' else
      if self.val = UInt32($8D47) then Result := 'STENCIL_INDEX4_OES' else
      if self.val = UInt32($8D48) then Result := 'STENCIL_INDEX8' else
      if self.val = UInt32($8D48) then Result := 'STENCIL_INDEX8_EXT' else
      if self.val = UInt32($8D48) then Result := 'STENCIL_INDEX8_OES' else
      if self.val = UInt32($8D49) then Result := 'STENCIL_INDEX16' else
      if self.val = UInt32($8D49) then Result := 'STENCIL_INDEX16_EXT' else
      if self.val = UInt32($8D70) then Result := 'RGBA32UI' else
      if self.val = UInt32($8D71) then Result := 'RGB32UI' else
      if self.val = UInt32($8D76) then Result := 'RGBA16UI' else
      if self.val = UInt32($8D77) then Result := 'RGB16UI' else
      if self.val = UInt32($8D7C) then Result := 'RGBA8UI' else
      if self.val = UInt32($8D7D) then Result := 'RGB8UI' else
      if self.val = UInt32($8D82) then Result := 'RGBA32I' else
      if self.val = UInt32($8D83) then Result := 'RGB32I' else
      if self.val = UInt32($8D88) then Result := 'RGBA16I' else
      if self.val = UInt32($8D89) then Result := 'RGB16I' else
      if self.val = UInt32($8D8E) then Result := 'RGBA8I' else
      if self.val = UInt32($8D8F) then Result := 'RGB8I' else
      if self.val = UInt32($8DAB) then Result := 'DEPTH_COMPONENT32F_NV' else
      if self.val = UInt32($8DAC) then Result := 'DEPTH32F_STENCIL8_NV' else
      if self.val = UInt32($8DBB) then Result := 'COMPRESSED_RED_RGTC1' else
      if self.val = UInt32($8DBB) then Result := 'COMPRESSED_RED_RGTC1_EXT' else
      if self.val = UInt32($8DBC) then Result := 'COMPRESSED_SIGNED_RED_RGTC1' else
      if self.val = UInt32($8DBC) then Result := 'COMPRESSED_SIGNED_RED_RGTC1_EXT' else
      if self.val = UInt32($8DBD) then Result := 'COMPRESSED_RG_RGTC2' else
      if self.val = UInt32($8DBE) then Result := 'COMPRESSED_SIGNED_RG_RGTC2' else
      if self.val = UInt32($8E8C) then Result := 'COMPRESSED_RGBA_BPTC_UNORM' else
      if self.val = UInt32($8E8D) then Result := 'COMPRESSED_SRGB_ALPHA_BPTC_UNORM' else
      if self.val = UInt32($8E8E) then Result := 'COMPRESSED_RGB_BPTC_SIGNED_FLOAT' else
      if self.val = UInt32($8E8F) then Result := 'COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT' else
      if self.val = UInt32($8F94) then Result := 'R8_SNORM' else
      if self.val = UInt32($8F95) then Result := 'RG8_SNORM' else
      if self.val = UInt32($8F96) then Result := 'RGB8_SNORM' else
      if self.val = UInt32($8F97) then Result := 'RGBA8_SNORM' else
      if self.val = UInt32($8F98) then Result := 'R16_SNORM' else
      if self.val = UInt32($8F98) then Result := 'R16_SNORM_EXT' else
      if self.val = UInt32($8F99) then Result := 'RG16_SNORM' else
      if self.val = UInt32($8F99) then Result := 'RG16_SNORM_EXT' else
      if self.val = UInt32($8F9A) then Result := 'RGB16_SNORM' else
      if self.val = UInt32($8F9A) then Result := 'RGB16_SNORM_EXT' else
      if self.val = UInt32($906F) then Result := 'RGB10_A2UI' else
      if self.val = UInt32($9270) then Result := 'COMPRESSED_R11_EAC' else
      if self.val = UInt32($9271) then Result := 'COMPRESSED_SIGNED_R11_EAC' else
      if self.val = UInt32($9272) then Result := 'COMPRESSED_RG11_EAC' else
      if self.val = UInt32($9273) then Result := 'COMPRESSED_SIGNED_RG11_EAC' else
      if self.val = UInt32($9274) then Result := 'COMPRESSED_RGB8_ETC2' else
      if self.val = UInt32($9275) then Result := 'COMPRESSED_SRGB8_ETC2' else
      if self.val = UInt32($9276) then Result := 'COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if self.val = UInt32($9277) then Result := 'COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2' else
      if self.val = UInt32($9278) then Result := 'COMPRESSED_RGBA8_ETC2_EAC' else
      if self.val = UInt32($9279) then Result := 'COMPRESSED_SRGB8_ALPHA8_ETC2_EAC' else
      if self.val = UInt32($93B0) then Result := 'COMPRESSED_RGBA_ASTC_4x4' else
      if self.val = UInt32($93B0) then Result := 'COMPRESSED_RGBA_ASTC_4x4_KHR' else
      if self.val = UInt32($93B1) then Result := 'COMPRESSED_RGBA_ASTC_5x4' else
      if self.val = UInt32($93B1) then Result := 'COMPRESSED_RGBA_ASTC_5x4_KHR' else
      if self.val = UInt32($93B2) then Result := 'COMPRESSED_RGBA_ASTC_5x5' else
      if self.val = UInt32($93B2) then Result := 'COMPRESSED_RGBA_ASTC_5x5_KHR' else
      if self.val = UInt32($93B3) then Result := 'COMPRESSED_RGBA_ASTC_6x5' else
      if self.val = UInt32($93B3) then Result := 'COMPRESSED_RGBA_ASTC_6x5_KHR' else
      if self.val = UInt32($93B4) then Result := 'COMPRESSED_RGBA_ASTC_6x6' else
      if self.val = UInt32($93B4) then Result := 'COMPRESSED_RGBA_ASTC_6x6_KHR' else
      if self.val = UInt32($93B5) then Result := 'COMPRESSED_RGBA_ASTC_8x5' else
      if self.val = UInt32($93B5) then Result := 'COMPRESSED_RGBA_ASTC_8x5_KHR' else
      if self.val = UInt32($93B6) then Result := 'COMPRESSED_RGBA_ASTC_8x6' else
      if self.val = UInt32($93B6) then Result := 'COMPRESSED_RGBA_ASTC_8x6_KHR' else
      if self.val = UInt32($93B7) then Result := 'COMPRESSED_RGBA_ASTC_8x8' else
      if self.val = UInt32($93B7) then Result := 'COMPRESSED_RGBA_ASTC_8x8_KHR' else
      if self.val = UInt32($93B8) then Result := 'COMPRESSED_RGBA_ASTC_10x5' else
      if self.val = UInt32($93B8) then Result := 'COMPRESSED_RGBA_ASTC_10x5_KHR' else
      if self.val = UInt32($93B9) then Result := 'COMPRESSED_RGBA_ASTC_10x6' else
      if self.val = UInt32($93B9) then Result := 'COMPRESSED_RGBA_ASTC_10x6_KHR' else
      if self.val = UInt32($93BA) then Result := 'COMPRESSED_RGBA_ASTC_10x8' else
      if self.val = UInt32($93BA) then Result := 'COMPRESSED_RGBA_ASTC_10x8_KHR' else
      if self.val = UInt32($93BB) then Result := 'COMPRESSED_RGBA_ASTC_10x10' else
      if self.val = UInt32($93BB) then Result := 'COMPRESSED_RGBA_ASTC_10x10_KHR' else
      if self.val = UInt32($93BC) then Result := 'COMPRESSED_RGBA_ASTC_12x10' else
      if self.val = UInt32($93BC) then Result := 'COMPRESSED_RGBA_ASTC_12x10_KHR' else
      if self.val = UInt32($93BD) then Result := 'COMPRESSED_RGBA_ASTC_12x12' else
      if self.val = UInt32($93BD) then Result := 'COMPRESSED_RGBA_ASTC_12x12_KHR' else
      if self.val = UInt32($93C0) then Result := 'COMPRESSED_RGBA_ASTC_3x3x3_OES' else
      if self.val = UInt32($93C1) then Result := 'COMPRESSED_RGBA_ASTC_4x3x3_OES' else
      if self.val = UInt32($93C2) then Result := 'COMPRESSED_RGBA_ASTC_4x4x3_OES' else
      if self.val = UInt32($93C3) then Result := 'COMPRESSED_RGBA_ASTC_4x4x4_OES' else
      if self.val = UInt32($93C4) then Result := 'COMPRESSED_RGBA_ASTC_5x4x4_OES' else
      if self.val = UInt32($93C5) then Result := 'COMPRESSED_RGBA_ASTC_5x5x4_OES' else
      if self.val = UInt32($93C6) then Result := 'COMPRESSED_RGBA_ASTC_5x5x5_OES' else
      if self.val = UInt32($93C7) then Result := 'COMPRESSED_RGBA_ASTC_6x5x5_OES' else
      if self.val = UInt32($93C8) then Result := 'COMPRESSED_RGBA_ASTC_6x6x5_OES' else
      if self.val = UInt32($93C9) then Result := 'COMPRESSED_RGBA_ASTC_6x6x6_OES' else
      if self.val = UInt32($93D0) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4' else
      if self.val = UInt32($93D0) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR' else
      if self.val = UInt32($93D1) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4' else
      if self.val = UInt32($93D1) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR' else
      if self.val = UInt32($93D2) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5' else
      if self.val = UInt32($93D2) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR' else
      if self.val = UInt32($93D3) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5' else
      if self.val = UInt32($93D3) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR' else
      if self.val = UInt32($93D4) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6' else
      if self.val = UInt32($93D4) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR' else
      if self.val = UInt32($93D5) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x5' else
      if self.val = UInt32($93D5) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR' else
      if self.val = UInt32($93D6) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x6' else
      if self.val = UInt32($93D6) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR' else
      if self.val = UInt32($93D7) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x8' else
      if self.val = UInt32($93D7) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR' else
      if self.val = UInt32($93D8) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x5' else
      if self.val = UInt32($93D8) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR' else
      if self.val = UInt32($93D9) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x6' else
      if self.val = UInt32($93D9) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR' else
      if self.val = UInt32($93DA) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x8' else
      if self.val = UInt32($93DA) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR' else
      if self.val = UInt32($93DB) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x10' else
      if self.val = UInt32($93DB) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR' else
      if self.val = UInt32($93DC) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x10' else
      if self.val = UInt32($93DC) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR' else
      if self.val = UInt32($93DD) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x12' else
      if self.val = UInt32($93DD) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR' else
      if self.val = UInt32($93E0) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES' else
      if self.val = UInt32($93E1) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES' else
      if self.val = UInt32($93E2) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES' else
      if self.val = UInt32($93E3) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES' else
      if self.val = UInt32($93E4) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES' else
      if self.val = UInt32($93E5) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES' else
      if self.val = UInt32($93E6) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES' else
      if self.val = UInt32($93E7) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES' else
      if self.val = UInt32($93E8) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES' else
      if self.val = UInt32($93E9) then Result := 'COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  InternalFormatPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SAMPLES                                := new InternalFormatPName($80A9);
    private static _GENERATE_MIPMAP                        := new InternalFormatPName($8191);
    private static _INTERNALFORMAT_SUPPORTED               := new InternalFormatPName($826F);
    private static _INTERNALFORMAT_PREFERRED               := new InternalFormatPName($8270);
    private static _INTERNALFORMAT_RED_SIZE                := new InternalFormatPName($8271);
    private static _INTERNALFORMAT_GREEN_SIZE              := new InternalFormatPName($8272);
    private static _INTERNALFORMAT_BLUE_SIZE               := new InternalFormatPName($8273);
    private static _INTERNALFORMAT_ALPHA_SIZE              := new InternalFormatPName($8274);
    private static _INTERNALFORMAT_DEPTH_SIZE              := new InternalFormatPName($8275);
    private static _INTERNALFORMAT_STENCIL_SIZE            := new InternalFormatPName($8276);
    private static _INTERNALFORMAT_SHARED_SIZE             := new InternalFormatPName($8277);
    private static _INTERNALFORMAT_RED_TYPE                := new InternalFormatPName($8278);
    private static _INTERNALFORMAT_GREEN_TYPE              := new InternalFormatPName($8279);
    private static _INTERNALFORMAT_BLUE_TYPE               := new InternalFormatPName($827A);
    private static _INTERNALFORMAT_ALPHA_TYPE              := new InternalFormatPName($827B);
    private static _INTERNALFORMAT_DEPTH_TYPE              := new InternalFormatPName($827C);
    private static _INTERNALFORMAT_STENCIL_TYPE            := new InternalFormatPName($827D);
    private static _MAX_WIDTH                              := new InternalFormatPName($827E);
    private static _MAX_HEIGHT                             := new InternalFormatPName($827F);
    private static _MAX_DEPTH                              := new InternalFormatPName($8280);
    private static _MAX_LAYERS                             := new InternalFormatPName($8281);
    private static _COLOR_COMPONENTS                       := new InternalFormatPName($8283);
    private static _COLOR_RENDERABLE                       := new InternalFormatPName($8286);
    private static _DEPTH_RENDERABLE                       := new InternalFormatPName($8287);
    private static _STENCIL_RENDERABLE                     := new InternalFormatPName($8288);
    private static _FRAMEBUFFER_RENDERABLE                 := new InternalFormatPName($8289);
    private static _FRAMEBUFFER_RENDERABLE_LAYERED         := new InternalFormatPName($828A);
    private static _FRAMEBUFFER_BLEND                      := new InternalFormatPName($828B);
    private static _READ_PIXELS                            := new InternalFormatPName($828C);
    private static _READ_PIXELS_FORMAT                     := new InternalFormatPName($828D);
    private static _READ_PIXELS_TYPE                       := new InternalFormatPName($828E);
    private static _TEXTURE_IMAGE_FORMAT                   := new InternalFormatPName($828F);
    private static _TEXTURE_IMAGE_TYPE                     := new InternalFormatPName($8290);
    private static _GET__TEXTURE_IMAGE_FORMAT              := new InternalFormatPName($8291);
    private static _GET__TEXTURE_IMAGE_TYPE                := new InternalFormatPName($8292);
    private static _MIPMAP                                 := new InternalFormatPName($8293);
    private static _AUTO_GENERATE_MIPMAP                   := new InternalFormatPName($8295);
    private static _COLOR_ENCODING                         := new InternalFormatPName($8296);
    private static _SRGB_READ                              := new InternalFormatPName($8297);
    private static _SRGB_WRITE                             := new InternalFormatPName($8298);
    private static _FILTER                                 := new InternalFormatPName($829A);
    private static _VERTEX_TEXTURE                         := new InternalFormatPName($829B);
    private static _TESS_CONTROL_TEXTURE                   := new InternalFormatPName($829C);
    private static _TESS_EVALUATION_TEXTURE                := new InternalFormatPName($829D);
    private static _GEOMETRY_TEXTURE                       := new InternalFormatPName($829E);
    private static _FRAGMENT_TEXTURE                       := new InternalFormatPName($829F);
    private static _COMPUTE_TEXTURE                        := new InternalFormatPName($82A0);
    private static _TEXTURE_SHADOW                         := new InternalFormatPName($82A1);
    private static _TEXTURE_GATHER                         := new InternalFormatPName($82A2);
    private static _TEXTURE_GATHER_SHADOW                  := new InternalFormatPName($82A3);
    private static _SHADER_IMAGE_LOAD                      := new InternalFormatPName($82A4);
    private static _SHADER_IMAGE_STORE                     := new InternalFormatPName($82A5);
    private static _SHADER_IMAGE_ATOMIC                    := new InternalFormatPName($82A6);
    private static _IMAGE_TEXEL_SIZE                       := new InternalFormatPName($82A7);
    private static _IMAGE_COMPATIBILITY_CLASS              := new InternalFormatPName($82A8);
    private static _IMAGE_PIXEL_FORMAT                     := new InternalFormatPName($82A9);
    private static _IMAGE_PIXEL_TYPE                       := new InternalFormatPName($82AA);
    private static _SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST    := new InternalFormatPName($82AC);
    private static _SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST  := new InternalFormatPName($82AD);
    private static _SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE   := new InternalFormatPName($82AE);
    private static _SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE := new InternalFormatPName($82AF);
    private static _TEXTURE_COMPRESSED_BLOCK_WIDTH         := new InternalFormatPName($82B1);
    private static _TEXTURE_COMPRESSED_BLOCK_HEIGHT        := new InternalFormatPName($82B2);
    private static _TEXTURE_COMPRESSED_BLOCK_SIZE          := new InternalFormatPName($82B3);
    private static _CLEAR_BUFFER                           := new InternalFormatPName($82B4);
    private static _TEXTURE_VIEW                           := new InternalFormatPName($82B5);
    private static _VIEW_COMPATIBILITY_CLASS               := new InternalFormatPName($82B6);
    private static _TEXTURE_COMPRESSED                     := new InternalFormatPName($86A1);
    private static _IMAGE_FORMAT_COMPATIBILITY_TYPE        := new InternalFormatPName($90C7);
    private static _CLEAR_TEXTURE                          := new InternalFormatPName($9365);
    private static _NUM_SAMPLE_COUNTS                      := new InternalFormatPName($9380);
    
    public static property SAMPLES:                                InternalFormatPName read _SAMPLES;
    public static property GENERATE_MIPMAP:                        InternalFormatPName read _GENERATE_MIPMAP;
    public static property INTERNALFORMAT_SUPPORTED:               InternalFormatPName read _INTERNALFORMAT_SUPPORTED;
    public static property INTERNALFORMAT_PREFERRED:               InternalFormatPName read _INTERNALFORMAT_PREFERRED;
    public static property INTERNALFORMAT_RED_SIZE:                InternalFormatPName read _INTERNALFORMAT_RED_SIZE;
    public static property INTERNALFORMAT_GREEN_SIZE:              InternalFormatPName read _INTERNALFORMAT_GREEN_SIZE;
    public static property INTERNALFORMAT_BLUE_SIZE:               InternalFormatPName read _INTERNALFORMAT_BLUE_SIZE;
    public static property INTERNALFORMAT_ALPHA_SIZE:              InternalFormatPName read _INTERNALFORMAT_ALPHA_SIZE;
    public static property INTERNALFORMAT_DEPTH_SIZE:              InternalFormatPName read _INTERNALFORMAT_DEPTH_SIZE;
    public static property INTERNALFORMAT_STENCIL_SIZE:            InternalFormatPName read _INTERNALFORMAT_STENCIL_SIZE;
    public static property INTERNALFORMAT_SHARED_SIZE:             InternalFormatPName read _INTERNALFORMAT_SHARED_SIZE;
    public static property INTERNALFORMAT_RED_TYPE:                InternalFormatPName read _INTERNALFORMAT_RED_TYPE;
    public static property INTERNALFORMAT_GREEN_TYPE:              InternalFormatPName read _INTERNALFORMAT_GREEN_TYPE;
    public static property INTERNALFORMAT_BLUE_TYPE:               InternalFormatPName read _INTERNALFORMAT_BLUE_TYPE;
    public static property INTERNALFORMAT_ALPHA_TYPE:              InternalFormatPName read _INTERNALFORMAT_ALPHA_TYPE;
    public static property INTERNALFORMAT_DEPTH_TYPE:              InternalFormatPName read _INTERNALFORMAT_DEPTH_TYPE;
    public static property INTERNALFORMAT_STENCIL_TYPE:            InternalFormatPName read _INTERNALFORMAT_STENCIL_TYPE;
    public static property MAX_WIDTH:                              InternalFormatPName read _MAX_WIDTH;
    public static property MAX_HEIGHT:                             InternalFormatPName read _MAX_HEIGHT;
    public static property MAX_DEPTH:                              InternalFormatPName read _MAX_DEPTH;
    public static property MAX_LAYERS:                             InternalFormatPName read _MAX_LAYERS;
    public static property COLOR_COMPONENTS:                       InternalFormatPName read _COLOR_COMPONENTS;
    public static property COLOR_RENDERABLE:                       InternalFormatPName read _COLOR_RENDERABLE;
    public static property DEPTH_RENDERABLE:                       InternalFormatPName read _DEPTH_RENDERABLE;
    public static property STENCIL_RENDERABLE:                     InternalFormatPName read _STENCIL_RENDERABLE;
    public static property FRAMEBUFFER_RENDERABLE:                 InternalFormatPName read _FRAMEBUFFER_RENDERABLE;
    public static property FRAMEBUFFER_RENDERABLE_LAYERED:         InternalFormatPName read _FRAMEBUFFER_RENDERABLE_LAYERED;
    public static property FRAMEBUFFER_BLEND:                      InternalFormatPName read _FRAMEBUFFER_BLEND;
    public static property READ_PIXELS:                            InternalFormatPName read _READ_PIXELS;
    public static property READ_PIXELS_FORMAT:                     InternalFormatPName read _READ_PIXELS_FORMAT;
    public static property READ_PIXELS_TYPE:                       InternalFormatPName read _READ_PIXELS_TYPE;
    public static property TEXTURE_IMAGE_FORMAT:                   InternalFormatPName read _TEXTURE_IMAGE_FORMAT;
    public static property TEXTURE_IMAGE_TYPE:                     InternalFormatPName read _TEXTURE_IMAGE_TYPE;
    public static property GET__TEXTURE_IMAGE_FORMAT:              InternalFormatPName read _GET__TEXTURE_IMAGE_FORMAT;
    public static property GET__TEXTURE_IMAGE_TYPE:                InternalFormatPName read _GET__TEXTURE_IMAGE_TYPE;
    public static property MIPMAP:                                 InternalFormatPName read _MIPMAP;
    public static property AUTO_GENERATE_MIPMAP:                   InternalFormatPName read _AUTO_GENERATE_MIPMAP;
    public static property COLOR_ENCODING:                         InternalFormatPName read _COLOR_ENCODING;
    public static property SRGB_READ:                              InternalFormatPName read _SRGB_READ;
    public static property SRGB_WRITE:                             InternalFormatPName read _SRGB_WRITE;
    public static property FILTER:                                 InternalFormatPName read _FILTER;
    public static property VERTEX_TEXTURE:                         InternalFormatPName read _VERTEX_TEXTURE;
    public static property TESS_CONTROL_TEXTURE:                   InternalFormatPName read _TESS_CONTROL_TEXTURE;
    public static property TESS_EVALUATION_TEXTURE:                InternalFormatPName read _TESS_EVALUATION_TEXTURE;
    public static property GEOMETRY_TEXTURE:                       InternalFormatPName read _GEOMETRY_TEXTURE;
    public static property FRAGMENT_TEXTURE:                       InternalFormatPName read _FRAGMENT_TEXTURE;
    public static property COMPUTE_TEXTURE:                        InternalFormatPName read _COMPUTE_TEXTURE;
    public static property TEXTURE_SHADOW:                         InternalFormatPName read _TEXTURE_SHADOW;
    public static property TEXTURE_GATHER:                         InternalFormatPName read _TEXTURE_GATHER;
    public static property TEXTURE_GATHER_SHADOW:                  InternalFormatPName read _TEXTURE_GATHER_SHADOW;
    public static property SHADER_IMAGE_LOAD:                      InternalFormatPName read _SHADER_IMAGE_LOAD;
    public static property SHADER_IMAGE_STORE:                     InternalFormatPName read _SHADER_IMAGE_STORE;
    public static property SHADER_IMAGE_ATOMIC:                    InternalFormatPName read _SHADER_IMAGE_ATOMIC;
    public static property IMAGE_TEXEL_SIZE:                       InternalFormatPName read _IMAGE_TEXEL_SIZE;
    public static property IMAGE_COMPATIBILITY_CLASS:              InternalFormatPName read _IMAGE_COMPATIBILITY_CLASS;
    public static property IMAGE_PIXEL_FORMAT:                     InternalFormatPName read _IMAGE_PIXEL_FORMAT;
    public static property IMAGE_PIXEL_TYPE:                       InternalFormatPName read _IMAGE_PIXEL_TYPE;
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST:    InternalFormatPName read _SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST;
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST:  InternalFormatPName read _SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST;
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE:   InternalFormatPName read _SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE;
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: InternalFormatPName read _SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE;
    public static property TEXTURE_COMPRESSED_BLOCK_WIDTH:         InternalFormatPName read _TEXTURE_COMPRESSED_BLOCK_WIDTH;
    public static property TEXTURE_COMPRESSED_BLOCK_HEIGHT:        InternalFormatPName read _TEXTURE_COMPRESSED_BLOCK_HEIGHT;
    public static property TEXTURE_COMPRESSED_BLOCK_SIZE:          InternalFormatPName read _TEXTURE_COMPRESSED_BLOCK_SIZE;
    public static property CLEAR_BUFFER:                           InternalFormatPName read _CLEAR_BUFFER;
    public static property TEXTURE_VIEW:                           InternalFormatPName read _TEXTURE_VIEW;
    public static property VIEW_COMPATIBILITY_CLASS:               InternalFormatPName read _VIEW_COMPATIBILITY_CLASS;
    public static property TEXTURE_COMPRESSED:                     InternalFormatPName read _TEXTURE_COMPRESSED;
    public static property IMAGE_FORMAT_COMPATIBILITY_TYPE:        InternalFormatPName read _IMAGE_FORMAT_COMPATIBILITY_TYPE;
    public static property CLEAR_TEXTURE:                          InternalFormatPName read _CLEAR_TEXTURE;
    public static property NUM_SAMPLE_COUNTS:                      InternalFormatPName read _NUM_SAMPLE_COUNTS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80A9) then Result := 'SAMPLES' else
      if self.val = UInt32($8191) then Result := 'GENERATE_MIPMAP' else
      if self.val = UInt32($826F) then Result := 'INTERNALFORMAT_SUPPORTED' else
      if self.val = UInt32($8270) then Result := 'INTERNALFORMAT_PREFERRED' else
      if self.val = UInt32($8271) then Result := 'INTERNALFORMAT_RED_SIZE' else
      if self.val = UInt32($8272) then Result := 'INTERNALFORMAT_GREEN_SIZE' else
      if self.val = UInt32($8273) then Result := 'INTERNALFORMAT_BLUE_SIZE' else
      if self.val = UInt32($8274) then Result := 'INTERNALFORMAT_ALPHA_SIZE' else
      if self.val = UInt32($8275) then Result := 'INTERNALFORMAT_DEPTH_SIZE' else
      if self.val = UInt32($8276) then Result := 'INTERNALFORMAT_STENCIL_SIZE' else
      if self.val = UInt32($8277) then Result := 'INTERNALFORMAT_SHARED_SIZE' else
      if self.val = UInt32($8278) then Result := 'INTERNALFORMAT_RED_TYPE' else
      if self.val = UInt32($8279) then Result := 'INTERNALFORMAT_GREEN_TYPE' else
      if self.val = UInt32($827A) then Result := 'INTERNALFORMAT_BLUE_TYPE' else
      if self.val = UInt32($827B) then Result := 'INTERNALFORMAT_ALPHA_TYPE' else
      if self.val = UInt32($827C) then Result := 'INTERNALFORMAT_DEPTH_TYPE' else
      if self.val = UInt32($827D) then Result := 'INTERNALFORMAT_STENCIL_TYPE' else
      if self.val = UInt32($827E) then Result := 'MAX_WIDTH' else
      if self.val = UInt32($827F) then Result := 'MAX_HEIGHT' else
      if self.val = UInt32($8280) then Result := 'MAX_DEPTH' else
      if self.val = UInt32($8281) then Result := 'MAX_LAYERS' else
      if self.val = UInt32($8283) then Result := 'COLOR_COMPONENTS' else
      if self.val = UInt32($8286) then Result := 'COLOR_RENDERABLE' else
      if self.val = UInt32($8287) then Result := 'DEPTH_RENDERABLE' else
      if self.val = UInt32($8288) then Result := 'STENCIL_RENDERABLE' else
      if self.val = UInt32($8289) then Result := 'FRAMEBUFFER_RENDERABLE' else
      if self.val = UInt32($828A) then Result := 'FRAMEBUFFER_RENDERABLE_LAYERED' else
      if self.val = UInt32($828B) then Result := 'FRAMEBUFFER_BLEND' else
      if self.val = UInt32($828C) then Result := 'READ_PIXELS' else
      if self.val = UInt32($828D) then Result := 'READ_PIXELS_FORMAT' else
      if self.val = UInt32($828E) then Result := 'READ_PIXELS_TYPE' else
      if self.val = UInt32($828F) then Result := 'TEXTURE_IMAGE_FORMAT' else
      if self.val = UInt32($8290) then Result := 'TEXTURE_IMAGE_TYPE' else
      if self.val = UInt32($8291) then Result := 'GET__TEXTURE_IMAGE_FORMAT' else
      if self.val = UInt32($8292) then Result := 'GET__TEXTURE_IMAGE_TYPE' else
      if self.val = UInt32($8293) then Result := 'MIPMAP' else
      if self.val = UInt32($8295) then Result := 'AUTO_GENERATE_MIPMAP' else
      if self.val = UInt32($8296) then Result := 'COLOR_ENCODING' else
      if self.val = UInt32($8297) then Result := 'SRGB_READ' else
      if self.val = UInt32($8298) then Result := 'SRGB_WRITE' else
      if self.val = UInt32($829A) then Result := 'FILTER' else
      if self.val = UInt32($829B) then Result := 'VERTEX_TEXTURE' else
      if self.val = UInt32($829C) then Result := 'TESS_CONTROL_TEXTURE' else
      if self.val = UInt32($829D) then Result := 'TESS_EVALUATION_TEXTURE' else
      if self.val = UInt32($829E) then Result := 'GEOMETRY_TEXTURE' else
      if self.val = UInt32($829F) then Result := 'FRAGMENT_TEXTURE' else
      if self.val = UInt32($82A0) then Result := 'COMPUTE_TEXTURE' else
      if self.val = UInt32($82A1) then Result := 'TEXTURE_SHADOW' else
      if self.val = UInt32($82A2) then Result := 'TEXTURE_GATHER' else
      if self.val = UInt32($82A3) then Result := 'TEXTURE_GATHER_SHADOW' else
      if self.val = UInt32($82A4) then Result := 'SHADER_IMAGE_LOAD' else
      if self.val = UInt32($82A5) then Result := 'SHADER_IMAGE_STORE' else
      if self.val = UInt32($82A6) then Result := 'SHADER_IMAGE_ATOMIC' else
      if self.val = UInt32($82A7) then Result := 'IMAGE_TEXEL_SIZE' else
      if self.val = UInt32($82A8) then Result := 'IMAGE_COMPATIBILITY_CLASS' else
      if self.val = UInt32($82A9) then Result := 'IMAGE_PIXEL_FORMAT' else
      if self.val = UInt32($82AA) then Result := 'IMAGE_PIXEL_TYPE' else
      if self.val = UInt32($82AC) then Result := 'SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST' else
      if self.val = UInt32($82AD) then Result := 'SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST' else
      if self.val = UInt32($82AE) then Result := 'SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE' else
      if self.val = UInt32($82AF) then Result := 'SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE' else
      if self.val = UInt32($82B1) then Result := 'TEXTURE_COMPRESSED_BLOCK_WIDTH' else
      if self.val = UInt32($82B2) then Result := 'TEXTURE_COMPRESSED_BLOCK_HEIGHT' else
      if self.val = UInt32($82B3) then Result := 'TEXTURE_COMPRESSED_BLOCK_SIZE' else
      if self.val = UInt32($82B4) then Result := 'CLEAR_BUFFER' else
      if self.val = UInt32($82B5) then Result := 'TEXTURE_VIEW' else
      if self.val = UInt32($82B6) then Result := 'VIEW_COMPATIBILITY_CLASS' else
      if self.val = UInt32($86A1) then Result := 'TEXTURE_COMPRESSED' else
      if self.val = UInt32($90C7) then Result := 'IMAGE_FORMAT_COMPATIBILITY_TYPE' else
      if self.val = UInt32($9365) then Result := 'CLEAR_TEXTURE' else
      if self.val = UInt32($9380) then Result := 'NUM_SAMPLE_COUNTS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  InvalidateFramebufferAttachment = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COLOR                    := new InvalidateFramebufferAttachment($1800);
    private static _DEPTH                    := new InvalidateFramebufferAttachment($1801);
    private static _STENCIL                  := new InvalidateFramebufferAttachment($1802);
    private static _DEPTH_STENCIL_ATTACHMENT := new InvalidateFramebufferAttachment($821A);
    private static _COLOR_ATTACHMENT0        := new InvalidateFramebufferAttachment($8CE0);
    private static _COLOR_ATTACHMENT0_EXT    := new InvalidateFramebufferAttachment($8CE0);
    private static _COLOR_ATTACHMENT0_NV     := new InvalidateFramebufferAttachment($8CE0);
    private static _COLOR_ATTACHMENT0_OES    := new InvalidateFramebufferAttachment($8CE0);
    private static _COLOR_ATTACHMENT1        := new InvalidateFramebufferAttachment($8CE1);
    private static _COLOR_ATTACHMENT1_EXT    := new InvalidateFramebufferAttachment($8CE1);
    private static _COLOR_ATTACHMENT1_NV     := new InvalidateFramebufferAttachment($8CE1);
    private static _COLOR_ATTACHMENT2        := new InvalidateFramebufferAttachment($8CE2);
    private static _COLOR_ATTACHMENT2_EXT    := new InvalidateFramebufferAttachment($8CE2);
    private static _COLOR_ATTACHMENT2_NV     := new InvalidateFramebufferAttachment($8CE2);
    private static _COLOR_ATTACHMENT3        := new InvalidateFramebufferAttachment($8CE3);
    private static _COLOR_ATTACHMENT3_EXT    := new InvalidateFramebufferAttachment($8CE3);
    private static _COLOR_ATTACHMENT3_NV     := new InvalidateFramebufferAttachment($8CE3);
    private static _COLOR_ATTACHMENT4        := new InvalidateFramebufferAttachment($8CE4);
    private static _COLOR_ATTACHMENT4_EXT    := new InvalidateFramebufferAttachment($8CE4);
    private static _COLOR_ATTACHMENT4_NV     := new InvalidateFramebufferAttachment($8CE4);
    private static _COLOR_ATTACHMENT5        := new InvalidateFramebufferAttachment($8CE5);
    private static _COLOR_ATTACHMENT5_EXT    := new InvalidateFramebufferAttachment($8CE5);
    private static _COLOR_ATTACHMENT5_NV     := new InvalidateFramebufferAttachment($8CE5);
    private static _COLOR_ATTACHMENT6        := new InvalidateFramebufferAttachment($8CE6);
    private static _COLOR_ATTACHMENT6_EXT    := new InvalidateFramebufferAttachment($8CE6);
    private static _COLOR_ATTACHMENT6_NV     := new InvalidateFramebufferAttachment($8CE6);
    private static _COLOR_ATTACHMENT7        := new InvalidateFramebufferAttachment($8CE7);
    private static _COLOR_ATTACHMENT7_EXT    := new InvalidateFramebufferAttachment($8CE7);
    private static _COLOR_ATTACHMENT7_NV     := new InvalidateFramebufferAttachment($8CE7);
    private static _COLOR_ATTACHMENT8        := new InvalidateFramebufferAttachment($8CE8);
    private static _COLOR_ATTACHMENT8_EXT    := new InvalidateFramebufferAttachment($8CE8);
    private static _COLOR_ATTACHMENT8_NV     := new InvalidateFramebufferAttachment($8CE8);
    private static _COLOR_ATTACHMENT9        := new InvalidateFramebufferAttachment($8CE9);
    private static _COLOR_ATTACHMENT9_EXT    := new InvalidateFramebufferAttachment($8CE9);
    private static _COLOR_ATTACHMENT9_NV     := new InvalidateFramebufferAttachment($8CE9);
    private static _COLOR_ATTACHMENT10       := new InvalidateFramebufferAttachment($8CEA);
    private static _COLOR_ATTACHMENT10_EXT   := new InvalidateFramebufferAttachment($8CEA);
    private static _COLOR_ATTACHMENT10_NV    := new InvalidateFramebufferAttachment($8CEA);
    private static _COLOR_ATTACHMENT11       := new InvalidateFramebufferAttachment($8CEB);
    private static _COLOR_ATTACHMENT11_EXT   := new InvalidateFramebufferAttachment($8CEB);
    private static _COLOR_ATTACHMENT11_NV    := new InvalidateFramebufferAttachment($8CEB);
    private static _COLOR_ATTACHMENT12       := new InvalidateFramebufferAttachment($8CEC);
    private static _COLOR_ATTACHMENT12_EXT   := new InvalidateFramebufferAttachment($8CEC);
    private static _COLOR_ATTACHMENT12_NV    := new InvalidateFramebufferAttachment($8CEC);
    private static _COLOR_ATTACHMENT13       := new InvalidateFramebufferAttachment($8CED);
    private static _COLOR_ATTACHMENT13_EXT   := new InvalidateFramebufferAttachment($8CED);
    private static _COLOR_ATTACHMENT13_NV    := new InvalidateFramebufferAttachment($8CED);
    private static _COLOR_ATTACHMENT14       := new InvalidateFramebufferAttachment($8CEE);
    private static _COLOR_ATTACHMENT14_EXT   := new InvalidateFramebufferAttachment($8CEE);
    private static _COLOR_ATTACHMENT14_NV    := new InvalidateFramebufferAttachment($8CEE);
    private static _COLOR_ATTACHMENT15       := new InvalidateFramebufferAttachment($8CEF);
    private static _COLOR_ATTACHMENT15_EXT   := new InvalidateFramebufferAttachment($8CEF);
    private static _COLOR_ATTACHMENT15_NV    := new InvalidateFramebufferAttachment($8CEF);
    private static _COLOR_ATTACHMENT16       := new InvalidateFramebufferAttachment($8CF0);
    private static _COLOR_ATTACHMENT17       := new InvalidateFramebufferAttachment($8CF1);
    private static _COLOR_ATTACHMENT18       := new InvalidateFramebufferAttachment($8CF2);
    private static _COLOR_ATTACHMENT19       := new InvalidateFramebufferAttachment($8CF3);
    private static _COLOR_ATTACHMENT20       := new InvalidateFramebufferAttachment($8CF4);
    private static _COLOR_ATTACHMENT21       := new InvalidateFramebufferAttachment($8CF5);
    private static _COLOR_ATTACHMENT22       := new InvalidateFramebufferAttachment($8CF6);
    private static _COLOR_ATTACHMENT23       := new InvalidateFramebufferAttachment($8CF7);
    private static _COLOR_ATTACHMENT24       := new InvalidateFramebufferAttachment($8CF8);
    private static _COLOR_ATTACHMENT25       := new InvalidateFramebufferAttachment($8CF9);
    private static _COLOR_ATTACHMENT26       := new InvalidateFramebufferAttachment($8CFA);
    private static _COLOR_ATTACHMENT27       := new InvalidateFramebufferAttachment($8CFB);
    private static _COLOR_ATTACHMENT28       := new InvalidateFramebufferAttachment($8CFC);
    private static _COLOR_ATTACHMENT29       := new InvalidateFramebufferAttachment($8CFD);
    private static _COLOR_ATTACHMENT30       := new InvalidateFramebufferAttachment($8CFE);
    private static _COLOR_ATTACHMENT31       := new InvalidateFramebufferAttachment($8CFF);
    private static _DEPTH_ATTACHMENT         := new InvalidateFramebufferAttachment($8D00);
    private static _DEPTH_ATTACHMENT_EXT     := new InvalidateFramebufferAttachment($8D00);
    private static _DEPTH_ATTACHMENT_OES     := new InvalidateFramebufferAttachment($8D00);
    private static _STENCIL_ATTACHMENT_EXT   := new InvalidateFramebufferAttachment($8D20);
    private static _STENCIL_ATTACHMENT_OES   := new InvalidateFramebufferAttachment($8D20);
    
    public static property COLOR:                    InvalidateFramebufferAttachment read _COLOR;
    public static property DEPTH:                    InvalidateFramebufferAttachment read _DEPTH;
    public static property STENCIL:                  InvalidateFramebufferAttachment read _STENCIL;
    public static property DEPTH_STENCIL_ATTACHMENT: InvalidateFramebufferAttachment read _DEPTH_STENCIL_ATTACHMENT;
    public static property COLOR_ATTACHMENT0:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT0;
    public static property COLOR_ATTACHMENT0_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT0_EXT;
    public static property COLOR_ATTACHMENT0_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT0_NV;
    public static property COLOR_ATTACHMENT0_OES:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT0_OES;
    public static property COLOR_ATTACHMENT1:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT1;
    public static property COLOR_ATTACHMENT1_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT1_EXT;
    public static property COLOR_ATTACHMENT1_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT1_NV;
    public static property COLOR_ATTACHMENT2:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT2;
    public static property COLOR_ATTACHMENT2_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT2_EXT;
    public static property COLOR_ATTACHMENT2_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT2_NV;
    public static property COLOR_ATTACHMENT3:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT3;
    public static property COLOR_ATTACHMENT3_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT3_EXT;
    public static property COLOR_ATTACHMENT3_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT3_NV;
    public static property COLOR_ATTACHMENT4:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT4;
    public static property COLOR_ATTACHMENT4_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT4_EXT;
    public static property COLOR_ATTACHMENT4_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT4_NV;
    public static property COLOR_ATTACHMENT5:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT5;
    public static property COLOR_ATTACHMENT5_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT5_EXT;
    public static property COLOR_ATTACHMENT5_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT5_NV;
    public static property COLOR_ATTACHMENT6:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT6;
    public static property COLOR_ATTACHMENT6_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT6_EXT;
    public static property COLOR_ATTACHMENT6_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT6_NV;
    public static property COLOR_ATTACHMENT7:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT7;
    public static property COLOR_ATTACHMENT7_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT7_EXT;
    public static property COLOR_ATTACHMENT7_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT7_NV;
    public static property COLOR_ATTACHMENT8:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT8;
    public static property COLOR_ATTACHMENT8_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT8_EXT;
    public static property COLOR_ATTACHMENT8_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT8_NV;
    public static property COLOR_ATTACHMENT9:        InvalidateFramebufferAttachment read _COLOR_ATTACHMENT9;
    public static property COLOR_ATTACHMENT9_EXT:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT9_EXT;
    public static property COLOR_ATTACHMENT9_NV:     InvalidateFramebufferAttachment read _COLOR_ATTACHMENT9_NV;
    public static property COLOR_ATTACHMENT10:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT10;
    public static property COLOR_ATTACHMENT10_EXT:   InvalidateFramebufferAttachment read _COLOR_ATTACHMENT10_EXT;
    public static property COLOR_ATTACHMENT10_NV:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT10_NV;
    public static property COLOR_ATTACHMENT11:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT11;
    public static property COLOR_ATTACHMENT11_EXT:   InvalidateFramebufferAttachment read _COLOR_ATTACHMENT11_EXT;
    public static property COLOR_ATTACHMENT11_NV:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT11_NV;
    public static property COLOR_ATTACHMENT12:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT12;
    public static property COLOR_ATTACHMENT12_EXT:   InvalidateFramebufferAttachment read _COLOR_ATTACHMENT12_EXT;
    public static property COLOR_ATTACHMENT12_NV:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT12_NV;
    public static property COLOR_ATTACHMENT13:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT13;
    public static property COLOR_ATTACHMENT13_EXT:   InvalidateFramebufferAttachment read _COLOR_ATTACHMENT13_EXT;
    public static property COLOR_ATTACHMENT13_NV:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT13_NV;
    public static property COLOR_ATTACHMENT14:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT14;
    public static property COLOR_ATTACHMENT14_EXT:   InvalidateFramebufferAttachment read _COLOR_ATTACHMENT14_EXT;
    public static property COLOR_ATTACHMENT14_NV:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT14_NV;
    public static property COLOR_ATTACHMENT15:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT15;
    public static property COLOR_ATTACHMENT15_EXT:   InvalidateFramebufferAttachment read _COLOR_ATTACHMENT15_EXT;
    public static property COLOR_ATTACHMENT15_NV:    InvalidateFramebufferAttachment read _COLOR_ATTACHMENT15_NV;
    public static property COLOR_ATTACHMENT16:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT16;
    public static property COLOR_ATTACHMENT17:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT17;
    public static property COLOR_ATTACHMENT18:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT18;
    public static property COLOR_ATTACHMENT19:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT19;
    public static property COLOR_ATTACHMENT20:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT20;
    public static property COLOR_ATTACHMENT21:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT21;
    public static property COLOR_ATTACHMENT22:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT22;
    public static property COLOR_ATTACHMENT23:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT23;
    public static property COLOR_ATTACHMENT24:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT24;
    public static property COLOR_ATTACHMENT25:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT25;
    public static property COLOR_ATTACHMENT26:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT26;
    public static property COLOR_ATTACHMENT27:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT27;
    public static property COLOR_ATTACHMENT28:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT28;
    public static property COLOR_ATTACHMENT29:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT29;
    public static property COLOR_ATTACHMENT30:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT30;
    public static property COLOR_ATTACHMENT31:       InvalidateFramebufferAttachment read _COLOR_ATTACHMENT31;
    public static property DEPTH_ATTACHMENT:         InvalidateFramebufferAttachment read _DEPTH_ATTACHMENT;
    public static property DEPTH_ATTACHMENT_EXT:     InvalidateFramebufferAttachment read _DEPTH_ATTACHMENT_EXT;
    public static property DEPTH_ATTACHMENT_OES:     InvalidateFramebufferAttachment read _DEPTH_ATTACHMENT_OES;
    public static property STENCIL_ATTACHMENT_EXT:   InvalidateFramebufferAttachment read _STENCIL_ATTACHMENT_EXT;
    public static property STENCIL_ATTACHMENT_OES:   InvalidateFramebufferAttachment read _STENCIL_ATTACHMENT_OES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1800) then Result := 'COLOR' else
      if self.val = UInt32($1801) then Result := 'DEPTH' else
      if self.val = UInt32($1802) then Result := 'STENCIL' else
      if self.val = UInt32($821A) then Result := 'DEPTH_STENCIL_ATTACHMENT' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0_EXT' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0_NV' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0_OES' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1_EXT' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1_NV' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2_EXT' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2_NV' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3_EXT' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3_NV' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4_EXT' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4_NV' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5_EXT' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5_NV' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6_EXT' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6_NV' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7_EXT' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7_NV' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8_EXT' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8_NV' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9_EXT' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9_NV' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10_EXT' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10_NV' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11_EXT' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11_NV' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12_EXT' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12_NV' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13_EXT' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13_NV' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14_EXT' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14_NV' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15_EXT' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15_NV' else
      if self.val = UInt32($8CF0) then Result := 'COLOR_ATTACHMENT16' else
      if self.val = UInt32($8CF1) then Result := 'COLOR_ATTACHMENT17' else
      if self.val = UInt32($8CF2) then Result := 'COLOR_ATTACHMENT18' else
      if self.val = UInt32($8CF3) then Result := 'COLOR_ATTACHMENT19' else
      if self.val = UInt32($8CF4) then Result := 'COLOR_ATTACHMENT20' else
      if self.val = UInt32($8CF5) then Result := 'COLOR_ATTACHMENT21' else
      if self.val = UInt32($8CF6) then Result := 'COLOR_ATTACHMENT22' else
      if self.val = UInt32($8CF7) then Result := 'COLOR_ATTACHMENT23' else
      if self.val = UInt32($8CF8) then Result := 'COLOR_ATTACHMENT24' else
      if self.val = UInt32($8CF9) then Result := 'COLOR_ATTACHMENT25' else
      if self.val = UInt32($8CFA) then Result := 'COLOR_ATTACHMENT26' else
      if self.val = UInt32($8CFB) then Result := 'COLOR_ATTACHMENT27' else
      if self.val = UInt32($8CFC) then Result := 'COLOR_ATTACHMENT28' else
      if self.val = UInt32($8CFD) then Result := 'COLOR_ATTACHMENT29' else
      if self.val = UInt32($8CFE) then Result := 'COLOR_ATTACHMENT30' else
      if self.val = UInt32($8CFF) then Result := 'COLOR_ATTACHMENT31' else
      if self.val = UInt32($8D00) then Result := 'DEPTH_ATTACHMENT' else
      if self.val = UInt32($8D00) then Result := 'DEPTH_ATTACHMENT_EXT' else
      if self.val = UInt32($8D00) then Result := 'DEPTH_ATTACHMENT_OES' else
      if self.val = UInt32($8D20) then Result := 'STENCIL_ATTACHMENT_EXT' else
      if self.val = UInt32($8D20) then Result := 'STENCIL_ATTACHMENT_OES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  LightModelParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _LIGHT_MODEL_LOCAL_VIEWER      := new LightModelParameter($0B51);
    private static _LIGHT_MODEL_TWO_SIDE          := new LightModelParameter($0B52);
    private static _LIGHT_MODEL_AMBIENT           := new LightModelParameter($0B53);
    private static _LIGHT_MODEL_COLOR_CONTROL     := new LightModelParameter($81F8);
    private static _LIGHT_MODEL_COLOR_CONTROL_EXT := new LightModelParameter($81F8);
    
    public static property LIGHT_MODEL_LOCAL_VIEWER:      LightModelParameter read _LIGHT_MODEL_LOCAL_VIEWER;
    public static property LIGHT_MODEL_TWO_SIDE:          LightModelParameter read _LIGHT_MODEL_TWO_SIDE;
    public static property LIGHT_MODEL_AMBIENT:           LightModelParameter read _LIGHT_MODEL_AMBIENT;
    public static property LIGHT_MODEL_COLOR_CONTROL:     LightModelParameter read _LIGHT_MODEL_COLOR_CONTROL;
    public static property LIGHT_MODEL_COLOR_CONTROL_EXT: LightModelParameter read _LIGHT_MODEL_COLOR_CONTROL_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B51) then Result := 'LIGHT_MODEL_LOCAL_VIEWER' else
      if self.val = UInt32($0B52) then Result := 'LIGHT_MODEL_TWO_SIDE' else
      if self.val = UInt32($0B53) then Result := 'LIGHT_MODEL_AMBIENT' else
      if self.val = UInt32($81F8) then Result := 'LIGHT_MODEL_COLOR_CONTROL' else
      if self.val = UInt32($81F8) then Result := 'LIGHT_MODEL_COLOR_CONTROL_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  LightName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _LIGHT0               := new LightName($4000);
    private static _LIGHT1               := new LightName($4001);
    private static _LIGHT2               := new LightName($4002);
    private static _LIGHT3               := new LightName($4003);
    private static _LIGHT4               := new LightName($4004);
    private static _LIGHT5               := new LightName($4005);
    private static _LIGHT6               := new LightName($4006);
    private static _LIGHT7               := new LightName($4007);
    private static _FRAGMENT_LIGHT0_SGIX := new LightName($840C);
    private static _FRAGMENT_LIGHT1_SGIX := new LightName($840D);
    private static _FRAGMENT_LIGHT2_SGIX := new LightName($840E);
    private static _FRAGMENT_LIGHT3_SGIX := new LightName($840F);
    private static _FRAGMENT_LIGHT4_SGIX := new LightName($8410);
    private static _FRAGMENT_LIGHT5_SGIX := new LightName($8411);
    private static _FRAGMENT_LIGHT6_SGIX := new LightName($8412);
    private static _FRAGMENT_LIGHT7_SGIX := new LightName($8413);
    
    public static property LIGHT0:               LightName read _LIGHT0;
    public static property LIGHT1:               LightName read _LIGHT1;
    public static property LIGHT2:               LightName read _LIGHT2;
    public static property LIGHT3:               LightName read _LIGHT3;
    public static property LIGHT4:               LightName read _LIGHT4;
    public static property LIGHT5:               LightName read _LIGHT5;
    public static property LIGHT6:               LightName read _LIGHT6;
    public static property LIGHT7:               LightName read _LIGHT7;
    public static property FRAGMENT_LIGHT0_SGIX: LightName read _FRAGMENT_LIGHT0_SGIX;
    public static property FRAGMENT_LIGHT1_SGIX: LightName read _FRAGMENT_LIGHT1_SGIX;
    public static property FRAGMENT_LIGHT2_SGIX: LightName read _FRAGMENT_LIGHT2_SGIX;
    public static property FRAGMENT_LIGHT3_SGIX: LightName read _FRAGMENT_LIGHT3_SGIX;
    public static property FRAGMENT_LIGHT4_SGIX: LightName read _FRAGMENT_LIGHT4_SGIX;
    public static property FRAGMENT_LIGHT5_SGIX: LightName read _FRAGMENT_LIGHT5_SGIX;
    public static property FRAGMENT_LIGHT6_SGIX: LightName read _FRAGMENT_LIGHT6_SGIX;
    public static property FRAGMENT_LIGHT7_SGIX: LightName read _FRAGMENT_LIGHT7_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($4000) then Result := 'LIGHT0' else
      if self.val = UInt32($4001) then Result := 'LIGHT1' else
      if self.val = UInt32($4002) then Result := 'LIGHT2' else
      if self.val = UInt32($4003) then Result := 'LIGHT3' else
      if self.val = UInt32($4004) then Result := 'LIGHT4' else
      if self.val = UInt32($4005) then Result := 'LIGHT5' else
      if self.val = UInt32($4006) then Result := 'LIGHT6' else
      if self.val = UInt32($4007) then Result := 'LIGHT7' else
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0_SGIX' else
      if self.val = UInt32($840D) then Result := 'FRAGMENT_LIGHT1_SGIX' else
      if self.val = UInt32($840E) then Result := 'FRAGMENT_LIGHT2_SGIX' else
      if self.val = UInt32($840F) then Result := 'FRAGMENT_LIGHT3_SGIX' else
      if self.val = UInt32($8410) then Result := 'FRAGMENT_LIGHT4_SGIX' else
      if self.val = UInt32($8411) then Result := 'FRAGMENT_LIGHT5_SGIX' else
      if self.val = UInt32($8412) then Result := 'FRAGMENT_LIGHT6_SGIX' else
      if self.val = UInt32($8413) then Result := 'FRAGMENT_LIGHT7_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  LightParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _POSITION              := new LightParameter($1203);
    private static _SPOT_DIRECTION        := new LightParameter($1204);
    private static _SPOT_EXPONENT         := new LightParameter($1205);
    private static _SPOT_CUTOFF           := new LightParameter($1206);
    private static _CONSTANT_ATTENUATION  := new LightParameter($1207);
    private static _LINEAR_ATTENUATION    := new LightParameter($1208);
    private static _QUADRATIC_ATTENUATION := new LightParameter($1209);
    
    public static property POSITION:              LightParameter read _POSITION;
    public static property SPOT_DIRECTION:        LightParameter read _SPOT_DIRECTION;
    public static property SPOT_EXPONENT:         LightParameter read _SPOT_EXPONENT;
    public static property SPOT_CUTOFF:           LightParameter read _SPOT_CUTOFF;
    public static property CONSTANT_ATTENUATION:  LightParameter read _CONSTANT_ATTENUATION;
    public static property LINEAR_ATTENUATION:    LightParameter read _LINEAR_ATTENUATION;
    public static property QUADRATIC_ATTENUATION: LightParameter read _QUADRATIC_ATTENUATION;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1203) then Result := 'POSITION' else
      if self.val = UInt32($1204) then Result := 'SPOT_DIRECTION' else
      if self.val = UInt32($1205) then Result := 'SPOT_EXPONENT' else
      if self.val = UInt32($1206) then Result := 'SPOT_CUTOFF' else
      if self.val = UInt32($1207) then Result := 'CONSTANT_ATTENUATION' else
      if self.val = UInt32($1208) then Result := 'LINEAR_ATTENUATION' else
      if self.val = UInt32($1209) then Result := 'QUADRATIC_ATTENUATION' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ListMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COMPILE             := new ListMode($1300);
    private static _COMPILE_AND_EXECUTE := new ListMode($1301);
    
    public static property COMPILE:             ListMode read _COMPILE;
    public static property COMPILE_AND_EXECUTE: ListMode read _COMPILE_AND_EXECUTE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1300) then Result := 'COMPILE' else
      if self.val = UInt32($1301) then Result := 'COMPILE_AND_EXECUTE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ListNameType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE           := new ListNameType($1400);
    private static _UNSIGNED_BYTE  := new ListNameType($1401);
    private static _SHORT          := new ListNameType($1402);
    private static _UNSIGNED_SHORT := new ListNameType($1403);
    private static _INT            := new ListNameType($1404);
    private static _UNSIGNED_INT   := new ListNameType($1405);
    private static _FLOAT          := new ListNameType($1406);
    private static _GL_2_BYTES     := new ListNameType($1407);
    private static _GL_3_BYTES     := new ListNameType($1408);
    private static _GL_4_BYTES     := new ListNameType($1409);
    
    public static property BYTE:           ListNameType read _BYTE;
    public static property UNSIGNED_BYTE:  ListNameType read _UNSIGNED_BYTE;
    public static property SHORT:          ListNameType read _SHORT;
    public static property UNSIGNED_SHORT: ListNameType read _UNSIGNED_SHORT;
    public static property INT:            ListNameType read _INT;
    public static property UNSIGNED_INT:   ListNameType read _UNSIGNED_INT;
    public static property FLOAT:          ListNameType read _FLOAT;
    public static property GL_2_BYTES:     ListNameType read _GL_2_BYTES;
    public static property GL_3_BYTES:     ListNameType read _GL_3_BYTES;
    public static property GL_4_BYTES:     ListNameType read _GL_4_BYTES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($1407) then Result := 'GL_2_BYTES' else
      if self.val = UInt32($1408) then Result := 'GL_3_BYTES' else
      if self.val = UInt32($1409) then Result := 'GL_4_BYTES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ListParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _LIST_PRIORITY_SGIX := new ListParameterName($8182);
    
    public static property LIST_PRIORITY_SGIX: ListParameterName read _LIST_PRIORITY_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8182) then Result := 'LIST_PRIORITY_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  LogicOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CLEAR         := new LogicOp($1500);
    private static _AND           := new LogicOp($1501);
    private static _AND_REVERSE   := new LogicOp($1502);
    private static _COPY          := new LogicOp($1503);
    private static _AND_INVERTED  := new LogicOp($1504);
    private static _NOOP          := new LogicOp($1505);
    private static _XOR           := new LogicOp($1506);
    private static _OR            := new LogicOp($1507);
    private static _NOR           := new LogicOp($1508);
    private static _EQUIV         := new LogicOp($1509);
    private static _INVERT        := new LogicOp($150A);
    private static _OR_REVERSE    := new LogicOp($150B);
    private static _COPY_INVERTED := new LogicOp($150C);
    private static _OR_INVERTED   := new LogicOp($150D);
    private static _NAND          := new LogicOp($150E);
    private static _SET           := new LogicOp($150F);
    
    public static property CLEAR:         LogicOp read _CLEAR;
    public static property &AND:          LogicOp read _AND;
    public static property AND_REVERSE:   LogicOp read _AND_REVERSE;
    public static property COPY:          LogicOp read _COPY;
    public static property AND_INVERTED:  LogicOp read _AND_INVERTED;
    public static property NOOP:          LogicOp read _NOOP;
    public static property &XOR:          LogicOp read _XOR;
    public static property &OR:           LogicOp read _OR;
    public static property NOR:           LogicOp read _NOR;
    public static property EQUIV:         LogicOp read _EQUIV;
    public static property INVERT:        LogicOp read _INVERT;
    public static property OR_REVERSE:    LogicOp read _OR_REVERSE;
    public static property COPY_INVERTED: LogicOp read _COPY_INVERTED;
    public static property OR_INVERTED:   LogicOp read _OR_INVERTED;
    public static property NAND:          LogicOp read _NAND;
    public static property &SET:          LogicOp read _SET;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1500) then Result := 'CLEAR' else
      if self.val = UInt32($1501) then Result := 'AND' else
      if self.val = UInt32($1502) then Result := 'AND_REVERSE' else
      if self.val = UInt32($1503) then Result := 'COPY' else
      if self.val = UInt32($1504) then Result := 'AND_INVERTED' else
      if self.val = UInt32($1505) then Result := 'NOOP' else
      if self.val = UInt32($1506) then Result := 'XOR' else
      if self.val = UInt32($1507) then Result := 'OR' else
      if self.val = UInt32($1508) then Result := 'NOR' else
      if self.val = UInt32($1509) then Result := 'EQUIV' else
      if self.val = UInt32($150A) then Result := 'INVERT' else
      if self.val = UInt32($150B) then Result := 'OR_REVERSE' else
      if self.val = UInt32($150C) then Result := 'COPY_INVERTED' else
      if self.val = UInt32($150D) then Result := 'OR_INVERTED' else
      if self.val = UInt32($150E) then Result := 'NAND' else
      if self.val = UInt32($150F) then Result := 'SET' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MapBufferAccessMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MAP_READ_BIT                  := new MapBufferAccessMask($0001);
    private static _MAP_READ_BIT_EXT              := new MapBufferAccessMask($0001);
    private static _MAP_WRITE_BIT                 := new MapBufferAccessMask($0002);
    private static _MAP_WRITE_BIT_EXT             := new MapBufferAccessMask($0002);
    private static _MAP_INVALIDATE_RANGE_BIT      := new MapBufferAccessMask($0004);
    private static _MAP_INVALIDATE_RANGE_BIT_EXT  := new MapBufferAccessMask($0004);
    private static _MAP_INVALIDATE_BUFFER_BIT     := new MapBufferAccessMask($0008);
    private static _MAP_INVALIDATE_BUFFER_BIT_EXT := new MapBufferAccessMask($0008);
    private static _MAP_FLUSH_EXPLICIT_BIT        := new MapBufferAccessMask($0010);
    private static _MAP_FLUSH_EXPLICIT_BIT_EXT    := new MapBufferAccessMask($0010);
    private static _MAP_UNSYNCHRONIZED_BIT        := new MapBufferAccessMask($0020);
    private static _MAP_UNSYNCHRONIZED_BIT_EXT    := new MapBufferAccessMask($0020);
    private static _MAP_PERSISTENT_BIT            := new MapBufferAccessMask($0040);
    private static _MAP_PERSISTENT_BIT_EXT        := new MapBufferAccessMask($0040);
    private static _MAP_COHERENT_BIT              := new MapBufferAccessMask($0080);
    private static _MAP_COHERENT_BIT_EXT          := new MapBufferAccessMask($0080);
    
    public static property MAP_READ_BIT:                  MapBufferAccessMask read _MAP_READ_BIT;
    public static property MAP_READ_BIT_EXT:              MapBufferAccessMask read _MAP_READ_BIT_EXT;
    public static property MAP_WRITE_BIT:                 MapBufferAccessMask read _MAP_WRITE_BIT;
    public static property MAP_WRITE_BIT_EXT:             MapBufferAccessMask read _MAP_WRITE_BIT_EXT;
    public static property MAP_INVALIDATE_RANGE_BIT:      MapBufferAccessMask read _MAP_INVALIDATE_RANGE_BIT;
    public static property MAP_INVALIDATE_RANGE_BIT_EXT:  MapBufferAccessMask read _MAP_INVALIDATE_RANGE_BIT_EXT;
    public static property MAP_INVALIDATE_BUFFER_BIT:     MapBufferAccessMask read _MAP_INVALIDATE_BUFFER_BIT;
    public static property MAP_INVALIDATE_BUFFER_BIT_EXT: MapBufferAccessMask read _MAP_INVALIDATE_BUFFER_BIT_EXT;
    public static property MAP_FLUSH_EXPLICIT_BIT:        MapBufferAccessMask read _MAP_FLUSH_EXPLICIT_BIT;
    public static property MAP_FLUSH_EXPLICIT_BIT_EXT:    MapBufferAccessMask read _MAP_FLUSH_EXPLICIT_BIT_EXT;
    public static property MAP_UNSYNCHRONIZED_BIT:        MapBufferAccessMask read _MAP_UNSYNCHRONIZED_BIT;
    public static property MAP_UNSYNCHRONIZED_BIT_EXT:    MapBufferAccessMask read _MAP_UNSYNCHRONIZED_BIT_EXT;
    public static property MAP_PERSISTENT_BIT:            MapBufferAccessMask read _MAP_PERSISTENT_BIT;
    public static property MAP_PERSISTENT_BIT_EXT:        MapBufferAccessMask read _MAP_PERSISTENT_BIT_EXT;
    public static property MAP_COHERENT_BIT:              MapBufferAccessMask read _MAP_COHERENT_BIT;
    public static property MAP_COHERENT_BIT_EXT:          MapBufferAccessMask read _MAP_COHERENT_BIT_EXT;
    
    public static function operator or(f1,f2: MapBufferAccessMask) := new MapBufferAccessMask(f1.val or f2.val);
    
    public property HAS_FLAG_MAP_READ_BIT:                  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_MAP_READ_BIT_EXT:              boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_MAP_WRITE_BIT:                 boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_MAP_WRITE_BIT_EXT:             boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_MAP_INVALIDATE_RANGE_BIT:      boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_MAP_INVALIDATE_RANGE_BIT_EXT:  boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_MAP_INVALIDATE_BUFFER_BIT:     boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_MAP_INVALIDATE_BUFFER_BIT_EXT: boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_MAP_FLUSH_EXPLICIT_BIT:        boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_MAP_FLUSH_EXPLICIT_BIT_EXT:    boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_MAP_UNSYNCHRONIZED_BIT:        boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_MAP_UNSYNCHRONIZED_BIT_EXT:    boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_MAP_PERSISTENT_BIT:            boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_MAP_PERSISTENT_BIT_EXT:        boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_MAP_COHERENT_BIT:              boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_MAP_COHERENT_BIT_EXT:          boolean read self.val and $0080 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'MAP_READ_BIT+';
      if self.val and UInt32($0001) = UInt32($0001) then res += 'MAP_READ_BIT_EXT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'MAP_WRITE_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'MAP_WRITE_BIT_EXT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'MAP_INVALIDATE_RANGE_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'MAP_INVALIDATE_RANGE_BIT_EXT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'MAP_INVALIDATE_BUFFER_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'MAP_INVALIDATE_BUFFER_BIT_EXT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'MAP_FLUSH_EXPLICIT_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'MAP_FLUSH_EXPLICIT_BIT_EXT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'MAP_UNSYNCHRONIZED_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'MAP_UNSYNCHRONIZED_BIT_EXT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MAP_PERSISTENT_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MAP_PERSISTENT_BIT_EXT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'MAP_COHERENT_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'MAP_COHERENT_BIT_EXT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  MapQuery = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COEFF  := new MapQuery($0A00);
    private static _ORDER  := new MapQuery($0A01);
    private static _DOMAIN := new MapQuery($0A02);
    
    public static property COEFF:  MapQuery read _COEFF;
    public static property ORDER:  MapQuery read _ORDER;
    public static property DOMAIN: MapQuery read _DOMAIN;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0A00) then Result := 'COEFF' else
      if self.val = UInt32($0A01) then Result := 'ORDER' else
      if self.val = UInt32($0A02) then Result := 'DOMAIN' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MapTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MAP1_COLOR_4              := new MapTarget($0D90);
    private static _MAP1_INDEX                := new MapTarget($0D91);
    private static _MAP1_NORMAL               := new MapTarget($0D92);
    private static _MAP1_TEXTURE_COORD_1      := new MapTarget($0D93);
    private static _MAP1_TEXTURE_COORD_2      := new MapTarget($0D94);
    private static _MAP1_TEXTURE_COORD_3      := new MapTarget($0D95);
    private static _MAP1_TEXTURE_COORD_4      := new MapTarget($0D96);
    private static _MAP1_VERTEX_3             := new MapTarget($0D97);
    private static _MAP1_VERTEX_4             := new MapTarget($0D98);
    private static _MAP2_COLOR_4              := new MapTarget($0DB0);
    private static _MAP2_INDEX                := new MapTarget($0DB1);
    private static _MAP2_NORMAL               := new MapTarget($0DB2);
    private static _MAP2_TEXTURE_COORD_1      := new MapTarget($0DB3);
    private static _MAP2_TEXTURE_COORD_2      := new MapTarget($0DB4);
    private static _MAP2_TEXTURE_COORD_3      := new MapTarget($0DB5);
    private static _MAP2_TEXTURE_COORD_4      := new MapTarget($0DB6);
    private static _MAP2_VERTEX_3             := new MapTarget($0DB7);
    private static _MAP2_VERTEX_4             := new MapTarget($0DB8);
    private static _GEOMETRY_DEFORMATION_SGIX := new MapTarget($8194);
    private static _TEXTURE_DEFORMATION_SGIX  := new MapTarget($8195);
    
    public static property MAP1_COLOR_4:              MapTarget read _MAP1_COLOR_4;
    public static property MAP1_INDEX:                MapTarget read _MAP1_INDEX;
    public static property MAP1_NORMAL:               MapTarget read _MAP1_NORMAL;
    public static property MAP1_TEXTURE_COORD_1:      MapTarget read _MAP1_TEXTURE_COORD_1;
    public static property MAP1_TEXTURE_COORD_2:      MapTarget read _MAP1_TEXTURE_COORD_2;
    public static property MAP1_TEXTURE_COORD_3:      MapTarget read _MAP1_TEXTURE_COORD_3;
    public static property MAP1_TEXTURE_COORD_4:      MapTarget read _MAP1_TEXTURE_COORD_4;
    public static property MAP1_VERTEX_3:             MapTarget read _MAP1_VERTEX_3;
    public static property MAP1_VERTEX_4:             MapTarget read _MAP1_VERTEX_4;
    public static property MAP2_COLOR_4:              MapTarget read _MAP2_COLOR_4;
    public static property MAP2_INDEX:                MapTarget read _MAP2_INDEX;
    public static property MAP2_NORMAL:               MapTarget read _MAP2_NORMAL;
    public static property MAP2_TEXTURE_COORD_1:      MapTarget read _MAP2_TEXTURE_COORD_1;
    public static property MAP2_TEXTURE_COORD_2:      MapTarget read _MAP2_TEXTURE_COORD_2;
    public static property MAP2_TEXTURE_COORD_3:      MapTarget read _MAP2_TEXTURE_COORD_3;
    public static property MAP2_TEXTURE_COORD_4:      MapTarget read _MAP2_TEXTURE_COORD_4;
    public static property MAP2_VERTEX_3:             MapTarget read _MAP2_VERTEX_3;
    public static property MAP2_VERTEX_4:             MapTarget read _MAP2_VERTEX_4;
    public static property GEOMETRY_DEFORMATION_SGIX: MapTarget read _GEOMETRY_DEFORMATION_SGIX;
    public static property TEXTURE_DEFORMATION_SGIX:  MapTarget read _TEXTURE_DEFORMATION_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0D90) then Result := 'MAP1_COLOR_4' else
      if self.val = UInt32($0D91) then Result := 'MAP1_INDEX' else
      if self.val = UInt32($0D92) then Result := 'MAP1_NORMAL' else
      if self.val = UInt32($0D93) then Result := 'MAP1_TEXTURE_COORD_1' else
      if self.val = UInt32($0D94) then Result := 'MAP1_TEXTURE_COORD_2' else
      if self.val = UInt32($0D95) then Result := 'MAP1_TEXTURE_COORD_3' else
      if self.val = UInt32($0D96) then Result := 'MAP1_TEXTURE_COORD_4' else
      if self.val = UInt32($0D97) then Result := 'MAP1_VERTEX_3' else
      if self.val = UInt32($0D98) then Result := 'MAP1_VERTEX_4' else
      if self.val = UInt32($0DB0) then Result := 'MAP2_COLOR_4' else
      if self.val = UInt32($0DB1) then Result := 'MAP2_INDEX' else
      if self.val = UInt32($0DB2) then Result := 'MAP2_NORMAL' else
      if self.val = UInt32($0DB3) then Result := 'MAP2_TEXTURE_COORD_1' else
      if self.val = UInt32($0DB4) then Result := 'MAP2_TEXTURE_COORD_2' else
      if self.val = UInt32($0DB5) then Result := 'MAP2_TEXTURE_COORD_3' else
      if self.val = UInt32($0DB6) then Result := 'MAP2_TEXTURE_COORD_4' else
      if self.val = UInt32($0DB7) then Result := 'MAP2_VERTEX_3' else
      if self.val = UInt32($0DB8) then Result := 'MAP2_VERTEX_4' else
      if self.val = UInt32($8194) then Result := 'GEOMETRY_DEFORMATION_SGIX' else
      if self.val = UInt32($8195) then Result := 'TEXTURE_DEFORMATION_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MaterialFace = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRONT          := new MaterialFace($0404);
    private static _BACK           := new MaterialFace($0405);
    private static _FRONT_AND_BACK := new MaterialFace($0408);
    
    public static property FRONT:          MaterialFace read _FRONT;
    public static property BACK:           MaterialFace read _BACK;
    public static property FRONT_AND_BACK: MaterialFace read _FRONT_AND_BACK;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MaterialParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _AMBIENT             := new MaterialParameter($1200);
    private static _DIFFUSE             := new MaterialParameter($1201);
    private static _SPECULAR            := new MaterialParameter($1202);
    private static _EMISSION            := new MaterialParameter($1600);
    private static _SHININESS           := new MaterialParameter($1601);
    private static _AMBIENT_AND_DIFFUSE := new MaterialParameter($1602);
    private static _COLOR_INDEXES       := new MaterialParameter($1603);
    
    public static property AMBIENT:             MaterialParameter read _AMBIENT;
    public static property DIFFUSE:             MaterialParameter read _DIFFUSE;
    public static property SPECULAR:            MaterialParameter read _SPECULAR;
    public static property EMISSION:            MaterialParameter read _EMISSION;
    public static property SHININESS:           MaterialParameter read _SHININESS;
    public static property AMBIENT_AND_DIFFUSE: MaterialParameter read _AMBIENT_AND_DIFFUSE;
    public static property COLOR_INDEXES:       MaterialParameter read _COLOR_INDEXES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1200) then Result := 'AMBIENT' else
      if self.val = UInt32($1201) then Result := 'DIFFUSE' else
      if self.val = UInt32($1202) then Result := 'SPECULAR' else
      if self.val = UInt32($1600) then Result := 'EMISSION' else
      if self.val = UInt32($1601) then Result := 'SHININESS' else
      if self.val = UInt32($1602) then Result := 'AMBIENT_AND_DIFFUSE' else
      if self.val = UInt32($1603) then Result := 'COLOR_INDEXES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MatrixMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MODELVIEW      := new MatrixMode($1700);
    private static _MODELVIEW0_EXT := new MatrixMode($1700);
    private static _PROJECTION     := new MatrixMode($1701);
    private static _TEXTURE        := new MatrixMode($1702);
    
    public static property MODELVIEW:      MatrixMode read _MODELVIEW;
    public static property MODELVIEW0_EXT: MatrixMode read _MODELVIEW0_EXT;
    public static property PROJECTION:     MatrixMode read _PROJECTION;
    public static property TEXTURE:        MatrixMode read _TEXTURE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1700) then Result := 'MODELVIEW' else
      if self.val = UInt32($1700) then Result := 'MODELVIEW0_EXT' else
      if self.val = UInt32($1701) then Result := 'PROJECTION' else
      if self.val = UInt32($1702) then Result := 'TEXTURE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MemoryBarrierMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_ATTRIB_ARRAY_BARRIER_BIT      := new MemoryBarrierMask($0001);
    private static _VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT  := new MemoryBarrierMask($0001);
    private static _ELEMENT_ARRAY_BARRIER_BIT            := new MemoryBarrierMask($0002);
    private static _ELEMENT_ARRAY_BARRIER_BIT_EXT        := new MemoryBarrierMask($0002);
    private static _UNIFORM_BARRIER_BIT                  := new MemoryBarrierMask($0004);
    private static _UNIFORM_BARRIER_BIT_EXT              := new MemoryBarrierMask($0004);
    private static _TEXTURE_FETCH_BARRIER_BIT            := new MemoryBarrierMask($0008);
    private static _TEXTURE_FETCH_BARRIER_BIT_EXT        := new MemoryBarrierMask($0008);
    private static _SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV  := new MemoryBarrierMask($0010);
    private static _SHADER_IMAGE_ACCESS_BARRIER_BIT      := new MemoryBarrierMask($0020);
    private static _SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT  := new MemoryBarrierMask($0020);
    private static _COMMAND_BARRIER_BIT                  := new MemoryBarrierMask($0040);
    private static _COMMAND_BARRIER_BIT_EXT              := new MemoryBarrierMask($0040);
    private static _PIXEL_BUFFER_BARRIER_BIT             := new MemoryBarrierMask($0080);
    private static _PIXEL_BUFFER_BARRIER_BIT_EXT         := new MemoryBarrierMask($0080);
    private static _TEXTURE_UPDATE_BARRIER_BIT           := new MemoryBarrierMask($0100);
    private static _TEXTURE_UPDATE_BARRIER_BIT_EXT       := new MemoryBarrierMask($0100);
    private static _BUFFER_UPDATE_BARRIER_BIT            := new MemoryBarrierMask($0200);
    private static _BUFFER_UPDATE_BARRIER_BIT_EXT        := new MemoryBarrierMask($0200);
    private static _FRAMEBUFFER_BARRIER_BIT              := new MemoryBarrierMask($0400);
    private static _FRAMEBUFFER_BARRIER_BIT_EXT          := new MemoryBarrierMask($0400);
    private static _TRANSFORM_FEEDBACK_BARRIER_BIT       := new MemoryBarrierMask($0800);
    private static _TRANSFORM_FEEDBACK_BARRIER_BIT_EXT   := new MemoryBarrierMask($0800);
    private static _ATOMIC_COUNTER_BARRIER_BIT           := new MemoryBarrierMask($1000);
    private static _ATOMIC_COUNTER_BARRIER_BIT_EXT       := new MemoryBarrierMask($1000);
    private static _SHADER_STORAGE_BARRIER_BIT           := new MemoryBarrierMask($2000);
    private static _CLIENT_MAPPED_BUFFER_BARRIER_BIT     := new MemoryBarrierMask($4000);
    private static _CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT := new MemoryBarrierMask($4000);
    private static _QUERY_BUFFER_BARRIER_BIT             := new MemoryBarrierMask($8000);
    private static _ALL_BARRIER_BITS                     := new MemoryBarrierMask($FFFFFFFF);
    private static _ALL_BARRIER_BITS_EXT                 := new MemoryBarrierMask($FFFFFFFF);
    
    public static property VERTEX_ATTRIB_ARRAY_BARRIER_BIT:      MemoryBarrierMask read _VERTEX_ATTRIB_ARRAY_BARRIER_BIT;
    public static property VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT:  MemoryBarrierMask read _VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT;
    public static property ELEMENT_ARRAY_BARRIER_BIT:            MemoryBarrierMask read _ELEMENT_ARRAY_BARRIER_BIT;
    public static property ELEMENT_ARRAY_BARRIER_BIT_EXT:        MemoryBarrierMask read _ELEMENT_ARRAY_BARRIER_BIT_EXT;
    public static property UNIFORM_BARRIER_BIT:                  MemoryBarrierMask read _UNIFORM_BARRIER_BIT;
    public static property UNIFORM_BARRIER_BIT_EXT:              MemoryBarrierMask read _UNIFORM_BARRIER_BIT_EXT;
    public static property TEXTURE_FETCH_BARRIER_BIT:            MemoryBarrierMask read _TEXTURE_FETCH_BARRIER_BIT;
    public static property TEXTURE_FETCH_BARRIER_BIT_EXT:        MemoryBarrierMask read _TEXTURE_FETCH_BARRIER_BIT_EXT;
    public static property SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV:  MemoryBarrierMask read _SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV;
    public static property SHADER_IMAGE_ACCESS_BARRIER_BIT:      MemoryBarrierMask read _SHADER_IMAGE_ACCESS_BARRIER_BIT;
    public static property SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT:  MemoryBarrierMask read _SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT;
    public static property COMMAND_BARRIER_BIT:                  MemoryBarrierMask read _COMMAND_BARRIER_BIT;
    public static property COMMAND_BARRIER_BIT_EXT:              MemoryBarrierMask read _COMMAND_BARRIER_BIT_EXT;
    public static property PIXEL_BUFFER_BARRIER_BIT:             MemoryBarrierMask read _PIXEL_BUFFER_BARRIER_BIT;
    public static property PIXEL_BUFFER_BARRIER_BIT_EXT:         MemoryBarrierMask read _PIXEL_BUFFER_BARRIER_BIT_EXT;
    public static property TEXTURE_UPDATE_BARRIER_BIT:           MemoryBarrierMask read _TEXTURE_UPDATE_BARRIER_BIT;
    public static property TEXTURE_UPDATE_BARRIER_BIT_EXT:       MemoryBarrierMask read _TEXTURE_UPDATE_BARRIER_BIT_EXT;
    public static property BUFFER_UPDATE_BARRIER_BIT:            MemoryBarrierMask read _BUFFER_UPDATE_BARRIER_BIT;
    public static property BUFFER_UPDATE_BARRIER_BIT_EXT:        MemoryBarrierMask read _BUFFER_UPDATE_BARRIER_BIT_EXT;
    public static property FRAMEBUFFER_BARRIER_BIT:              MemoryBarrierMask read _FRAMEBUFFER_BARRIER_BIT;
    public static property FRAMEBUFFER_BARRIER_BIT_EXT:          MemoryBarrierMask read _FRAMEBUFFER_BARRIER_BIT_EXT;
    public static property TRANSFORM_FEEDBACK_BARRIER_BIT:       MemoryBarrierMask read _TRANSFORM_FEEDBACK_BARRIER_BIT;
    public static property TRANSFORM_FEEDBACK_BARRIER_BIT_EXT:   MemoryBarrierMask read _TRANSFORM_FEEDBACK_BARRIER_BIT_EXT;
    public static property ATOMIC_COUNTER_BARRIER_BIT:           MemoryBarrierMask read _ATOMIC_COUNTER_BARRIER_BIT;
    public static property ATOMIC_COUNTER_BARRIER_BIT_EXT:       MemoryBarrierMask read _ATOMIC_COUNTER_BARRIER_BIT_EXT;
    public static property SHADER_STORAGE_BARRIER_BIT:           MemoryBarrierMask read _SHADER_STORAGE_BARRIER_BIT;
    public static property CLIENT_MAPPED_BUFFER_BARRIER_BIT:     MemoryBarrierMask read _CLIENT_MAPPED_BUFFER_BARRIER_BIT;
    public static property CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT: MemoryBarrierMask read _CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT;
    public static property QUERY_BUFFER_BARRIER_BIT:             MemoryBarrierMask read _QUERY_BUFFER_BARRIER_BIT;
    public static property ALL_BARRIER_BITS:                     MemoryBarrierMask read _ALL_BARRIER_BITS;
    public static property ALL_BARRIER_BITS_EXT:                 MemoryBarrierMask read _ALL_BARRIER_BITS_EXT;
    
    public static function operator or(f1,f2: MemoryBarrierMask) := new MemoryBarrierMask(f1.val or f2.val);
    
    public property HAS_FLAG_VERTEX_ATTRIB_ARRAY_BARRIER_BIT:      boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT:  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_ELEMENT_ARRAY_BARRIER_BIT:            boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_ELEMENT_ARRAY_BARRIER_BIT_EXT:        boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_UNIFORM_BARRIER_BIT:                  boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_UNIFORM_BARRIER_BIT_EXT:              boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_TEXTURE_FETCH_BARRIER_BIT:            boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_TEXTURE_FETCH_BARRIER_BIT_EXT:        boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV:  boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_SHADER_IMAGE_ACCESS_BARRIER_BIT:      boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT:  boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_COMMAND_BARRIER_BIT:                  boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_COMMAND_BARRIER_BIT_EXT:              boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_PIXEL_BUFFER_BARRIER_BIT:             boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_PIXEL_BUFFER_BARRIER_BIT_EXT:         boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_TEXTURE_UPDATE_BARRIER_BIT:           boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_TEXTURE_UPDATE_BARRIER_BIT_EXT:       boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_BUFFER_UPDATE_BARRIER_BIT:            boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_BUFFER_UPDATE_BARRIER_BIT_EXT:        boolean read self.val and $0200 <> 0;
    public property HAS_FLAG_FRAMEBUFFER_BARRIER_BIT:              boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_FRAMEBUFFER_BARRIER_BIT_EXT:          boolean read self.val and $0400 <> 0;
    public property HAS_FLAG_TRANSFORM_FEEDBACK_BARRIER_BIT:       boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT:   boolean read self.val and $0800 <> 0;
    public property HAS_FLAG_ATOMIC_COUNTER_BARRIER_BIT:           boolean read self.val and $1000 <> 0;
    public property HAS_FLAG_ATOMIC_COUNTER_BARRIER_BIT_EXT:       boolean read self.val and $1000 <> 0;
    public property HAS_FLAG_SHADER_STORAGE_BARRIER_BIT:           boolean read self.val and $2000 <> 0;
    public property HAS_FLAG_CLIENT_MAPPED_BUFFER_BARRIER_BIT:     boolean read self.val and $4000 <> 0;
    public property HAS_FLAG_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT: boolean read self.val and $4000 <> 0;
    public property HAS_FLAG_QUERY_BUFFER_BARRIER_BIT:             boolean read self.val and $8000 <> 0;
    public property HAS_FLAG_ALL_BARRIER_BITS:                     boolean read self.val and $FFFFFFFF <> 0;
    public property HAS_FLAG_ALL_BARRIER_BITS_EXT:                 boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'VERTEX_ATTRIB_ARRAY_BARRIER_BIT+';
      if self.val and UInt32($0001) = UInt32($0001) then res += 'VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'ELEMENT_ARRAY_BARRIER_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'ELEMENT_ARRAY_BARRIER_BIT_EXT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'UNIFORM_BARRIER_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'UNIFORM_BARRIER_BIT_EXT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'TEXTURE_FETCH_BARRIER_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'TEXTURE_FETCH_BARRIER_BIT_EXT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'SHADER_IMAGE_ACCESS_BARRIER_BIT+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'COMMAND_BARRIER_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'COMMAND_BARRIER_BIT_EXT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'PIXEL_BUFFER_BARRIER_BIT+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'PIXEL_BUFFER_BARRIER_BIT_EXT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'TEXTURE_UPDATE_BARRIER_BIT+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'TEXTURE_UPDATE_BARRIER_BIT_EXT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'BUFFER_UPDATE_BARRIER_BIT+';
      if self.val and UInt32($0200) = UInt32($0200) then res += 'BUFFER_UPDATE_BARRIER_BIT_EXT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'FRAMEBUFFER_BARRIER_BIT+';
      if self.val and UInt32($0400) = UInt32($0400) then res += 'FRAMEBUFFER_BARRIER_BIT_EXT+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'TRANSFORM_FEEDBACK_BARRIER_BIT+';
      if self.val and UInt32($0800) = UInt32($0800) then res += 'TRANSFORM_FEEDBACK_BARRIER_BIT_EXT+';
      if self.val and UInt32($1000) = UInt32($1000) then res += 'ATOMIC_COUNTER_BARRIER_BIT+';
      if self.val and UInt32($1000) = UInt32($1000) then res += 'ATOMIC_COUNTER_BARRIER_BIT_EXT+';
      if self.val and UInt32($2000) = UInt32($2000) then res += 'SHADER_STORAGE_BARRIER_BIT+';
      if self.val and UInt32($4000) = UInt32($4000) then res += 'CLIENT_MAPPED_BUFFER_BARRIER_BIT+';
      if self.val and UInt32($4000) = UInt32($4000) then res += 'CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT+';
      if self.val and UInt32($8000) = UInt32($8000) then res += 'QUERY_BUFFER_BARRIER_BIT+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_BARRIER_BITS+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_BARRIER_BITS_EXT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  MemoryObjectParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DEDICATED_MEMORY_OBJECT_EXT := new MemoryObjectParameterName($9581);
    private static _PROTECTED_MEMORY_OBJECT_EXT := new MemoryObjectParameterName($959B);
    
    public static property DEDICATED_MEMORY_OBJECT_EXT: MemoryObjectParameterName read _DEDICATED_MEMORY_OBJECT_EXT;
    public static property PROTECTED_MEMORY_OBJECT_EXT: MemoryObjectParameterName read _PROTECTED_MEMORY_OBJECT_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9581) then Result := 'DEDICATED_MEMORY_OBJECT_EXT' else
      if self.val = UInt32($959B) then Result := 'PROTECTED_MEMORY_OBJECT_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MeshMode1 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _POINT := new MeshMode1($1B00);
    private static _LINE  := new MeshMode1($1B01);
    
    public static property POINT: MeshMode1 read _POINT;
    public static property LINE:  MeshMode1 read _LINE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B00) then Result := 'POINT' else
      if self.val = UInt32($1B01) then Result := 'LINE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MeshMode2 = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _POINT := new MeshMode2($1B00);
    private static _LINE  := new MeshMode2($1B01);
    private static _FILL  := new MeshMode2($1B02);
    
    public static property POINT: MeshMode2 read _POINT;
    public static property LINE:  MeshMode2 read _LINE;
    public static property FILL:  MeshMode2 read _FILL;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B00) then Result := 'POINT' else
      if self.val = UInt32($1B01) then Result := 'LINE' else
      if self.val = UInt32($1B02) then Result := 'FILL' else
        Result := self.val.ToString;
    end;
    
  end;
  
  NormalPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE   := new NormalPointerType($1400);
    private static _SHORT  := new NormalPointerType($1402);
    private static _INT    := new NormalPointerType($1404);
    private static _FLOAT  := new NormalPointerType($1406);
    private static _DOUBLE := new NormalPointerType($140A);
    
    public static property BYTE:   NormalPointerType read _BYTE;
    public static property SHORT:  NormalPointerType read _SHORT;
    public static property INT:    NormalPointerType read _INT;
    public static property FLOAT:  NormalPointerType read _FLOAT;
    public static property DOUBLE: NormalPointerType read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ObjectIdentifier = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE            := new ObjectIdentifier($1702);
    private static _VERTEX_ARRAY       := new ObjectIdentifier($8074);
    private static _BUFFER             := new ObjectIdentifier($82E0);
    private static _SHADER             := new ObjectIdentifier($82E1);
    private static _PROGRAM            := new ObjectIdentifier($82E2);
    private static _QUERY              := new ObjectIdentifier($82E3);
    private static _PROGRAM_PIPELINE   := new ObjectIdentifier($82E4);
    private static _SAMPLER            := new ObjectIdentifier($82E6);
    private static _FRAMEBUFFER        := new ObjectIdentifier($8D40);
    private static _RENDERBUFFER       := new ObjectIdentifier($8D41);
    private static _TRANSFORM_FEEDBACK := new ObjectIdentifier($8E22);
    
    public static property TEXTURE:            ObjectIdentifier read _TEXTURE;
    public static property VERTEX_ARRAY:       ObjectIdentifier read _VERTEX_ARRAY;
    public static property BUFFER:             ObjectIdentifier read _BUFFER;
    public static property SHADER:             ObjectIdentifier read _SHADER;
    public static property &PROGRAM:           ObjectIdentifier read _PROGRAM;
    public static property QUERY:              ObjectIdentifier read _QUERY;
    public static property PROGRAM_PIPELINE:   ObjectIdentifier read _PROGRAM_PIPELINE;
    public static property SAMPLER:            ObjectIdentifier read _SAMPLER;
    public static property FRAMEBUFFER:        ObjectIdentifier read _FRAMEBUFFER;
    public static property RENDERBUFFER:       ObjectIdentifier read _RENDERBUFFER;
    public static property TRANSFORM_FEEDBACK: ObjectIdentifier read _TRANSFORM_FEEDBACK;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1702) then Result := 'TEXTURE' else
      if self.val = UInt32($8074) then Result := 'VERTEX_ARRAY' else
      if self.val = UInt32($82E0) then Result := 'BUFFER' else
      if self.val = UInt32($82E1) then Result := 'SHADER' else
      if self.val = UInt32($82E2) then Result := 'PROGRAM' else
      if self.val = UInt32($82E3) then Result := 'QUERY' else
      if self.val = UInt32($82E4) then Result := 'PROGRAM_PIPELINE' else
      if self.val = UInt32($82E6) then Result := 'SAMPLER' else
      if self.val = UInt32($8D40) then Result := 'FRAMEBUFFER' else
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER' else
      if self.val = UInt32($8E22) then Result := 'TRANSFORM_FEEDBACK' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PatchParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PATCH_VERTICES            := new PatchParameterName($8E72);
    private static _PATCH_DEFAULT_INNER_LEVEL := new PatchParameterName($8E73);
    private static _PATCH_DEFAULT_OUTER_LEVEL := new PatchParameterName($8E74);
    
    public static property PATCH_VERTICES:            PatchParameterName read _PATCH_VERTICES;
    public static property PATCH_DEFAULT_INNER_LEVEL: PatchParameterName read _PATCH_DEFAULT_INNER_LEVEL;
    public static property PATCH_DEFAULT_OUTER_LEVEL: PatchParameterName read _PATCH_DEFAULT_OUTER_LEVEL;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E72) then Result := 'PATCH_VERTICES' else
      if self.val = UInt32($8E73) then Result := 'PATCH_DEFAULT_INNER_LEVEL' else
      if self.val = UInt32($8E74) then Result := 'PATCH_DEFAULT_OUTER_LEVEL' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathColor = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PRIMARY_COLOR_NV   := new PathColor($852C);
    private static _SECONDARY_COLOR_NV := new PathColor($852D);
    private static _PRIMARY_COLOR      := new PathColor($8577);
    
    public static property PRIMARY_COLOR_NV:   PathColor read _PRIMARY_COLOR_NV;
    public static property SECONDARY_COLOR_NV: PathColor read _SECONDARY_COLOR_NV;
    public static property PRIMARY_COLOR:      PathColor read _PRIMARY_COLOR;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($852C) then Result := 'PRIMARY_COLOR_NV' else
      if self.val = UInt32($852D) then Result := 'SECONDARY_COLOR_NV' else
      if self.val = UInt32($8577) then Result := 'PRIMARY_COLOR' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathColorFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE            := new PathColorFormat($0000);
    private static _ALPHA           := new PathColorFormat($1906);
    private static _RGB             := new PathColorFormat($1907);
    private static _RGBA            := new PathColorFormat($1908);
    private static _LUMINANCE       := new PathColorFormat($1909);
    private static _LUMINANCE_ALPHA := new PathColorFormat($190A);
    private static _INTENSITY       := new PathColorFormat($8049);
    
    public static property NONE:            PathColorFormat read _NONE;
    public static property ALPHA:           PathColorFormat read _ALPHA;
    public static property RGB:             PathColorFormat read _RGB;
    public static property RGBA:            PathColorFormat read _RGBA;
    public static property LUMINANCE:       PathColorFormat read _LUMINANCE;
    public static property LUMINANCE_ALPHA: PathColorFormat read _LUMINANCE_ALPHA;
    public static property INTENSITY:       PathColorFormat read _INTENSITY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
      if self.val = UInt32($1908) then Result := 'RGBA' else
      if self.val = UInt32($1909) then Result := 'LUMINANCE' else
      if self.val = UInt32($190A) then Result := 'LUMINANCE_ALPHA' else
      if self.val = UInt32($8049) then Result := 'INTENSITY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathCoordType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CLOSE_PATH_NV                         := new PathCoordType($0000);
    private static _MOVE_TO_NV                            := new PathCoordType($0002);
    private static _RELATIVE_MOVE_TO_NV                   := new PathCoordType($0003);
    private static _LINE_TO_NV                            := new PathCoordType($0004);
    private static _RELATIVE_LINE_TO_NV                   := new PathCoordType($0005);
    private static _HORIZONTAL_LINE_TO_NV                 := new PathCoordType($0006);
    private static _RELATIVE_HORIZONTAL_LINE_TO_NV        := new PathCoordType($0007);
    private static _VERTICAL_LINE_TO_NV                   := new PathCoordType($0008);
    private static _RELATIVE_VERTICAL_LINE_TO_NV          := new PathCoordType($0009);
    private static _QUADRATIC_CURVE_TO_NV                 := new PathCoordType($000A);
    private static _RELATIVE_QUADRATIC_CURVE_TO_NV        := new PathCoordType($000B);
    private static _CUBIC_CURVE_TO_NV                     := new PathCoordType($000C);
    private static _RELATIVE_CUBIC_CURVE_TO_NV            := new PathCoordType($000D);
    private static _SMOOTH_QUADRATIC_CURVE_TO_NV          := new PathCoordType($000E);
    private static _RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV := new PathCoordType($000F);
    private static _SMOOTH_CUBIC_CURVE_TO_NV              := new PathCoordType($0010);
    private static _RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV     := new PathCoordType($0011);
    private static _SMALL_CCW_ARC_TO_NV                   := new PathCoordType($0012);
    private static _RELATIVE_SMALL_CCW_ARC_TO_NV          := new PathCoordType($0013);
    private static _SMALL_CW_ARC_TO_NV                    := new PathCoordType($0014);
    private static _RELATIVE_SMALL_CW_ARC_TO_NV           := new PathCoordType($0015);
    private static _LARGE_CCW_ARC_TO_NV                   := new PathCoordType($0016);
    private static _RELATIVE_LARGE_CCW_ARC_TO_NV          := new PathCoordType($0017);
    private static _LARGE_CW_ARC_TO_NV                    := new PathCoordType($0018);
    private static _RELATIVE_LARGE_CW_ARC_TO_NV           := new PathCoordType($0019);
    private static _CONIC_CURVE_TO_NV                     := new PathCoordType($001A);
    private static _RELATIVE_CONIC_CURVE_TO_NV            := new PathCoordType($001B);
    private static _ROUNDED_RECT_NV                       := new PathCoordType($00E8);
    private static _RELATIVE_ROUNDED_RECT_NV              := new PathCoordType($00E9);
    private static _ROUNDED_RECT2_NV                      := new PathCoordType($00EA);
    private static _RELATIVE_ROUNDED_RECT2_NV             := new PathCoordType($00EB);
    private static _ROUNDED_RECT4_NV                      := new PathCoordType($00EC);
    private static _RELATIVE_ROUNDED_RECT4_NV             := new PathCoordType($00ED);
    private static _ROUNDED_RECT8_NV                      := new PathCoordType($00EE);
    private static _RELATIVE_ROUNDED_RECT8_NV             := new PathCoordType($00EF);
    private static _RESTART_PATH_NV                       := new PathCoordType($00F0);
    private static _DUP_FIRST_CUBIC_CURVE_TO_NV           := new PathCoordType($00F2);
    private static _DUP_LAST_CUBIC_CURVE_TO_NV            := new PathCoordType($00F4);
    private static _RECT_NV                               := new PathCoordType($00F6);
    private static _RELATIVE_RECT_NV                      := new PathCoordType($00F7);
    private static _CIRCULAR_CCW_ARC_TO_NV                := new PathCoordType($00F8);
    private static _CIRCULAR_CW_ARC_TO_NV                 := new PathCoordType($00FA);
    private static _CIRCULAR_TANGENT_ARC_TO_NV            := new PathCoordType($00FC);
    private static _ARC_TO_NV                             := new PathCoordType($00FE);
    private static _RELATIVE_ARC_TO_NV                    := new PathCoordType($00FF);
    
    public static property CLOSE_PATH_NV:                         PathCoordType read _CLOSE_PATH_NV;
    public static property MOVE_TO_NV:                            PathCoordType read _MOVE_TO_NV;
    public static property RELATIVE_MOVE_TO_NV:                   PathCoordType read _RELATIVE_MOVE_TO_NV;
    public static property LINE_TO_NV:                            PathCoordType read _LINE_TO_NV;
    public static property RELATIVE_LINE_TO_NV:                   PathCoordType read _RELATIVE_LINE_TO_NV;
    public static property HORIZONTAL_LINE_TO_NV:                 PathCoordType read _HORIZONTAL_LINE_TO_NV;
    public static property RELATIVE_HORIZONTAL_LINE_TO_NV:        PathCoordType read _RELATIVE_HORIZONTAL_LINE_TO_NV;
    public static property VERTICAL_LINE_TO_NV:                   PathCoordType read _VERTICAL_LINE_TO_NV;
    public static property RELATIVE_VERTICAL_LINE_TO_NV:          PathCoordType read _RELATIVE_VERTICAL_LINE_TO_NV;
    public static property QUADRATIC_CURVE_TO_NV:                 PathCoordType read _QUADRATIC_CURVE_TO_NV;
    public static property RELATIVE_QUADRATIC_CURVE_TO_NV:        PathCoordType read _RELATIVE_QUADRATIC_CURVE_TO_NV;
    public static property CUBIC_CURVE_TO_NV:                     PathCoordType read _CUBIC_CURVE_TO_NV;
    public static property RELATIVE_CUBIC_CURVE_TO_NV:            PathCoordType read _RELATIVE_CUBIC_CURVE_TO_NV;
    public static property SMOOTH_QUADRATIC_CURVE_TO_NV:          PathCoordType read _SMOOTH_QUADRATIC_CURVE_TO_NV;
    public static property RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV: PathCoordType read _RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV;
    public static property SMOOTH_CUBIC_CURVE_TO_NV:              PathCoordType read _SMOOTH_CUBIC_CURVE_TO_NV;
    public static property RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV:     PathCoordType read _RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV;
    public static property SMALL_CCW_ARC_TO_NV:                   PathCoordType read _SMALL_CCW_ARC_TO_NV;
    public static property RELATIVE_SMALL_CCW_ARC_TO_NV:          PathCoordType read _RELATIVE_SMALL_CCW_ARC_TO_NV;
    public static property SMALL_CW_ARC_TO_NV:                    PathCoordType read _SMALL_CW_ARC_TO_NV;
    public static property RELATIVE_SMALL_CW_ARC_TO_NV:           PathCoordType read _RELATIVE_SMALL_CW_ARC_TO_NV;
    public static property LARGE_CCW_ARC_TO_NV:                   PathCoordType read _LARGE_CCW_ARC_TO_NV;
    public static property RELATIVE_LARGE_CCW_ARC_TO_NV:          PathCoordType read _RELATIVE_LARGE_CCW_ARC_TO_NV;
    public static property LARGE_CW_ARC_TO_NV:                    PathCoordType read _LARGE_CW_ARC_TO_NV;
    public static property RELATIVE_LARGE_CW_ARC_TO_NV:           PathCoordType read _RELATIVE_LARGE_CW_ARC_TO_NV;
    public static property CONIC_CURVE_TO_NV:                     PathCoordType read _CONIC_CURVE_TO_NV;
    public static property RELATIVE_CONIC_CURVE_TO_NV:            PathCoordType read _RELATIVE_CONIC_CURVE_TO_NV;
    public static property ROUNDED_RECT_NV:                       PathCoordType read _ROUNDED_RECT_NV;
    public static property RELATIVE_ROUNDED_RECT_NV:              PathCoordType read _RELATIVE_ROUNDED_RECT_NV;
    public static property ROUNDED_RECT2_NV:                      PathCoordType read _ROUNDED_RECT2_NV;
    public static property RELATIVE_ROUNDED_RECT2_NV:             PathCoordType read _RELATIVE_ROUNDED_RECT2_NV;
    public static property ROUNDED_RECT4_NV:                      PathCoordType read _ROUNDED_RECT4_NV;
    public static property RELATIVE_ROUNDED_RECT4_NV:             PathCoordType read _RELATIVE_ROUNDED_RECT4_NV;
    public static property ROUNDED_RECT8_NV:                      PathCoordType read _ROUNDED_RECT8_NV;
    public static property RELATIVE_ROUNDED_RECT8_NV:             PathCoordType read _RELATIVE_ROUNDED_RECT8_NV;
    public static property RESTART_PATH_NV:                       PathCoordType read _RESTART_PATH_NV;
    public static property DUP_FIRST_CUBIC_CURVE_TO_NV:           PathCoordType read _DUP_FIRST_CUBIC_CURVE_TO_NV;
    public static property DUP_LAST_CUBIC_CURVE_TO_NV:            PathCoordType read _DUP_LAST_CUBIC_CURVE_TO_NV;
    public static property RECT_NV:                               PathCoordType read _RECT_NV;
    public static property RELATIVE_RECT_NV:                      PathCoordType read _RELATIVE_RECT_NV;
    public static property CIRCULAR_CCW_ARC_TO_NV:                PathCoordType read _CIRCULAR_CCW_ARC_TO_NV;
    public static property CIRCULAR_CW_ARC_TO_NV:                 PathCoordType read _CIRCULAR_CW_ARC_TO_NV;
    public static property CIRCULAR_TANGENT_ARC_TO_NV:            PathCoordType read _CIRCULAR_TANGENT_ARC_TO_NV;
    public static property ARC_TO_NV:                             PathCoordType read _ARC_TO_NV;
    public static property RELATIVE_ARC_TO_NV:                    PathCoordType read _RELATIVE_ARC_TO_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'CLOSE_PATH_NV' else
      if self.val = UInt32($0002) then Result := 'MOVE_TO_NV' else
      if self.val = UInt32($0003) then Result := 'RELATIVE_MOVE_TO_NV' else
      if self.val = UInt32($0004) then Result := 'LINE_TO_NV' else
      if self.val = UInt32($0005) then Result := 'RELATIVE_LINE_TO_NV' else
      if self.val = UInt32($0006) then Result := 'HORIZONTAL_LINE_TO_NV' else
      if self.val = UInt32($0007) then Result := 'RELATIVE_HORIZONTAL_LINE_TO_NV' else
      if self.val = UInt32($0008) then Result := 'VERTICAL_LINE_TO_NV' else
      if self.val = UInt32($0009) then Result := 'RELATIVE_VERTICAL_LINE_TO_NV' else
      if self.val = UInt32($000A) then Result := 'QUADRATIC_CURVE_TO_NV' else
      if self.val = UInt32($000B) then Result := 'RELATIVE_QUADRATIC_CURVE_TO_NV' else
      if self.val = UInt32($000C) then Result := 'CUBIC_CURVE_TO_NV' else
      if self.val = UInt32($000D) then Result := 'RELATIVE_CUBIC_CURVE_TO_NV' else
      if self.val = UInt32($000E) then Result := 'SMOOTH_QUADRATIC_CURVE_TO_NV' else
      if self.val = UInt32($000F) then Result := 'RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV' else
      if self.val = UInt32($0010) then Result := 'SMOOTH_CUBIC_CURVE_TO_NV' else
      if self.val = UInt32($0011) then Result := 'RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV' else
      if self.val = UInt32($0012) then Result := 'SMALL_CCW_ARC_TO_NV' else
      if self.val = UInt32($0013) then Result := 'RELATIVE_SMALL_CCW_ARC_TO_NV' else
      if self.val = UInt32($0014) then Result := 'SMALL_CW_ARC_TO_NV' else
      if self.val = UInt32($0015) then Result := 'RELATIVE_SMALL_CW_ARC_TO_NV' else
      if self.val = UInt32($0016) then Result := 'LARGE_CCW_ARC_TO_NV' else
      if self.val = UInt32($0017) then Result := 'RELATIVE_LARGE_CCW_ARC_TO_NV' else
      if self.val = UInt32($0018) then Result := 'LARGE_CW_ARC_TO_NV' else
      if self.val = UInt32($0019) then Result := 'RELATIVE_LARGE_CW_ARC_TO_NV' else
      if self.val = UInt32($001A) then Result := 'CONIC_CURVE_TO_NV' else
      if self.val = UInt32($001B) then Result := 'RELATIVE_CONIC_CURVE_TO_NV' else
      if self.val = UInt32($00E8) then Result := 'ROUNDED_RECT_NV' else
      if self.val = UInt32($00E9) then Result := 'RELATIVE_ROUNDED_RECT_NV' else
      if self.val = UInt32($00EA) then Result := 'ROUNDED_RECT2_NV' else
      if self.val = UInt32($00EB) then Result := 'RELATIVE_ROUNDED_RECT2_NV' else
      if self.val = UInt32($00EC) then Result := 'ROUNDED_RECT4_NV' else
      if self.val = UInt32($00ED) then Result := 'RELATIVE_ROUNDED_RECT4_NV' else
      if self.val = UInt32($00EE) then Result := 'ROUNDED_RECT8_NV' else
      if self.val = UInt32($00EF) then Result := 'RELATIVE_ROUNDED_RECT8_NV' else
      if self.val = UInt32($00F0) then Result := 'RESTART_PATH_NV' else
      if self.val = UInt32($00F2) then Result := 'DUP_FIRST_CUBIC_CURVE_TO_NV' else
      if self.val = UInt32($00F4) then Result := 'DUP_LAST_CUBIC_CURVE_TO_NV' else
      if self.val = UInt32($00F6) then Result := 'RECT_NV' else
      if self.val = UInt32($00F7) then Result := 'RELATIVE_RECT_NV' else
      if self.val = UInt32($00F8) then Result := 'CIRCULAR_CCW_ARC_TO_NV' else
      if self.val = UInt32($00FA) then Result := 'CIRCULAR_CW_ARC_TO_NV' else
      if self.val = UInt32($00FC) then Result := 'CIRCULAR_TANGENT_ARC_TO_NV' else
      if self.val = UInt32($00FE) then Result := 'ARC_TO_NV' else
      if self.val = UInt32($00FF) then Result := 'RELATIVE_ARC_TO_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathCoverMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PATH_FILL_COVER_MODE_NV           := new PathCoverMode($9082);
    private static _CONVEX_HULL_NV                    := new PathCoverMode($908B);
    private static _BOUNDING_BOX_NV                   := new PathCoverMode($908D);
    private static _BOUNDING_BOX_OF_BOUNDING_BOXES_NV := new PathCoverMode($909C);
    
    public static property PATH_FILL_COVER_MODE_NV:           PathCoverMode read _PATH_FILL_COVER_MODE_NV;
    public static property CONVEX_HULL_NV:                    PathCoverMode read _CONVEX_HULL_NV;
    public static property BOUNDING_BOX_NV:                   PathCoverMode read _BOUNDING_BOX_NV;
    public static property BOUNDING_BOX_OF_BOUNDING_BOXES_NV: PathCoverMode read _BOUNDING_BOX_OF_BOUNDING_BOXES_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9082) then Result := 'PATH_FILL_COVER_MODE_NV' else
      if self.val = UInt32($908B) then Result := 'CONVEX_HULL_NV' else
      if self.val = UInt32($908D) then Result := 'BOUNDING_BOX_NV' else
      if self.val = UInt32($909C) then Result := 'BOUNDING_BOX_OF_BOUNDING_BOXES_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathElementType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UTF8_NV  := new PathElementType($909A);
    private static _UTF16_NV := new PathElementType($909B);
    
    public static property UTF8_NV:  PathElementType read _UTF8_NV;
    public static property UTF16_NV: PathElementType read _UTF16_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($909A) then Result := 'UTF8_NV' else
      if self.val = UInt32($909B) then Result := 'UTF16_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathFillMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _INVERT            := new PathFillMode($150A);
    private static _PATH_FILL_MODE_NV := new PathFillMode($9080);
    private static _COUNT_UP_NV       := new PathFillMode($9088);
    private static _COUNT_DOWN_NV     := new PathFillMode($9089);
    
    public static property INVERT:            PathFillMode read _INVERT;
    public static property PATH_FILL_MODE_NV: PathFillMode read _PATH_FILL_MODE_NV;
    public static property COUNT_UP_NV:       PathFillMode read _COUNT_UP_NV;
    public static property COUNT_DOWN_NV:     PathFillMode read _COUNT_DOWN_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($150A) then Result := 'INVERT' else
      if self.val = UInt32($9080) then Result := 'PATH_FILL_MODE_NV' else
      if self.val = UInt32($9088) then Result := 'COUNT_UP_NV' else
      if self.val = UInt32($9089) then Result := 'COUNT_DOWN_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathFontStyle = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE          := new PathFontStyle($0000);
    private static _BOLD_BIT_NV   := new PathFontStyle($0001);
    private static _ITALIC_BIT_NV := new PathFontStyle($0002);
    
    public static property NONE:          PathFontStyle read _NONE;
    public static property BOLD_BIT_NV:   PathFontStyle read _BOLD_BIT_NV;
    public static property ITALIC_BIT_NV: PathFontStyle read _ITALIC_BIT_NV;
    
    public static function operator or(f1,f2: PathFontStyle) := new PathFontStyle(f1.val or f2.val);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    public property HAS_FLAG_BOLD_BIT_NV:   boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_ITALIC_BIT_NV: boolean read self.val and $0002 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0000) = UInt32($0000) then res += 'NONE+';
      if self.val and UInt32($0001) = UInt32($0001) then res += 'BOLD_BIT_NV+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'ITALIC_BIT_NV+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathFontTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _STANDARD_FONT_NAME_NV := new PathFontTarget($9072);
    private static _SYSTEM_FONT_NAME_NV   := new PathFontTarget($9073);
    private static _FILE_NAME_NV          := new PathFontTarget($9074);
    
    public static property STANDARD_FONT_NAME_NV: PathFontTarget read _STANDARD_FONT_NAME_NV;
    public static property SYSTEM_FONT_NAME_NV:   PathFontTarget read _SYSTEM_FONT_NAME_NV;
    public static property FILE_NAME_NV:          PathFontTarget read _FILE_NAME_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9072) then Result := 'STANDARD_FONT_NAME_NV' else
      if self.val = UInt32($9073) then Result := 'SYSTEM_FONT_NAME_NV' else
      if self.val = UInt32($9074) then Result := 'FILE_NAME_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathGenMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE                        := new PathGenMode($0000);
    private static _EYE_LINEAR                  := new PathGenMode($2400);
    private static _OBJECT_LINEAR               := new PathGenMode($2401);
    private static _CONSTANT                    := new PathGenMode($8576);
    private static _PATH_OBJECT_BOUNDING_BOX_NV := new PathGenMode($908A);
    
    public static property NONE:                        PathGenMode read _NONE;
    public static property EYE_LINEAR:                  PathGenMode read _EYE_LINEAR;
    public static property OBJECT_LINEAR:               PathGenMode read _OBJECT_LINEAR;
    public static property CONSTANT:                    PathGenMode read _CONSTANT;
    public static property PATH_OBJECT_BOUNDING_BOX_NV: PathGenMode read _PATH_OBJECT_BOUNDING_BOX_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($2400) then Result := 'EYE_LINEAR' else
      if self.val = UInt32($2401) then Result := 'OBJECT_LINEAR' else
      if self.val = UInt32($8576) then Result := 'CONSTANT' else
      if self.val = UInt32($908A) then Result := 'PATH_OBJECT_BOUNDING_BOX_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathHandleMissingGlyphs = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SKIP_MISSING_GLYPH_NV := new PathHandleMissingGlyphs($90A9);
    private static _USE_MISSING_GLYPH_NV  := new PathHandleMissingGlyphs($90AA);
    
    public static property SKIP_MISSING_GLYPH_NV: PathHandleMissingGlyphs read _SKIP_MISSING_GLYPH_NV;
    public static property USE_MISSING_GLYPH_NV:  PathHandleMissingGlyphs read _USE_MISSING_GLYPH_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($90A9) then Result := 'SKIP_MISSING_GLYPH_NV' else
      if self.val = UInt32($90AA) then Result := 'USE_MISSING_GLYPH_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathListMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ACCUM_ADJACENT_PAIRS_NV := new PathListMode($90AD);
    private static _ADJACENT_PAIRS_NV       := new PathListMode($90AE);
    private static _FIRST_TO_REST_NV        := new PathListMode($90AF);
    
    public static property ACCUM_ADJACENT_PAIRS_NV: PathListMode read _ACCUM_ADJACENT_PAIRS_NV;
    public static property ADJACENT_PAIRS_NV:       PathListMode read _ADJACENT_PAIRS_NV;
    public static property FIRST_TO_REST_NV:        PathListMode read _FIRST_TO_REST_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($90AD) then Result := 'ACCUM_ADJACENT_PAIRS_NV' else
      if self.val = UInt32($90AE) then Result := 'ADJACENT_PAIRS_NV' else
      if self.val = UInt32($90AF) then Result := 'FIRST_TO_REST_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathMetricMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _GLYPH_WIDTH_BIT_NV                      := new PathMetricMask($0001);
    private static _GLYPH_HEIGHT_BIT_NV                     := new PathMetricMask($0002);
    private static _GLYPH_HORIZONTAL_BEARING_X_BIT_NV       := new PathMetricMask($0004);
    private static _GLYPH_HORIZONTAL_BEARING_Y_BIT_NV       := new PathMetricMask($0008);
    private static _GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV := new PathMetricMask($0010);
    private static _GLYPH_VERTICAL_BEARING_X_BIT_NV         := new PathMetricMask($0020);
    private static _GLYPH_VERTICAL_BEARING_Y_BIT_NV         := new PathMetricMask($0040);
    private static _GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV   := new PathMetricMask($0080);
    private static _GLYPH_HAS_KERNING_BIT_NV                := new PathMetricMask($0100);
    private static _FONT_X_MIN_BOUNDS_BIT_NV                := new PathMetricMask($10000);
    private static _FONT_Y_MIN_BOUNDS_BIT_NV                := new PathMetricMask($20000);
    private static _FONT_X_MAX_BOUNDS_BIT_NV                := new PathMetricMask($40000);
    private static _FONT_Y_MAX_BOUNDS_BIT_NV                := new PathMetricMask($80000);
    private static _FONT_UNITS_PER_EM_BIT_NV                := new PathMetricMask($100000);
    private static _FONT_ASCENDER_BIT_NV                    := new PathMetricMask($200000);
    private static _FONT_DESCENDER_BIT_NV                   := new PathMetricMask($400000);
    private static _FONT_HEIGHT_BIT_NV                      := new PathMetricMask($800000);
    private static _FONT_MAX_ADVANCE_WIDTH_BIT_NV           := new PathMetricMask($1000000);
    private static _FONT_MAX_ADVANCE_HEIGHT_BIT_NV          := new PathMetricMask($2000000);
    private static _FONT_UNDERLINE_POSITION_BIT_NV          := new PathMetricMask($4000000);
    private static _FONT_UNDERLINE_THICKNESS_BIT_NV         := new PathMetricMask($8000000);
    private static _FONT_HAS_KERNING_BIT_NV                 := new PathMetricMask($10000000);
    private static _FONT_NUM_GLYPH_INDICES_BIT_NV           := new PathMetricMask($20000000);
    
    public static property GLYPH_WIDTH_BIT_NV:                      PathMetricMask read _GLYPH_WIDTH_BIT_NV;
    public static property GLYPH_HEIGHT_BIT_NV:                     PathMetricMask read _GLYPH_HEIGHT_BIT_NV;
    public static property GLYPH_HORIZONTAL_BEARING_X_BIT_NV:       PathMetricMask read _GLYPH_HORIZONTAL_BEARING_X_BIT_NV;
    public static property GLYPH_HORIZONTAL_BEARING_Y_BIT_NV:       PathMetricMask read _GLYPH_HORIZONTAL_BEARING_Y_BIT_NV;
    public static property GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV: PathMetricMask read _GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV;
    public static property GLYPH_VERTICAL_BEARING_X_BIT_NV:         PathMetricMask read _GLYPH_VERTICAL_BEARING_X_BIT_NV;
    public static property GLYPH_VERTICAL_BEARING_Y_BIT_NV:         PathMetricMask read _GLYPH_VERTICAL_BEARING_Y_BIT_NV;
    public static property GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV:   PathMetricMask read _GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV;
    public static property GLYPH_HAS_KERNING_BIT_NV:                PathMetricMask read _GLYPH_HAS_KERNING_BIT_NV;
    public static property FONT_X_MIN_BOUNDS_BIT_NV:                PathMetricMask read _FONT_X_MIN_BOUNDS_BIT_NV;
    public static property FONT_Y_MIN_BOUNDS_BIT_NV:                PathMetricMask read _FONT_Y_MIN_BOUNDS_BIT_NV;
    public static property FONT_X_MAX_BOUNDS_BIT_NV:                PathMetricMask read _FONT_X_MAX_BOUNDS_BIT_NV;
    public static property FONT_Y_MAX_BOUNDS_BIT_NV:                PathMetricMask read _FONT_Y_MAX_BOUNDS_BIT_NV;
    public static property FONT_UNITS_PER_EM_BIT_NV:                PathMetricMask read _FONT_UNITS_PER_EM_BIT_NV;
    public static property FONT_ASCENDER_BIT_NV:                    PathMetricMask read _FONT_ASCENDER_BIT_NV;
    public static property FONT_DESCENDER_BIT_NV:                   PathMetricMask read _FONT_DESCENDER_BIT_NV;
    public static property FONT_HEIGHT_BIT_NV:                      PathMetricMask read _FONT_HEIGHT_BIT_NV;
    public static property FONT_MAX_ADVANCE_WIDTH_BIT_NV:           PathMetricMask read _FONT_MAX_ADVANCE_WIDTH_BIT_NV;
    public static property FONT_MAX_ADVANCE_HEIGHT_BIT_NV:          PathMetricMask read _FONT_MAX_ADVANCE_HEIGHT_BIT_NV;
    public static property FONT_UNDERLINE_POSITION_BIT_NV:          PathMetricMask read _FONT_UNDERLINE_POSITION_BIT_NV;
    public static property FONT_UNDERLINE_THICKNESS_BIT_NV:         PathMetricMask read _FONT_UNDERLINE_THICKNESS_BIT_NV;
    public static property FONT_HAS_KERNING_BIT_NV:                 PathMetricMask read _FONT_HAS_KERNING_BIT_NV;
    public static property FONT_NUM_GLYPH_INDICES_BIT_NV:           PathMetricMask read _FONT_NUM_GLYPH_INDICES_BIT_NV;
    
    public static function operator or(f1,f2: PathMetricMask) := new PathMetricMask(f1.val or f2.val);
    
    public property HAS_FLAG_GLYPH_WIDTH_BIT_NV:                      boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_GLYPH_HEIGHT_BIT_NV:                     boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_GLYPH_HORIZONTAL_BEARING_X_BIT_NV:       boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV:       boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV: boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_GLYPH_VERTICAL_BEARING_X_BIT_NV:         boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_GLYPH_VERTICAL_BEARING_Y_BIT_NV:         boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV:   boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_GLYPH_HAS_KERNING_BIT_NV:                boolean read self.val and $0100 <> 0;
    public property HAS_FLAG_FONT_X_MIN_BOUNDS_BIT_NV:                boolean read self.val and $10000 <> 0;
    public property HAS_FLAG_FONT_Y_MIN_BOUNDS_BIT_NV:                boolean read self.val and $20000 <> 0;
    public property HAS_FLAG_FONT_X_MAX_BOUNDS_BIT_NV:                boolean read self.val and $40000 <> 0;
    public property HAS_FLAG_FONT_Y_MAX_BOUNDS_BIT_NV:                boolean read self.val and $80000 <> 0;
    public property HAS_FLAG_FONT_UNITS_PER_EM_BIT_NV:                boolean read self.val and $100000 <> 0;
    public property HAS_FLAG_FONT_ASCENDER_BIT_NV:                    boolean read self.val and $200000 <> 0;
    public property HAS_FLAG_FONT_DESCENDER_BIT_NV:                   boolean read self.val and $400000 <> 0;
    public property HAS_FLAG_FONT_HEIGHT_BIT_NV:                      boolean read self.val and $800000 <> 0;
    public property HAS_FLAG_FONT_MAX_ADVANCE_WIDTH_BIT_NV:           boolean read self.val and $1000000 <> 0;
    public property HAS_FLAG_FONT_MAX_ADVANCE_HEIGHT_BIT_NV:          boolean read self.val and $2000000 <> 0;
    public property HAS_FLAG_FONT_UNDERLINE_POSITION_BIT_NV:          boolean read self.val and $4000000 <> 0;
    public property HAS_FLAG_FONT_UNDERLINE_THICKNESS_BIT_NV:         boolean read self.val and $8000000 <> 0;
    public property HAS_FLAG_FONT_HAS_KERNING_BIT_NV:                 boolean read self.val and $10000000 <> 0;
    public property HAS_FLAG_FONT_NUM_GLYPH_INDICES_BIT_NV:           boolean read self.val and $20000000 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'GLYPH_WIDTH_BIT_NV+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'GLYPH_HEIGHT_BIT_NV+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'GLYPH_HORIZONTAL_BEARING_X_BIT_NV+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'GLYPH_HORIZONTAL_BEARING_Y_BIT_NV+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'GLYPH_VERTICAL_BEARING_X_BIT_NV+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'GLYPH_VERTICAL_BEARING_Y_BIT_NV+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV+';
      if self.val and UInt32($0100) = UInt32($0100) then res += 'GLYPH_HAS_KERNING_BIT_NV+';
      if self.val and UInt32($10000) = UInt32($10000) then res += 'FONT_X_MIN_BOUNDS_BIT_NV+';
      if self.val and UInt32($20000) = UInt32($20000) then res += 'FONT_Y_MIN_BOUNDS_BIT_NV+';
      if self.val and UInt32($40000) = UInt32($40000) then res += 'FONT_X_MAX_BOUNDS_BIT_NV+';
      if self.val and UInt32($80000) = UInt32($80000) then res += 'FONT_Y_MAX_BOUNDS_BIT_NV+';
      if self.val and UInt32($100000) = UInt32($100000) then res += 'FONT_UNITS_PER_EM_BIT_NV+';
      if self.val and UInt32($200000) = UInt32($200000) then res += 'FONT_ASCENDER_BIT_NV+';
      if self.val and UInt32($400000) = UInt32($400000) then res += 'FONT_DESCENDER_BIT_NV+';
      if self.val and UInt32($800000) = UInt32($800000) then res += 'FONT_HEIGHT_BIT_NV+';
      if self.val and UInt32($1000000) = UInt32($1000000) then res += 'FONT_MAX_ADVANCE_WIDTH_BIT_NV+';
      if self.val and UInt32($2000000) = UInt32($2000000) then res += 'FONT_MAX_ADVANCE_HEIGHT_BIT_NV+';
      if self.val and UInt32($4000000) = UInt32($4000000) then res += 'FONT_UNDERLINE_POSITION_BIT_NV+';
      if self.val and UInt32($8000000) = UInt32($8000000) then res += 'FONT_UNDERLINE_THICKNESS_BIT_NV+';
      if self.val and UInt32($10000000) = UInt32($10000000) then res += 'FONT_HAS_KERNING_BIT_NV+';
      if self.val and UInt32($20000000) = UInt32($20000000) then res += 'FONT_NUM_GLYPH_INDICES_BIT_NV+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PATH_STROKE_WIDTH_NV        := new PathParameter($9075);
    private static _PATH_END_CAPS_NV            := new PathParameter($9076);
    private static _PATH_INITIAL_END_CAP_NV     := new PathParameter($9077);
    private static _PATH_TERMINAL_END_CAP_NV    := new PathParameter($9078);
    private static _PATH_JOIN_STYLE_NV          := new PathParameter($9079);
    private static _PATH_MITER_LIMIT_NV         := new PathParameter($907A);
    private static _PATH_DASH_CAPS_NV           := new PathParameter($907B);
    private static _PATH_INITIAL_DASH_CAP_NV    := new PathParameter($907C);
    private static _PATH_TERMINAL_DASH_CAP_NV   := new PathParameter($907D);
    private static _PATH_DASH_OFFSET_NV         := new PathParameter($907E);
    private static _PATH_CLIENT_LENGTH_NV       := new PathParameter($907F);
    private static _PATH_FILL_MODE_NV           := new PathParameter($9080);
    private static _PATH_FILL_MASK_NV           := new PathParameter($9081);
    private static _PATH_FILL_COVER_MODE_NV     := new PathParameter($9082);
    private static _PATH_STROKE_COVER_MODE_NV   := new PathParameter($9083);
    private static _PATH_STROKE_MASK_NV         := new PathParameter($9084);
    private static _PATH_OBJECT_BOUNDING_BOX_NV := new PathParameter($908A);
    private static _PATH_COMMAND_COUNT_NV       := new PathParameter($909D);
    private static _PATH_COORD_COUNT_NV         := new PathParameter($909E);
    private static _PATH_DASH_ARRAY_COUNT_NV    := new PathParameter($909F);
    private static _PATH_COMPUTED_LENGTH_NV     := new PathParameter($90A0);
    private static _PATH_FILL_BOUNDING_BOX_NV   := new PathParameter($90A1);
    private static _PATH_STROKE_BOUNDING_BOX_NV := new PathParameter($90A2);
    private static _PATH_DASH_OFFSET_RESET_NV   := new PathParameter($90B4);
    
    public static property PATH_STROKE_WIDTH_NV:        PathParameter read _PATH_STROKE_WIDTH_NV;
    public static property PATH_END_CAPS_NV:            PathParameter read _PATH_END_CAPS_NV;
    public static property PATH_INITIAL_END_CAP_NV:     PathParameter read _PATH_INITIAL_END_CAP_NV;
    public static property PATH_TERMINAL_END_CAP_NV:    PathParameter read _PATH_TERMINAL_END_CAP_NV;
    public static property PATH_JOIN_STYLE_NV:          PathParameter read _PATH_JOIN_STYLE_NV;
    public static property PATH_MITER_LIMIT_NV:         PathParameter read _PATH_MITER_LIMIT_NV;
    public static property PATH_DASH_CAPS_NV:           PathParameter read _PATH_DASH_CAPS_NV;
    public static property PATH_INITIAL_DASH_CAP_NV:    PathParameter read _PATH_INITIAL_DASH_CAP_NV;
    public static property PATH_TERMINAL_DASH_CAP_NV:   PathParameter read _PATH_TERMINAL_DASH_CAP_NV;
    public static property PATH_DASH_OFFSET_NV:         PathParameter read _PATH_DASH_OFFSET_NV;
    public static property PATH_CLIENT_LENGTH_NV:       PathParameter read _PATH_CLIENT_LENGTH_NV;
    public static property PATH_FILL_MODE_NV:           PathParameter read _PATH_FILL_MODE_NV;
    public static property PATH_FILL_MASK_NV:           PathParameter read _PATH_FILL_MASK_NV;
    public static property PATH_FILL_COVER_MODE_NV:     PathParameter read _PATH_FILL_COVER_MODE_NV;
    public static property PATH_STROKE_COVER_MODE_NV:   PathParameter read _PATH_STROKE_COVER_MODE_NV;
    public static property PATH_STROKE_MASK_NV:         PathParameter read _PATH_STROKE_MASK_NV;
    public static property PATH_OBJECT_BOUNDING_BOX_NV: PathParameter read _PATH_OBJECT_BOUNDING_BOX_NV;
    public static property PATH_COMMAND_COUNT_NV:       PathParameter read _PATH_COMMAND_COUNT_NV;
    public static property PATH_COORD_COUNT_NV:         PathParameter read _PATH_COORD_COUNT_NV;
    public static property PATH_DASH_ARRAY_COUNT_NV:    PathParameter read _PATH_DASH_ARRAY_COUNT_NV;
    public static property PATH_COMPUTED_LENGTH_NV:     PathParameter read _PATH_COMPUTED_LENGTH_NV;
    public static property PATH_FILL_BOUNDING_BOX_NV:   PathParameter read _PATH_FILL_BOUNDING_BOX_NV;
    public static property PATH_STROKE_BOUNDING_BOX_NV: PathParameter read _PATH_STROKE_BOUNDING_BOX_NV;
    public static property PATH_DASH_OFFSET_RESET_NV:   PathParameter read _PATH_DASH_OFFSET_RESET_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9075) then Result := 'PATH_STROKE_WIDTH_NV' else
      if self.val = UInt32($9076) then Result := 'PATH_END_CAPS_NV' else
      if self.val = UInt32($9077) then Result := 'PATH_INITIAL_END_CAP_NV' else
      if self.val = UInt32($9078) then Result := 'PATH_TERMINAL_END_CAP_NV' else
      if self.val = UInt32($9079) then Result := 'PATH_JOIN_STYLE_NV' else
      if self.val = UInt32($907A) then Result := 'PATH_MITER_LIMIT_NV' else
      if self.val = UInt32($907B) then Result := 'PATH_DASH_CAPS_NV' else
      if self.val = UInt32($907C) then Result := 'PATH_INITIAL_DASH_CAP_NV' else
      if self.val = UInt32($907D) then Result := 'PATH_TERMINAL_DASH_CAP_NV' else
      if self.val = UInt32($907E) then Result := 'PATH_DASH_OFFSET_NV' else
      if self.val = UInt32($907F) then Result := 'PATH_CLIENT_LENGTH_NV' else
      if self.val = UInt32($9080) then Result := 'PATH_FILL_MODE_NV' else
      if self.val = UInt32($9081) then Result := 'PATH_FILL_MASK_NV' else
      if self.val = UInt32($9082) then Result := 'PATH_FILL_COVER_MODE_NV' else
      if self.val = UInt32($9083) then Result := 'PATH_STROKE_COVER_MODE_NV' else
      if self.val = UInt32($9084) then Result := 'PATH_STROKE_MASK_NV' else
      if self.val = UInt32($908A) then Result := 'PATH_OBJECT_BOUNDING_BOX_NV' else
      if self.val = UInt32($909D) then Result := 'PATH_COMMAND_COUNT_NV' else
      if self.val = UInt32($909E) then Result := 'PATH_COORD_COUNT_NV' else
      if self.val = UInt32($909F) then Result := 'PATH_DASH_ARRAY_COUNT_NV' else
      if self.val = UInt32($90A0) then Result := 'PATH_COMPUTED_LENGTH_NV' else
      if self.val = UInt32($90A1) then Result := 'PATH_FILL_BOUNDING_BOX_NV' else
      if self.val = UInt32($90A2) then Result := 'PATH_STROKE_BOUNDING_BOX_NV' else
      if self.val = UInt32($90B4) then Result := 'PATH_DASH_OFFSET_RESET_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathStringFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PATH_FORMAT_SVG_NV := new PathStringFormat($9070);
    private static _PATH_FORMAT_PS_NV  := new PathStringFormat($9071);
    
    public static property PATH_FORMAT_SVG_NV: PathStringFormat read _PATH_FORMAT_SVG_NV;
    public static property PATH_FORMAT_PS_NV:  PathStringFormat read _PATH_FORMAT_PS_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9070) then Result := 'PATH_FORMAT_SVG_NV' else
      if self.val = UInt32($9071) then Result := 'PATH_FORMAT_PS_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PathTransformType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE                   := new PathTransformType($0000);
    private static _TRANSLATE_X_NV         := new PathTransformType($908E);
    private static _TRANSLATE_Y_NV         := new PathTransformType($908F);
    private static _TRANSLATE_2D_NV        := new PathTransformType($9090);
    private static _TRANSLATE_3D_NV        := new PathTransformType($9091);
    private static _AFFINE_2D_NV           := new PathTransformType($9092);
    private static _AFFINE_3D_NV           := new PathTransformType($9094);
    private static _TRANSPOSE_AFFINE_2D_NV := new PathTransformType($9096);
    private static _TRANSPOSE_AFFINE_3D_NV := new PathTransformType($9098);
    
    public static property NONE:                   PathTransformType read _NONE;
    public static property TRANSLATE_X_NV:         PathTransformType read _TRANSLATE_X_NV;
    public static property TRANSLATE_Y_NV:         PathTransformType read _TRANSLATE_Y_NV;
    public static property TRANSLATE_2D_NV:        PathTransformType read _TRANSLATE_2D_NV;
    public static property TRANSLATE_3D_NV:        PathTransformType read _TRANSLATE_3D_NV;
    public static property AFFINE_2D_NV:           PathTransformType read _AFFINE_2D_NV;
    public static property AFFINE_3D_NV:           PathTransformType read _AFFINE_3D_NV;
    public static property TRANSPOSE_AFFINE_2D_NV: PathTransformType read _TRANSPOSE_AFFINE_2D_NV;
    public static property TRANSPOSE_AFFINE_3D_NV: PathTransformType read _TRANSPOSE_AFFINE_3D_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($908E) then Result := 'TRANSLATE_X_NV' else
      if self.val = UInt32($908F) then Result := 'TRANSLATE_Y_NV' else
      if self.val = UInt32($9090) then Result := 'TRANSLATE_2D_NV' else
      if self.val = UInt32($9091) then Result := 'TRANSLATE_3D_NV' else
      if self.val = UInt32($9092) then Result := 'AFFINE_2D_NV' else
      if self.val = UInt32($9094) then Result := 'AFFINE_3D_NV' else
      if self.val = UInt32($9096) then Result := 'TRANSPOSE_AFFINE_2D_NV' else
      if self.val = UInt32($9098) then Result := 'TRANSPOSE_AFFINE_3D_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PipelineParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ACTIVE_PROGRAM         := new PipelineParameterName($8259);
    private static _FRAGMENT_SHADER        := new PipelineParameterName($8B30);
    private static _VERTEX_SHADER          := new PipelineParameterName($8B31);
    private static _INFO_LOG_LENGTH        := new PipelineParameterName($8B84);
    private static _GEOMETRY_SHADER        := new PipelineParameterName($8DD9);
    private static _TESS_EVALUATION_SHADER := new PipelineParameterName($8E87);
    private static _TESS_CONTROL_SHADER    := new PipelineParameterName($8E88);
    
    public static property ACTIVE_PROGRAM:         PipelineParameterName read _ACTIVE_PROGRAM;
    public static property FRAGMENT_SHADER:        PipelineParameterName read _FRAGMENT_SHADER;
    public static property VERTEX_SHADER:          PipelineParameterName read _VERTEX_SHADER;
    public static property INFO_LOG_LENGTH:        PipelineParameterName read _INFO_LOG_LENGTH;
    public static property GEOMETRY_SHADER:        PipelineParameterName read _GEOMETRY_SHADER;
    public static property TESS_EVALUATION_SHADER: PipelineParameterName read _TESS_EVALUATION_SHADER;
    public static property TESS_CONTROL_SHADER:    PipelineParameterName read _TESS_CONTROL_SHADER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8259) then Result := 'ACTIVE_PROGRAM' else
      if self.val = UInt32($8B30) then Result := 'FRAGMENT_SHADER' else
      if self.val = UInt32($8B31) then Result := 'VERTEX_SHADER' else
      if self.val = UInt32($8B84) then Result := 'INFO_LOG_LENGTH' else
      if self.val = UInt32($8DD9) then Result := 'GEOMETRY_SHADER' else
      if self.val = UInt32($8E87) then Result := 'TESS_EVALUATION_SHADER' else
      if self.val = UInt32($8E88) then Result := 'TESS_CONTROL_SHADER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelCopyType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COLOR       := new PixelCopyType($1800);
    private static _COLOR_EXT   := new PixelCopyType($1800);
    private static _DEPTH       := new PixelCopyType($1801);
    private static _DEPTH_EXT   := new PixelCopyType($1801);
    private static _STENCIL     := new PixelCopyType($1802);
    private static _STENCIL_EXT := new PixelCopyType($1802);
    
    public static property COLOR:       PixelCopyType read _COLOR;
    public static property COLOR_EXT:   PixelCopyType read _COLOR_EXT;
    public static property DEPTH:       PixelCopyType read _DEPTH;
    public static property DEPTH_EXT:   PixelCopyType read _DEPTH_EXT;
    public static property STENCIL:     PixelCopyType read _STENCIL;
    public static property STENCIL_EXT: PixelCopyType read _STENCIL_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1800) then Result := 'COLOR' else
      if self.val = UInt32($1800) then Result := 'COLOR_EXT' else
      if self.val = UInt32($1801) then Result := 'DEPTH' else
      if self.val = UInt32($1801) then Result := 'DEPTH_EXT' else
      if self.val = UInt32($1802) then Result := 'STENCIL' else
      if self.val = UInt32($1802) then Result := 'STENCIL_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNSIGNED_SHORT  := new PixelFormat($1403);
    private static _UNSIGNED_INT    := new PixelFormat($1405);
    private static _COLOR_INDEX     := new PixelFormat($1900);
    private static _STENCIL_INDEX   := new PixelFormat($1901);
    private static _DEPTH_COMPONENT := new PixelFormat($1902);
    private static _RED             := new PixelFormat($1903);
    private static _RED_EXT         := new PixelFormat($1903);
    private static _GREEN           := new PixelFormat($1904);
    private static _BLUE            := new PixelFormat($1905);
    private static _ALPHA           := new PixelFormat($1906);
    private static _RGB             := new PixelFormat($1907);
    private static _RGBA            := new PixelFormat($1908);
    private static _LUMINANCE       := new PixelFormat($1909);
    private static _LUMINANCE_ALPHA := new PixelFormat($190A);
    private static _ABGR_EXT        := new PixelFormat($8000);
    private static _CMYK_EXT        := new PixelFormat($800C);
    private static _CMYKA_EXT       := new PixelFormat($800D);
    private static _BGR             := new PixelFormat($80E0);
    private static _BGRA            := new PixelFormat($80E1);
    private static _YCRCB_422_SGIX  := new PixelFormat($81BB);
    private static _YCRCB_444_SGIX  := new PixelFormat($81BC);
    private static _RG              := new PixelFormat($8227);
    private static _RG_INTEGER      := new PixelFormat($8228);
    private static _DEPTH_STENCIL   := new PixelFormat($84F9);
    private static _RED_INTEGER     := new PixelFormat($8D94);
    private static _GREEN_INTEGER   := new PixelFormat($8D95);
    private static _BLUE_INTEGER    := new PixelFormat($8D96);
    private static _RGB_INTEGER     := new PixelFormat($8D98);
    private static _RGBA_INTEGER    := new PixelFormat($8D99);
    private static _BGR_INTEGER     := new PixelFormat($8D9A);
    private static _BGRA_INTEGER    := new PixelFormat($8D9B);
    
    public static property UNSIGNED_SHORT:  PixelFormat read _UNSIGNED_SHORT;
    public static property UNSIGNED_INT:    PixelFormat read _UNSIGNED_INT;
    public static property COLOR_INDEX:     PixelFormat read _COLOR_INDEX;
    public static property STENCIL_INDEX:   PixelFormat read _STENCIL_INDEX;
    public static property DEPTH_COMPONENT: PixelFormat read _DEPTH_COMPONENT;
    public static property RED:             PixelFormat read _RED;
    public static property RED_EXT:         PixelFormat read _RED_EXT;
    public static property GREEN:           PixelFormat read _GREEN;
    public static property BLUE:            PixelFormat read _BLUE;
    public static property ALPHA:           PixelFormat read _ALPHA;
    public static property RGB:             PixelFormat read _RGB;
    public static property RGBA:            PixelFormat read _RGBA;
    public static property LUMINANCE:       PixelFormat read _LUMINANCE;
    public static property LUMINANCE_ALPHA: PixelFormat read _LUMINANCE_ALPHA;
    public static property ABGR_EXT:        PixelFormat read _ABGR_EXT;
    public static property CMYK_EXT:        PixelFormat read _CMYK_EXT;
    public static property CMYKA_EXT:       PixelFormat read _CMYKA_EXT;
    public static property BGR:             PixelFormat read _BGR;
    public static property BGRA:            PixelFormat read _BGRA;
    public static property YCRCB_422_SGIX:  PixelFormat read _YCRCB_422_SGIX;
    public static property YCRCB_444_SGIX:  PixelFormat read _YCRCB_444_SGIX;
    public static property RG:              PixelFormat read _RG;
    public static property RG_INTEGER:      PixelFormat read _RG_INTEGER;
    public static property DEPTH_STENCIL:   PixelFormat read _DEPTH_STENCIL;
    public static property RED_INTEGER:     PixelFormat read _RED_INTEGER;
    public static property GREEN_INTEGER:   PixelFormat read _GREEN_INTEGER;
    public static property BLUE_INTEGER:    PixelFormat read _BLUE_INTEGER;
    public static property RGB_INTEGER:     PixelFormat read _RGB_INTEGER;
    public static property RGBA_INTEGER:    PixelFormat read _RGBA_INTEGER;
    public static property BGR_INTEGER:     PixelFormat read _BGR_INTEGER;
    public static property BGRA_INTEGER:    PixelFormat read _BGRA_INTEGER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1900) then Result := 'COLOR_INDEX' else
      if self.val = UInt32($1901) then Result := 'STENCIL_INDEX' else
      if self.val = UInt32($1902) then Result := 'DEPTH_COMPONENT' else
      if self.val = UInt32($1903) then Result := 'RED' else
      if self.val = UInt32($1903) then Result := 'RED_EXT' else
      if self.val = UInt32($1904) then Result := 'GREEN' else
      if self.val = UInt32($1905) then Result := 'BLUE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
      if self.val = UInt32($1908) then Result := 'RGBA' else
      if self.val = UInt32($1909) then Result := 'LUMINANCE' else
      if self.val = UInt32($190A) then Result := 'LUMINANCE_ALPHA' else
      if self.val = UInt32($8000) then Result := 'ABGR_EXT' else
      if self.val = UInt32($800C) then Result := 'CMYK_EXT' else
      if self.val = UInt32($800D) then Result := 'CMYKA_EXT' else
      if self.val = UInt32($80E0) then Result := 'BGR' else
      if self.val = UInt32($80E1) then Result := 'BGRA' else
      if self.val = UInt32($81BB) then Result := 'YCRCB_422_SGIX' else
      if self.val = UInt32($81BC) then Result := 'YCRCB_444_SGIX' else
      if self.val = UInt32($8227) then Result := 'RG' else
      if self.val = UInt32($8228) then Result := 'RG_INTEGER' else
      if self.val = UInt32($84F9) then Result := 'DEPTH_STENCIL' else
      if self.val = UInt32($8D94) then Result := 'RED_INTEGER' else
      if self.val = UInt32($8D95) then Result := 'GREEN_INTEGER' else
      if self.val = UInt32($8D96) then Result := 'BLUE_INTEGER' else
      if self.val = UInt32($8D98) then Result := 'RGB_INTEGER' else
      if self.val = UInt32($8D99) then Result := 'RGBA_INTEGER' else
      if self.val = UInt32($8D9A) then Result := 'BGR_INTEGER' else
      if self.val = UInt32($8D9B) then Result := 'BGRA_INTEGER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelMap = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PIXEL_MAP_I_TO_I := new PixelMap($0C70);
    private static _PIXEL_MAP_S_TO_S := new PixelMap($0C71);
    private static _PIXEL_MAP_I_TO_R := new PixelMap($0C72);
    private static _PIXEL_MAP_I_TO_G := new PixelMap($0C73);
    private static _PIXEL_MAP_I_TO_B := new PixelMap($0C74);
    private static _PIXEL_MAP_I_TO_A := new PixelMap($0C75);
    private static _PIXEL_MAP_R_TO_R := new PixelMap($0C76);
    private static _PIXEL_MAP_G_TO_G := new PixelMap($0C77);
    private static _PIXEL_MAP_B_TO_B := new PixelMap($0C78);
    private static _PIXEL_MAP_A_TO_A := new PixelMap($0C79);
    
    public static property PIXEL_MAP_I_TO_I: PixelMap read _PIXEL_MAP_I_TO_I;
    public static property PIXEL_MAP_S_TO_S: PixelMap read _PIXEL_MAP_S_TO_S;
    public static property PIXEL_MAP_I_TO_R: PixelMap read _PIXEL_MAP_I_TO_R;
    public static property PIXEL_MAP_I_TO_G: PixelMap read _PIXEL_MAP_I_TO_G;
    public static property PIXEL_MAP_I_TO_B: PixelMap read _PIXEL_MAP_I_TO_B;
    public static property PIXEL_MAP_I_TO_A: PixelMap read _PIXEL_MAP_I_TO_A;
    public static property PIXEL_MAP_R_TO_R: PixelMap read _PIXEL_MAP_R_TO_R;
    public static property PIXEL_MAP_G_TO_G: PixelMap read _PIXEL_MAP_G_TO_G;
    public static property PIXEL_MAP_B_TO_B: PixelMap read _PIXEL_MAP_B_TO_B;
    public static property PIXEL_MAP_A_TO_A: PixelMap read _PIXEL_MAP_A_TO_A;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0C70) then Result := 'PIXEL_MAP_I_TO_I' else
      if self.val = UInt32($0C71) then Result := 'PIXEL_MAP_S_TO_S' else
      if self.val = UInt32($0C72) then Result := 'PIXEL_MAP_I_TO_R' else
      if self.val = UInt32($0C73) then Result := 'PIXEL_MAP_I_TO_G' else
      if self.val = UInt32($0C74) then Result := 'PIXEL_MAP_I_TO_B' else
      if self.val = UInt32($0C75) then Result := 'PIXEL_MAP_I_TO_A' else
      if self.val = UInt32($0C76) then Result := 'PIXEL_MAP_R_TO_R' else
      if self.val = UInt32($0C77) then Result := 'PIXEL_MAP_G_TO_G' else
      if self.val = UInt32($0C78) then Result := 'PIXEL_MAP_B_TO_B' else
      if self.val = UInt32($0C79) then Result := 'PIXEL_MAP_A_TO_A' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelStoreParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNPACK_SWAP_BYTES           := new PixelStoreParameter($0CF0);
    private static _UNPACK_LSB_FIRST            := new PixelStoreParameter($0CF1);
    private static _UNPACK_ROW_LENGTH           := new PixelStoreParameter($0CF2);
    private static _UNPACK_ROW_LENGTH_EXT       := new PixelStoreParameter($0CF2);
    private static _UNPACK_SKIP_ROWS            := new PixelStoreParameter($0CF3);
    private static _UNPACK_SKIP_ROWS_EXT        := new PixelStoreParameter($0CF3);
    private static _UNPACK_SKIP_PIXELS          := new PixelStoreParameter($0CF4);
    private static _UNPACK_SKIP_PIXELS_EXT      := new PixelStoreParameter($0CF4);
    private static _UNPACK_ALIGNMENT            := new PixelStoreParameter($0CF5);
    private static _PACK_SWAP_BYTES             := new PixelStoreParameter($0D00);
    private static _PACK_LSB_FIRST              := new PixelStoreParameter($0D01);
    private static _PACK_ROW_LENGTH             := new PixelStoreParameter($0D02);
    private static _PACK_SKIP_ROWS              := new PixelStoreParameter($0D03);
    private static _PACK_SKIP_PIXELS            := new PixelStoreParameter($0D04);
    private static _PACK_ALIGNMENT              := new PixelStoreParameter($0D05);
    private static _PACK_SKIP_IMAGES            := new PixelStoreParameter($806B);
    private static _PACK_SKIP_IMAGES_EXT        := new PixelStoreParameter($806B);
    private static _PACK_IMAGE_HEIGHT           := new PixelStoreParameter($806C);
    private static _PACK_IMAGE_HEIGHT_EXT       := new PixelStoreParameter($806C);
    private static _UNPACK_SKIP_IMAGES          := new PixelStoreParameter($806D);
    private static _UNPACK_SKIP_IMAGES_EXT      := new PixelStoreParameter($806D);
    private static _UNPACK_IMAGE_HEIGHT         := new PixelStoreParameter($806E);
    private static _UNPACK_IMAGE_HEIGHT_EXT     := new PixelStoreParameter($806E);
    private static _PACK_SKIP_VOLUMES_SGIS      := new PixelStoreParameter($8130);
    private static _PACK_IMAGE_DEPTH_SGIS       := new PixelStoreParameter($8131);
    private static _UNPACK_SKIP_VOLUMES_SGIS    := new PixelStoreParameter($8132);
    private static _UNPACK_IMAGE_DEPTH_SGIS     := new PixelStoreParameter($8133);
    private static _PIXEL_TILE_WIDTH_SGIX       := new PixelStoreParameter($8140);
    private static _PIXEL_TILE_HEIGHT_SGIX      := new PixelStoreParameter($8141);
    private static _PIXEL_TILE_GRID_WIDTH_SGIX  := new PixelStoreParameter($8142);
    private static _PIXEL_TILE_GRID_HEIGHT_SGIX := new PixelStoreParameter($8143);
    private static _PIXEL_TILE_GRID_DEPTH_SGIX  := new PixelStoreParameter($8144);
    private static _PIXEL_TILE_CACHE_SIZE_SGIX  := new PixelStoreParameter($8145);
    private static _PACK_RESAMPLE_SGIX          := new PixelStoreParameter($842E);
    private static _UNPACK_RESAMPLE_SGIX        := new PixelStoreParameter($842F);
    private static _PACK_SUBSAMPLE_RATE_SGIX    := new PixelStoreParameter($85A0);
    private static _UNPACK_SUBSAMPLE_RATE_SGIX  := new PixelStoreParameter($85A1);
    private static _PACK_RESAMPLE_OML           := new PixelStoreParameter($8984);
    private static _UNPACK_RESAMPLE_OML         := new PixelStoreParameter($8985);
    
    public static property UNPACK_SWAP_BYTES:           PixelStoreParameter read _UNPACK_SWAP_BYTES;
    public static property UNPACK_LSB_FIRST:            PixelStoreParameter read _UNPACK_LSB_FIRST;
    public static property UNPACK_ROW_LENGTH:           PixelStoreParameter read _UNPACK_ROW_LENGTH;
    public static property UNPACK_ROW_LENGTH_EXT:       PixelStoreParameter read _UNPACK_ROW_LENGTH_EXT;
    public static property UNPACK_SKIP_ROWS:            PixelStoreParameter read _UNPACK_SKIP_ROWS;
    public static property UNPACK_SKIP_ROWS_EXT:        PixelStoreParameter read _UNPACK_SKIP_ROWS_EXT;
    public static property UNPACK_SKIP_PIXELS:          PixelStoreParameter read _UNPACK_SKIP_PIXELS;
    public static property UNPACK_SKIP_PIXELS_EXT:      PixelStoreParameter read _UNPACK_SKIP_PIXELS_EXT;
    public static property UNPACK_ALIGNMENT:            PixelStoreParameter read _UNPACK_ALIGNMENT;
    public static property PACK_SWAP_BYTES:             PixelStoreParameter read _PACK_SWAP_BYTES;
    public static property PACK_LSB_FIRST:              PixelStoreParameter read _PACK_LSB_FIRST;
    public static property PACK_ROW_LENGTH:             PixelStoreParameter read _PACK_ROW_LENGTH;
    public static property PACK_SKIP_ROWS:              PixelStoreParameter read _PACK_SKIP_ROWS;
    public static property PACK_SKIP_PIXELS:            PixelStoreParameter read _PACK_SKIP_PIXELS;
    public static property PACK_ALIGNMENT:              PixelStoreParameter read _PACK_ALIGNMENT;
    public static property PACK_SKIP_IMAGES:            PixelStoreParameter read _PACK_SKIP_IMAGES;
    public static property PACK_SKIP_IMAGES_EXT:        PixelStoreParameter read _PACK_SKIP_IMAGES_EXT;
    public static property PACK_IMAGE_HEIGHT:           PixelStoreParameter read _PACK_IMAGE_HEIGHT;
    public static property PACK_IMAGE_HEIGHT_EXT:       PixelStoreParameter read _PACK_IMAGE_HEIGHT_EXT;
    public static property UNPACK_SKIP_IMAGES:          PixelStoreParameter read _UNPACK_SKIP_IMAGES;
    public static property UNPACK_SKIP_IMAGES_EXT:      PixelStoreParameter read _UNPACK_SKIP_IMAGES_EXT;
    public static property UNPACK_IMAGE_HEIGHT:         PixelStoreParameter read _UNPACK_IMAGE_HEIGHT;
    public static property UNPACK_IMAGE_HEIGHT_EXT:     PixelStoreParameter read _UNPACK_IMAGE_HEIGHT_EXT;
    public static property PACK_SKIP_VOLUMES_SGIS:      PixelStoreParameter read _PACK_SKIP_VOLUMES_SGIS;
    public static property PACK_IMAGE_DEPTH_SGIS:       PixelStoreParameter read _PACK_IMAGE_DEPTH_SGIS;
    public static property UNPACK_SKIP_VOLUMES_SGIS:    PixelStoreParameter read _UNPACK_SKIP_VOLUMES_SGIS;
    public static property UNPACK_IMAGE_DEPTH_SGIS:     PixelStoreParameter read _UNPACK_IMAGE_DEPTH_SGIS;
    public static property PIXEL_TILE_WIDTH_SGIX:       PixelStoreParameter read _PIXEL_TILE_WIDTH_SGIX;
    public static property PIXEL_TILE_HEIGHT_SGIX:      PixelStoreParameter read _PIXEL_TILE_HEIGHT_SGIX;
    public static property PIXEL_TILE_GRID_WIDTH_SGIX:  PixelStoreParameter read _PIXEL_TILE_GRID_WIDTH_SGIX;
    public static property PIXEL_TILE_GRID_HEIGHT_SGIX: PixelStoreParameter read _PIXEL_TILE_GRID_HEIGHT_SGIX;
    public static property PIXEL_TILE_GRID_DEPTH_SGIX:  PixelStoreParameter read _PIXEL_TILE_GRID_DEPTH_SGIX;
    public static property PIXEL_TILE_CACHE_SIZE_SGIX:  PixelStoreParameter read _PIXEL_TILE_CACHE_SIZE_SGIX;
    public static property PACK_RESAMPLE_SGIX:          PixelStoreParameter read _PACK_RESAMPLE_SGIX;
    public static property UNPACK_RESAMPLE_SGIX:        PixelStoreParameter read _UNPACK_RESAMPLE_SGIX;
    public static property PACK_SUBSAMPLE_RATE_SGIX:    PixelStoreParameter read _PACK_SUBSAMPLE_RATE_SGIX;
    public static property UNPACK_SUBSAMPLE_RATE_SGIX:  PixelStoreParameter read _UNPACK_SUBSAMPLE_RATE_SGIX;
    public static property PACK_RESAMPLE_OML:           PixelStoreParameter read _PACK_RESAMPLE_OML;
    public static property UNPACK_RESAMPLE_OML:         PixelStoreParameter read _UNPACK_RESAMPLE_OML;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0CF0) then Result := 'UNPACK_SWAP_BYTES' else
      if self.val = UInt32($0CF1) then Result := 'UNPACK_LSB_FIRST' else
      if self.val = UInt32($0CF2) then Result := 'UNPACK_ROW_LENGTH' else
      if self.val = UInt32($0CF2) then Result := 'UNPACK_ROW_LENGTH_EXT' else
      if self.val = UInt32($0CF3) then Result := 'UNPACK_SKIP_ROWS' else
      if self.val = UInt32($0CF3) then Result := 'UNPACK_SKIP_ROWS_EXT' else
      if self.val = UInt32($0CF4) then Result := 'UNPACK_SKIP_PIXELS' else
      if self.val = UInt32($0CF4) then Result := 'UNPACK_SKIP_PIXELS_EXT' else
      if self.val = UInt32($0CF5) then Result := 'UNPACK_ALIGNMENT' else
      if self.val = UInt32($0D00) then Result := 'PACK_SWAP_BYTES' else
      if self.val = UInt32($0D01) then Result := 'PACK_LSB_FIRST' else
      if self.val = UInt32($0D02) then Result := 'PACK_ROW_LENGTH' else
      if self.val = UInt32($0D03) then Result := 'PACK_SKIP_ROWS' else
      if self.val = UInt32($0D04) then Result := 'PACK_SKIP_PIXELS' else
      if self.val = UInt32($0D05) then Result := 'PACK_ALIGNMENT' else
      if self.val = UInt32($806B) then Result := 'PACK_SKIP_IMAGES' else
      if self.val = UInt32($806B) then Result := 'PACK_SKIP_IMAGES_EXT' else
      if self.val = UInt32($806C) then Result := 'PACK_IMAGE_HEIGHT' else
      if self.val = UInt32($806C) then Result := 'PACK_IMAGE_HEIGHT_EXT' else
      if self.val = UInt32($806D) then Result := 'UNPACK_SKIP_IMAGES' else
      if self.val = UInt32($806D) then Result := 'UNPACK_SKIP_IMAGES_EXT' else
      if self.val = UInt32($806E) then Result := 'UNPACK_IMAGE_HEIGHT' else
      if self.val = UInt32($806E) then Result := 'UNPACK_IMAGE_HEIGHT_EXT' else
      if self.val = UInt32($8130) then Result := 'PACK_SKIP_VOLUMES_SGIS' else
      if self.val = UInt32($8131) then Result := 'PACK_IMAGE_DEPTH_SGIS' else
      if self.val = UInt32($8132) then Result := 'UNPACK_SKIP_VOLUMES_SGIS' else
      if self.val = UInt32($8133) then Result := 'UNPACK_IMAGE_DEPTH_SGIS' else
      if self.val = UInt32($8140) then Result := 'PIXEL_TILE_WIDTH_SGIX' else
      if self.val = UInt32($8141) then Result := 'PIXEL_TILE_HEIGHT_SGIX' else
      if self.val = UInt32($8142) then Result := 'PIXEL_TILE_GRID_WIDTH_SGIX' else
      if self.val = UInt32($8143) then Result := 'PIXEL_TILE_GRID_HEIGHT_SGIX' else
      if self.val = UInt32($8144) then Result := 'PIXEL_TILE_GRID_DEPTH_SGIX' else
      if self.val = UInt32($8145) then Result := 'PIXEL_TILE_CACHE_SIZE_SGIX' else
      if self.val = UInt32($842E) then Result := 'PACK_RESAMPLE_SGIX' else
      if self.val = UInt32($842F) then Result := 'UNPACK_RESAMPLE_SGIX' else
      if self.val = UInt32($85A0) then Result := 'PACK_SUBSAMPLE_RATE_SGIX' else
      if self.val = UInt32($85A1) then Result := 'UNPACK_SUBSAMPLE_RATE_SGIX' else
      if self.val = UInt32($8984) then Result := 'PACK_RESAMPLE_OML' else
      if self.val = UInt32($8985) then Result := 'UNPACK_RESAMPLE_OML' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelTransferParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MAP_COLOR                         := new PixelTransferParameter($0D10);
    private static _MAP_STENCIL                       := new PixelTransferParameter($0D11);
    private static _INDEX_SHIFT                       := new PixelTransferParameter($0D12);
    private static _INDEX_OFFSET                      := new PixelTransferParameter($0D13);
    private static _RED_SCALE                         := new PixelTransferParameter($0D14);
    private static _RED_BIAS                          := new PixelTransferParameter($0D15);
    private static _GREEN_SCALE                       := new PixelTransferParameter($0D18);
    private static _GREEN_BIAS                        := new PixelTransferParameter($0D19);
    private static _BLUE_SCALE                        := new PixelTransferParameter($0D1A);
    private static _BLUE_BIAS                         := new PixelTransferParameter($0D1B);
    private static _ALPHA_SCALE                       := new PixelTransferParameter($0D1C);
    private static _ALPHA_BIAS                        := new PixelTransferParameter($0D1D);
    private static _DEPTH_SCALE                       := new PixelTransferParameter($0D1E);
    private static _DEPTH_BIAS                        := new PixelTransferParameter($0D1F);
    private static _POST_CONVOLUTION_RED_SCALE        := new PixelTransferParameter($801C);
    private static _POST_CONVOLUTION_RED_SCALE_EXT    := new PixelTransferParameter($801C);
    private static _POST_CONVOLUTION_GREEN_SCALE      := new PixelTransferParameter($801D);
    private static _POST_CONVOLUTION_GREEN_SCALE_EXT  := new PixelTransferParameter($801D);
    private static _POST_CONVOLUTION_BLUE_SCALE       := new PixelTransferParameter($801E);
    private static _POST_CONVOLUTION_BLUE_SCALE_EXT   := new PixelTransferParameter($801E);
    private static _POST_CONVOLUTION_ALPHA_SCALE      := new PixelTransferParameter($801F);
    private static _POST_CONVOLUTION_ALPHA_SCALE_EXT  := new PixelTransferParameter($801F);
    private static _POST_CONVOLUTION_RED_BIAS         := new PixelTransferParameter($8020);
    private static _POST_CONVOLUTION_RED_BIAS_EXT     := new PixelTransferParameter($8020);
    private static _POST_CONVOLUTION_GREEN_BIAS       := new PixelTransferParameter($8021);
    private static _POST_CONVOLUTION_GREEN_BIAS_EXT   := new PixelTransferParameter($8021);
    private static _POST_CONVOLUTION_BLUE_BIAS        := new PixelTransferParameter($8022);
    private static _POST_CONVOLUTION_BLUE_BIAS_EXT    := new PixelTransferParameter($8022);
    private static _POST_CONVOLUTION_ALPHA_BIAS       := new PixelTransferParameter($8023);
    private static _POST_CONVOLUTION_ALPHA_BIAS_EXT   := new PixelTransferParameter($8023);
    private static _POST_COLOR_MATRIX_RED_SCALE       := new PixelTransferParameter($80B4);
    private static _POST_COLOR_MATRIX_RED_SCALE_SGI   := new PixelTransferParameter($80B4);
    private static _POST_COLOR_MATRIX_GREEN_SCALE     := new PixelTransferParameter($80B5);
    private static _POST_COLOR_MATRIX_GREEN_SCALE_SGI := new PixelTransferParameter($80B5);
    private static _POST_COLOR_MATRIX_BLUE_SCALE      := new PixelTransferParameter($80B6);
    private static _POST_COLOR_MATRIX_BLUE_SCALE_SGI  := new PixelTransferParameter($80B6);
    private static _POST_COLOR_MATRIX_ALPHA_SCALE     := new PixelTransferParameter($80B7);
    private static _POST_COLOR_MATRIX_ALPHA_SCALE_SGI := new PixelTransferParameter($80B7);
    private static _POST_COLOR_MATRIX_RED_BIAS        := new PixelTransferParameter($80B8);
    private static _POST_COLOR_MATRIX_RED_BIAS_SGI    := new PixelTransferParameter($80B8);
    private static _POST_COLOR_MATRIX_GREEN_BIAS      := new PixelTransferParameter($80B9);
    private static _POST_COLOR_MATRIX_GREEN_BIAS_SGI  := new PixelTransferParameter($80B9);
    private static _POST_COLOR_MATRIX_BLUE_BIAS       := new PixelTransferParameter($80BA);
    private static _POST_COLOR_MATRIX_BLUE_BIAS_SGI   := new PixelTransferParameter($80BA);
    private static _POST_COLOR_MATRIX_ALPHA_BIAS      := new PixelTransferParameter($80BB);
    private static _POST_COLOR_MATRIX_ALPHA_BIAS_SGI  := new PixelTransferParameter($80BB);
    
    public static property MAP_COLOR:                         PixelTransferParameter read _MAP_COLOR;
    public static property MAP_STENCIL:                       PixelTransferParameter read _MAP_STENCIL;
    public static property INDEX_SHIFT:                       PixelTransferParameter read _INDEX_SHIFT;
    public static property INDEX_OFFSET:                      PixelTransferParameter read _INDEX_OFFSET;
    public static property RED_SCALE:                         PixelTransferParameter read _RED_SCALE;
    public static property RED_BIAS:                          PixelTransferParameter read _RED_BIAS;
    public static property GREEN_SCALE:                       PixelTransferParameter read _GREEN_SCALE;
    public static property GREEN_BIAS:                        PixelTransferParameter read _GREEN_BIAS;
    public static property BLUE_SCALE:                        PixelTransferParameter read _BLUE_SCALE;
    public static property BLUE_BIAS:                         PixelTransferParameter read _BLUE_BIAS;
    public static property ALPHA_SCALE:                       PixelTransferParameter read _ALPHA_SCALE;
    public static property ALPHA_BIAS:                        PixelTransferParameter read _ALPHA_BIAS;
    public static property DEPTH_SCALE:                       PixelTransferParameter read _DEPTH_SCALE;
    public static property DEPTH_BIAS:                        PixelTransferParameter read _DEPTH_BIAS;
    public static property POST_CONVOLUTION_RED_SCALE:        PixelTransferParameter read _POST_CONVOLUTION_RED_SCALE;
    public static property POST_CONVOLUTION_RED_SCALE_EXT:    PixelTransferParameter read _POST_CONVOLUTION_RED_SCALE_EXT;
    public static property POST_CONVOLUTION_GREEN_SCALE:      PixelTransferParameter read _POST_CONVOLUTION_GREEN_SCALE;
    public static property POST_CONVOLUTION_GREEN_SCALE_EXT:  PixelTransferParameter read _POST_CONVOLUTION_GREEN_SCALE_EXT;
    public static property POST_CONVOLUTION_BLUE_SCALE:       PixelTransferParameter read _POST_CONVOLUTION_BLUE_SCALE;
    public static property POST_CONVOLUTION_BLUE_SCALE_EXT:   PixelTransferParameter read _POST_CONVOLUTION_BLUE_SCALE_EXT;
    public static property POST_CONVOLUTION_ALPHA_SCALE:      PixelTransferParameter read _POST_CONVOLUTION_ALPHA_SCALE;
    public static property POST_CONVOLUTION_ALPHA_SCALE_EXT:  PixelTransferParameter read _POST_CONVOLUTION_ALPHA_SCALE_EXT;
    public static property POST_CONVOLUTION_RED_BIAS:         PixelTransferParameter read _POST_CONVOLUTION_RED_BIAS;
    public static property POST_CONVOLUTION_RED_BIAS_EXT:     PixelTransferParameter read _POST_CONVOLUTION_RED_BIAS_EXT;
    public static property POST_CONVOLUTION_GREEN_BIAS:       PixelTransferParameter read _POST_CONVOLUTION_GREEN_BIAS;
    public static property POST_CONVOLUTION_GREEN_BIAS_EXT:   PixelTransferParameter read _POST_CONVOLUTION_GREEN_BIAS_EXT;
    public static property POST_CONVOLUTION_BLUE_BIAS:        PixelTransferParameter read _POST_CONVOLUTION_BLUE_BIAS;
    public static property POST_CONVOLUTION_BLUE_BIAS_EXT:    PixelTransferParameter read _POST_CONVOLUTION_BLUE_BIAS_EXT;
    public static property POST_CONVOLUTION_ALPHA_BIAS:       PixelTransferParameter read _POST_CONVOLUTION_ALPHA_BIAS;
    public static property POST_CONVOLUTION_ALPHA_BIAS_EXT:   PixelTransferParameter read _POST_CONVOLUTION_ALPHA_BIAS_EXT;
    public static property POST_COLOR_MATRIX_RED_SCALE:       PixelTransferParameter read _POST_COLOR_MATRIX_RED_SCALE;
    public static property POST_COLOR_MATRIX_RED_SCALE_SGI:   PixelTransferParameter read _POST_COLOR_MATRIX_RED_SCALE_SGI;
    public static property POST_COLOR_MATRIX_GREEN_SCALE:     PixelTransferParameter read _POST_COLOR_MATRIX_GREEN_SCALE;
    public static property POST_COLOR_MATRIX_GREEN_SCALE_SGI: PixelTransferParameter read _POST_COLOR_MATRIX_GREEN_SCALE_SGI;
    public static property POST_COLOR_MATRIX_BLUE_SCALE:      PixelTransferParameter read _POST_COLOR_MATRIX_BLUE_SCALE;
    public static property POST_COLOR_MATRIX_BLUE_SCALE_SGI:  PixelTransferParameter read _POST_COLOR_MATRIX_BLUE_SCALE_SGI;
    public static property POST_COLOR_MATRIX_ALPHA_SCALE:     PixelTransferParameter read _POST_COLOR_MATRIX_ALPHA_SCALE;
    public static property POST_COLOR_MATRIX_ALPHA_SCALE_SGI: PixelTransferParameter read _POST_COLOR_MATRIX_ALPHA_SCALE_SGI;
    public static property POST_COLOR_MATRIX_RED_BIAS:        PixelTransferParameter read _POST_COLOR_MATRIX_RED_BIAS;
    public static property POST_COLOR_MATRIX_RED_BIAS_SGI:    PixelTransferParameter read _POST_COLOR_MATRIX_RED_BIAS_SGI;
    public static property POST_COLOR_MATRIX_GREEN_BIAS:      PixelTransferParameter read _POST_COLOR_MATRIX_GREEN_BIAS;
    public static property POST_COLOR_MATRIX_GREEN_BIAS_SGI:  PixelTransferParameter read _POST_COLOR_MATRIX_GREEN_BIAS_SGI;
    public static property POST_COLOR_MATRIX_BLUE_BIAS:       PixelTransferParameter read _POST_COLOR_MATRIX_BLUE_BIAS;
    public static property POST_COLOR_MATRIX_BLUE_BIAS_SGI:   PixelTransferParameter read _POST_COLOR_MATRIX_BLUE_BIAS_SGI;
    public static property POST_COLOR_MATRIX_ALPHA_BIAS:      PixelTransferParameter read _POST_COLOR_MATRIX_ALPHA_BIAS;
    public static property POST_COLOR_MATRIX_ALPHA_BIAS_SGI:  PixelTransferParameter read _POST_COLOR_MATRIX_ALPHA_BIAS_SGI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0D10) then Result := 'MAP_COLOR' else
      if self.val = UInt32($0D11) then Result := 'MAP_STENCIL' else
      if self.val = UInt32($0D12) then Result := 'INDEX_SHIFT' else
      if self.val = UInt32($0D13) then Result := 'INDEX_OFFSET' else
      if self.val = UInt32($0D14) then Result := 'RED_SCALE' else
      if self.val = UInt32($0D15) then Result := 'RED_BIAS' else
      if self.val = UInt32($0D18) then Result := 'GREEN_SCALE' else
      if self.val = UInt32($0D19) then Result := 'GREEN_BIAS' else
      if self.val = UInt32($0D1A) then Result := 'BLUE_SCALE' else
      if self.val = UInt32($0D1B) then Result := 'BLUE_BIAS' else
      if self.val = UInt32($0D1C) then Result := 'ALPHA_SCALE' else
      if self.val = UInt32($0D1D) then Result := 'ALPHA_BIAS' else
      if self.val = UInt32($0D1E) then Result := 'DEPTH_SCALE' else
      if self.val = UInt32($0D1F) then Result := 'DEPTH_BIAS' else
      if self.val = UInt32($801C) then Result := 'POST_CONVOLUTION_RED_SCALE' else
      if self.val = UInt32($801C) then Result := 'POST_CONVOLUTION_RED_SCALE_EXT' else
      if self.val = UInt32($801D) then Result := 'POST_CONVOLUTION_GREEN_SCALE' else
      if self.val = UInt32($801D) then Result := 'POST_CONVOLUTION_GREEN_SCALE_EXT' else
      if self.val = UInt32($801E) then Result := 'POST_CONVOLUTION_BLUE_SCALE' else
      if self.val = UInt32($801E) then Result := 'POST_CONVOLUTION_BLUE_SCALE_EXT' else
      if self.val = UInt32($801F) then Result := 'POST_CONVOLUTION_ALPHA_SCALE' else
      if self.val = UInt32($801F) then Result := 'POST_CONVOLUTION_ALPHA_SCALE_EXT' else
      if self.val = UInt32($8020) then Result := 'POST_CONVOLUTION_RED_BIAS' else
      if self.val = UInt32($8020) then Result := 'POST_CONVOLUTION_RED_BIAS_EXT' else
      if self.val = UInt32($8021) then Result := 'POST_CONVOLUTION_GREEN_BIAS' else
      if self.val = UInt32($8021) then Result := 'POST_CONVOLUTION_GREEN_BIAS_EXT' else
      if self.val = UInt32($8022) then Result := 'POST_CONVOLUTION_BLUE_BIAS' else
      if self.val = UInt32($8022) then Result := 'POST_CONVOLUTION_BLUE_BIAS_EXT' else
      if self.val = UInt32($8023) then Result := 'POST_CONVOLUTION_ALPHA_BIAS' else
      if self.val = UInt32($8023) then Result := 'POST_CONVOLUTION_ALPHA_BIAS_EXT' else
      if self.val = UInt32($80B4) then Result := 'POST_COLOR_MATRIX_RED_SCALE' else
      if self.val = UInt32($80B4) then Result := 'POST_COLOR_MATRIX_RED_SCALE_SGI' else
      if self.val = UInt32($80B5) then Result := 'POST_COLOR_MATRIX_GREEN_SCALE' else
      if self.val = UInt32($80B5) then Result := 'POST_COLOR_MATRIX_GREEN_SCALE_SGI' else
      if self.val = UInt32($80B6) then Result := 'POST_COLOR_MATRIX_BLUE_SCALE' else
      if self.val = UInt32($80B6) then Result := 'POST_COLOR_MATRIX_BLUE_SCALE_SGI' else
      if self.val = UInt32($80B7) then Result := 'POST_COLOR_MATRIX_ALPHA_SCALE' else
      if self.val = UInt32($80B7) then Result := 'POST_COLOR_MATRIX_ALPHA_SCALE_SGI' else
      if self.val = UInt32($80B8) then Result := 'POST_COLOR_MATRIX_RED_BIAS' else
      if self.val = UInt32($80B8) then Result := 'POST_COLOR_MATRIX_RED_BIAS_SGI' else
      if self.val = UInt32($80B9) then Result := 'POST_COLOR_MATRIX_GREEN_BIAS' else
      if self.val = UInt32($80B9) then Result := 'POST_COLOR_MATRIX_GREEN_BIAS_SGI' else
      if self.val = UInt32($80BA) then Result := 'POST_COLOR_MATRIX_BLUE_BIAS' else
      if self.val = UInt32($80BA) then Result := 'POST_COLOR_MATRIX_BLUE_BIAS_SGI' else
      if self.val = UInt32($80BB) then Result := 'POST_COLOR_MATRIX_ALPHA_BIAS' else
      if self.val = UInt32($80BB) then Result := 'POST_COLOR_MATRIX_ALPHA_BIAS_SGI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE                        := new PixelType($1400);
    private static _UNSIGNED_BYTE               := new PixelType($1401);
    private static _SHORT                       := new PixelType($1402);
    private static _UNSIGNED_SHORT              := new PixelType($1403);
    private static _INT                         := new PixelType($1404);
    private static _UNSIGNED_INT                := new PixelType($1405);
    private static _FLOAT                       := new PixelType($1406);
    private static _BITMAP                      := new PixelType($1A00);
    private static _UNSIGNED_BYTE_3_3_2         := new PixelType($8032);
    private static _UNSIGNED_BYTE_3_3_2_EXT     := new PixelType($8032);
    private static _UNSIGNED_SHORT_4_4_4_4      := new PixelType($8033);
    private static _UNSIGNED_SHORT_4_4_4_4_EXT  := new PixelType($8033);
    private static _UNSIGNED_SHORT_5_5_5_1      := new PixelType($8034);
    private static _UNSIGNED_SHORT_5_5_5_1_EXT  := new PixelType($8034);
    private static _UNSIGNED_INT_8_8_8_8        := new PixelType($8035);
    private static _UNSIGNED_INT_8_8_8_8_EXT    := new PixelType($8035);
    private static _UNSIGNED_INT_10_10_10_2     := new PixelType($8036);
    private static _UNSIGNED_INT_10_10_10_2_EXT := new PixelType($8036);
    
    public static property BYTE:                        PixelType read _BYTE;
    public static property UNSIGNED_BYTE:               PixelType read _UNSIGNED_BYTE;
    public static property SHORT:                       PixelType read _SHORT;
    public static property UNSIGNED_SHORT:              PixelType read _UNSIGNED_SHORT;
    public static property INT:                         PixelType read _INT;
    public static property UNSIGNED_INT:                PixelType read _UNSIGNED_INT;
    public static property FLOAT:                       PixelType read _FLOAT;
    public static property BITMAP:                      PixelType read _BITMAP;
    public static property UNSIGNED_BYTE_3_3_2:         PixelType read _UNSIGNED_BYTE_3_3_2;
    public static property UNSIGNED_BYTE_3_3_2_EXT:     PixelType read _UNSIGNED_BYTE_3_3_2_EXT;
    public static property UNSIGNED_SHORT_4_4_4_4:      PixelType read _UNSIGNED_SHORT_4_4_4_4;
    public static property UNSIGNED_SHORT_4_4_4_4_EXT:  PixelType read _UNSIGNED_SHORT_4_4_4_4_EXT;
    public static property UNSIGNED_SHORT_5_5_5_1:      PixelType read _UNSIGNED_SHORT_5_5_5_1;
    public static property UNSIGNED_SHORT_5_5_5_1_EXT:  PixelType read _UNSIGNED_SHORT_5_5_5_1_EXT;
    public static property UNSIGNED_INT_8_8_8_8:        PixelType read _UNSIGNED_INT_8_8_8_8;
    public static property UNSIGNED_INT_8_8_8_8_EXT:    PixelType read _UNSIGNED_INT_8_8_8_8_EXT;
    public static property UNSIGNED_INT_10_10_10_2:     PixelType read _UNSIGNED_INT_10_10_10_2;
    public static property UNSIGNED_INT_10_10_10_2_EXT: PixelType read _UNSIGNED_INT_10_10_10_2_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($1A00) then Result := 'BITMAP' else
      if self.val = UInt32($8032) then Result := 'UNSIGNED_BYTE_3_3_2' else
      if self.val = UInt32($8032) then Result := 'UNSIGNED_BYTE_3_3_2_EXT' else
      if self.val = UInt32($8033) then Result := 'UNSIGNED_SHORT_4_4_4_4' else
      if self.val = UInt32($8033) then Result := 'UNSIGNED_SHORT_4_4_4_4_EXT' else
      if self.val = UInt32($8034) then Result := 'UNSIGNED_SHORT_5_5_5_1' else
      if self.val = UInt32($8034) then Result := 'UNSIGNED_SHORT_5_5_5_1_EXT' else
      if self.val = UInt32($8035) then Result := 'UNSIGNED_INT_8_8_8_8' else
      if self.val = UInt32($8035) then Result := 'UNSIGNED_INT_8_8_8_8_EXT' else
      if self.val = UInt32($8036) then Result := 'UNSIGNED_INT_10_10_10_2' else
      if self.val = UInt32($8036) then Result := 'UNSIGNED_INT_10_10_10_2_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PolygonMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _POINT := new PolygonMode($1B00);
    private static _LINE  := new PolygonMode($1B01);
    private static _FILL  := new PolygonMode($1B02);
    
    public static property POINT: PolygonMode read _POINT;
    public static property LINE:  PolygonMode read _LINE;
    public static property FILL:  PolygonMode read _FILL;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B00) then Result := 'POINT' else
      if self.val = UInt32($1B01) then Result := 'LINE' else
      if self.val = UInt32($1B02) then Result := 'FILL' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PrecisionType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _LOW_FLOAT    := new PrecisionType($8DF0);
    private static _MEDIUM_FLOAT := new PrecisionType($8DF1);
    private static _HIGH_FLOAT   := new PrecisionType($8DF2);
    private static _LOW_INT      := new PrecisionType($8DF3);
    private static _MEDIUM_INT   := new PrecisionType($8DF4);
    private static _HIGH_INT     := new PrecisionType($8DF5);
    
    public static property LOW_FLOAT:    PrecisionType read _LOW_FLOAT;
    public static property MEDIUM_FLOAT: PrecisionType read _MEDIUM_FLOAT;
    public static property HIGH_FLOAT:   PrecisionType read _HIGH_FLOAT;
    public static property LOW_INT:      PrecisionType read _LOW_INT;
    public static property MEDIUM_INT:   PrecisionType read _MEDIUM_INT;
    public static property HIGH_INT:     PrecisionType read _HIGH_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8DF0) then Result := 'LOW_FLOAT' else
      if self.val = UInt32($8DF1) then Result := 'MEDIUM_FLOAT' else
      if self.val = UInt32($8DF2) then Result := 'HIGH_FLOAT' else
      if self.val = UInt32($8DF3) then Result := 'LOW_INT' else
      if self.val = UInt32($8DF4) then Result := 'MEDIUM_INT' else
      if self.val = UInt32($8DF5) then Result := 'HIGH_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PrimitiveType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _POINTS                       := new PrimitiveType($0000);
    private static _LINES                        := new PrimitiveType($0001);
    private static _LINE_LOOP                    := new PrimitiveType($0002);
    private static _LINE_STRIP                   := new PrimitiveType($0003);
    private static _TRIANGLES                    := new PrimitiveType($0004);
    private static _TRIANGLE_STRIP               := new PrimitiveType($0005);
    private static _TRIANGLE_FAN                 := new PrimitiveType($0006);
    private static _QUADS                        := new PrimitiveType($0007);
    private static _QUADS_EXT                    := new PrimitiveType($0007);
    private static _QUAD_STRIP                   := new PrimitiveType($0008);
    private static _POLYGON                      := new PrimitiveType($0009);
    private static _LINES_ADJACENCY              := new PrimitiveType($000A);
    private static _LINES_ADJACENCY_ARB          := new PrimitiveType($000A);
    private static _LINES_ADJACENCY_EXT          := new PrimitiveType($000A);
    private static _LINE_STRIP_ADJACENCY         := new PrimitiveType($000B);
    private static _LINE_STRIP_ADJACENCY_ARB     := new PrimitiveType($000B);
    private static _LINE_STRIP_ADJACENCY_EXT     := new PrimitiveType($000B);
    private static _TRIANGLES_ADJACENCY          := new PrimitiveType($000C);
    private static _TRIANGLES_ADJACENCY_ARB      := new PrimitiveType($000C);
    private static _TRIANGLES_ADJACENCY_EXT      := new PrimitiveType($000C);
    private static _TRIANGLE_STRIP_ADJACENCY     := new PrimitiveType($000D);
    private static _TRIANGLE_STRIP_ADJACENCY_ARB := new PrimitiveType($000D);
    private static _TRIANGLE_STRIP_ADJACENCY_EXT := new PrimitiveType($000D);
    private static _PATCHES                      := new PrimitiveType($000E);
    private static _PATCHES_EXT                  := new PrimitiveType($000E);
    
    public static property POINTS:                       PrimitiveType read _POINTS;
    public static property LINES:                        PrimitiveType read _LINES;
    public static property LINE_LOOP:                    PrimitiveType read _LINE_LOOP;
    public static property LINE_STRIP:                   PrimitiveType read _LINE_STRIP;
    public static property TRIANGLES:                    PrimitiveType read _TRIANGLES;
    public static property TRIANGLE_STRIP:               PrimitiveType read _TRIANGLE_STRIP;
    public static property TRIANGLE_FAN:                 PrimitiveType read _TRIANGLE_FAN;
    public static property QUADS:                        PrimitiveType read _QUADS;
    public static property QUADS_EXT:                    PrimitiveType read _QUADS_EXT;
    public static property QUAD_STRIP:                   PrimitiveType read _QUAD_STRIP;
    public static property POLYGON:                      PrimitiveType read _POLYGON;
    public static property LINES_ADJACENCY:              PrimitiveType read _LINES_ADJACENCY;
    public static property LINES_ADJACENCY_ARB:          PrimitiveType read _LINES_ADJACENCY_ARB;
    public static property LINES_ADJACENCY_EXT:          PrimitiveType read _LINES_ADJACENCY_EXT;
    public static property LINE_STRIP_ADJACENCY:         PrimitiveType read _LINE_STRIP_ADJACENCY;
    public static property LINE_STRIP_ADJACENCY_ARB:     PrimitiveType read _LINE_STRIP_ADJACENCY_ARB;
    public static property LINE_STRIP_ADJACENCY_EXT:     PrimitiveType read _LINE_STRIP_ADJACENCY_EXT;
    public static property TRIANGLES_ADJACENCY:          PrimitiveType read _TRIANGLES_ADJACENCY;
    public static property TRIANGLES_ADJACENCY_ARB:      PrimitiveType read _TRIANGLES_ADJACENCY_ARB;
    public static property TRIANGLES_ADJACENCY_EXT:      PrimitiveType read _TRIANGLES_ADJACENCY_EXT;
    public static property TRIANGLE_STRIP_ADJACENCY:     PrimitiveType read _TRIANGLE_STRIP_ADJACENCY;
    public static property TRIANGLE_STRIP_ADJACENCY_ARB: PrimitiveType read _TRIANGLE_STRIP_ADJACENCY_ARB;
    public static property TRIANGLE_STRIP_ADJACENCY_EXT: PrimitiveType read _TRIANGLE_STRIP_ADJACENCY_EXT;
    public static property PATCHES:                      PrimitiveType read _PATCHES;
    public static property PATCHES_EXT:                  PrimitiveType read _PATCHES_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'POINTS' else
      if self.val = UInt32($0001) then Result := 'LINES' else
      if self.val = UInt32($0002) then Result := 'LINE_LOOP' else
      if self.val = UInt32($0003) then Result := 'LINE_STRIP' else
      if self.val = UInt32($0004) then Result := 'TRIANGLES' else
      if self.val = UInt32($0005) then Result := 'TRIANGLE_STRIP' else
      if self.val = UInt32($0006) then Result := 'TRIANGLE_FAN' else
      if self.val = UInt32($0007) then Result := 'QUADS' else
      if self.val = UInt32($0007) then Result := 'QUADS_EXT' else
      if self.val = UInt32($0008) then Result := 'QUAD_STRIP' else
      if self.val = UInt32($0009) then Result := 'POLYGON' else
      if self.val = UInt32($000A) then Result := 'LINES_ADJACENCY' else
      if self.val = UInt32($000A) then Result := 'LINES_ADJACENCY_ARB' else
      if self.val = UInt32($000A) then Result := 'LINES_ADJACENCY_EXT' else
      if self.val = UInt32($000B) then Result := 'LINE_STRIP_ADJACENCY' else
      if self.val = UInt32($000B) then Result := 'LINE_STRIP_ADJACENCY_ARB' else
      if self.val = UInt32($000B) then Result := 'LINE_STRIP_ADJACENCY_EXT' else
      if self.val = UInt32($000C) then Result := 'TRIANGLES_ADJACENCY' else
      if self.val = UInt32($000C) then Result := 'TRIANGLES_ADJACENCY_ARB' else
      if self.val = UInt32($000C) then Result := 'TRIANGLES_ADJACENCY_EXT' else
      if self.val = UInt32($000D) then Result := 'TRIANGLE_STRIP_ADJACENCY' else
      if self.val = UInt32($000D) then Result := 'TRIANGLE_STRIP_ADJACENCY_ARB' else
      if self.val = UInt32($000D) then Result := 'TRIANGLE_STRIP_ADJACENCY_EXT' else
      if self.val = UInt32($000E) then Result := 'PATCHES' else
      if self.val = UInt32($000E) then Result := 'PATCHES_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PROGRAM_FORMAT_ASCII_ARB := new ProgramFormat($8875);
    
    public static property PROGRAM_FORMAT_ASCII_ARB: ProgramFormat read _PROGRAM_FORMAT_ASCII_ARB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8875) then Result := 'PROGRAM_FORMAT_ASCII_ARB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramInterface = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TRANSFORM_FEEDBACK_BUFFER          := new ProgramInterface($8C8E);
    private static _UNIFORM                            := new ProgramInterface($92E1);
    private static _UNIFORM_BLOCK                      := new ProgramInterface($92E2);
    private static _PROGRAM_INPUT                      := new ProgramInterface($92E3);
    private static _PROGRAM_OUTPUT                     := new ProgramInterface($92E4);
    private static _BUFFER_VARIABLE                    := new ProgramInterface($92E5);
    private static _SHADER_STORAGE_BLOCK               := new ProgramInterface($92E6);
    private static _VERTEX_SUBROUTINE                  := new ProgramInterface($92E8);
    private static _TESS_CONTROL_SUBROUTINE            := new ProgramInterface($92E9);
    private static _TESS_EVALUATION_SUBROUTINE         := new ProgramInterface($92EA);
    private static _GEOMETRY_SUBROUTINE                := new ProgramInterface($92EB);
    private static _FRAGMENT_SUBROUTINE                := new ProgramInterface($92EC);
    private static _COMPUTE_SUBROUTINE                 := new ProgramInterface($92ED);
    private static _VERTEX_SUBROUTINE_UNIFORM          := new ProgramInterface($92EE);
    private static _TESS_CONTROL_SUBROUTINE_UNIFORM    := new ProgramInterface($92EF);
    private static _TESS_EVALUATION_SUBROUTINE_UNIFORM := new ProgramInterface($92F0);
    private static _GEOMETRY_SUBROUTINE_UNIFORM        := new ProgramInterface($92F1);
    private static _FRAGMENT_SUBROUTINE_UNIFORM        := new ProgramInterface($92F2);
    private static _COMPUTE_SUBROUTINE_UNIFORM         := new ProgramInterface($92F3);
    private static _TRANSFORM_FEEDBACK_VARYING         := new ProgramInterface($92F4);
    
    public static property TRANSFORM_FEEDBACK_BUFFER:          ProgramInterface read _TRANSFORM_FEEDBACK_BUFFER;
    public static property UNIFORM:                            ProgramInterface read _UNIFORM;
    public static property UNIFORM_BLOCK:                      ProgramInterface read _UNIFORM_BLOCK;
    public static property PROGRAM_INPUT:                      ProgramInterface read _PROGRAM_INPUT;
    public static property PROGRAM_OUTPUT:                     ProgramInterface read _PROGRAM_OUTPUT;
    public static property BUFFER_VARIABLE:                    ProgramInterface read _BUFFER_VARIABLE;
    public static property SHADER_STORAGE_BLOCK:               ProgramInterface read _SHADER_STORAGE_BLOCK;
    public static property VERTEX_SUBROUTINE:                  ProgramInterface read _VERTEX_SUBROUTINE;
    public static property TESS_CONTROL_SUBROUTINE:            ProgramInterface read _TESS_CONTROL_SUBROUTINE;
    public static property TESS_EVALUATION_SUBROUTINE:         ProgramInterface read _TESS_EVALUATION_SUBROUTINE;
    public static property GEOMETRY_SUBROUTINE:                ProgramInterface read _GEOMETRY_SUBROUTINE;
    public static property FRAGMENT_SUBROUTINE:                ProgramInterface read _FRAGMENT_SUBROUTINE;
    public static property COMPUTE_SUBROUTINE:                 ProgramInterface read _COMPUTE_SUBROUTINE;
    public static property VERTEX_SUBROUTINE_UNIFORM:          ProgramInterface read _VERTEX_SUBROUTINE_UNIFORM;
    public static property TESS_CONTROL_SUBROUTINE_UNIFORM:    ProgramInterface read _TESS_CONTROL_SUBROUTINE_UNIFORM;
    public static property TESS_EVALUATION_SUBROUTINE_UNIFORM: ProgramInterface read _TESS_EVALUATION_SUBROUTINE_UNIFORM;
    public static property GEOMETRY_SUBROUTINE_UNIFORM:        ProgramInterface read _GEOMETRY_SUBROUTINE_UNIFORM;
    public static property FRAGMENT_SUBROUTINE_UNIFORM:        ProgramInterface read _FRAGMENT_SUBROUTINE_UNIFORM;
    public static property COMPUTE_SUBROUTINE_UNIFORM:         ProgramInterface read _COMPUTE_SUBROUTINE_UNIFORM;
    public static property TRANSFORM_FEEDBACK_VARYING:         ProgramInterface read _TRANSFORM_FEEDBACK_VARYING;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($92E1) then Result := 'UNIFORM' else
      if self.val = UInt32($92E2) then Result := 'UNIFORM_BLOCK' else
      if self.val = UInt32($92E3) then Result := 'PROGRAM_INPUT' else
      if self.val = UInt32($92E4) then Result := 'PROGRAM_OUTPUT' else
      if self.val = UInt32($92E5) then Result := 'BUFFER_VARIABLE' else
      if self.val = UInt32($92E6) then Result := 'SHADER_STORAGE_BLOCK' else
      if self.val = UInt32($92E8) then Result := 'VERTEX_SUBROUTINE' else
      if self.val = UInt32($92E9) then Result := 'TESS_CONTROL_SUBROUTINE' else
      if self.val = UInt32($92EA) then Result := 'TESS_EVALUATION_SUBROUTINE' else
      if self.val = UInt32($92EB) then Result := 'GEOMETRY_SUBROUTINE' else
      if self.val = UInt32($92EC) then Result := 'FRAGMENT_SUBROUTINE' else
      if self.val = UInt32($92ED) then Result := 'COMPUTE_SUBROUTINE' else
      if self.val = UInt32($92EE) then Result := 'VERTEX_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92EF) then Result := 'TESS_CONTROL_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F0) then Result := 'TESS_EVALUATION_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F1) then Result := 'GEOMETRY_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F2) then Result := 'FRAGMENT_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F3) then Result := 'COMPUTE_SUBROUTINE_UNIFORM' else
      if self.val = UInt32($92F4) then Result := 'TRANSFORM_FEEDBACK_VARYING' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramInterfacePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ACTIVE_RESOURCES               := new ProgramInterfacePName($92F5);
    private static _MAX_NAME_LENGTH                := new ProgramInterfacePName($92F6);
    private static _MAX_NUM_ACTIVE_VARIABLES       := new ProgramInterfacePName($92F7);
    private static _MAX_NUM_COMPATIBLE_SUBROUTINES := new ProgramInterfacePName($92F8);
    
    public static property ACTIVE_RESOURCES:               ProgramInterfacePName read _ACTIVE_RESOURCES;
    public static property MAX_NAME_LENGTH:                ProgramInterfacePName read _MAX_NAME_LENGTH;
    public static property MAX_NUM_ACTIVE_VARIABLES:       ProgramInterfacePName read _MAX_NUM_ACTIVE_VARIABLES;
    public static property MAX_NUM_COMPATIBLE_SUBROUTINES: ProgramInterfacePName read _MAX_NUM_COMPATIBLE_SUBROUTINES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($92F5) then Result := 'ACTIVE_RESOURCES' else
      if self.val = UInt32($92F6) then Result := 'MAX_NAME_LENGTH' else
      if self.val = UInt32($92F7) then Result := 'MAX_NUM_ACTIVE_VARIABLES' else
      if self.val = UInt32($92F8) then Result := 'MAX_NUM_COMPATIBLE_SUBROUTINES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramParameterPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PROGRAM_BINARY_RETRIEVABLE_HINT := new ProgramParameterPName($8257);
    private static _PROGRAM_SEPARABLE               := new ProgramParameterPName($8258);
    
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT: ProgramParameterPName read _PROGRAM_BINARY_RETRIEVABLE_HINT;
    public static property PROGRAM_SEPARABLE:               ProgramParameterPName read _PROGRAM_SEPARABLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8257) then Result := 'PROGRAM_BINARY_RETRIEVABLE_HINT' else
      if self.val = UInt32($8258) then Result := 'PROGRAM_SEPARABLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramResourceProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NUM_COMPATIBLE_SUBROUTINES           := new ProgramResourceProperty($8E4A);
    private static _COMPATIBLE_SUBROUTINES               := new ProgramResourceProperty($8E4B);
    private static _UNIFORM                              := new ProgramResourceProperty($92E1);
    private static _IS_PER_PATCH                         := new ProgramResourceProperty($92E7);
    private static _NAME_LENGTH                          := new ProgramResourceProperty($92F9);
    private static _TYPE                                 := new ProgramResourceProperty($92FA);
    private static _ARRAY_SIZE                           := new ProgramResourceProperty($92FB);
    private static _OFFSET                               := new ProgramResourceProperty($92FC);
    private static _BLOCK_INDEX                          := new ProgramResourceProperty($92FD);
    private static _ARRAY_STRIDE                         := new ProgramResourceProperty($92FE);
    private static _MATRIX_STRIDE                        := new ProgramResourceProperty($92FF);
    private static _IS_ROW_MAJOR                         := new ProgramResourceProperty($9300);
    private static _ATOMIC_COUNTER_BUFFER_INDEX          := new ProgramResourceProperty($9301);
    private static _BUFFER_BINDING                       := new ProgramResourceProperty($9302);
    private static _BUFFER_DATA_SIZE                     := new ProgramResourceProperty($9303);
    private static _NUM_ACTIVE_VARIABLES                 := new ProgramResourceProperty($9304);
    private static _ACTIVE_VARIABLES                     := new ProgramResourceProperty($9305);
    private static _REFERENCED_BY_VERTEX_SHADER          := new ProgramResourceProperty($9306);
    private static _REFERENCED_BY_TESS_CONTROL_SHADER    := new ProgramResourceProperty($9307);
    private static _REFERENCED_BY_TESS_EVALUATION_SHADER := new ProgramResourceProperty($9308);
    private static _REFERENCED_BY_GEOMETRY_SHADER        := new ProgramResourceProperty($9309);
    private static _REFERENCED_BY_FRAGMENT_SHADER        := new ProgramResourceProperty($930A);
    private static _REFERENCED_BY_COMPUTE_SHADER         := new ProgramResourceProperty($930B);
    private static _TOP_LEVEL_ARRAY_SIZE                 := new ProgramResourceProperty($930C);
    private static _TOP_LEVEL_ARRAY_STRIDE               := new ProgramResourceProperty($930D);
    private static _LOCATION                             := new ProgramResourceProperty($930E);
    private static _LOCATION_INDEX                       := new ProgramResourceProperty($930F);
    private static _LOCATION_COMPONENT                   := new ProgramResourceProperty($934A);
    private static _TRANSFORM_FEEDBACK_BUFFER_INDEX      := new ProgramResourceProperty($934B);
    private static _TRANSFORM_FEEDBACK_BUFFER_STRIDE     := new ProgramResourceProperty($934C);
    
    public static property NUM_COMPATIBLE_SUBROUTINES:           ProgramResourceProperty read _NUM_COMPATIBLE_SUBROUTINES;
    public static property COMPATIBLE_SUBROUTINES:               ProgramResourceProperty read _COMPATIBLE_SUBROUTINES;
    public static property UNIFORM:                              ProgramResourceProperty read _UNIFORM;
    public static property IS_PER_PATCH:                         ProgramResourceProperty read _IS_PER_PATCH;
    public static property NAME_LENGTH:                          ProgramResourceProperty read _NAME_LENGTH;
    public static property &TYPE:                                ProgramResourceProperty read _TYPE;
    public static property ARRAY_SIZE:                           ProgramResourceProperty read _ARRAY_SIZE;
    public static property OFFSET:                               ProgramResourceProperty read _OFFSET;
    public static property BLOCK_INDEX:                          ProgramResourceProperty read _BLOCK_INDEX;
    public static property ARRAY_STRIDE:                         ProgramResourceProperty read _ARRAY_STRIDE;
    public static property MATRIX_STRIDE:                        ProgramResourceProperty read _MATRIX_STRIDE;
    public static property IS_ROW_MAJOR:                         ProgramResourceProperty read _IS_ROW_MAJOR;
    public static property ATOMIC_COUNTER_BUFFER_INDEX:          ProgramResourceProperty read _ATOMIC_COUNTER_BUFFER_INDEX;
    public static property BUFFER_BINDING:                       ProgramResourceProperty read _BUFFER_BINDING;
    public static property BUFFER_DATA_SIZE:                     ProgramResourceProperty read _BUFFER_DATA_SIZE;
    public static property NUM_ACTIVE_VARIABLES:                 ProgramResourceProperty read _NUM_ACTIVE_VARIABLES;
    public static property ACTIVE_VARIABLES:                     ProgramResourceProperty read _ACTIVE_VARIABLES;
    public static property REFERENCED_BY_VERTEX_SHADER:          ProgramResourceProperty read _REFERENCED_BY_VERTEX_SHADER;
    public static property REFERENCED_BY_TESS_CONTROL_SHADER:    ProgramResourceProperty read _REFERENCED_BY_TESS_CONTROL_SHADER;
    public static property REFERENCED_BY_TESS_EVALUATION_SHADER: ProgramResourceProperty read _REFERENCED_BY_TESS_EVALUATION_SHADER;
    public static property REFERENCED_BY_GEOMETRY_SHADER:        ProgramResourceProperty read _REFERENCED_BY_GEOMETRY_SHADER;
    public static property REFERENCED_BY_FRAGMENT_SHADER:        ProgramResourceProperty read _REFERENCED_BY_FRAGMENT_SHADER;
    public static property REFERENCED_BY_COMPUTE_SHADER:         ProgramResourceProperty read _REFERENCED_BY_COMPUTE_SHADER;
    public static property TOP_LEVEL_ARRAY_SIZE:                 ProgramResourceProperty read _TOP_LEVEL_ARRAY_SIZE;
    public static property TOP_LEVEL_ARRAY_STRIDE:               ProgramResourceProperty read _TOP_LEVEL_ARRAY_STRIDE;
    public static property LOCATION:                             ProgramResourceProperty read _LOCATION;
    public static property LOCATION_INDEX:                       ProgramResourceProperty read _LOCATION_INDEX;
    public static property LOCATION_COMPONENT:                   ProgramResourceProperty read _LOCATION_COMPONENT;
    public static property TRANSFORM_FEEDBACK_BUFFER_INDEX:      ProgramResourceProperty read _TRANSFORM_FEEDBACK_BUFFER_INDEX;
    public static property TRANSFORM_FEEDBACK_BUFFER_STRIDE:     ProgramResourceProperty read _TRANSFORM_FEEDBACK_BUFFER_STRIDE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E4A) then Result := 'NUM_COMPATIBLE_SUBROUTINES' else
      if self.val = UInt32($8E4B) then Result := 'COMPATIBLE_SUBROUTINES' else
      if self.val = UInt32($92E1) then Result := 'UNIFORM' else
      if self.val = UInt32($92E7) then Result := 'IS_PER_PATCH' else
      if self.val = UInt32($92F9) then Result := 'NAME_LENGTH' else
      if self.val = UInt32($92FA) then Result := 'TYPE' else
      if self.val = UInt32($92FB) then Result := 'ARRAY_SIZE' else
      if self.val = UInt32($92FC) then Result := 'OFFSET' else
      if self.val = UInt32($92FD) then Result := 'BLOCK_INDEX' else
      if self.val = UInt32($92FE) then Result := 'ARRAY_STRIDE' else
      if self.val = UInt32($92FF) then Result := 'MATRIX_STRIDE' else
      if self.val = UInt32($9300) then Result := 'IS_ROW_MAJOR' else
      if self.val = UInt32($9301) then Result := 'ATOMIC_COUNTER_BUFFER_INDEX' else
      if self.val = UInt32($9302) then Result := 'BUFFER_BINDING' else
      if self.val = UInt32($9303) then Result := 'BUFFER_DATA_SIZE' else
      if self.val = UInt32($9304) then Result := 'NUM_ACTIVE_VARIABLES' else
      if self.val = UInt32($9305) then Result := 'ACTIVE_VARIABLES' else
      if self.val = UInt32($9306) then Result := 'REFERENCED_BY_VERTEX_SHADER' else
      if self.val = UInt32($9307) then Result := 'REFERENCED_BY_TESS_CONTROL_SHADER' else
      if self.val = UInt32($9308) then Result := 'REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if self.val = UInt32($9309) then Result := 'REFERENCED_BY_GEOMETRY_SHADER' else
      if self.val = UInt32($930A) then Result := 'REFERENCED_BY_FRAGMENT_SHADER' else
      if self.val = UInt32($930B) then Result := 'REFERENCED_BY_COMPUTE_SHADER' else
      if self.val = UInt32($930C) then Result := 'TOP_LEVEL_ARRAY_SIZE' else
      if self.val = UInt32($930D) then Result := 'TOP_LEVEL_ARRAY_STRIDE' else
      if self.val = UInt32($930E) then Result := 'LOCATION' else
      if self.val = UInt32($930F) then Result := 'LOCATION_INDEX' else
      if self.val = UInt32($934A) then Result := 'LOCATION_COMPONENT' else
      if self.val = UInt32($934B) then Result := 'TRANSFORM_FEEDBACK_BUFFER_INDEX' else
      if self.val = UInt32($934C) then Result := 'TRANSFORM_FEEDBACK_BUFFER_STRIDE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramStagePName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ACTIVE_SUBROUTINES                   := new ProgramStagePName($8DE5);
    private static _ACTIVE_SUBROUTINE_UNIFORMS           := new ProgramStagePName($8DE6);
    private static _ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS  := new ProgramStagePName($8E47);
    private static _ACTIVE_SUBROUTINE_MAX_LENGTH         := new ProgramStagePName($8E48);
    private static _ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH := new ProgramStagePName($8E49);
    
    public static property ACTIVE_SUBROUTINES:                   ProgramStagePName read _ACTIVE_SUBROUTINES;
    public static property ACTIVE_SUBROUTINE_UNIFORMS:           ProgramStagePName read _ACTIVE_SUBROUTINE_UNIFORMS;
    public static property ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS:  ProgramStagePName read _ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS;
    public static property ACTIVE_SUBROUTINE_MAX_LENGTH:         ProgramStagePName read _ACTIVE_SUBROUTINE_MAX_LENGTH;
    public static property ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: ProgramStagePName read _ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8DE5) then Result := 'ACTIVE_SUBROUTINES' else
      if self.val = UInt32($8DE6) then Result := 'ACTIVE_SUBROUTINE_UNIFORMS' else
      if self.val = UInt32($8E47) then Result := 'ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS' else
      if self.val = UInt32($8E48) then Result := 'ACTIVE_SUBROUTINE_MAX_LENGTH' else
      if self.val = UInt32($8E49) then Result := 'ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramStringProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PROGRAM_STRING_ARB := new ProgramStringProperty($8628);
    
    public static property PROGRAM_STRING_ARB: ProgramStringProperty read _PROGRAM_STRING_ARB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8628) then Result := 'PROGRAM_STRING_ARB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXT_FRAGMENT_SHADER_ATI   := new ProgramTarget($8200);
    private static _VERTEX_PROGRAM_ARB         := new ProgramTarget($8620);
    private static _FRAGMENT_PROGRAM_ARB       := new ProgramTarget($8804);
    private static _TESS_CONTROL_PROGRAM_NV    := new ProgramTarget($891E);
    private static _TESS_EVALUATION_PROGRAM_NV := new ProgramTarget($891F);
    private static _GEOMETRY_PROGRAM_NV        := new ProgramTarget($8C26);
    private static _COMPUTE_PROGRAM_NV         := new ProgramTarget($90FB);
    
    public static property TEXT_FRAGMENT_SHADER_ATI:   ProgramTarget read _TEXT_FRAGMENT_SHADER_ATI;
    public static property VERTEX_PROGRAM_ARB:         ProgramTarget read _VERTEX_PROGRAM_ARB;
    public static property FRAGMENT_PROGRAM_ARB:       ProgramTarget read _FRAGMENT_PROGRAM_ARB;
    public static property TESS_CONTROL_PROGRAM_NV:    ProgramTarget read _TESS_CONTROL_PROGRAM_NV;
    public static property TESS_EVALUATION_PROGRAM_NV: ProgramTarget read _TESS_EVALUATION_PROGRAM_NV;
    public static property GEOMETRY_PROGRAM_NV:        ProgramTarget read _GEOMETRY_PROGRAM_NV;
    public static property COMPUTE_PROGRAM_NV:         ProgramTarget read _COMPUTE_PROGRAM_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8200) then Result := 'TEXT_FRAGMENT_SHADER_ATI' else
      if self.val = UInt32($8620) then Result := 'VERTEX_PROGRAM_ARB' else
      if self.val = UInt32($8804) then Result := 'FRAGMENT_PROGRAM_ARB' else
      if self.val = UInt32($891E) then Result := 'TESS_CONTROL_PROGRAM_NV' else
      if self.val = UInt32($891F) then Result := 'TESS_EVALUATION_PROGRAM_NV' else
      if self.val = UInt32($8C26) then Result := 'GEOMETRY_PROGRAM_NV' else
      if self.val = UInt32($90FB) then Result := 'COMPUTE_PROGRAM_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  QueryCounterTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TIMESTAMP := new QueryCounterTarget($8E28);
    
    public static property TIMESTAMP: QueryCounterTarget read _TIMESTAMP;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E28) then Result := 'TIMESTAMP' else
        Result := self.val.ToString;
    end;
    
  end;
  
  QueryObjectParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _QUERY_TARGET           := new QueryObjectParameterName($82EA);
    private static _QUERY_RESULT           := new QueryObjectParameterName($8866);
    private static _QUERY_RESULT_AVAILABLE := new QueryObjectParameterName($8867);
    private static _QUERY_RESULT_NO_WAIT   := new QueryObjectParameterName($9194);
    
    public static property QUERY_TARGET:           QueryObjectParameterName read _QUERY_TARGET;
    public static property QUERY_RESULT:           QueryObjectParameterName read _QUERY_RESULT;
    public static property QUERY_RESULT_AVAILABLE: QueryObjectParameterName read _QUERY_RESULT_AVAILABLE;
    public static property QUERY_RESULT_NO_WAIT:   QueryObjectParameterName read _QUERY_RESULT_NO_WAIT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82EA) then Result := 'QUERY_TARGET' else
      if self.val = UInt32($8866) then Result := 'QUERY_RESULT' else
      if self.val = UInt32($8867) then Result := 'QUERY_RESULT_AVAILABLE' else
      if self.val = UInt32($9194) then Result := 'QUERY_RESULT_NO_WAIT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  QueryParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _QUERY_COUNTER_BITS := new QueryParameterName($8864);
    private static _CURRENT_QUERY      := new QueryParameterName($8865);
    
    public static property QUERY_COUNTER_BITS: QueryParameterName read _QUERY_COUNTER_BITS;
    public static property CURRENT_QUERY:      QueryParameterName read _CURRENT_QUERY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8864) then Result := 'QUERY_COUNTER_BITS' else
      if self.val = UInt32($8865) then Result := 'CURRENT_QUERY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  QueryTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TRANSFORM_FEEDBACK_OVERFLOW           := new QueryTarget($82EC);
    private static _VERTICES_SUBMITTED                    := new QueryTarget($82EE);
    private static _PRIMITIVES_SUBMITTED                  := new QueryTarget($82EF);
    private static _VERTEX_SHADER_INVOCATIONS             := new QueryTarget($82F0);
    private static _TIME_ELAPSED                          := new QueryTarget($88BF);
    private static _SAMPLES_PASSED                        := new QueryTarget($8914);
    private static _ANY_SAMPLES_PASSED                    := new QueryTarget($8C2F);
    private static _PRIMITIVES_GENERATED                  := new QueryTarget($8C87);
    private static _TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN := new QueryTarget($8C88);
    private static _ANY_SAMPLES_PASSED_CONSERVATIVE       := new QueryTarget($8D6A);
    
    public static property TRANSFORM_FEEDBACK_OVERFLOW:           QueryTarget read _TRANSFORM_FEEDBACK_OVERFLOW;
    public static property VERTICES_SUBMITTED:                    QueryTarget read _VERTICES_SUBMITTED;
    public static property PRIMITIVES_SUBMITTED:                  QueryTarget read _PRIMITIVES_SUBMITTED;
    public static property VERTEX_SHADER_INVOCATIONS:             QueryTarget read _VERTEX_SHADER_INVOCATIONS;
    public static property TIME_ELAPSED:                          QueryTarget read _TIME_ELAPSED;
    public static property SAMPLES_PASSED:                        QueryTarget read _SAMPLES_PASSED;
    public static property ANY_SAMPLES_PASSED:                    QueryTarget read _ANY_SAMPLES_PASSED;
    public static property PRIMITIVES_GENERATED:                  QueryTarget read _PRIMITIVES_GENERATED;
    public static property TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: QueryTarget read _TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN;
    public static property ANY_SAMPLES_PASSED_CONSERVATIVE:       QueryTarget read _ANY_SAMPLES_PASSED_CONSERVATIVE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82EC) then Result := 'TRANSFORM_FEEDBACK_OVERFLOW' else
      if self.val = UInt32($82EE) then Result := 'VERTICES_SUBMITTED' else
      if self.val = UInt32($82EF) then Result := 'PRIMITIVES_SUBMITTED' else
      if self.val = UInt32($82F0) then Result := 'VERTEX_SHADER_INVOCATIONS' else
      if self.val = UInt32($88BF) then Result := 'TIME_ELAPSED' else
      if self.val = UInt32($8914) then Result := 'SAMPLES_PASSED' else
      if self.val = UInt32($8C2F) then Result := 'ANY_SAMPLES_PASSED' else
      if self.val = UInt32($8C87) then Result := 'PRIMITIVES_GENERATED' else
      if self.val = UInt32($8C88) then Result := 'TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN' else
      if self.val = UInt32($8D6A) then Result := 'ANY_SAMPLES_PASSED_CONSERVATIVE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ReadBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE               := new ReadBufferMode($0000);
    private static _NONE_OES           := new ReadBufferMode($0000);
    private static _FRONT_LEFT         := new ReadBufferMode($0400);
    private static _FRONT_RIGHT        := new ReadBufferMode($0401);
    private static _BACK_LEFT          := new ReadBufferMode($0402);
    private static _BACK_RIGHT         := new ReadBufferMode($0403);
    private static _FRONT              := new ReadBufferMode($0404);
    private static _BACK               := new ReadBufferMode($0405);
    private static _LEFT               := new ReadBufferMode($0406);
    private static _RIGHT              := new ReadBufferMode($0407);
    private static _AUX0               := new ReadBufferMode($0409);
    private static _AUX1               := new ReadBufferMode($040A);
    private static _AUX2               := new ReadBufferMode($040B);
    private static _AUX3               := new ReadBufferMode($040C);
    private static _COLOR_ATTACHMENT0  := new ReadBufferMode($8CE0);
    private static _COLOR_ATTACHMENT1  := new ReadBufferMode($8CE1);
    private static _COLOR_ATTACHMENT2  := new ReadBufferMode($8CE2);
    private static _COLOR_ATTACHMENT3  := new ReadBufferMode($8CE3);
    private static _COLOR_ATTACHMENT4  := new ReadBufferMode($8CE4);
    private static _COLOR_ATTACHMENT5  := new ReadBufferMode($8CE5);
    private static _COLOR_ATTACHMENT6  := new ReadBufferMode($8CE6);
    private static _COLOR_ATTACHMENT7  := new ReadBufferMode($8CE7);
    private static _COLOR_ATTACHMENT8  := new ReadBufferMode($8CE8);
    private static _COLOR_ATTACHMENT9  := new ReadBufferMode($8CE9);
    private static _COLOR_ATTACHMENT10 := new ReadBufferMode($8CEA);
    private static _COLOR_ATTACHMENT11 := new ReadBufferMode($8CEB);
    private static _COLOR_ATTACHMENT12 := new ReadBufferMode($8CEC);
    private static _COLOR_ATTACHMENT13 := new ReadBufferMode($8CED);
    private static _COLOR_ATTACHMENT14 := new ReadBufferMode($8CEE);
    private static _COLOR_ATTACHMENT15 := new ReadBufferMode($8CEF);
    
    public static property NONE:               ReadBufferMode read _NONE;
    public static property NONE_OES:           ReadBufferMode read _NONE_OES;
    public static property FRONT_LEFT:         ReadBufferMode read _FRONT_LEFT;
    public static property FRONT_RIGHT:        ReadBufferMode read _FRONT_RIGHT;
    public static property BACK_LEFT:          ReadBufferMode read _BACK_LEFT;
    public static property BACK_RIGHT:         ReadBufferMode read _BACK_RIGHT;
    public static property FRONT:              ReadBufferMode read _FRONT;
    public static property BACK:               ReadBufferMode read _BACK;
    public static property LEFT:               ReadBufferMode read _LEFT;
    public static property RIGHT:              ReadBufferMode read _RIGHT;
    public static property AUX0:               ReadBufferMode read _AUX0;
    public static property AUX1:               ReadBufferMode read _AUX1;
    public static property AUX2:               ReadBufferMode read _AUX2;
    public static property AUX3:               ReadBufferMode read _AUX3;
    public static property COLOR_ATTACHMENT0:  ReadBufferMode read _COLOR_ATTACHMENT0;
    public static property COLOR_ATTACHMENT1:  ReadBufferMode read _COLOR_ATTACHMENT1;
    public static property COLOR_ATTACHMENT2:  ReadBufferMode read _COLOR_ATTACHMENT2;
    public static property COLOR_ATTACHMENT3:  ReadBufferMode read _COLOR_ATTACHMENT3;
    public static property COLOR_ATTACHMENT4:  ReadBufferMode read _COLOR_ATTACHMENT4;
    public static property COLOR_ATTACHMENT5:  ReadBufferMode read _COLOR_ATTACHMENT5;
    public static property COLOR_ATTACHMENT6:  ReadBufferMode read _COLOR_ATTACHMENT6;
    public static property COLOR_ATTACHMENT7:  ReadBufferMode read _COLOR_ATTACHMENT7;
    public static property COLOR_ATTACHMENT8:  ReadBufferMode read _COLOR_ATTACHMENT8;
    public static property COLOR_ATTACHMENT9:  ReadBufferMode read _COLOR_ATTACHMENT9;
    public static property COLOR_ATTACHMENT10: ReadBufferMode read _COLOR_ATTACHMENT10;
    public static property COLOR_ATTACHMENT11: ReadBufferMode read _COLOR_ATTACHMENT11;
    public static property COLOR_ATTACHMENT12: ReadBufferMode read _COLOR_ATTACHMENT12;
    public static property COLOR_ATTACHMENT13: ReadBufferMode read _COLOR_ATTACHMENT13;
    public static property COLOR_ATTACHMENT14: ReadBufferMode read _COLOR_ATTACHMENT14;
    public static property COLOR_ATTACHMENT15: ReadBufferMode read _COLOR_ATTACHMENT15;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($0000) then Result := 'NONE_OES' else
      if self.val = UInt32($0400) then Result := 'FRONT_LEFT' else
      if self.val = UInt32($0401) then Result := 'FRONT_RIGHT' else
      if self.val = UInt32($0402) then Result := 'BACK_LEFT' else
      if self.val = UInt32($0403) then Result := 'BACK_RIGHT' else
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0406) then Result := 'LEFT' else
      if self.val = UInt32($0407) then Result := 'RIGHT' else
      if self.val = UInt32($0409) then Result := 'AUX0' else
      if self.val = UInt32($040A) then Result := 'AUX1' else
      if self.val = UInt32($040B) then Result := 'AUX2' else
      if self.val = UInt32($040C) then Result := 'AUX3' else
      if self.val = UInt32($8CE0) then Result := 'COLOR_ATTACHMENT0' else
      if self.val = UInt32($8CE1) then Result := 'COLOR_ATTACHMENT1' else
      if self.val = UInt32($8CE2) then Result := 'COLOR_ATTACHMENT2' else
      if self.val = UInt32($8CE3) then Result := 'COLOR_ATTACHMENT3' else
      if self.val = UInt32($8CE4) then Result := 'COLOR_ATTACHMENT4' else
      if self.val = UInt32($8CE5) then Result := 'COLOR_ATTACHMENT5' else
      if self.val = UInt32($8CE6) then Result := 'COLOR_ATTACHMENT6' else
      if self.val = UInt32($8CE7) then Result := 'COLOR_ATTACHMENT7' else
      if self.val = UInt32($8CE8) then Result := 'COLOR_ATTACHMENT8' else
      if self.val = UInt32($8CE9) then Result := 'COLOR_ATTACHMENT9' else
      if self.val = UInt32($8CEA) then Result := 'COLOR_ATTACHMENT10' else
      if self.val = UInt32($8CEB) then Result := 'COLOR_ATTACHMENT11' else
      if self.val = UInt32($8CEC) then Result := 'COLOR_ATTACHMENT12' else
      if self.val = UInt32($8CED) then Result := 'COLOR_ATTACHMENT13' else
      if self.val = UInt32($8CEE) then Result := 'COLOR_ATTACHMENT14' else
      if self.val = UInt32($8CEF) then Result := 'COLOR_ATTACHMENT15' else
        Result := self.val.ToString;
    end;
    
  end;
  
  RenderbufferParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _RENDERBUFFER_COVERAGE_SAMPLES_NV := new RenderbufferParameterName($8CAB);
    private static _RENDERBUFFER_SAMPLES             := new RenderbufferParameterName($8CAB);
    private static _RENDERBUFFER_SAMPLES_ANGLE       := new RenderbufferParameterName($8CAB);
    private static _RENDERBUFFER_SAMPLES_APPLE       := new RenderbufferParameterName($8CAB);
    private static _RENDERBUFFER_SAMPLES_EXT         := new RenderbufferParameterName($8CAB);
    private static _RENDERBUFFER_SAMPLES_NV          := new RenderbufferParameterName($8CAB);
    private static _RENDERBUFFER_WIDTH               := new RenderbufferParameterName($8D42);
    private static _RENDERBUFFER_WIDTH_EXT           := new RenderbufferParameterName($8D42);
    private static _RENDERBUFFER_WIDTH_OES           := new RenderbufferParameterName($8D42);
    private static _RENDERBUFFER_HEIGHT              := new RenderbufferParameterName($8D43);
    private static _RENDERBUFFER_HEIGHT_EXT          := new RenderbufferParameterName($8D43);
    private static _RENDERBUFFER_HEIGHT_OES          := new RenderbufferParameterName($8D43);
    private static _RENDERBUFFER_INTERNAL_FORMAT     := new RenderbufferParameterName($8D44);
    private static _RENDERBUFFER_INTERNAL_FORMAT_EXT := new RenderbufferParameterName($8D44);
    private static _RENDERBUFFER_INTERNAL_FORMAT_OES := new RenderbufferParameterName($8D44);
    private static _RENDERBUFFER_RED_SIZE            := new RenderbufferParameterName($8D50);
    private static _RENDERBUFFER_RED_SIZE_EXT        := new RenderbufferParameterName($8D50);
    private static _RENDERBUFFER_RED_SIZE_OES        := new RenderbufferParameterName($8D50);
    private static _RENDERBUFFER_GREEN_SIZE          := new RenderbufferParameterName($8D51);
    private static _RENDERBUFFER_GREEN_SIZE_EXT      := new RenderbufferParameterName($8D51);
    private static _RENDERBUFFER_GREEN_SIZE_OES      := new RenderbufferParameterName($8D51);
    private static _RENDERBUFFER_BLUE_SIZE           := new RenderbufferParameterName($8D52);
    private static _RENDERBUFFER_BLUE_SIZE_EXT       := new RenderbufferParameterName($8D52);
    private static _RENDERBUFFER_BLUE_SIZE_OES       := new RenderbufferParameterName($8D52);
    private static _RENDERBUFFER_ALPHA_SIZE          := new RenderbufferParameterName($8D53);
    private static _RENDERBUFFER_ALPHA_SIZE_EXT      := new RenderbufferParameterName($8D53);
    private static _RENDERBUFFER_ALPHA_SIZE_OES      := new RenderbufferParameterName($8D53);
    private static _RENDERBUFFER_DEPTH_SIZE          := new RenderbufferParameterName($8D54);
    private static _RENDERBUFFER_DEPTH_SIZE_EXT      := new RenderbufferParameterName($8D54);
    private static _RENDERBUFFER_DEPTH_SIZE_OES      := new RenderbufferParameterName($8D54);
    private static _RENDERBUFFER_STENCIL_SIZE        := new RenderbufferParameterName($8D55);
    private static _RENDERBUFFER_STENCIL_SIZE_EXT    := new RenderbufferParameterName($8D55);
    private static _RENDERBUFFER_STENCIL_SIZE_OES    := new RenderbufferParameterName($8D55);
    private static _RENDERBUFFER_COLOR_SAMPLES_NV    := new RenderbufferParameterName($8E10);
    private static _RENDERBUFFER_SAMPLES_IMG         := new RenderbufferParameterName($9133);
    private static _RENDERBUFFER_STORAGE_SAMPLES_AMD := new RenderbufferParameterName($91B2);
    
    public static property RENDERBUFFER_COVERAGE_SAMPLES_NV: RenderbufferParameterName read _RENDERBUFFER_COVERAGE_SAMPLES_NV;
    public static property RENDERBUFFER_SAMPLES:             RenderbufferParameterName read _RENDERBUFFER_SAMPLES;
    public static property RENDERBUFFER_SAMPLES_ANGLE:       RenderbufferParameterName read _RENDERBUFFER_SAMPLES_ANGLE;
    public static property RENDERBUFFER_SAMPLES_APPLE:       RenderbufferParameterName read _RENDERBUFFER_SAMPLES_APPLE;
    public static property RENDERBUFFER_SAMPLES_EXT:         RenderbufferParameterName read _RENDERBUFFER_SAMPLES_EXT;
    public static property RENDERBUFFER_SAMPLES_NV:          RenderbufferParameterName read _RENDERBUFFER_SAMPLES_NV;
    public static property RENDERBUFFER_WIDTH:               RenderbufferParameterName read _RENDERBUFFER_WIDTH;
    public static property RENDERBUFFER_WIDTH_EXT:           RenderbufferParameterName read _RENDERBUFFER_WIDTH_EXT;
    public static property RENDERBUFFER_WIDTH_OES:           RenderbufferParameterName read _RENDERBUFFER_WIDTH_OES;
    public static property RENDERBUFFER_HEIGHT:              RenderbufferParameterName read _RENDERBUFFER_HEIGHT;
    public static property RENDERBUFFER_HEIGHT_EXT:          RenderbufferParameterName read _RENDERBUFFER_HEIGHT_EXT;
    public static property RENDERBUFFER_HEIGHT_OES:          RenderbufferParameterName read _RENDERBUFFER_HEIGHT_OES;
    public static property RENDERBUFFER_INTERNAL_FORMAT:     RenderbufferParameterName read _RENDERBUFFER_INTERNAL_FORMAT;
    public static property RENDERBUFFER_INTERNAL_FORMAT_EXT: RenderbufferParameterName read _RENDERBUFFER_INTERNAL_FORMAT_EXT;
    public static property RENDERBUFFER_INTERNAL_FORMAT_OES: RenderbufferParameterName read _RENDERBUFFER_INTERNAL_FORMAT_OES;
    public static property RENDERBUFFER_RED_SIZE:            RenderbufferParameterName read _RENDERBUFFER_RED_SIZE;
    public static property RENDERBUFFER_RED_SIZE_EXT:        RenderbufferParameterName read _RENDERBUFFER_RED_SIZE_EXT;
    public static property RENDERBUFFER_RED_SIZE_OES:        RenderbufferParameterName read _RENDERBUFFER_RED_SIZE_OES;
    public static property RENDERBUFFER_GREEN_SIZE:          RenderbufferParameterName read _RENDERBUFFER_GREEN_SIZE;
    public static property RENDERBUFFER_GREEN_SIZE_EXT:      RenderbufferParameterName read _RENDERBUFFER_GREEN_SIZE_EXT;
    public static property RENDERBUFFER_GREEN_SIZE_OES:      RenderbufferParameterName read _RENDERBUFFER_GREEN_SIZE_OES;
    public static property RENDERBUFFER_BLUE_SIZE:           RenderbufferParameterName read _RENDERBUFFER_BLUE_SIZE;
    public static property RENDERBUFFER_BLUE_SIZE_EXT:       RenderbufferParameterName read _RENDERBUFFER_BLUE_SIZE_EXT;
    public static property RENDERBUFFER_BLUE_SIZE_OES:       RenderbufferParameterName read _RENDERBUFFER_BLUE_SIZE_OES;
    public static property RENDERBUFFER_ALPHA_SIZE:          RenderbufferParameterName read _RENDERBUFFER_ALPHA_SIZE;
    public static property RENDERBUFFER_ALPHA_SIZE_EXT:      RenderbufferParameterName read _RENDERBUFFER_ALPHA_SIZE_EXT;
    public static property RENDERBUFFER_ALPHA_SIZE_OES:      RenderbufferParameterName read _RENDERBUFFER_ALPHA_SIZE_OES;
    public static property RENDERBUFFER_DEPTH_SIZE:          RenderbufferParameterName read _RENDERBUFFER_DEPTH_SIZE;
    public static property RENDERBUFFER_DEPTH_SIZE_EXT:      RenderbufferParameterName read _RENDERBUFFER_DEPTH_SIZE_EXT;
    public static property RENDERBUFFER_DEPTH_SIZE_OES:      RenderbufferParameterName read _RENDERBUFFER_DEPTH_SIZE_OES;
    public static property RENDERBUFFER_STENCIL_SIZE:        RenderbufferParameterName read _RENDERBUFFER_STENCIL_SIZE;
    public static property RENDERBUFFER_STENCIL_SIZE_EXT:    RenderbufferParameterName read _RENDERBUFFER_STENCIL_SIZE_EXT;
    public static property RENDERBUFFER_STENCIL_SIZE_OES:    RenderbufferParameterName read _RENDERBUFFER_STENCIL_SIZE_OES;
    public static property RENDERBUFFER_COLOR_SAMPLES_NV:    RenderbufferParameterName read _RENDERBUFFER_COLOR_SAMPLES_NV;
    public static property RENDERBUFFER_SAMPLES_IMG:         RenderbufferParameterName read _RENDERBUFFER_SAMPLES_IMG;
    public static property RENDERBUFFER_STORAGE_SAMPLES_AMD: RenderbufferParameterName read _RENDERBUFFER_STORAGE_SAMPLES_AMD;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_COVERAGE_SAMPLES_NV' else
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_SAMPLES' else
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_SAMPLES_ANGLE' else
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_SAMPLES_APPLE' else
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_SAMPLES_EXT' else
      if self.val = UInt32($8CAB) then Result := 'RENDERBUFFER_SAMPLES_NV' else
      if self.val = UInt32($8D42) then Result := 'RENDERBUFFER_WIDTH' else
      if self.val = UInt32($8D42) then Result := 'RENDERBUFFER_WIDTH_EXT' else
      if self.val = UInt32($8D42) then Result := 'RENDERBUFFER_WIDTH_OES' else
      if self.val = UInt32($8D43) then Result := 'RENDERBUFFER_HEIGHT' else
      if self.val = UInt32($8D43) then Result := 'RENDERBUFFER_HEIGHT_EXT' else
      if self.val = UInt32($8D43) then Result := 'RENDERBUFFER_HEIGHT_OES' else
      if self.val = UInt32($8D44) then Result := 'RENDERBUFFER_INTERNAL_FORMAT' else
      if self.val = UInt32($8D44) then Result := 'RENDERBUFFER_INTERNAL_FORMAT_EXT' else
      if self.val = UInt32($8D44) then Result := 'RENDERBUFFER_INTERNAL_FORMAT_OES' else
      if self.val = UInt32($8D50) then Result := 'RENDERBUFFER_RED_SIZE' else
      if self.val = UInt32($8D50) then Result := 'RENDERBUFFER_RED_SIZE_EXT' else
      if self.val = UInt32($8D50) then Result := 'RENDERBUFFER_RED_SIZE_OES' else
      if self.val = UInt32($8D51) then Result := 'RENDERBUFFER_GREEN_SIZE' else
      if self.val = UInt32($8D51) then Result := 'RENDERBUFFER_GREEN_SIZE_EXT' else
      if self.val = UInt32($8D51) then Result := 'RENDERBUFFER_GREEN_SIZE_OES' else
      if self.val = UInt32($8D52) then Result := 'RENDERBUFFER_BLUE_SIZE' else
      if self.val = UInt32($8D52) then Result := 'RENDERBUFFER_BLUE_SIZE_EXT' else
      if self.val = UInt32($8D52) then Result := 'RENDERBUFFER_BLUE_SIZE_OES' else
      if self.val = UInt32($8D53) then Result := 'RENDERBUFFER_ALPHA_SIZE' else
      if self.val = UInt32($8D53) then Result := 'RENDERBUFFER_ALPHA_SIZE_EXT' else
      if self.val = UInt32($8D53) then Result := 'RENDERBUFFER_ALPHA_SIZE_OES' else
      if self.val = UInt32($8D54) then Result := 'RENDERBUFFER_DEPTH_SIZE' else
      if self.val = UInt32($8D54) then Result := 'RENDERBUFFER_DEPTH_SIZE_EXT' else
      if self.val = UInt32($8D54) then Result := 'RENDERBUFFER_DEPTH_SIZE_OES' else
      if self.val = UInt32($8D55) then Result := 'RENDERBUFFER_STENCIL_SIZE' else
      if self.val = UInt32($8D55) then Result := 'RENDERBUFFER_STENCIL_SIZE_EXT' else
      if self.val = UInt32($8D55) then Result := 'RENDERBUFFER_STENCIL_SIZE_OES' else
      if self.val = UInt32($8E10) then Result := 'RENDERBUFFER_COLOR_SAMPLES_NV' else
      if self.val = UInt32($9133) then Result := 'RENDERBUFFER_SAMPLES_IMG' else
      if self.val = UInt32($91B2) then Result := 'RENDERBUFFER_STORAGE_SAMPLES_AMD' else
        Result := self.val.ToString;
    end;
    
  end;
  
  RenderbufferTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _RENDERBUFFER     := new RenderbufferTarget($8D41);
    private static _RENDERBUFFER_OES := new RenderbufferTarget($8D41);
    
    public static property RENDERBUFFER:     RenderbufferTarget read _RENDERBUFFER;
    public static property RENDERBUFFER_OES: RenderbufferTarget read _RENDERBUFFER_OES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER' else
      if self.val = UInt32($8D41) then Result := 'RENDERBUFFER_OES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  RenderingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _RENDER   := new RenderingMode($1C00);
    private static _FEEDBACK := new RenderingMode($1C01);
    private static _SELECT   := new RenderingMode($1C02);
    
    public static property RENDER:   RenderingMode read _RENDER;
    public static property FEEDBACK: RenderingMode read _FEEDBACK;
    public static property SELECT:   RenderingMode read _SELECT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1C00) then Result := 'RENDER' else
      if self.val = UInt32($1C01) then Result := 'FEEDBACK' else
      if self.val = UInt32($1C02) then Result := 'SELECT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SamplerParameterF = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_BORDER_COLOR                 := new SamplerParameterF($1004);
    private static _TEXTURE_MIN_LOD                      := new SamplerParameterF($813A);
    private static _TEXTURE_MAX_LOD                      := new SamplerParameterF($813B);
    private static _TEXTURE_MAX_ANISOTROPY               := new SamplerParameterF($84FE);
    private static _TEXTURE_LOD_BIAS                     := new SamplerParameterF($8501);
    private static _TEXTURE_UNNORMALIZED_COORDINATES_ARM := new SamplerParameterF($8F6A);
    
    public static property TEXTURE_BORDER_COLOR:                 SamplerParameterF read _TEXTURE_BORDER_COLOR;
    public static property TEXTURE_MIN_LOD:                      SamplerParameterF read _TEXTURE_MIN_LOD;
    public static property TEXTURE_MAX_LOD:                      SamplerParameterF read _TEXTURE_MAX_LOD;
    public static property TEXTURE_MAX_ANISOTROPY:               SamplerParameterF read _TEXTURE_MAX_ANISOTROPY;
    public static property TEXTURE_LOD_BIAS:                     SamplerParameterF read _TEXTURE_LOD_BIAS;
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: SamplerParameterF read _TEXTURE_UNNORMALIZED_COORDINATES_ARM;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR' else
      if self.val = UInt32($813A) then Result := 'TEXTURE_MIN_LOD' else
      if self.val = UInt32($813B) then Result := 'TEXTURE_MAX_LOD' else
      if self.val = UInt32($84FE) then Result := 'TEXTURE_MAX_ANISOTROPY' else
      if self.val = UInt32($8501) then Result := 'TEXTURE_LOD_BIAS' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SamplerParameterI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_MAG_FILTER                   := new SamplerParameterI($2800);
    private static _TEXTURE_MIN_FILTER                   := new SamplerParameterI($2801);
    private static _TEXTURE_WRAP_S                       := new SamplerParameterI($2802);
    private static _TEXTURE_WRAP_T                       := new SamplerParameterI($2803);
    private static _TEXTURE_WRAP_R                       := new SamplerParameterI($8072);
    private static _TEXTURE_COMPARE_MODE                 := new SamplerParameterI($884C);
    private static _TEXTURE_COMPARE_FUNC                 := new SamplerParameterI($884D);
    private static _TEXTURE_UNNORMALIZED_COORDINATES_ARM := new SamplerParameterI($8F6A);
    
    public static property TEXTURE_MAG_FILTER:                   SamplerParameterI read _TEXTURE_MAG_FILTER;
    public static property TEXTURE_MIN_FILTER:                   SamplerParameterI read _TEXTURE_MIN_FILTER;
    public static property TEXTURE_WRAP_S:                       SamplerParameterI read _TEXTURE_WRAP_S;
    public static property TEXTURE_WRAP_T:                       SamplerParameterI read _TEXTURE_WRAP_T;
    public static property TEXTURE_WRAP_R:                       SamplerParameterI read _TEXTURE_WRAP_R;
    public static property TEXTURE_COMPARE_MODE:                 SamplerParameterI read _TEXTURE_COMPARE_MODE;
    public static property TEXTURE_COMPARE_FUNC:                 SamplerParameterI read _TEXTURE_COMPARE_FUNC;
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: SamplerParameterI read _TEXTURE_UNNORMALIZED_COORDINATES_ARM;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2800) then Result := 'TEXTURE_MAG_FILTER' else
      if self.val = UInt32($2801) then Result := 'TEXTURE_MIN_FILTER' else
      if self.val = UInt32($2802) then Result := 'TEXTURE_WRAP_S' else
      if self.val = UInt32($2803) then Result := 'TEXTURE_WRAP_T' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R' else
      if self.val = UInt32($884C) then Result := 'TEXTURE_COMPARE_MODE' else
      if self.val = UInt32($884D) then Result := 'TEXTURE_COMPARE_FUNC' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ScalarType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNSIGNED_BYTE  := new ScalarType($1401);
    private static _UNSIGNED_SHORT := new ScalarType($1403);
    private static _UNSIGNED_INT   := new ScalarType($1405);
    
    public static property UNSIGNED_BYTE:  ScalarType read _UNSIGNED_BYTE;
    public static property UNSIGNED_SHORT: ScalarType read _UNSIGNED_SHORT;
    public static property UNSIGNED_INT:   ScalarType read _UNSIGNED_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SemaphoreParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _D3D12_FENCE_VALUE_EXT := new SemaphoreParameterName($9595);
    
    public static property D3D12_FENCE_VALUE_EXT: SemaphoreParameterName read _D3D12_FENCE_VALUE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9595) then Result := 'D3D12_FENCE_VALUE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ShaderParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SHADER_TYPE          := new ShaderParameterName($8B4F);
    private static _DELETE_STATUS        := new ShaderParameterName($8B80);
    private static _COMPILE_STATUS       := new ShaderParameterName($8B81);
    private static _INFO_LOG_LENGTH      := new ShaderParameterName($8B84);
    private static _SHADER_SOURCE_LENGTH := new ShaderParameterName($8B88);
    
    public static property SHADER_TYPE:          ShaderParameterName read _SHADER_TYPE;
    public static property DELETE_STATUS:        ShaderParameterName read _DELETE_STATUS;
    public static property COMPILE_STATUS:       ShaderParameterName read _COMPILE_STATUS;
    public static property INFO_LOG_LENGTH:      ShaderParameterName read _INFO_LOG_LENGTH;
    public static property SHADER_SOURCE_LENGTH: ShaderParameterName read _SHADER_SOURCE_LENGTH;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8B4F) then Result := 'SHADER_TYPE' else
      if self.val = UInt32($8B80) then Result := 'DELETE_STATUS' else
      if self.val = UInt32($8B81) then Result := 'COMPILE_STATUS' else
      if self.val = UInt32($8B84) then Result := 'INFO_LOG_LENGTH' else
      if self.val = UInt32($8B88) then Result := 'SHADER_SOURCE_LENGTH' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ShaderType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRAGMENT_SHADER        := new ShaderType($8B30);
    private static _FRAGMENT_SHADER_ARB    := new ShaderType($8B30);
    private static _VERTEX_SHADER          := new ShaderType($8B31);
    private static _VERTEX_SHADER_ARB      := new ShaderType($8B31);
    private static _GEOMETRY_SHADER        := new ShaderType($8DD9);
    private static _TESS_EVALUATION_SHADER := new ShaderType($8E87);
    private static _TESS_CONTROL_SHADER    := new ShaderType($8E88);
    private static _COMPUTE_SHADER         := new ShaderType($91B9);
    
    public static property FRAGMENT_SHADER:        ShaderType read _FRAGMENT_SHADER;
    public static property FRAGMENT_SHADER_ARB:    ShaderType read _FRAGMENT_SHADER_ARB;
    public static property VERTEX_SHADER:          ShaderType read _VERTEX_SHADER;
    public static property VERTEX_SHADER_ARB:      ShaderType read _VERTEX_SHADER_ARB;
    public static property GEOMETRY_SHADER:        ShaderType read _GEOMETRY_SHADER;
    public static property TESS_EVALUATION_SHADER: ShaderType read _TESS_EVALUATION_SHADER;
    public static property TESS_CONTROL_SHADER:    ShaderType read _TESS_CONTROL_SHADER;
    public static property COMPUTE_SHADER:         ShaderType read _COMPUTE_SHADER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8B30) then Result := 'FRAGMENT_SHADER' else
      if self.val = UInt32($8B30) then Result := 'FRAGMENT_SHADER_ARB' else
      if self.val = UInt32($8B31) then Result := 'VERTEX_SHADER' else
      if self.val = UInt32($8B31) then Result := 'VERTEX_SHADER_ARB' else
      if self.val = UInt32($8DD9) then Result := 'GEOMETRY_SHADER' else
      if self.val = UInt32($8E87) then Result := 'TESS_EVALUATION_SHADER' else
      if self.val = UInt32($8E88) then Result := 'TESS_CONTROL_SHADER' else
      if self.val = UInt32($91B9) then Result := 'COMPUTE_SHADER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ShadingModel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FLAT   := new ShadingModel($1D00);
    private static _SMOOTH := new ShadingModel($1D01);
    
    public static property FLAT:   ShadingModel read _FLAT;
    public static property SMOOTH: ShadingModel read _SMOOTH;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1D00) then Result := 'FLAT' else
      if self.val = UInt32($1D01) then Result := 'SMOOTH' else
        Result := self.val.ToString;
    end;
    
  end;
  
  StencilFaceDirection = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRONT          := new StencilFaceDirection($0404);
    private static _BACK           := new StencilFaceDirection($0405);
    private static _FRONT_AND_BACK := new StencilFaceDirection($0408);
    
    public static property FRONT:          StencilFaceDirection read _FRONT;
    public static property BACK:           StencilFaceDirection read _BACK;
    public static property FRONT_AND_BACK: StencilFaceDirection read _FRONT_AND_BACK;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0404) then Result := 'FRONT' else
      if self.val = UInt32($0405) then Result := 'BACK' else
      if self.val = UInt32($0408) then Result := 'FRONT_AND_BACK' else
        Result := self.val.ToString;
    end;
    
  end;
  
  StencilFunction = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NEVER    := new StencilFunction($0200);
    private static _LESS     := new StencilFunction($0201);
    private static _EQUAL    := new StencilFunction($0202);
    private static _LEQUAL   := new StencilFunction($0203);
    private static _GREATER  := new StencilFunction($0204);
    private static _NOTEQUAL := new StencilFunction($0205);
    private static _GEQUAL   := new StencilFunction($0206);
    private static _ALWAYS   := new StencilFunction($0207);
    
    public static property NEVER:    StencilFunction read _NEVER;
    public static property LESS:     StencilFunction read _LESS;
    public static property EQUAL:    StencilFunction read _EQUAL;
    public static property LEQUAL:   StencilFunction read _LEQUAL;
    public static property GREATER:  StencilFunction read _GREATER;
    public static property NOTEQUAL: StencilFunction read _NOTEQUAL;
    public static property GEQUAL:   StencilFunction read _GEQUAL;
    public static property ALWAYS:   StencilFunction read _ALWAYS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  StencilOp = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ZERO      := new StencilOp($0000);
    private static _INVERT    := new StencilOp($150A);
    private static _KEEP      := new StencilOp($1E00);
    private static _REPLACE   := new StencilOp($1E01);
    private static _INCR      := new StencilOp($1E02);
    private static _DECR      := new StencilOp($1E03);
    private static _INCR_WRAP := new StencilOp($8507);
    private static _DECR_WRAP := new StencilOp($8508);
    
    public static property ZERO:      StencilOp read _ZERO;
    public static property INVERT:    StencilOp read _INVERT;
    public static property KEEP:      StencilOp read _KEEP;
    public static property REPLACE:   StencilOp read _REPLACE;
    public static property INCR:      StencilOp read _INCR;
    public static property DECR:      StencilOp read _DECR;
    public static property INCR_WRAP: StencilOp read _INCR_WRAP;
    public static property DECR_WRAP: StencilOp read _DECR_WRAP;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'ZERO' else
      if self.val = UInt32($150A) then Result := 'INVERT' else
      if self.val = UInt32($1E00) then Result := 'KEEP' else
      if self.val = UInt32($1E01) then Result := 'REPLACE' else
      if self.val = UInt32($1E02) then Result := 'INCR' else
      if self.val = UInt32($1E03) then Result := 'DECR' else
      if self.val = UInt32($8507) then Result := 'INCR_WRAP' else
      if self.val = UInt32($8508) then Result := 'DECR_WRAP' else
        Result := self.val.ToString;
    end;
    
  end;
  
  StringName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VENDOR                   := new StringName($1F00);
    private static _RENDERER                 := new StringName($1F01);
    private static _VERSION                  := new StringName($1F02);
    private static _EXTENSIONS               := new StringName($1F03);
    private static _SHADING_LANGUAGE_VERSION := new StringName($8B8C);
    
    public static property VENDOR:                   StringName read _VENDOR;
    public static property RENDERER:                 StringName read _RENDERER;
    public static property VERSION:                  StringName read _VERSION;
    public static property EXTENSIONS:               StringName read _EXTENSIONS;
    public static property SHADING_LANGUAGE_VERSION: StringName read _SHADING_LANGUAGE_VERSION;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1F00) then Result := 'VENDOR' else
      if self.val = UInt32($1F01) then Result := 'RENDERER' else
      if self.val = UInt32($1F02) then Result := 'VERSION' else
      if self.val = UInt32($1F03) then Result := 'EXTENSIONS' else
      if self.val = UInt32($8B8C) then Result := 'SHADING_LANGUAGE_VERSION' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SubroutineParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNIFORM_SIZE               := new SubroutineParameterName($8A38);
    private static _UNIFORM_NAME_LENGTH        := new SubroutineParameterName($8A39);
    private static _NUM_COMPATIBLE_SUBROUTINES := new SubroutineParameterName($8E4A);
    private static _COMPATIBLE_SUBROUTINES     := new SubroutineParameterName($8E4B);
    
    public static property UNIFORM_SIZE:               SubroutineParameterName read _UNIFORM_SIZE;
    public static property UNIFORM_NAME_LENGTH:        SubroutineParameterName read _UNIFORM_NAME_LENGTH;
    public static property NUM_COMPATIBLE_SUBROUTINES: SubroutineParameterName read _NUM_COMPATIBLE_SUBROUTINES;
    public static property COMPATIBLE_SUBROUTINES:     SubroutineParameterName read _COMPATIBLE_SUBROUTINES;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8A38) then Result := 'UNIFORM_SIZE' else
      if self.val = UInt32($8A39) then Result := 'UNIFORM_NAME_LENGTH' else
      if self.val = UInt32($8E4A) then Result := 'NUM_COMPATIBLE_SUBROUTINES' else
      if self.val = UInt32($8E4B) then Result := 'COMPATIBLE_SUBROUTINES' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SyncCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SYNC_GPU_COMMANDS_COMPLETE := new SyncCondition($9117);
    
    public static property SYNC_GPU_COMMANDS_COMPLETE: SyncCondition read _SYNC_GPU_COMMANDS_COMPLETE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9117) then Result := 'SYNC_GPU_COMMANDS_COMPLETE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SyncObjectMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SYNC_FLUSH_COMMANDS_BIT       := new SyncObjectMask($0001);
    private static _SYNC_FLUSH_COMMANDS_BIT_APPLE := new SyncObjectMask($0001);
    
    public static property SYNC_FLUSH_COMMANDS_BIT:       SyncObjectMask read _SYNC_FLUSH_COMMANDS_BIT;
    public static property SYNC_FLUSH_COMMANDS_BIT_APPLE: SyncObjectMask read _SYNC_FLUSH_COMMANDS_BIT_APPLE;
    
    public static function operator or(f1,f2: SyncObjectMask) := new SyncObjectMask(f1.val or f2.val);
    
    public property HAS_FLAG_SYNC_FLUSH_COMMANDS_BIT:       boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_SYNC_FLUSH_COMMANDS_BIT_APPLE: boolean read self.val and $0001 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'SYNC_FLUSH_COMMANDS_BIT+';
      if self.val and UInt32($0001) = UInt32($0001) then res += 'SYNC_FLUSH_COMMANDS_BIT_APPLE+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  SyncParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _OBJECT_TYPE    := new SyncParameterName($9112);
    private static _SYNC_CONDITION := new SyncParameterName($9113);
    private static _SYNC_STATUS    := new SyncParameterName($9114);
    private static _SYNC_FLAGS     := new SyncParameterName($9115);
    
    public static property OBJECT_TYPE:    SyncParameterName read _OBJECT_TYPE;
    public static property SYNC_CONDITION: SyncParameterName read _SYNC_CONDITION;
    public static property SYNC_STATUS:    SyncParameterName read _SYNC_STATUS;
    public static property SYNC_FLAGS:     SyncParameterName read _SYNC_FLAGS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9112) then Result := 'OBJECT_TYPE' else
      if self.val = UInt32($9113) then Result := 'SYNC_CONDITION' else
      if self.val = UInt32($9114) then Result := 'SYNC_STATUS' else
      if self.val = UInt32($9115) then Result := 'SYNC_FLAGS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SyncStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ALREADY_SIGNALED    := new SyncStatus($911A);
    private static _TIMEOUT_EXPIRED     := new SyncStatus($911B);
    private static _CONDITION_SATISFIED := new SyncStatus($911C);
    private static _WAIT_FAILED         := new SyncStatus($911D);
    
    public static property ALREADY_SIGNALED:    SyncStatus read _ALREADY_SIGNALED;
    public static property TIMEOUT_EXPIRED:     SyncStatus read _TIMEOUT_EXPIRED;
    public static property CONDITION_SATISFIED: SyncStatus read _CONDITION_SATISFIED;
    public static property WAIT_FAILED:         SyncStatus read _WAIT_FAILED;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($911A) then Result := 'ALREADY_SIGNALED' else
      if self.val = UInt32($911B) then Result := 'TIMEOUT_EXPIRED' else
      if self.val = UInt32($911C) then Result := 'CONDITION_SATISFIED' else
      if self.val = UInt32($911D) then Result := 'WAIT_FAILED' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TexCoordPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SHORT  := new TexCoordPointerType($1402);
    private static _INT    := new TexCoordPointerType($1404);
    private static _FLOAT  := new TexCoordPointerType($1406);
    private static _DOUBLE := new TexCoordPointerType($140A);
    
    public static property SHORT:  TexCoordPointerType read _SHORT;
    public static property INT:    TexCoordPointerType read _INT;
    public static property FLOAT:  TexCoordPointerType read _FLOAT;
    public static property DOUBLE: TexCoordPointerType read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureCoordName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _S := new TextureCoordName($2000);
    private static _T := new TextureCoordName($2001);
    private static _R := new TextureCoordName($2002);
    private static _Q := new TextureCoordName($2003);
    
    public static property S: TextureCoordName read _S;
    public static property T: TextureCoordName read _T;
    public static property R: TextureCoordName read _R;
    public static property Q: TextureCoordName read _Q;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2000) then Result := 'S' else
      if self.val = UInt32($2001) then Result := 'T' else
      if self.val = UInt32($2002) then Result := 'R' else
      if self.val = UInt32($2003) then Result := 'Q' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureEnvParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_ENV_MODE  := new TextureEnvParameter($2200);
    private static _TEXTURE_ENV_COLOR := new TextureEnvParameter($2201);
    
    public static property TEXTURE_ENV_MODE:  TextureEnvParameter read _TEXTURE_ENV_MODE;
    public static property TEXTURE_ENV_COLOR: TextureEnvParameter read _TEXTURE_ENV_COLOR;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2200) then Result := 'TEXTURE_ENV_MODE' else
      if self.val = UInt32($2201) then Result := 'TEXTURE_ENV_COLOR' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureEnvTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_ENV := new TextureEnvTarget($2300);
    
    public static property TEXTURE_ENV: TextureEnvTarget read _TEXTURE_ENV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2300) then Result := 'TEXTURE_ENV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureGenParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_GEN_MODE  := new TextureGenParameter($2500);
    private static _OBJECT_PLANE      := new TextureGenParameter($2501);
    private static _EYE_PLANE         := new TextureGenParameter($2502);
    private static _EYE_POINT_SGIS    := new TextureGenParameter($81F4);
    private static _OBJECT_POINT_SGIS := new TextureGenParameter($81F5);
    private static _EYE_LINE_SGIS     := new TextureGenParameter($81F6);
    private static _OBJECT_LINE_SGIS  := new TextureGenParameter($81F7);
    
    public static property TEXTURE_GEN_MODE:  TextureGenParameter read _TEXTURE_GEN_MODE;
    public static property OBJECT_PLANE:      TextureGenParameter read _OBJECT_PLANE;
    public static property EYE_PLANE:         TextureGenParameter read _EYE_PLANE;
    public static property EYE_POINT_SGIS:    TextureGenParameter read _EYE_POINT_SGIS;
    public static property OBJECT_POINT_SGIS: TextureGenParameter read _OBJECT_POINT_SGIS;
    public static property EYE_LINE_SGIS:     TextureGenParameter read _EYE_LINE_SGIS;
    public static property OBJECT_LINE_SGIS:  TextureGenParameter read _OBJECT_LINE_SGIS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($2500) then Result := 'TEXTURE_GEN_MODE' else
      if self.val = UInt32($2501) then Result := 'OBJECT_PLANE' else
      if self.val = UInt32($2502) then Result := 'EYE_PLANE' else
      if self.val = UInt32($81F4) then Result := 'EYE_POINT_SGIS' else
      if self.val = UInt32($81F5) then Result := 'OBJECT_POINT_SGIS' else
      if self.val = UInt32($81F6) then Result := 'EYE_LINE_SGIS' else
      if self.val = UInt32($81F7) then Result := 'OBJECT_LINE_SGIS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureLayout = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT := new TextureLayout($9530);
    private static _LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT := new TextureLayout($9531);
    private static _LAYOUT_GENERAL_EXT                            := new TextureLayout($958D);
    private static _LAYOUT_COLOR_ATTACHMENT_EXT                   := new TextureLayout($958E);
    private static _LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT           := new TextureLayout($958F);
    private static _LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT            := new TextureLayout($9590);
    private static _LAYOUT_SHADER_READ_ONLY_EXT                   := new TextureLayout($9591);
    private static _LAYOUT_TRANSFER_SRC_EXT                       := new TextureLayout($9592);
    private static _LAYOUT_TRANSFER_DST_EXT                       := new TextureLayout($9593);
    
    public static property LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT: TextureLayout read _LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT;
    public static property LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT: TextureLayout read _LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT;
    public static property LAYOUT_GENERAL_EXT:                            TextureLayout read _LAYOUT_GENERAL_EXT;
    public static property LAYOUT_COLOR_ATTACHMENT_EXT:                   TextureLayout read _LAYOUT_COLOR_ATTACHMENT_EXT;
    public static property LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT:           TextureLayout read _LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT;
    public static property LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT:            TextureLayout read _LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT;
    public static property LAYOUT_SHADER_READ_ONLY_EXT:                   TextureLayout read _LAYOUT_SHADER_READ_ONLY_EXT;
    public static property LAYOUT_TRANSFER_SRC_EXT:                       TextureLayout read _LAYOUT_TRANSFER_SRC_EXT;
    public static property LAYOUT_TRANSFER_DST_EXT:                       TextureLayout read _LAYOUT_TRANSFER_DST_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($9530) then Result := 'LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT' else
      if self.val = UInt32($9531) then Result := 'LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT' else
      if self.val = UInt32($958D) then Result := 'LAYOUT_GENERAL_EXT' else
      if self.val = UInt32($958E) then Result := 'LAYOUT_COLOR_ATTACHMENT_EXT' else
      if self.val = UInt32($958F) then Result := 'LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT' else
      if self.val = UInt32($9590) then Result := 'LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT' else
      if self.val = UInt32($9591) then Result := 'LAYOUT_SHADER_READ_ONLY_EXT' else
      if self.val = UInt32($9592) then Result := 'LAYOUT_TRANSFER_SRC_EXT' else
      if self.val = UInt32($9593) then Result := 'LAYOUT_TRANSFER_DST_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureParameterName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_WIDTH                        := new TextureParameterName($1000);
    private static _TEXTURE_HEIGHT                       := new TextureParameterName($1001);
    private static _TEXTURE_COMPONENTS                   := new TextureParameterName($1003);
    private static _TEXTURE_INTERNAL_FORMAT              := new TextureParameterName($1003);
    private static _TEXTURE_BORDER_COLOR                 := new TextureParameterName($1004);
    private static _TEXTURE_BORDER_COLOR_NV              := new TextureParameterName($1004);
    private static _TEXTURE_BORDER                       := new TextureParameterName($1005);
    private static _TEXTURE_MAG_FILTER                   := new TextureParameterName($2800);
    private static _TEXTURE_MIN_FILTER                   := new TextureParameterName($2801);
    private static _TEXTURE_WRAP_S                       := new TextureParameterName($2802);
    private static _TEXTURE_WRAP_T                       := new TextureParameterName($2803);
    private static _TEXTURE_RED_SIZE                     := new TextureParameterName($805C);
    private static _TEXTURE_GREEN_SIZE                   := new TextureParameterName($805D);
    private static _TEXTURE_BLUE_SIZE                    := new TextureParameterName($805E);
    private static _TEXTURE_ALPHA_SIZE                   := new TextureParameterName($805F);
    private static _TEXTURE_LUMINANCE_SIZE               := new TextureParameterName($8060);
    private static _TEXTURE_INTENSITY_SIZE               := new TextureParameterName($8061);
    private static _TEXTURE_PRIORITY                     := new TextureParameterName($8066);
    private static _TEXTURE_PRIORITY_EXT                 := new TextureParameterName($8066);
    private static _TEXTURE_RESIDENT                     := new TextureParameterName($8067);
    private static _TEXTURE_DEPTH_EXT                    := new TextureParameterName($8071);
    private static _TEXTURE_WRAP_R                       := new TextureParameterName($8072);
    private static _TEXTURE_WRAP_R_EXT                   := new TextureParameterName($8072);
    private static _TEXTURE_WRAP_R_OES                   := new TextureParameterName($8072);
    private static _DETAIL_TEXTURE_LEVEL_SGIS            := new TextureParameterName($809A);
    private static _DETAIL_TEXTURE_MODE_SGIS             := new TextureParameterName($809B);
    private static _DETAIL_TEXTURE_FUNC_POINTS_SGIS      := new TextureParameterName($809C);
    private static _SHARPEN_TEXTURE_FUNC_POINTS_SGIS     := new TextureParameterName($80B0);
    private static _SHADOW_AMBIENT_SGIX                  := new TextureParameterName($80BF);
    private static _DUAL_TEXTURE_SELECT_SGIS             := new TextureParameterName($8124);
    private static _QUAD_TEXTURE_SELECT_SGIS             := new TextureParameterName($8125);
    private static _TEXTURE_4DSIZE_SGIS                  := new TextureParameterName($8136);
    private static _TEXTURE_WRAP_Q_SGIS                  := new TextureParameterName($8137);
    private static _TEXTURE_MIN_LOD                      := new TextureParameterName($813A);
    private static _TEXTURE_MIN_LOD_SGIS                 := new TextureParameterName($813A);
    private static _TEXTURE_MAX_LOD                      := new TextureParameterName($813B);
    private static _TEXTURE_MAX_LOD_SGIS                 := new TextureParameterName($813B);
    private static _TEXTURE_BASE_LEVEL                   := new TextureParameterName($813C);
    private static _TEXTURE_BASE_LEVEL_SGIS              := new TextureParameterName($813C);
    private static _TEXTURE_MAX_LEVEL                    := new TextureParameterName($813D);
    private static _TEXTURE_MAX_LEVEL_SGIS               := new TextureParameterName($813D);
    private static _TEXTURE_FILTER4_SIZE_SGIS            := new TextureParameterName($8147);
    private static _TEXTURE_CLIPMAP_CENTER_SGIX          := new TextureParameterName($8171);
    private static _TEXTURE_CLIPMAP_FRAME_SGIX           := new TextureParameterName($8172);
    private static _TEXTURE_CLIPMAP_OFFSET_SGIX          := new TextureParameterName($8173);
    private static _TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX   := new TextureParameterName($8174);
    private static _TEXTURE_CLIPMAP_LOD_OFFSET_SGIX      := new TextureParameterName($8175);
    private static _TEXTURE_CLIPMAP_DEPTH_SGIX           := new TextureParameterName($8176);
    private static _POST_TEXTURE_FILTER_BIAS_SGIX        := new TextureParameterName($8179);
    private static _POST_TEXTURE_FILTER_SCALE_SGIX       := new TextureParameterName($817A);
    private static _TEXTURE_LOD_BIAS_S_SGIX              := new TextureParameterName($818E);
    private static _TEXTURE_LOD_BIAS_T_SGIX              := new TextureParameterName($818F);
    private static _TEXTURE_LOD_BIAS_R_SGIX              := new TextureParameterName($8190);
    private static _GENERATE_MIPMAP                      := new TextureParameterName($8191);
    private static _GENERATE_MIPMAP_SGIS                 := new TextureParameterName($8191);
    private static _TEXTURE_COMPARE_SGIX                 := new TextureParameterName($819A);
    private static _TEXTURE_COMPARE_OPERATOR_SGIX        := new TextureParameterName($819B);
    private static _TEXTURE_LEQUAL_R_SGIX                := new TextureParameterName($819C);
    private static _TEXTURE_GEQUAL_R_SGIX                := new TextureParameterName($819D);
    private static _TEXTURE_MAX_CLAMP_S_SGIX             := new TextureParameterName($8369);
    private static _TEXTURE_MAX_CLAMP_T_SGIX             := new TextureParameterName($836A);
    private static _TEXTURE_MAX_CLAMP_R_SGIX             := new TextureParameterName($836B);
    private static _TEXTURE_LOD_BIAS                     := new TextureParameterName($8501);
    private static _TEXTURE_COMPARE_MODE                 := new TextureParameterName($884C);
    private static _TEXTURE_COMPARE_FUNC                 := new TextureParameterName($884D);
    private static _TEXTURE_SWIZZLE_R                    := new TextureParameterName($8E42);
    private static _TEXTURE_SWIZZLE_G                    := new TextureParameterName($8E43);
    private static _TEXTURE_SWIZZLE_B                    := new TextureParameterName($8E44);
    private static _TEXTURE_SWIZZLE_A                    := new TextureParameterName($8E45);
    private static _TEXTURE_SWIZZLE_RGBA                 := new TextureParameterName($8E46);
    private static _TEXTURE_UNNORMALIZED_COORDINATES_ARM := new TextureParameterName($8F6A);
    private static _DEPTH_STENCIL_TEXTURE_MODE           := new TextureParameterName($90EA);
    private static _TEXTURE_TILING_EXT                   := new TextureParameterName($9580);
    
    public static property TEXTURE_WIDTH:                        TextureParameterName read _TEXTURE_WIDTH;
    public static property TEXTURE_HEIGHT:                       TextureParameterName read _TEXTURE_HEIGHT;
    public static property TEXTURE_COMPONENTS:                   TextureParameterName read _TEXTURE_COMPONENTS;
    public static property TEXTURE_INTERNAL_FORMAT:              TextureParameterName read _TEXTURE_INTERNAL_FORMAT;
    public static property TEXTURE_BORDER_COLOR:                 TextureParameterName read _TEXTURE_BORDER_COLOR;
    public static property TEXTURE_BORDER_COLOR_NV:              TextureParameterName read _TEXTURE_BORDER_COLOR_NV;
    public static property TEXTURE_BORDER:                       TextureParameterName read _TEXTURE_BORDER;
    public static property TEXTURE_MAG_FILTER:                   TextureParameterName read _TEXTURE_MAG_FILTER;
    public static property TEXTURE_MIN_FILTER:                   TextureParameterName read _TEXTURE_MIN_FILTER;
    public static property TEXTURE_WRAP_S:                       TextureParameterName read _TEXTURE_WRAP_S;
    public static property TEXTURE_WRAP_T:                       TextureParameterName read _TEXTURE_WRAP_T;
    public static property TEXTURE_RED_SIZE:                     TextureParameterName read _TEXTURE_RED_SIZE;
    public static property TEXTURE_GREEN_SIZE:                   TextureParameterName read _TEXTURE_GREEN_SIZE;
    public static property TEXTURE_BLUE_SIZE:                    TextureParameterName read _TEXTURE_BLUE_SIZE;
    public static property TEXTURE_ALPHA_SIZE:                   TextureParameterName read _TEXTURE_ALPHA_SIZE;
    public static property TEXTURE_LUMINANCE_SIZE:               TextureParameterName read _TEXTURE_LUMINANCE_SIZE;
    public static property TEXTURE_INTENSITY_SIZE:               TextureParameterName read _TEXTURE_INTENSITY_SIZE;
    public static property TEXTURE_PRIORITY:                     TextureParameterName read _TEXTURE_PRIORITY;
    public static property TEXTURE_PRIORITY_EXT:                 TextureParameterName read _TEXTURE_PRIORITY_EXT;
    public static property TEXTURE_RESIDENT:                     TextureParameterName read _TEXTURE_RESIDENT;
    public static property TEXTURE_DEPTH_EXT:                    TextureParameterName read _TEXTURE_DEPTH_EXT;
    public static property TEXTURE_WRAP_R:                       TextureParameterName read _TEXTURE_WRAP_R;
    public static property TEXTURE_WRAP_R_EXT:                   TextureParameterName read _TEXTURE_WRAP_R_EXT;
    public static property TEXTURE_WRAP_R_OES:                   TextureParameterName read _TEXTURE_WRAP_R_OES;
    public static property DETAIL_TEXTURE_LEVEL_SGIS:            TextureParameterName read _DETAIL_TEXTURE_LEVEL_SGIS;
    public static property DETAIL_TEXTURE_MODE_SGIS:             TextureParameterName read _DETAIL_TEXTURE_MODE_SGIS;
    public static property DETAIL_TEXTURE_FUNC_POINTS_SGIS:      TextureParameterName read _DETAIL_TEXTURE_FUNC_POINTS_SGIS;
    public static property SHARPEN_TEXTURE_FUNC_POINTS_SGIS:     TextureParameterName read _SHARPEN_TEXTURE_FUNC_POINTS_SGIS;
    public static property SHADOW_AMBIENT_SGIX:                  TextureParameterName read _SHADOW_AMBIENT_SGIX;
    public static property DUAL_TEXTURE_SELECT_SGIS:             TextureParameterName read _DUAL_TEXTURE_SELECT_SGIS;
    public static property QUAD_TEXTURE_SELECT_SGIS:             TextureParameterName read _QUAD_TEXTURE_SELECT_SGIS;
    public static property TEXTURE_4DSIZE_SGIS:                  TextureParameterName read _TEXTURE_4DSIZE_SGIS;
    public static property TEXTURE_WRAP_Q_SGIS:                  TextureParameterName read _TEXTURE_WRAP_Q_SGIS;
    public static property TEXTURE_MIN_LOD:                      TextureParameterName read _TEXTURE_MIN_LOD;
    public static property TEXTURE_MIN_LOD_SGIS:                 TextureParameterName read _TEXTURE_MIN_LOD_SGIS;
    public static property TEXTURE_MAX_LOD:                      TextureParameterName read _TEXTURE_MAX_LOD;
    public static property TEXTURE_MAX_LOD_SGIS:                 TextureParameterName read _TEXTURE_MAX_LOD_SGIS;
    public static property TEXTURE_BASE_LEVEL:                   TextureParameterName read _TEXTURE_BASE_LEVEL;
    public static property TEXTURE_BASE_LEVEL_SGIS:              TextureParameterName read _TEXTURE_BASE_LEVEL_SGIS;
    public static property TEXTURE_MAX_LEVEL:                    TextureParameterName read _TEXTURE_MAX_LEVEL;
    public static property TEXTURE_MAX_LEVEL_SGIS:               TextureParameterName read _TEXTURE_MAX_LEVEL_SGIS;
    public static property TEXTURE_FILTER4_SIZE_SGIS:            TextureParameterName read _TEXTURE_FILTER4_SIZE_SGIS;
    public static property TEXTURE_CLIPMAP_CENTER_SGIX:          TextureParameterName read _TEXTURE_CLIPMAP_CENTER_SGIX;
    public static property TEXTURE_CLIPMAP_FRAME_SGIX:           TextureParameterName read _TEXTURE_CLIPMAP_FRAME_SGIX;
    public static property TEXTURE_CLIPMAP_OFFSET_SGIX:          TextureParameterName read _TEXTURE_CLIPMAP_OFFSET_SGIX;
    public static property TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX:   TextureParameterName read _TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX;
    public static property TEXTURE_CLIPMAP_LOD_OFFSET_SGIX:      TextureParameterName read _TEXTURE_CLIPMAP_LOD_OFFSET_SGIX;
    public static property TEXTURE_CLIPMAP_DEPTH_SGIX:           TextureParameterName read _TEXTURE_CLIPMAP_DEPTH_SGIX;
    public static property POST_TEXTURE_FILTER_BIAS_SGIX:        TextureParameterName read _POST_TEXTURE_FILTER_BIAS_SGIX;
    public static property POST_TEXTURE_FILTER_SCALE_SGIX:       TextureParameterName read _POST_TEXTURE_FILTER_SCALE_SGIX;
    public static property TEXTURE_LOD_BIAS_S_SGIX:              TextureParameterName read _TEXTURE_LOD_BIAS_S_SGIX;
    public static property TEXTURE_LOD_BIAS_T_SGIX:              TextureParameterName read _TEXTURE_LOD_BIAS_T_SGIX;
    public static property TEXTURE_LOD_BIAS_R_SGIX:              TextureParameterName read _TEXTURE_LOD_BIAS_R_SGIX;
    public static property GENERATE_MIPMAP:                      TextureParameterName read _GENERATE_MIPMAP;
    public static property GENERATE_MIPMAP_SGIS:                 TextureParameterName read _GENERATE_MIPMAP_SGIS;
    public static property TEXTURE_COMPARE_SGIX:                 TextureParameterName read _TEXTURE_COMPARE_SGIX;
    public static property TEXTURE_COMPARE_OPERATOR_SGIX:        TextureParameterName read _TEXTURE_COMPARE_OPERATOR_SGIX;
    public static property TEXTURE_LEQUAL_R_SGIX:                TextureParameterName read _TEXTURE_LEQUAL_R_SGIX;
    public static property TEXTURE_GEQUAL_R_SGIX:                TextureParameterName read _TEXTURE_GEQUAL_R_SGIX;
    public static property TEXTURE_MAX_CLAMP_S_SGIX:             TextureParameterName read _TEXTURE_MAX_CLAMP_S_SGIX;
    public static property TEXTURE_MAX_CLAMP_T_SGIX:             TextureParameterName read _TEXTURE_MAX_CLAMP_T_SGIX;
    public static property TEXTURE_MAX_CLAMP_R_SGIX:             TextureParameterName read _TEXTURE_MAX_CLAMP_R_SGIX;
    public static property TEXTURE_LOD_BIAS:                     TextureParameterName read _TEXTURE_LOD_BIAS;
    public static property TEXTURE_COMPARE_MODE:                 TextureParameterName read _TEXTURE_COMPARE_MODE;
    public static property TEXTURE_COMPARE_FUNC:                 TextureParameterName read _TEXTURE_COMPARE_FUNC;
    public static property TEXTURE_SWIZZLE_R:                    TextureParameterName read _TEXTURE_SWIZZLE_R;
    public static property TEXTURE_SWIZZLE_G:                    TextureParameterName read _TEXTURE_SWIZZLE_G;
    public static property TEXTURE_SWIZZLE_B:                    TextureParameterName read _TEXTURE_SWIZZLE_B;
    public static property TEXTURE_SWIZZLE_A:                    TextureParameterName read _TEXTURE_SWIZZLE_A;
    public static property TEXTURE_SWIZZLE_RGBA:                 TextureParameterName read _TEXTURE_SWIZZLE_RGBA;
    public static property TEXTURE_UNNORMALIZED_COORDINATES_ARM: TextureParameterName read _TEXTURE_UNNORMALIZED_COORDINATES_ARM;
    public static property DEPTH_STENCIL_TEXTURE_MODE:           TextureParameterName read _DEPTH_STENCIL_TEXTURE_MODE;
    public static property TEXTURE_TILING_EXT:                   TextureParameterName read _TEXTURE_TILING_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1000) then Result := 'TEXTURE_WIDTH' else
      if self.val = UInt32($1001) then Result := 'TEXTURE_HEIGHT' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_COMPONENTS' else
      if self.val = UInt32($1003) then Result := 'TEXTURE_INTERNAL_FORMAT' else
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR' else
      if self.val = UInt32($1004) then Result := 'TEXTURE_BORDER_COLOR_NV' else
      if self.val = UInt32($1005) then Result := 'TEXTURE_BORDER' else
      if self.val = UInt32($2800) then Result := 'TEXTURE_MAG_FILTER' else
      if self.val = UInt32($2801) then Result := 'TEXTURE_MIN_FILTER' else
      if self.val = UInt32($2802) then Result := 'TEXTURE_WRAP_S' else
      if self.val = UInt32($2803) then Result := 'TEXTURE_WRAP_T' else
      if self.val = UInt32($805C) then Result := 'TEXTURE_RED_SIZE' else
      if self.val = UInt32($805D) then Result := 'TEXTURE_GREEN_SIZE' else
      if self.val = UInt32($805E) then Result := 'TEXTURE_BLUE_SIZE' else
      if self.val = UInt32($805F) then Result := 'TEXTURE_ALPHA_SIZE' else
      if self.val = UInt32($8060) then Result := 'TEXTURE_LUMINANCE_SIZE' else
      if self.val = UInt32($8061) then Result := 'TEXTURE_INTENSITY_SIZE' else
      if self.val = UInt32($8066) then Result := 'TEXTURE_PRIORITY' else
      if self.val = UInt32($8066) then Result := 'TEXTURE_PRIORITY_EXT' else
      if self.val = UInt32($8067) then Result := 'TEXTURE_RESIDENT' else
      if self.val = UInt32($8071) then Result := 'TEXTURE_DEPTH_EXT' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R_EXT' else
      if self.val = UInt32($8072) then Result := 'TEXTURE_WRAP_R_OES' else
      if self.val = UInt32($809A) then Result := 'DETAIL_TEXTURE_LEVEL_SGIS' else
      if self.val = UInt32($809B) then Result := 'DETAIL_TEXTURE_MODE_SGIS' else
      if self.val = UInt32($809C) then Result := 'DETAIL_TEXTURE_FUNC_POINTS_SGIS' else
      if self.val = UInt32($80B0) then Result := 'SHARPEN_TEXTURE_FUNC_POINTS_SGIS' else
      if self.val = UInt32($80BF) then Result := 'SHADOW_AMBIENT_SGIX' else
      if self.val = UInt32($8124) then Result := 'DUAL_TEXTURE_SELECT_SGIS' else
      if self.val = UInt32($8125) then Result := 'QUAD_TEXTURE_SELECT_SGIS' else
      if self.val = UInt32($8136) then Result := 'TEXTURE_4DSIZE_SGIS' else
      if self.val = UInt32($8137) then Result := 'TEXTURE_WRAP_Q_SGIS' else
      if self.val = UInt32($813A) then Result := 'TEXTURE_MIN_LOD' else
      if self.val = UInt32($813A) then Result := 'TEXTURE_MIN_LOD_SGIS' else
      if self.val = UInt32($813B) then Result := 'TEXTURE_MAX_LOD' else
      if self.val = UInt32($813B) then Result := 'TEXTURE_MAX_LOD_SGIS' else
      if self.val = UInt32($813C) then Result := 'TEXTURE_BASE_LEVEL' else
      if self.val = UInt32($813C) then Result := 'TEXTURE_BASE_LEVEL_SGIS' else
      if self.val = UInt32($813D) then Result := 'TEXTURE_MAX_LEVEL' else
      if self.val = UInt32($813D) then Result := 'TEXTURE_MAX_LEVEL_SGIS' else
      if self.val = UInt32($8147) then Result := 'TEXTURE_FILTER4_SIZE_SGIS' else
      if self.val = UInt32($8171) then Result := 'TEXTURE_CLIPMAP_CENTER_SGIX' else
      if self.val = UInt32($8172) then Result := 'TEXTURE_CLIPMAP_FRAME_SGIX' else
      if self.val = UInt32($8173) then Result := 'TEXTURE_CLIPMAP_OFFSET_SGIX' else
      if self.val = UInt32($8174) then Result := 'TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX' else
      if self.val = UInt32($8175) then Result := 'TEXTURE_CLIPMAP_LOD_OFFSET_SGIX' else
      if self.val = UInt32($8176) then Result := 'TEXTURE_CLIPMAP_DEPTH_SGIX' else
      if self.val = UInt32($8179) then Result := 'POST_TEXTURE_FILTER_BIAS_SGIX' else
      if self.val = UInt32($817A) then Result := 'POST_TEXTURE_FILTER_SCALE_SGIX' else
      if self.val = UInt32($818E) then Result := 'TEXTURE_LOD_BIAS_S_SGIX' else
      if self.val = UInt32($818F) then Result := 'TEXTURE_LOD_BIAS_T_SGIX' else
      if self.val = UInt32($8190) then Result := 'TEXTURE_LOD_BIAS_R_SGIX' else
      if self.val = UInt32($8191) then Result := 'GENERATE_MIPMAP' else
      if self.val = UInt32($8191) then Result := 'GENERATE_MIPMAP_SGIS' else
      if self.val = UInt32($819A) then Result := 'TEXTURE_COMPARE_SGIX' else
      if self.val = UInt32($819B) then Result := 'TEXTURE_COMPARE_OPERATOR_SGIX' else
      if self.val = UInt32($819C) then Result := 'TEXTURE_LEQUAL_R_SGIX' else
      if self.val = UInt32($819D) then Result := 'TEXTURE_GEQUAL_R_SGIX' else
      if self.val = UInt32($8369) then Result := 'TEXTURE_MAX_CLAMP_S_SGIX' else
      if self.val = UInt32($836A) then Result := 'TEXTURE_MAX_CLAMP_T_SGIX' else
      if self.val = UInt32($836B) then Result := 'TEXTURE_MAX_CLAMP_R_SGIX' else
      if self.val = UInt32($8501) then Result := 'TEXTURE_LOD_BIAS' else
      if self.val = UInt32($884C) then Result := 'TEXTURE_COMPARE_MODE' else
      if self.val = UInt32($884D) then Result := 'TEXTURE_COMPARE_FUNC' else
      if self.val = UInt32($8E42) then Result := 'TEXTURE_SWIZZLE_R' else
      if self.val = UInt32($8E43) then Result := 'TEXTURE_SWIZZLE_G' else
      if self.val = UInt32($8E44) then Result := 'TEXTURE_SWIZZLE_B' else
      if self.val = UInt32($8E45) then Result := 'TEXTURE_SWIZZLE_A' else
      if self.val = UInt32($8E46) then Result := 'TEXTURE_SWIZZLE_RGBA' else
      if self.val = UInt32($8F6A) then Result := 'TEXTURE_UNNORMALIZED_COORDINATES_ARM' else
      if self.val = UInt32($90EA) then Result := 'DEPTH_STENCIL_TEXTURE_MODE' else
      if self.val = UInt32($9580) then Result := 'TEXTURE_TILING_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_1D                         := new TextureTarget($0DE0);
    private static _TEXTURE_2D                         := new TextureTarget($0DE1);
    private static _PROXY_TEXTURE_1D                   := new TextureTarget($8063);
    private static _PROXY_TEXTURE_1D_EXT               := new TextureTarget($8063);
    private static _PROXY_TEXTURE_2D                   := new TextureTarget($8064);
    private static _PROXY_TEXTURE_2D_EXT               := new TextureTarget($8064);
    private static _TEXTURE_3D                         := new TextureTarget($806F);
    private static _TEXTURE_3D_EXT                     := new TextureTarget($806F);
    private static _TEXTURE_3D_OES                     := new TextureTarget($806F);
    private static _PROXY_TEXTURE_3D                   := new TextureTarget($8070);
    private static _PROXY_TEXTURE_3D_EXT               := new TextureTarget($8070);
    private static _DETAIL_TEXTURE_2D_SGIS             := new TextureTarget($8095);
    private static _TEXTURE_4D_SGIS                    := new TextureTarget($8134);
    private static _PROXY_TEXTURE_4D_SGIS              := new TextureTarget($8135);
    private static _TEXTURE_RECTANGLE                  := new TextureTarget($84F5);
    private static _PROXY_TEXTURE_RECTANGLE            := new TextureTarget($84F7);
    private static _PROXY_TEXTURE_RECTANGLE_ARB        := new TextureTarget($84F7);
    private static _PROXY_TEXTURE_RECTANGLE_NV         := new TextureTarget($84F7);
    private static _TEXTURE_CUBE_MAP                   := new TextureTarget($8513);
    private static _TEXTURE_CUBE_MAP_POSITIVE_X        := new TextureTarget($8515);
    private static _TEXTURE_CUBE_MAP_NEGATIVE_X        := new TextureTarget($8516);
    private static _TEXTURE_CUBE_MAP_POSITIVE_Y        := new TextureTarget($8517);
    private static _TEXTURE_CUBE_MAP_NEGATIVE_Y        := new TextureTarget($8518);
    private static _TEXTURE_CUBE_MAP_POSITIVE_Z        := new TextureTarget($8519);
    private static _TEXTURE_CUBE_MAP_NEGATIVE_Z        := new TextureTarget($851A);
    private static _PROXY_TEXTURE_CUBE_MAP             := new TextureTarget($851B);
    private static _PROXY_TEXTURE_CUBE_MAP_ARB         := new TextureTarget($851B);
    private static _PROXY_TEXTURE_CUBE_MAP_EXT         := new TextureTarget($851B);
    private static _TEXTURE_1D_ARRAY                   := new TextureTarget($8C18);
    private static _PROXY_TEXTURE_1D_ARRAY             := new TextureTarget($8C19);
    private static _PROXY_TEXTURE_1D_ARRAY_EXT         := new TextureTarget($8C19);
    private static _TEXTURE_2D_ARRAY                   := new TextureTarget($8C1A);
    private static _PROXY_TEXTURE_2D_ARRAY             := new TextureTarget($8C1B);
    private static _PROXY_TEXTURE_2D_ARRAY_EXT         := new TextureTarget($8C1B);
    private static _TEXTURE_BUFFER                     := new TextureTarget($8C2A);
    private static _TEXTURE_CUBE_MAP_ARRAY             := new TextureTarget($9009);
    private static _TEXTURE_CUBE_MAP_ARRAY_ARB         := new TextureTarget($9009);
    private static _TEXTURE_CUBE_MAP_ARRAY_EXT         := new TextureTarget($9009);
    private static _TEXTURE_CUBE_MAP_ARRAY_OES         := new TextureTarget($9009);
    private static _PROXY_TEXTURE_CUBE_MAP_ARRAY       := new TextureTarget($900B);
    private static _PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB   := new TextureTarget($900B);
    private static _TEXTURE_2D_MULTISAMPLE             := new TextureTarget($9100);
    private static _PROXY_TEXTURE_2D_MULTISAMPLE       := new TextureTarget($9101);
    private static _TEXTURE_2D_MULTISAMPLE_ARRAY       := new TextureTarget($9102);
    private static _PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY := new TextureTarget($9103);
    
    public static property TEXTURE_1D:                         TextureTarget read _TEXTURE_1D;
    public static property TEXTURE_2D:                         TextureTarget read _TEXTURE_2D;
    public static property PROXY_TEXTURE_1D:                   TextureTarget read _PROXY_TEXTURE_1D;
    public static property PROXY_TEXTURE_1D_EXT:               TextureTarget read _PROXY_TEXTURE_1D_EXT;
    public static property PROXY_TEXTURE_2D:                   TextureTarget read _PROXY_TEXTURE_2D;
    public static property PROXY_TEXTURE_2D_EXT:               TextureTarget read _PROXY_TEXTURE_2D_EXT;
    public static property TEXTURE_3D:                         TextureTarget read _TEXTURE_3D;
    public static property TEXTURE_3D_EXT:                     TextureTarget read _TEXTURE_3D_EXT;
    public static property TEXTURE_3D_OES:                     TextureTarget read _TEXTURE_3D_OES;
    public static property PROXY_TEXTURE_3D:                   TextureTarget read _PROXY_TEXTURE_3D;
    public static property PROXY_TEXTURE_3D_EXT:               TextureTarget read _PROXY_TEXTURE_3D_EXT;
    public static property DETAIL_TEXTURE_2D_SGIS:             TextureTarget read _DETAIL_TEXTURE_2D_SGIS;
    public static property TEXTURE_4D_SGIS:                    TextureTarget read _TEXTURE_4D_SGIS;
    public static property PROXY_TEXTURE_4D_SGIS:              TextureTarget read _PROXY_TEXTURE_4D_SGIS;
    public static property TEXTURE_RECTANGLE:                  TextureTarget read _TEXTURE_RECTANGLE;
    public static property PROXY_TEXTURE_RECTANGLE:            TextureTarget read _PROXY_TEXTURE_RECTANGLE;
    public static property PROXY_TEXTURE_RECTANGLE_ARB:        TextureTarget read _PROXY_TEXTURE_RECTANGLE_ARB;
    public static property PROXY_TEXTURE_RECTANGLE_NV:         TextureTarget read _PROXY_TEXTURE_RECTANGLE_NV;
    public static property TEXTURE_CUBE_MAP:                   TextureTarget read _TEXTURE_CUBE_MAP;
    public static property TEXTURE_CUBE_MAP_POSITIVE_X:        TextureTarget read _TEXTURE_CUBE_MAP_POSITIVE_X;
    public static property TEXTURE_CUBE_MAP_NEGATIVE_X:        TextureTarget read _TEXTURE_CUBE_MAP_NEGATIVE_X;
    public static property TEXTURE_CUBE_MAP_POSITIVE_Y:        TextureTarget read _TEXTURE_CUBE_MAP_POSITIVE_Y;
    public static property TEXTURE_CUBE_MAP_NEGATIVE_Y:        TextureTarget read _TEXTURE_CUBE_MAP_NEGATIVE_Y;
    public static property TEXTURE_CUBE_MAP_POSITIVE_Z:        TextureTarget read _TEXTURE_CUBE_MAP_POSITIVE_Z;
    public static property TEXTURE_CUBE_MAP_NEGATIVE_Z:        TextureTarget read _TEXTURE_CUBE_MAP_NEGATIVE_Z;
    public static property PROXY_TEXTURE_CUBE_MAP:             TextureTarget read _PROXY_TEXTURE_CUBE_MAP;
    public static property PROXY_TEXTURE_CUBE_MAP_ARB:         TextureTarget read _PROXY_TEXTURE_CUBE_MAP_ARB;
    public static property PROXY_TEXTURE_CUBE_MAP_EXT:         TextureTarget read _PROXY_TEXTURE_CUBE_MAP_EXT;
    public static property TEXTURE_1D_ARRAY:                   TextureTarget read _TEXTURE_1D_ARRAY;
    public static property PROXY_TEXTURE_1D_ARRAY:             TextureTarget read _PROXY_TEXTURE_1D_ARRAY;
    public static property PROXY_TEXTURE_1D_ARRAY_EXT:         TextureTarget read _PROXY_TEXTURE_1D_ARRAY_EXT;
    public static property TEXTURE_2D_ARRAY:                   TextureTarget read _TEXTURE_2D_ARRAY;
    public static property PROXY_TEXTURE_2D_ARRAY:             TextureTarget read _PROXY_TEXTURE_2D_ARRAY;
    public static property PROXY_TEXTURE_2D_ARRAY_EXT:         TextureTarget read _PROXY_TEXTURE_2D_ARRAY_EXT;
    public static property TEXTURE_BUFFER:                     TextureTarget read _TEXTURE_BUFFER;
    public static property TEXTURE_CUBE_MAP_ARRAY:             TextureTarget read _TEXTURE_CUBE_MAP_ARRAY;
    public static property TEXTURE_CUBE_MAP_ARRAY_ARB:         TextureTarget read _TEXTURE_CUBE_MAP_ARRAY_ARB;
    public static property TEXTURE_CUBE_MAP_ARRAY_EXT:         TextureTarget read _TEXTURE_CUBE_MAP_ARRAY_EXT;
    public static property TEXTURE_CUBE_MAP_ARRAY_OES:         TextureTarget read _TEXTURE_CUBE_MAP_ARRAY_OES;
    public static property PROXY_TEXTURE_CUBE_MAP_ARRAY:       TextureTarget read _PROXY_TEXTURE_CUBE_MAP_ARRAY;
    public static property PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB:   TextureTarget read _PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB;
    public static property TEXTURE_2D_MULTISAMPLE:             TextureTarget read _TEXTURE_2D_MULTISAMPLE;
    public static property PROXY_TEXTURE_2D_MULTISAMPLE:       TextureTarget read _PROXY_TEXTURE_2D_MULTISAMPLE;
    public static property TEXTURE_2D_MULTISAMPLE_ARRAY:       TextureTarget read _TEXTURE_2D_MULTISAMPLE_ARRAY;
    public static property PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: TextureTarget read _PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0DE0) then Result := 'TEXTURE_1D' else
      if self.val = UInt32($0DE1) then Result := 'TEXTURE_2D' else
      if self.val = UInt32($8063) then Result := 'PROXY_TEXTURE_1D' else
      if self.val = UInt32($8063) then Result := 'PROXY_TEXTURE_1D_EXT' else
      if self.val = UInt32($8064) then Result := 'PROXY_TEXTURE_2D' else
      if self.val = UInt32($8064) then Result := 'PROXY_TEXTURE_2D_EXT' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D_EXT' else
      if self.val = UInt32($806F) then Result := 'TEXTURE_3D_OES' else
      if self.val = UInt32($8070) then Result := 'PROXY_TEXTURE_3D' else
      if self.val = UInt32($8070) then Result := 'PROXY_TEXTURE_3D_EXT' else
      if self.val = UInt32($8095) then Result := 'DETAIL_TEXTURE_2D_SGIS' else
      if self.val = UInt32($8134) then Result := 'TEXTURE_4D_SGIS' else
      if self.val = UInt32($8135) then Result := 'PROXY_TEXTURE_4D_SGIS' else
      if self.val = UInt32($84F5) then Result := 'TEXTURE_RECTANGLE' else
      if self.val = UInt32($84F7) then Result := 'PROXY_TEXTURE_RECTANGLE' else
      if self.val = UInt32($84F7) then Result := 'PROXY_TEXTURE_RECTANGLE_ARB' else
      if self.val = UInt32($84F7) then Result := 'PROXY_TEXTURE_RECTANGLE_NV' else
      if self.val = UInt32($8513) then Result := 'TEXTURE_CUBE_MAP' else
      if self.val = UInt32($8515) then Result := 'TEXTURE_CUBE_MAP_POSITIVE_X' else
      if self.val = UInt32($8516) then Result := 'TEXTURE_CUBE_MAP_NEGATIVE_X' else
      if self.val = UInt32($8517) then Result := 'TEXTURE_CUBE_MAP_POSITIVE_Y' else
      if self.val = UInt32($8518) then Result := 'TEXTURE_CUBE_MAP_NEGATIVE_Y' else
      if self.val = UInt32($8519) then Result := 'TEXTURE_CUBE_MAP_POSITIVE_Z' else
      if self.val = UInt32($851A) then Result := 'TEXTURE_CUBE_MAP_NEGATIVE_Z' else
      if self.val = UInt32($851B) then Result := 'PROXY_TEXTURE_CUBE_MAP' else
      if self.val = UInt32($851B) then Result := 'PROXY_TEXTURE_CUBE_MAP_ARB' else
      if self.val = UInt32($851B) then Result := 'PROXY_TEXTURE_CUBE_MAP_EXT' else
      if self.val = UInt32($8C18) then Result := 'TEXTURE_1D_ARRAY' else
      if self.val = UInt32($8C19) then Result := 'PROXY_TEXTURE_1D_ARRAY' else
      if self.val = UInt32($8C19) then Result := 'PROXY_TEXTURE_1D_ARRAY_EXT' else
      if self.val = UInt32($8C1A) then Result := 'TEXTURE_2D_ARRAY' else
      if self.val = UInt32($8C1B) then Result := 'PROXY_TEXTURE_2D_ARRAY' else
      if self.val = UInt32($8C1B) then Result := 'PROXY_TEXTURE_2D_ARRAY_EXT' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($9009) then Result := 'TEXTURE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9009) then Result := 'TEXTURE_CUBE_MAP_ARRAY_ARB' else
      if self.val = UInt32($9009) then Result := 'TEXTURE_CUBE_MAP_ARRAY_EXT' else
      if self.val = UInt32($9009) then Result := 'TEXTURE_CUBE_MAP_ARRAY_OES' else
      if self.val = UInt32($900B) then Result := 'PROXY_TEXTURE_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900B) then Result := 'PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB' else
      if self.val = UInt32($9100) then Result := 'TEXTURE_2D_MULTISAMPLE' else
      if self.val = UInt32($9101) then Result := 'PROXY_TEXTURE_2D_MULTISAMPLE' else
      if self.val = UInt32($9102) then Result := 'TEXTURE_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($9103) then Result := 'PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureUnit = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE0  := new TextureUnit($84C0);
    private static _TEXTURE1  := new TextureUnit($84C1);
    private static _TEXTURE2  := new TextureUnit($84C2);
    private static _TEXTURE3  := new TextureUnit($84C3);
    private static _TEXTURE4  := new TextureUnit($84C4);
    private static _TEXTURE5  := new TextureUnit($84C5);
    private static _TEXTURE6  := new TextureUnit($84C6);
    private static _TEXTURE7  := new TextureUnit($84C7);
    private static _TEXTURE8  := new TextureUnit($84C8);
    private static _TEXTURE9  := new TextureUnit($84C9);
    private static _TEXTURE10 := new TextureUnit($84CA);
    private static _TEXTURE11 := new TextureUnit($84CB);
    private static _TEXTURE12 := new TextureUnit($84CC);
    private static _TEXTURE13 := new TextureUnit($84CD);
    private static _TEXTURE14 := new TextureUnit($84CE);
    private static _TEXTURE15 := new TextureUnit($84CF);
    private static _TEXTURE16 := new TextureUnit($84D0);
    private static _TEXTURE17 := new TextureUnit($84D1);
    private static _TEXTURE18 := new TextureUnit($84D2);
    private static _TEXTURE19 := new TextureUnit($84D3);
    private static _TEXTURE20 := new TextureUnit($84D4);
    private static _TEXTURE21 := new TextureUnit($84D5);
    private static _TEXTURE22 := new TextureUnit($84D6);
    private static _TEXTURE23 := new TextureUnit($84D7);
    private static _TEXTURE24 := new TextureUnit($84D8);
    private static _TEXTURE25 := new TextureUnit($84D9);
    private static _TEXTURE26 := new TextureUnit($84DA);
    private static _TEXTURE27 := new TextureUnit($84DB);
    private static _TEXTURE28 := new TextureUnit($84DC);
    private static _TEXTURE29 := new TextureUnit($84DD);
    private static _TEXTURE30 := new TextureUnit($84DE);
    private static _TEXTURE31 := new TextureUnit($84DF);
    
    public static property TEXTURE0:  TextureUnit read _TEXTURE0;
    public static property TEXTURE1:  TextureUnit read _TEXTURE1;
    public static property TEXTURE2:  TextureUnit read _TEXTURE2;
    public static property TEXTURE3:  TextureUnit read _TEXTURE3;
    public static property TEXTURE4:  TextureUnit read _TEXTURE4;
    public static property TEXTURE5:  TextureUnit read _TEXTURE5;
    public static property TEXTURE6:  TextureUnit read _TEXTURE6;
    public static property TEXTURE7:  TextureUnit read _TEXTURE7;
    public static property TEXTURE8:  TextureUnit read _TEXTURE8;
    public static property TEXTURE9:  TextureUnit read _TEXTURE9;
    public static property TEXTURE10: TextureUnit read _TEXTURE10;
    public static property TEXTURE11: TextureUnit read _TEXTURE11;
    public static property TEXTURE12: TextureUnit read _TEXTURE12;
    public static property TEXTURE13: TextureUnit read _TEXTURE13;
    public static property TEXTURE14: TextureUnit read _TEXTURE14;
    public static property TEXTURE15: TextureUnit read _TEXTURE15;
    public static property TEXTURE16: TextureUnit read _TEXTURE16;
    public static property TEXTURE17: TextureUnit read _TEXTURE17;
    public static property TEXTURE18: TextureUnit read _TEXTURE18;
    public static property TEXTURE19: TextureUnit read _TEXTURE19;
    public static property TEXTURE20: TextureUnit read _TEXTURE20;
    public static property TEXTURE21: TextureUnit read _TEXTURE21;
    public static property TEXTURE22: TextureUnit read _TEXTURE22;
    public static property TEXTURE23: TextureUnit read _TEXTURE23;
    public static property TEXTURE24: TextureUnit read _TEXTURE24;
    public static property TEXTURE25: TextureUnit read _TEXTURE25;
    public static property TEXTURE26: TextureUnit read _TEXTURE26;
    public static property TEXTURE27: TextureUnit read _TEXTURE27;
    public static property TEXTURE28: TextureUnit read _TEXTURE28;
    public static property TEXTURE29: TextureUnit read _TEXTURE29;
    public static property TEXTURE30: TextureUnit read _TEXTURE30;
    public static property TEXTURE31: TextureUnit read _TEXTURE31;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84C0) then Result := 'TEXTURE0' else
      if self.val = UInt32($84C1) then Result := 'TEXTURE1' else
      if self.val = UInt32($84C2) then Result := 'TEXTURE2' else
      if self.val = UInt32($84C3) then Result := 'TEXTURE3' else
      if self.val = UInt32($84C4) then Result := 'TEXTURE4' else
      if self.val = UInt32($84C5) then Result := 'TEXTURE5' else
      if self.val = UInt32($84C6) then Result := 'TEXTURE6' else
      if self.val = UInt32($84C7) then Result := 'TEXTURE7' else
      if self.val = UInt32($84C8) then Result := 'TEXTURE8' else
      if self.val = UInt32($84C9) then Result := 'TEXTURE9' else
      if self.val = UInt32($84CA) then Result := 'TEXTURE10' else
      if self.val = UInt32($84CB) then Result := 'TEXTURE11' else
      if self.val = UInt32($84CC) then Result := 'TEXTURE12' else
      if self.val = UInt32($84CD) then Result := 'TEXTURE13' else
      if self.val = UInt32($84CE) then Result := 'TEXTURE14' else
      if self.val = UInt32($84CF) then Result := 'TEXTURE15' else
      if self.val = UInt32($84D0) then Result := 'TEXTURE16' else
      if self.val = UInt32($84D1) then Result := 'TEXTURE17' else
      if self.val = UInt32($84D2) then Result := 'TEXTURE18' else
      if self.val = UInt32($84D3) then Result := 'TEXTURE19' else
      if self.val = UInt32($84D4) then Result := 'TEXTURE20' else
      if self.val = UInt32($84D5) then Result := 'TEXTURE21' else
      if self.val = UInt32($84D6) then Result := 'TEXTURE22' else
      if self.val = UInt32($84D7) then Result := 'TEXTURE23' else
      if self.val = UInt32($84D8) then Result := 'TEXTURE24' else
      if self.val = UInt32($84D9) then Result := 'TEXTURE25' else
      if self.val = UInt32($84DA) then Result := 'TEXTURE26' else
      if self.val = UInt32($84DB) then Result := 'TEXTURE27' else
      if self.val = UInt32($84DC) then Result := 'TEXTURE28' else
      if self.val = UInt32($84DD) then Result := 'TEXTURE29' else
      if self.val = UInt32($84DE) then Result := 'TEXTURE30' else
      if self.val = UInt32($84DF) then Result := 'TEXTURE31' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TransformFeedbackBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _INTERLEAVED_ATTRIBS := new TransformFeedbackBufferMode($8C8C);
    private static _SEPARATE_ATTRIBS    := new TransformFeedbackBufferMode($8C8D);
    
    public static property INTERLEAVED_ATTRIBS: TransformFeedbackBufferMode read _INTERLEAVED_ATTRIBS;
    public static property SEPARATE_ATTRIBS:    TransformFeedbackBufferMode read _SEPARATE_ATTRIBS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8C8C) then Result := 'INTERLEAVED_ATTRIBS' else
      if self.val = UInt32($8C8D) then Result := 'SEPARATE_ATTRIBS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TransformFeedbackPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TRANSFORM_FEEDBACK_BUFFER_START   := new TransformFeedbackPName($8C84);
    private static _TRANSFORM_FEEDBACK_BUFFER_SIZE    := new TransformFeedbackPName($8C85);
    private static _TRANSFORM_FEEDBACK_BUFFER_BINDING := new TransformFeedbackPName($8C8F);
    private static _TRANSFORM_FEEDBACK_PAUSED         := new TransformFeedbackPName($8E23);
    private static _TRANSFORM_FEEDBACK_ACTIVE         := new TransformFeedbackPName($8E24);
    
    public static property TRANSFORM_FEEDBACK_BUFFER_START:   TransformFeedbackPName read _TRANSFORM_FEEDBACK_BUFFER_START;
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:    TransformFeedbackPName read _TRANSFORM_FEEDBACK_BUFFER_SIZE;
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING: TransformFeedbackPName read _TRANSFORM_FEEDBACK_BUFFER_BINDING;
    public static property TRANSFORM_FEEDBACK_PAUSED:         TransformFeedbackPName read _TRANSFORM_FEEDBACK_PAUSED;
    public static property TRANSFORM_FEEDBACK_ACTIVE:         TransformFeedbackPName read _TRANSFORM_FEEDBACK_ACTIVE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8C84) then Result := 'TRANSFORM_FEEDBACK_BUFFER_START' else
      if self.val = UInt32($8C85) then Result := 'TRANSFORM_FEEDBACK_BUFFER_SIZE' else
      if self.val = UInt32($8C8F) then Result := 'TRANSFORM_FEEDBACK_BUFFER_BINDING' else
      if self.val = UInt32($8E23) then Result := 'TRANSFORM_FEEDBACK_PAUSED' else
      if self.val = UInt32($8E24) then Result := 'TRANSFORM_FEEDBACK_ACTIVE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  UniformBlockPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER    := new UniformBlockPName($84F0);
    private static _UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER := new UniformBlockPName($84F1);
    private static _UNIFORM_BLOCK_BINDING                              := new UniformBlockPName($8A3F);
    private static _UNIFORM_BLOCK_DATA_SIZE                            := new UniformBlockPName($8A40);
    private static _UNIFORM_BLOCK_NAME_LENGTH                          := new UniformBlockPName($8A41);
    private static _UNIFORM_BLOCK_ACTIVE_UNIFORMS                      := new UniformBlockPName($8A42);
    private static _UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES               := new UniformBlockPName($8A43);
    private static _UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER          := new UniformBlockPName($8A44);
    private static _UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER        := new UniformBlockPName($8A45);
    private static _UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER        := new UniformBlockPName($8A46);
    private static _UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER         := new UniformBlockPName($90EC);
    
    public static property UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER:    UniformBlockPName read _UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER;
    public static property UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: UniformBlockPName read _UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER;
    public static property UNIFORM_BLOCK_BINDING:                              UniformBlockPName read _UNIFORM_BLOCK_BINDING;
    public static property UNIFORM_BLOCK_DATA_SIZE:                            UniformBlockPName read _UNIFORM_BLOCK_DATA_SIZE;
    public static property UNIFORM_BLOCK_NAME_LENGTH:                          UniformBlockPName read _UNIFORM_BLOCK_NAME_LENGTH;
    public static property UNIFORM_BLOCK_ACTIVE_UNIFORMS:                      UniformBlockPName read _UNIFORM_BLOCK_ACTIVE_UNIFORMS;
    public static property UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:               UniformBlockPName read _UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES;
    public static property UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:          UniformBlockPName read _UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER;
    public static property UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER:        UniformBlockPName read _UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER;
    public static property UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:        UniformBlockPName read _UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER;
    public static property UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER:         UniformBlockPName read _UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84F0) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER' else
      if self.val = UInt32($84F1) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER' else
      if self.val = UInt32($8A3F) then Result := 'UNIFORM_BLOCK_BINDING' else
      if self.val = UInt32($8A40) then Result := 'UNIFORM_BLOCK_DATA_SIZE' else
      if self.val = UInt32($8A41) then Result := 'UNIFORM_BLOCK_NAME_LENGTH' else
      if self.val = UInt32($8A42) then Result := 'UNIFORM_BLOCK_ACTIVE_UNIFORMS' else
      if self.val = UInt32($8A43) then Result := 'UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES' else
      if self.val = UInt32($8A44) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER' else
      if self.val = UInt32($8A45) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER' else
      if self.val = UInt32($8A46) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER' else
      if self.val = UInt32($90EC) then Result := 'UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  UniformPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNIFORM_TYPE                        := new UniformPName($8A37);
    private static _UNIFORM_SIZE                        := new UniformPName($8A38);
    private static _UNIFORM_NAME_LENGTH                 := new UniformPName($8A39);
    private static _UNIFORM_BLOCK_INDEX                 := new UniformPName($8A3A);
    private static _UNIFORM_OFFSET                      := new UniformPName($8A3B);
    private static _UNIFORM_ARRAY_STRIDE                := new UniformPName($8A3C);
    private static _UNIFORM_MATRIX_STRIDE               := new UniformPName($8A3D);
    private static _UNIFORM_IS_ROW_MAJOR                := new UniformPName($8A3E);
    private static _UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX := new UniformPName($92DA);
    
    public static property UNIFORM_TYPE:                        UniformPName read _UNIFORM_TYPE;
    public static property UNIFORM_SIZE:                        UniformPName read _UNIFORM_SIZE;
    public static property UNIFORM_NAME_LENGTH:                 UniformPName read _UNIFORM_NAME_LENGTH;
    public static property UNIFORM_BLOCK_INDEX:                 UniformPName read _UNIFORM_BLOCK_INDEX;
    public static property UNIFORM_OFFSET:                      UniformPName read _UNIFORM_OFFSET;
    public static property UNIFORM_ARRAY_STRIDE:                UniformPName read _UNIFORM_ARRAY_STRIDE;
    public static property UNIFORM_MATRIX_STRIDE:               UniformPName read _UNIFORM_MATRIX_STRIDE;
    public static property UNIFORM_IS_ROW_MAJOR:                UniformPName read _UNIFORM_IS_ROW_MAJOR;
    public static property UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: UniformPName read _UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8A37) then Result := 'UNIFORM_TYPE' else
      if self.val = UInt32($8A38) then Result := 'UNIFORM_SIZE' else
      if self.val = UInt32($8A39) then Result := 'UNIFORM_NAME_LENGTH' else
      if self.val = UInt32($8A3A) then Result := 'UNIFORM_BLOCK_INDEX' else
      if self.val = UInt32($8A3B) then Result := 'UNIFORM_OFFSET' else
      if self.val = UInt32($8A3C) then Result := 'UNIFORM_ARRAY_STRIDE' else
      if self.val = UInt32($8A3D) then Result := 'UNIFORM_MATRIX_STRIDE' else
      if self.val = UInt32($8A3E) then Result := 'UNIFORM_IS_ROW_MAJOR' else
      if self.val = UInt32($92DA) then Result := 'UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  UniformType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _INT                                       := new UniformType($1404);
    private static _UNSIGNED_INT                              := new UniformType($1405);
    private static _FLOAT                                     := new UniformType($1406);
    private static _DOUBLE                                    := new UniformType($140A);
    private static _FLOAT_VEC2                                := new UniformType($8B50);
    private static _FLOAT_VEC3                                := new UniformType($8B51);
    private static _FLOAT_VEC4                                := new UniformType($8B52);
    private static _INT_VEC2                                  := new UniformType($8B53);
    private static _INT_VEC3                                  := new UniformType($8B54);
    private static _INT_VEC4                                  := new UniformType($8B55);
    private static _BOOL                                      := new UniformType($8B56);
    private static _BOOL_VEC2                                 := new UniformType($8B57);
    private static _BOOL_VEC3                                 := new UniformType($8B58);
    private static _BOOL_VEC4                                 := new UniformType($8B59);
    private static _FLOAT_MAT2                                := new UniformType($8B5A);
    private static _FLOAT_MAT3                                := new UniformType($8B5B);
    private static _FLOAT_MAT4                                := new UniformType($8B5C);
    private static _SAMPLER_1D                                := new UniformType($8B5D);
    private static _SAMPLER_2D                                := new UniformType($8B5E);
    private static _SAMPLER_3D                                := new UniformType($8B5F);
    private static _SAMPLER_CUBE                              := new UniformType($8B60);
    private static _SAMPLER_1D_SHADOW                         := new UniformType($8B61);
    private static _SAMPLER_2D_SHADOW                         := new UniformType($8B62);
    private static _SAMPLER_2D_RECT                           := new UniformType($8B63);
    private static _SAMPLER_2D_RECT_SHADOW                    := new UniformType($8B64);
    private static _FLOAT_MAT2x3                              := new UniformType($8B65);
    private static _FLOAT_MAT2x4                              := new UniformType($8B66);
    private static _FLOAT_MAT3x2                              := new UniformType($8B67);
    private static _FLOAT_MAT3x4                              := new UniformType($8B68);
    private static _FLOAT_MAT4x2                              := new UniformType($8B69);
    private static _FLOAT_MAT4x3                              := new UniformType($8B6A);
    private static _SAMPLER_1D_ARRAY                          := new UniformType($8DC0);
    private static _SAMPLER_2D_ARRAY                          := new UniformType($8DC1);
    private static _SAMPLER_BUFFER                            := new UniformType($8DC2);
    private static _SAMPLER_1D_ARRAY_SHADOW                   := new UniformType($8DC3);
    private static _SAMPLER_2D_ARRAY_SHADOW                   := new UniformType($8DC4);
    private static _SAMPLER_CUBE_SHADOW                       := new UniformType($8DC5);
    private static _UNSIGNED_INT_VEC2                         := new UniformType($8DC6);
    private static _UNSIGNED_INT_VEC3                         := new UniformType($8DC7);
    private static _UNSIGNED_INT_VEC4                         := new UniformType($8DC8);
    private static _INT_SAMPLER_1D                            := new UniformType($8DC9);
    private static _INT_SAMPLER_2D                            := new UniformType($8DCA);
    private static _INT_SAMPLER_3D                            := new UniformType($8DCB);
    private static _INT_SAMPLER_CUBE                          := new UniformType($8DCC);
    private static _INT_SAMPLER_2D_RECT                       := new UniformType($8DCD);
    private static _INT_SAMPLER_1D_ARRAY                      := new UniformType($8DCE);
    private static _INT_SAMPLER_2D_ARRAY                      := new UniformType($8DCF);
    private static _INT_SAMPLER_BUFFER                        := new UniformType($8DD0);
    private static _UNSIGNED_INT_SAMPLER_1D                   := new UniformType($8DD1);
    private static _UNSIGNED_INT_SAMPLER_2D                   := new UniformType($8DD2);
    private static _UNSIGNED_INT_SAMPLER_3D                   := new UniformType($8DD3);
    private static _UNSIGNED_INT_SAMPLER_CUBE                 := new UniformType($8DD4);
    private static _UNSIGNED_INT_SAMPLER_2D_RECT              := new UniformType($8DD5);
    private static _UNSIGNED_INT_SAMPLER_1D_ARRAY             := new UniformType($8DD6);
    private static _UNSIGNED_INT_SAMPLER_2D_ARRAY             := new UniformType($8DD7);
    private static _UNSIGNED_INT_SAMPLER_BUFFER               := new UniformType($8DD8);
    private static _DOUBLE_MAT2                               := new UniformType($8F46);
    private static _DOUBLE_MAT3                               := new UniformType($8F47);
    private static _DOUBLE_MAT4                               := new UniformType($8F48);
    private static _DOUBLE_MAT2x3                             := new UniformType($8F49);
    private static _DOUBLE_MAT2x4                             := new UniformType($8F4A);
    private static _DOUBLE_MAT3x2                             := new UniformType($8F4B);
    private static _DOUBLE_MAT3x4                             := new UniformType($8F4C);
    private static _DOUBLE_MAT4x2                             := new UniformType($8F4D);
    private static _DOUBLE_MAT4x3                             := new UniformType($8F4E);
    private static _DOUBLE_VEC2                               := new UniformType($8FFC);
    private static _DOUBLE_VEC3                               := new UniformType($8FFD);
    private static _DOUBLE_VEC4                               := new UniformType($8FFE);
    private static _SAMPLER_CUBE_MAP_ARRAY                    := new UniformType($900C);
    private static _SAMPLER_CUBE_MAP_ARRAY_SHADOW             := new UniformType($900D);
    private static _INT_SAMPLER_CUBE_MAP_ARRAY                := new UniformType($900E);
    private static _UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY       := new UniformType($900F);
    private static _SAMPLER_2D_MULTISAMPLE                    := new UniformType($9108);
    private static _INT_SAMPLER_2D_MULTISAMPLE                := new UniformType($9109);
    private static _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE       := new UniformType($910A);
    private static _SAMPLER_2D_MULTISAMPLE_ARRAY              := new UniformType($910B);
    private static _INT_SAMPLER_2D_MULTISAMPLE_ARRAY          := new UniformType($910C);
    private static _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY := new UniformType($910D);
    
    public static property INT:                                       UniformType read _INT;
    public static property UNSIGNED_INT:                              UniformType read _UNSIGNED_INT;
    public static property FLOAT:                                     UniformType read _FLOAT;
    public static property DOUBLE:                                    UniformType read _DOUBLE;
    public static property FLOAT_VEC2:                                UniformType read _FLOAT_VEC2;
    public static property FLOAT_VEC3:                                UniformType read _FLOAT_VEC3;
    public static property FLOAT_VEC4:                                UniformType read _FLOAT_VEC4;
    public static property INT_VEC2:                                  UniformType read _INT_VEC2;
    public static property INT_VEC3:                                  UniformType read _INT_VEC3;
    public static property INT_VEC4:                                  UniformType read _INT_VEC4;
    public static property BOOL:                                      UniformType read _BOOL;
    public static property BOOL_VEC2:                                 UniformType read _BOOL_VEC2;
    public static property BOOL_VEC3:                                 UniformType read _BOOL_VEC3;
    public static property BOOL_VEC4:                                 UniformType read _BOOL_VEC4;
    public static property FLOAT_MAT2:                                UniformType read _FLOAT_MAT2;
    public static property FLOAT_MAT3:                                UniformType read _FLOAT_MAT3;
    public static property FLOAT_MAT4:                                UniformType read _FLOAT_MAT4;
    public static property SAMPLER_1D:                                UniformType read _SAMPLER_1D;
    public static property SAMPLER_2D:                                UniformType read _SAMPLER_2D;
    public static property SAMPLER_3D:                                UniformType read _SAMPLER_3D;
    public static property SAMPLER_CUBE:                              UniformType read _SAMPLER_CUBE;
    public static property SAMPLER_1D_SHADOW:                         UniformType read _SAMPLER_1D_SHADOW;
    public static property SAMPLER_2D_SHADOW:                         UniformType read _SAMPLER_2D_SHADOW;
    public static property SAMPLER_2D_RECT:                           UniformType read _SAMPLER_2D_RECT;
    public static property SAMPLER_2D_RECT_SHADOW:                    UniformType read _SAMPLER_2D_RECT_SHADOW;
    public static property FLOAT_MAT2x3:                              UniformType read _FLOAT_MAT2x3;
    public static property FLOAT_MAT2x4:                              UniformType read _FLOAT_MAT2x4;
    public static property FLOAT_MAT3x2:                              UniformType read _FLOAT_MAT3x2;
    public static property FLOAT_MAT3x4:                              UniformType read _FLOAT_MAT3x4;
    public static property FLOAT_MAT4x2:                              UniformType read _FLOAT_MAT4x2;
    public static property FLOAT_MAT4x3:                              UniformType read _FLOAT_MAT4x3;
    public static property SAMPLER_1D_ARRAY:                          UniformType read _SAMPLER_1D_ARRAY;
    public static property SAMPLER_2D_ARRAY:                          UniformType read _SAMPLER_2D_ARRAY;
    public static property SAMPLER_BUFFER:                            UniformType read _SAMPLER_BUFFER;
    public static property SAMPLER_1D_ARRAY_SHADOW:                   UniformType read _SAMPLER_1D_ARRAY_SHADOW;
    public static property SAMPLER_2D_ARRAY_SHADOW:                   UniformType read _SAMPLER_2D_ARRAY_SHADOW;
    public static property SAMPLER_CUBE_SHADOW:                       UniformType read _SAMPLER_CUBE_SHADOW;
    public static property UNSIGNED_INT_VEC2:                         UniformType read _UNSIGNED_INT_VEC2;
    public static property UNSIGNED_INT_VEC3:                         UniformType read _UNSIGNED_INT_VEC3;
    public static property UNSIGNED_INT_VEC4:                         UniformType read _UNSIGNED_INT_VEC4;
    public static property INT_SAMPLER_1D:                            UniformType read _INT_SAMPLER_1D;
    public static property INT_SAMPLER_2D:                            UniformType read _INT_SAMPLER_2D;
    public static property INT_SAMPLER_3D:                            UniformType read _INT_SAMPLER_3D;
    public static property INT_SAMPLER_CUBE:                          UniformType read _INT_SAMPLER_CUBE;
    public static property INT_SAMPLER_2D_RECT:                       UniformType read _INT_SAMPLER_2D_RECT;
    public static property INT_SAMPLER_1D_ARRAY:                      UniformType read _INT_SAMPLER_1D_ARRAY;
    public static property INT_SAMPLER_2D_ARRAY:                      UniformType read _INT_SAMPLER_2D_ARRAY;
    public static property INT_SAMPLER_BUFFER:                        UniformType read _INT_SAMPLER_BUFFER;
    public static property UNSIGNED_INT_SAMPLER_1D:                   UniformType read _UNSIGNED_INT_SAMPLER_1D;
    public static property UNSIGNED_INT_SAMPLER_2D:                   UniformType read _UNSIGNED_INT_SAMPLER_2D;
    public static property UNSIGNED_INT_SAMPLER_3D:                   UniformType read _UNSIGNED_INT_SAMPLER_3D;
    public static property UNSIGNED_INT_SAMPLER_CUBE:                 UniformType read _UNSIGNED_INT_SAMPLER_CUBE;
    public static property UNSIGNED_INT_SAMPLER_2D_RECT:              UniformType read _UNSIGNED_INT_SAMPLER_2D_RECT;
    public static property UNSIGNED_INT_SAMPLER_1D_ARRAY:             UniformType read _UNSIGNED_INT_SAMPLER_1D_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_2D_ARRAY:             UniformType read _UNSIGNED_INT_SAMPLER_2D_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_BUFFER:               UniformType read _UNSIGNED_INT_SAMPLER_BUFFER;
    public static property DOUBLE_MAT2:                               UniformType read _DOUBLE_MAT2;
    public static property DOUBLE_MAT3:                               UniformType read _DOUBLE_MAT3;
    public static property DOUBLE_MAT4:                               UniformType read _DOUBLE_MAT4;
    public static property DOUBLE_MAT2x3:                             UniformType read _DOUBLE_MAT2x3;
    public static property DOUBLE_MAT2x4:                             UniformType read _DOUBLE_MAT2x4;
    public static property DOUBLE_MAT3x2:                             UniformType read _DOUBLE_MAT3x2;
    public static property DOUBLE_MAT3x4:                             UniformType read _DOUBLE_MAT3x4;
    public static property DOUBLE_MAT4x2:                             UniformType read _DOUBLE_MAT4x2;
    public static property DOUBLE_MAT4x3:                             UniformType read _DOUBLE_MAT4x3;
    public static property DOUBLE_VEC2:                               UniformType read _DOUBLE_VEC2;
    public static property DOUBLE_VEC3:                               UniformType read _DOUBLE_VEC3;
    public static property DOUBLE_VEC4:                               UniformType read _DOUBLE_VEC4;
    public static property SAMPLER_CUBE_MAP_ARRAY:                    UniformType read _SAMPLER_CUBE_MAP_ARRAY;
    public static property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             UniformType read _SAMPLER_CUBE_MAP_ARRAY_SHADOW;
    public static property INT_SAMPLER_CUBE_MAP_ARRAY:                UniformType read _INT_SAMPLER_CUBE_MAP_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       UniformType read _UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY;
    public static property SAMPLER_2D_MULTISAMPLE:                    UniformType read _SAMPLER_2D_MULTISAMPLE;
    public static property INT_SAMPLER_2D_MULTISAMPLE:                UniformType read _INT_SAMPLER_2D_MULTISAMPLE;
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       UniformType read _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE;
    public static property SAMPLER_2D_MULTISAMPLE_ARRAY:              UniformType read _SAMPLER_2D_MULTISAMPLE_ARRAY;
    public static property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          UniformType read _INT_SAMPLER_2D_MULTISAMPLE_ARRAY;
    public static property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: UniformType read _UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($8B50) then Result := 'FLOAT_VEC2' else
      if self.val = UInt32($8B51) then Result := 'FLOAT_VEC3' else
      if self.val = UInt32($8B52) then Result := 'FLOAT_VEC4' else
      if self.val = UInt32($8B53) then Result := 'INT_VEC2' else
      if self.val = UInt32($8B54) then Result := 'INT_VEC3' else
      if self.val = UInt32($8B55) then Result := 'INT_VEC4' else
      if self.val = UInt32($8B56) then Result := 'BOOL' else
      if self.val = UInt32($8B57) then Result := 'BOOL_VEC2' else
      if self.val = UInt32($8B58) then Result := 'BOOL_VEC3' else
      if self.val = UInt32($8B59) then Result := 'BOOL_VEC4' else
      if self.val = UInt32($8B5A) then Result := 'FLOAT_MAT2' else
      if self.val = UInt32($8B5B) then Result := 'FLOAT_MAT3' else
      if self.val = UInt32($8B5C) then Result := 'FLOAT_MAT4' else
      if self.val = UInt32($8B5D) then Result := 'SAMPLER_1D' else
      if self.val = UInt32($8B5E) then Result := 'SAMPLER_2D' else
      if self.val = UInt32($8B5F) then Result := 'SAMPLER_3D' else
      if self.val = UInt32($8B60) then Result := 'SAMPLER_CUBE' else
      if self.val = UInt32($8B61) then Result := 'SAMPLER_1D_SHADOW' else
      if self.val = UInt32($8B62) then Result := 'SAMPLER_2D_SHADOW' else
      if self.val = UInt32($8B63) then Result := 'SAMPLER_2D_RECT' else
      if self.val = UInt32($8B64) then Result := 'SAMPLER_2D_RECT_SHADOW' else
      if self.val = UInt32($8B65) then Result := 'FLOAT_MAT2x3' else
      if self.val = UInt32($8B66) then Result := 'FLOAT_MAT2x4' else
      if self.val = UInt32($8B67) then Result := 'FLOAT_MAT3x2' else
      if self.val = UInt32($8B68) then Result := 'FLOAT_MAT3x4' else
      if self.val = UInt32($8B69) then Result := 'FLOAT_MAT4x2' else
      if self.val = UInt32($8B6A) then Result := 'FLOAT_MAT4x3' else
      if self.val = UInt32($8DC0) then Result := 'SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DC1) then Result := 'SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DC2) then Result := 'SAMPLER_BUFFER' else
      if self.val = UInt32($8DC3) then Result := 'SAMPLER_1D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC4) then Result := 'SAMPLER_2D_ARRAY_SHADOW' else
      if self.val = UInt32($8DC5) then Result := 'SAMPLER_CUBE_SHADOW' else
      if self.val = UInt32($8DC6) then Result := 'UNSIGNED_INT_VEC2' else
      if self.val = UInt32($8DC7) then Result := 'UNSIGNED_INT_VEC3' else
      if self.val = UInt32($8DC8) then Result := 'UNSIGNED_INT_VEC4' else
      if self.val = UInt32($8DC9) then Result := 'INT_SAMPLER_1D' else
      if self.val = UInt32($8DCA) then Result := 'INT_SAMPLER_2D' else
      if self.val = UInt32($8DCB) then Result := 'INT_SAMPLER_3D' else
      if self.val = UInt32($8DCC) then Result := 'INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DCD) then Result := 'INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DCE) then Result := 'INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DCF) then Result := 'INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD0) then Result := 'INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8DD1) then Result := 'UNSIGNED_INT_SAMPLER_1D' else
      if self.val = UInt32($8DD2) then Result := 'UNSIGNED_INT_SAMPLER_2D' else
      if self.val = UInt32($8DD3) then Result := 'UNSIGNED_INT_SAMPLER_3D' else
      if self.val = UInt32($8DD4) then Result := 'UNSIGNED_INT_SAMPLER_CUBE' else
      if self.val = UInt32($8DD5) then Result := 'UNSIGNED_INT_SAMPLER_2D_RECT' else
      if self.val = UInt32($8DD6) then Result := 'UNSIGNED_INT_SAMPLER_1D_ARRAY' else
      if self.val = UInt32($8DD7) then Result := 'UNSIGNED_INT_SAMPLER_2D_ARRAY' else
      if self.val = UInt32($8DD8) then Result := 'UNSIGNED_INT_SAMPLER_BUFFER' else
      if self.val = UInt32($8F46) then Result := 'DOUBLE_MAT2' else
      if self.val = UInt32($8F47) then Result := 'DOUBLE_MAT3' else
      if self.val = UInt32($8F48) then Result := 'DOUBLE_MAT4' else
      if self.val = UInt32($8F49) then Result := 'DOUBLE_MAT2x3' else
      if self.val = UInt32($8F4A) then Result := 'DOUBLE_MAT2x4' else
      if self.val = UInt32($8F4B) then Result := 'DOUBLE_MAT3x2' else
      if self.val = UInt32($8F4C) then Result := 'DOUBLE_MAT3x4' else
      if self.val = UInt32($8F4D) then Result := 'DOUBLE_MAT4x2' else
      if self.val = UInt32($8F4E) then Result := 'DOUBLE_MAT4x3' else
      if self.val = UInt32($8FFC) then Result := 'DOUBLE_VEC2' else
      if self.val = UInt32($8FFD) then Result := 'DOUBLE_VEC3' else
      if self.val = UInt32($8FFE) then Result := 'DOUBLE_VEC4' else
      if self.val = UInt32($900C) then Result := 'SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900D) then Result := 'SAMPLER_CUBE_MAP_ARRAY_SHADOW' else
      if self.val = UInt32($900E) then Result := 'INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($900F) then Result := 'UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY' else
      if self.val = UInt32($9108) then Result := 'SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($9109) then Result := 'INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910A) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE' else
      if self.val = UInt32($910B) then Result := 'SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910C) then Result := 'INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
      if self.val = UInt32($910D) then Result := 'UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  UseProgramStageMask = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_SHADER_BIT              := new UseProgramStageMask($0001);
    private static _VERTEX_SHADER_BIT_EXT          := new UseProgramStageMask($0001);
    private static _FRAGMENT_SHADER_BIT            := new UseProgramStageMask($0002);
    private static _FRAGMENT_SHADER_BIT_EXT        := new UseProgramStageMask($0002);
    private static _GEOMETRY_SHADER_BIT            := new UseProgramStageMask($0004);
    private static _GEOMETRY_SHADER_BIT_EXT        := new UseProgramStageMask($0004);
    private static _GEOMETRY_SHADER_BIT_OES        := new UseProgramStageMask($0004);
    private static _TESS_CONTROL_SHADER_BIT        := new UseProgramStageMask($0008);
    private static _TESS_CONTROL_SHADER_BIT_EXT    := new UseProgramStageMask($0008);
    private static _TESS_CONTROL_SHADER_BIT_OES    := new UseProgramStageMask($0008);
    private static _TESS_EVALUATION_SHADER_BIT     := new UseProgramStageMask($0010);
    private static _TESS_EVALUATION_SHADER_BIT_EXT := new UseProgramStageMask($0010);
    private static _TESS_EVALUATION_SHADER_BIT_OES := new UseProgramStageMask($0010);
    private static _COMPUTE_SHADER_BIT             := new UseProgramStageMask($0020);
    private static _MESH_SHADER_BIT_NV             := new UseProgramStageMask($0040);
    private static _TASK_SHADER_BIT_NV             := new UseProgramStageMask($0080);
    private static _ALL_SHADER_BITS                := new UseProgramStageMask($FFFFFFFF);
    private static _ALL_SHADER_BITS_EXT            := new UseProgramStageMask($FFFFFFFF);
    
    public static property VERTEX_SHADER_BIT:              UseProgramStageMask read _VERTEX_SHADER_BIT;
    public static property VERTEX_SHADER_BIT_EXT:          UseProgramStageMask read _VERTEX_SHADER_BIT_EXT;
    public static property FRAGMENT_SHADER_BIT:            UseProgramStageMask read _FRAGMENT_SHADER_BIT;
    public static property FRAGMENT_SHADER_BIT_EXT:        UseProgramStageMask read _FRAGMENT_SHADER_BIT_EXT;
    public static property GEOMETRY_SHADER_BIT:            UseProgramStageMask read _GEOMETRY_SHADER_BIT;
    public static property GEOMETRY_SHADER_BIT_EXT:        UseProgramStageMask read _GEOMETRY_SHADER_BIT_EXT;
    public static property GEOMETRY_SHADER_BIT_OES:        UseProgramStageMask read _GEOMETRY_SHADER_BIT_OES;
    public static property TESS_CONTROL_SHADER_BIT:        UseProgramStageMask read _TESS_CONTROL_SHADER_BIT;
    public static property TESS_CONTROL_SHADER_BIT_EXT:    UseProgramStageMask read _TESS_CONTROL_SHADER_BIT_EXT;
    public static property TESS_CONTROL_SHADER_BIT_OES:    UseProgramStageMask read _TESS_CONTROL_SHADER_BIT_OES;
    public static property TESS_EVALUATION_SHADER_BIT:     UseProgramStageMask read _TESS_EVALUATION_SHADER_BIT;
    public static property TESS_EVALUATION_SHADER_BIT_EXT: UseProgramStageMask read _TESS_EVALUATION_SHADER_BIT_EXT;
    public static property TESS_EVALUATION_SHADER_BIT_OES: UseProgramStageMask read _TESS_EVALUATION_SHADER_BIT_OES;
    public static property COMPUTE_SHADER_BIT:             UseProgramStageMask read _COMPUTE_SHADER_BIT;
    public static property MESH_SHADER_BIT_NV:             UseProgramStageMask read _MESH_SHADER_BIT_NV;
    public static property TASK_SHADER_BIT_NV:             UseProgramStageMask read _TASK_SHADER_BIT_NV;
    public static property ALL_SHADER_BITS:                UseProgramStageMask read _ALL_SHADER_BITS;
    public static property ALL_SHADER_BITS_EXT:            UseProgramStageMask read _ALL_SHADER_BITS_EXT;
    
    public static function operator or(f1,f2: UseProgramStageMask) := new UseProgramStageMask(f1.val or f2.val);
    
    public property HAS_FLAG_VERTEX_SHADER_BIT:              boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_VERTEX_SHADER_BIT_EXT:          boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_FRAGMENT_SHADER_BIT:            boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_FRAGMENT_SHADER_BIT_EXT:        boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_GEOMETRY_SHADER_BIT:            boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_GEOMETRY_SHADER_BIT_EXT:        boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_GEOMETRY_SHADER_BIT_OES:        boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_TESS_CONTROL_SHADER_BIT:        boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_TESS_CONTROL_SHADER_BIT_EXT:    boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_TESS_CONTROL_SHADER_BIT_OES:    boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_TESS_EVALUATION_SHADER_BIT:     boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_TESS_EVALUATION_SHADER_BIT_EXT: boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_TESS_EVALUATION_SHADER_BIT_OES: boolean read self.val and $0010 <> 0;
    public property HAS_FLAG_COMPUTE_SHADER_BIT:             boolean read self.val and $0020 <> 0;
    public property HAS_FLAG_MESH_SHADER_BIT_NV:             boolean read self.val and $0040 <> 0;
    public property HAS_FLAG_TASK_SHADER_BIT_NV:             boolean read self.val and $0080 <> 0;
    public property HAS_FLAG_ALL_SHADER_BITS:                boolean read self.val and $FFFFFFFF <> 0;
    public property HAS_FLAG_ALL_SHADER_BITS_EXT:            boolean read self.val and $FFFFFFFF <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'VERTEX_SHADER_BIT+';
      if self.val and UInt32($0001) = UInt32($0001) then res += 'VERTEX_SHADER_BIT_EXT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'FRAGMENT_SHADER_BIT+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'FRAGMENT_SHADER_BIT_EXT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'GEOMETRY_SHADER_BIT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'GEOMETRY_SHADER_BIT_EXT+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'GEOMETRY_SHADER_BIT_OES+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'TESS_CONTROL_SHADER_BIT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'TESS_CONTROL_SHADER_BIT_EXT+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'TESS_CONTROL_SHADER_BIT_OES+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'TESS_EVALUATION_SHADER_BIT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'TESS_EVALUATION_SHADER_BIT_EXT+';
      if self.val and UInt32($0010) = UInt32($0010) then res += 'TESS_EVALUATION_SHADER_BIT_OES+';
      if self.val and UInt32($0020) = UInt32($0020) then res += 'COMPUTE_SHADER_BIT+';
      if self.val and UInt32($0040) = UInt32($0040) then res += 'MESH_SHADER_BIT_NV+';
      if self.val and UInt32($0080) = UInt32($0080) then res += 'TASK_SHADER_BIT_NV+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_SHADER_BITS+';
      if self.val and UInt32($FFFFFFFF) = UInt32($FFFFFFFF) then res += 'ALL_SHADER_BITS_EXT+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexArrayPName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_ATTRIB_RELATIVE_OFFSET  := new VertexArrayPName($82D5);
    private static _VERTEX_ATTRIB_ARRAY_ENABLED    := new VertexArrayPName($8622);
    private static _VERTEX_ATTRIB_ARRAY_SIZE       := new VertexArrayPName($8623);
    private static _VERTEX_ATTRIB_ARRAY_STRIDE     := new VertexArrayPName($8624);
    private static _VERTEX_ATTRIB_ARRAY_TYPE       := new VertexArrayPName($8625);
    private static _VERTEX_ATTRIB_ARRAY_LONG       := new VertexArrayPName($874E);
    private static _VERTEX_ATTRIB_ARRAY_NORMALIZED := new VertexArrayPName($886A);
    private static _VERTEX_ATTRIB_ARRAY_INTEGER    := new VertexArrayPName($88FD);
    private static _VERTEX_ATTRIB_ARRAY_DIVISOR    := new VertexArrayPName($88FE);
    
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:  VertexArrayPName read _VERTEX_ATTRIB_RELATIVE_OFFSET;
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:    VertexArrayPName read _VERTEX_ATTRIB_ARRAY_ENABLED;
    public static property VERTEX_ATTRIB_ARRAY_SIZE:       VertexArrayPName read _VERTEX_ATTRIB_ARRAY_SIZE;
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:     VertexArrayPName read _VERTEX_ATTRIB_ARRAY_STRIDE;
    public static property VERTEX_ATTRIB_ARRAY_TYPE:       VertexArrayPName read _VERTEX_ATTRIB_ARRAY_TYPE;
    public static property VERTEX_ATTRIB_ARRAY_LONG:       VertexArrayPName read _VERTEX_ATTRIB_ARRAY_LONG;
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED: VertexArrayPName read _VERTEX_ATTRIB_ARRAY_NORMALIZED;
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:    VertexArrayPName read _VERTEX_ATTRIB_ARRAY_INTEGER;
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:    VertexArrayPName read _VERTEX_ATTRIB_ARRAY_DIVISOR;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82D5) then Result := 'VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if self.val = UInt32($8622) then Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if self.val = UInt32($8623) then Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if self.val = UInt32($8624) then Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if self.val = UInt32($8625) then Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if self.val = UInt32($874E) then Result := 'VERTEX_ATTRIB_ARRAY_LONG' else
      if self.val = UInt32($886A) then Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if self.val = UInt32($88FD) then Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if self.val = UInt32($88FE) then Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribEnum = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_ATTRIB_ARRAY_ENABLED        := new VertexAttribEnum($8622);
    private static _VERTEX_ATTRIB_ARRAY_SIZE           := new VertexAttribEnum($8623);
    private static _VERTEX_ATTRIB_ARRAY_STRIDE         := new VertexAttribEnum($8624);
    private static _VERTEX_ATTRIB_ARRAY_TYPE           := new VertexAttribEnum($8625);
    private static _CURRENT_VERTEX_ATTRIB              := new VertexAttribEnum($8626);
    private static _VERTEX_ATTRIB_ARRAY_NORMALIZED     := new VertexAttribEnum($886A);
    private static _VERTEX_ATTRIB_ARRAY_BUFFER_BINDING := new VertexAttribEnum($889F);
    private static _VERTEX_ATTRIB_ARRAY_INTEGER        := new VertexAttribEnum($88FD);
    private static _VERTEX_ATTRIB_ARRAY_DIVISOR        := new VertexAttribEnum($88FE);
    
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:        VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_ENABLED;
    public static property VERTEX_ATTRIB_ARRAY_SIZE:           VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_SIZE;
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:         VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_STRIDE;
    public static property VERTEX_ATTRIB_ARRAY_TYPE:           VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_TYPE;
    public static property CURRENT_VERTEX_ATTRIB:              VertexAttribEnum read _CURRENT_VERTEX_ATTRIB;
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:     VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_NORMALIZED;
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:        VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_INTEGER;
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:        VertexAttribEnum read _VERTEX_ATTRIB_ARRAY_DIVISOR;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8622) then Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if self.val = UInt32($8623) then Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if self.val = UInt32($8624) then Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if self.val = UInt32($8625) then Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if self.val = UInt32($8626) then Result := 'CURRENT_VERTEX_ATTRIB' else
      if self.val = UInt32($886A) then Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if self.val = UInt32($889F) then Result := 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($88FD) then Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if self.val = UInt32($88FE) then Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribIType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE           := new VertexAttribIType($1400);
    private static _UNSIGNED_BYTE  := new VertexAttribIType($1401);
    private static _SHORT          := new VertexAttribIType($1402);
    private static _UNSIGNED_SHORT := new VertexAttribIType($1403);
    private static _INT            := new VertexAttribIType($1404);
    private static _UNSIGNED_INT   := new VertexAttribIType($1405);
    
    public static property BYTE:           VertexAttribIType read _BYTE;
    public static property UNSIGNED_BYTE:  VertexAttribIType read _UNSIGNED_BYTE;
    public static property SHORT:          VertexAttribIType read _SHORT;
    public static property UNSIGNED_SHORT: VertexAttribIType read _UNSIGNED_SHORT;
    public static property INT:            VertexAttribIType read _INT;
    public static property UNSIGNED_INT:   VertexAttribIType read _UNSIGNED_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribLType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DOUBLE := new VertexAttribLType($140A);
    
    public static property DOUBLE: VertexAttribLType read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE                         := new VertexAttribPointerType($1400);
    private static _UNSIGNED_BYTE                := new VertexAttribPointerType($1401);
    private static _SHORT                        := new VertexAttribPointerType($1402);
    private static _UNSIGNED_SHORT               := new VertexAttribPointerType($1403);
    private static _INT                          := new VertexAttribPointerType($1404);
    private static _UNSIGNED_INT                 := new VertexAttribPointerType($1405);
    private static _FLOAT                        := new VertexAttribPointerType($1406);
    private static _DOUBLE                       := new VertexAttribPointerType($140A);
    private static _HALF_FLOAT                   := new VertexAttribPointerType($140B);
    private static _FIXED                        := new VertexAttribPointerType($140C);
    private static _INT64_ARB                    := new VertexAttribPointerType($140E);
    private static _INT64_NV                     := new VertexAttribPointerType($140E);
    private static _UNSIGNED_INT64_ARB           := new VertexAttribPointerType($140F);
    private static _UNSIGNED_INT64_NV            := new VertexAttribPointerType($140F);
    private static _UNSIGNED_INT_2_10_10_10_REV  := new VertexAttribPointerType($8368);
    private static _UNSIGNED_INT_10F_11F_11F_REV := new VertexAttribPointerType($8C3B);
    private static _INT_2_10_10_10_REV           := new VertexAttribPointerType($8D9F);
    
    public static property BYTE:                         VertexAttribPointerType read _BYTE;
    public static property UNSIGNED_BYTE:                VertexAttribPointerType read _UNSIGNED_BYTE;
    public static property SHORT:                        VertexAttribPointerType read _SHORT;
    public static property UNSIGNED_SHORT:               VertexAttribPointerType read _UNSIGNED_SHORT;
    public static property INT:                          VertexAttribPointerType read _INT;
    public static property UNSIGNED_INT:                 VertexAttribPointerType read _UNSIGNED_INT;
    public static property FLOAT:                        VertexAttribPointerType read _FLOAT;
    public static property DOUBLE:                       VertexAttribPointerType read _DOUBLE;
    public static property HALF_FLOAT:                   VertexAttribPointerType read _HALF_FLOAT;
    public static property FIXED:                        VertexAttribPointerType read _FIXED;
    public static property INT64_ARB:                    VertexAttribPointerType read _INT64_ARB;
    public static property INT64_NV:                     VertexAttribPointerType read _INT64_NV;
    public static property UNSIGNED_INT64_ARB:           VertexAttribPointerType read _UNSIGNED_INT64_ARB;
    public static property UNSIGNED_INT64_NV:            VertexAttribPointerType read _UNSIGNED_INT64_NV;
    public static property UNSIGNED_INT_2_10_10_10_REV:  VertexAttribPointerType read _UNSIGNED_INT_2_10_10_10_REV;
    public static property UNSIGNED_INT_10F_11F_11F_REV: VertexAttribPointerType read _UNSIGNED_INT_10F_11F_11F_REV;
    public static property INT_2_10_10_10_REV:           VertexAttribPointerType read _INT_2_10_10_10_REV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140B) then Result := 'HALF_FLOAT' else
      if self.val = UInt32($140C) then Result := 'FIXED' else
      if self.val = UInt32($140E) then Result := 'INT64_ARB' else
      if self.val = UInt32($140E) then Result := 'INT64_NV' else
      if self.val = UInt32($140F) then Result := 'UNSIGNED_INT64_ARB' else
      if self.val = UInt32($140F) then Result := 'UNSIGNED_INT64_NV' else
      if self.val = UInt32($8368) then Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if self.val = UInt32($8C3B) then Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if self.val = UInt32($8D9F) then Result := 'INT_2_10_10_10_REV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE                         := new VertexAttribType($1400);
    private static _UNSIGNED_BYTE                := new VertexAttribType($1401);
    private static _SHORT                        := new VertexAttribType($1402);
    private static _UNSIGNED_SHORT               := new VertexAttribType($1403);
    private static _INT                          := new VertexAttribType($1404);
    private static _UNSIGNED_INT                 := new VertexAttribType($1405);
    private static _FLOAT                        := new VertexAttribType($1406);
    private static _DOUBLE                       := new VertexAttribType($140A);
    private static _HALF_FLOAT                   := new VertexAttribType($140B);
    private static _FIXED                        := new VertexAttribType($140C);
    private static _UNSIGNED_INT_2_10_10_10_REV  := new VertexAttribType($8368);
    private static _UNSIGNED_INT_10F_11F_11F_REV := new VertexAttribType($8C3B);
    private static _INT_2_10_10_10_REV           := new VertexAttribType($8D9F);
    
    public static property BYTE:                         VertexAttribType read _BYTE;
    public static property UNSIGNED_BYTE:                VertexAttribType read _UNSIGNED_BYTE;
    public static property SHORT:                        VertexAttribType read _SHORT;
    public static property UNSIGNED_SHORT:               VertexAttribType read _UNSIGNED_SHORT;
    public static property INT:                          VertexAttribType read _INT;
    public static property UNSIGNED_INT:                 VertexAttribType read _UNSIGNED_INT;
    public static property FLOAT:                        VertexAttribType read _FLOAT;
    public static property DOUBLE:                       VertexAttribType read _DOUBLE;
    public static property HALF_FLOAT:                   VertexAttribType read _HALF_FLOAT;
    public static property FIXED:                        VertexAttribType read _FIXED;
    public static property UNSIGNED_INT_2_10_10_10_REV:  VertexAttribType read _UNSIGNED_INT_2_10_10_10_REV;
    public static property UNSIGNED_INT_10F_11F_11F_REV: VertexAttribType read _UNSIGNED_INT_10F_11F_11F_REV;
    public static property INT_2_10_10_10_REV:           VertexAttribType read _INT_2_10_10_10_REV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140B) then Result := 'HALF_FLOAT' else
      if self.val = UInt32($140C) then Result := 'FIXED' else
      if self.val = UInt32($8368) then Result := 'UNSIGNED_INT_2_10_10_10_REV' else
      if self.val = UInt32($8C3B) then Result := 'UNSIGNED_INT_10F_11F_11F_REV' else
      if self.val = UInt32($8D9F) then Result := 'INT_2_10_10_10_REV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexBufferObjectUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _STREAM_DRAW  := new VertexBufferObjectUsage($88E0);
    private static _STREAM_READ  := new VertexBufferObjectUsage($88E1);
    private static _STREAM_COPY  := new VertexBufferObjectUsage($88E2);
    private static _STATIC_DRAW  := new VertexBufferObjectUsage($88E4);
    private static _STATIC_READ  := new VertexBufferObjectUsage($88E5);
    private static _STATIC_COPY  := new VertexBufferObjectUsage($88E6);
    private static _DYNAMIC_DRAW := new VertexBufferObjectUsage($88E8);
    private static _DYNAMIC_READ := new VertexBufferObjectUsage($88E9);
    private static _DYNAMIC_COPY := new VertexBufferObjectUsage($88EA);
    
    public static property STREAM_DRAW:  VertexBufferObjectUsage read _STREAM_DRAW;
    public static property STREAM_READ:  VertexBufferObjectUsage read _STREAM_READ;
    public static property STREAM_COPY:  VertexBufferObjectUsage read _STREAM_COPY;
    public static property STATIC_DRAW:  VertexBufferObjectUsage read _STATIC_DRAW;
    public static property STATIC_READ:  VertexBufferObjectUsage read _STATIC_READ;
    public static property STATIC_COPY:  VertexBufferObjectUsage read _STATIC_COPY;
    public static property DYNAMIC_DRAW: VertexBufferObjectUsage read _DYNAMIC_DRAW;
    public static property DYNAMIC_READ: VertexBufferObjectUsage read _DYNAMIC_READ;
    public static property DYNAMIC_COPY: VertexBufferObjectUsage read _DYNAMIC_COPY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88E0) then Result := 'STREAM_DRAW' else
      if self.val = UInt32($88E1) then Result := 'STREAM_READ' else
      if self.val = UInt32($88E2) then Result := 'STREAM_COPY' else
      if self.val = UInt32($88E4) then Result := 'STATIC_DRAW' else
      if self.val = UInt32($88E5) then Result := 'STATIC_READ' else
      if self.val = UInt32($88E6) then Result := 'STATIC_COPY' else
      if self.val = UInt32($88E8) then Result := 'DYNAMIC_DRAW' else
      if self.val = UInt32($88E9) then Result := 'DYNAMIC_READ' else
      if self.val = UInt32($88EA) then Result := 'DYNAMIC_COPY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexPointerType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SHORT  := new VertexPointerType($1402);
    private static _INT    := new VertexPointerType($1404);
    private static _FLOAT  := new VertexPointerType($1406);
    private static _DOUBLE := new VertexPointerType($140A);
    
    public static property SHORT:  VertexPointerType read _SHORT;
    public static property INT:    VertexPointerType read _INT;
    public static property FLOAT:  VertexPointerType read _FLOAT;
    public static property DOUBLE: VertexPointerType read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexProvokingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FIRST_VERTEX_CONVENTION := new VertexProvokingMode($8E4D);
    private static _LAST_VERTEX_CONVENTION  := new VertexProvokingMode($8E4E);
    
    public static property FIRST_VERTEX_CONVENTION: VertexProvokingMode read _FIRST_VERTEX_CONVENTION;
    public static property LAST_VERTEX_CONVENTION:  VertexProvokingMode read _LAST_VERTEX_CONVENTION;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E4D) then Result := 'FIRST_VERTEX_CONVENTION' else
      if self.val = UInt32($8E4E) then Result := 'LAST_VERTEX_CONVENTION' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexShaderTextureUnitParameter = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CURRENT_TEXTURE_COORDS := new VertexShaderTextureUnitParameter($0B03);
    private static _TEXTURE_MATRIX         := new VertexShaderTextureUnitParameter($0BA8);
    
    public static property CURRENT_TEXTURE_COORDS: VertexShaderTextureUnitParameter read _CURRENT_TEXTURE_COORDS;
    public static property TEXTURE_MATRIX:         VertexShaderTextureUnitParameter read _TEXTURE_MATRIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0B03) then Result := 'CURRENT_TEXTURE_COORDS' else
      if self.val = UInt32($0BA8) then Result := 'TEXTURE_MATRIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion Core}
  
  {$region ARB}
  
  BufferAccessARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _READ_ONLY  := new BufferAccessARB($88B8);
    private static _WRITE_ONLY := new BufferAccessARB($88B9);
    private static _READ_WRITE := new BufferAccessARB($88BA);
    
    public static property READ_ONLY:  BufferAccessARB read _READ_ONLY;
    public static property WRITE_ONLY: BufferAccessARB read _WRITE_ONLY;
    public static property READ_WRITE: BufferAccessARB read _READ_WRITE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88B8) then Result := 'READ_ONLY' else
      if self.val = UInt32($88B9) then Result := 'WRITE_ONLY' else
      if self.val = UInt32($88BA) then Result := 'READ_WRITE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BufferPNameARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BUFFER_IMMUTABLE_STORAGE := new BufferPNameARB($821F);
    private static _BUFFER_STORAGE_FLAGS     := new BufferPNameARB($8220);
    private static _BUFFER_SIZE              := new BufferPNameARB($8764);
    private static _BUFFER_SIZE_ARB          := new BufferPNameARB($8764);
    private static _BUFFER_USAGE             := new BufferPNameARB($8765);
    private static _BUFFER_USAGE_ARB         := new BufferPNameARB($8765);
    private static _BUFFER_ACCESS            := new BufferPNameARB($88BB);
    private static _BUFFER_ACCESS_ARB        := new BufferPNameARB($88BB);
    private static _BUFFER_MAPPED            := new BufferPNameARB($88BC);
    private static _BUFFER_MAPPED_ARB        := new BufferPNameARB($88BC);
    private static _BUFFER_ACCESS_FLAGS      := new BufferPNameARB($911F);
    private static _BUFFER_MAP_LENGTH        := new BufferPNameARB($9120);
    private static _BUFFER_MAP_OFFSET        := new BufferPNameARB($9121);
    
    public static property BUFFER_IMMUTABLE_STORAGE: BufferPNameARB read _BUFFER_IMMUTABLE_STORAGE;
    public static property BUFFER_STORAGE_FLAGS:     BufferPNameARB read _BUFFER_STORAGE_FLAGS;
    public static property BUFFER_SIZE:              BufferPNameARB read _BUFFER_SIZE;
    public static property BUFFER_SIZE_ARB:          BufferPNameARB read _BUFFER_SIZE_ARB;
    public static property BUFFER_USAGE:             BufferPNameARB read _BUFFER_USAGE;
    public static property BUFFER_USAGE_ARB:         BufferPNameARB read _BUFFER_USAGE_ARB;
    public static property BUFFER_ACCESS:            BufferPNameARB read _BUFFER_ACCESS;
    public static property BUFFER_ACCESS_ARB:        BufferPNameARB read _BUFFER_ACCESS_ARB;
    public static property BUFFER_MAPPED:            BufferPNameARB read _BUFFER_MAPPED;
    public static property BUFFER_MAPPED_ARB:        BufferPNameARB read _BUFFER_MAPPED_ARB;
    public static property BUFFER_ACCESS_FLAGS:      BufferPNameARB read _BUFFER_ACCESS_FLAGS;
    public static property BUFFER_MAP_LENGTH:        BufferPNameARB read _BUFFER_MAP_LENGTH;
    public static property BUFFER_MAP_OFFSET:        BufferPNameARB read _BUFFER_MAP_OFFSET;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($821F) then Result := 'BUFFER_IMMUTABLE_STORAGE' else
      if self.val = UInt32($8220) then Result := 'BUFFER_STORAGE_FLAGS' else
      if self.val = UInt32($8764) then Result := 'BUFFER_SIZE' else
      if self.val = UInt32($8764) then Result := 'BUFFER_SIZE_ARB' else
      if self.val = UInt32($8765) then Result := 'BUFFER_USAGE' else
      if self.val = UInt32($8765) then Result := 'BUFFER_USAGE_ARB' else
      if self.val = UInt32($88BB) then Result := 'BUFFER_ACCESS' else
      if self.val = UInt32($88BB) then Result := 'BUFFER_ACCESS_ARB' else
      if self.val = UInt32($88BC) then Result := 'BUFFER_MAPPED' else
      if self.val = UInt32($88BC) then Result := 'BUFFER_MAPPED_ARB' else
      if self.val = UInt32($911F) then Result := 'BUFFER_ACCESS_FLAGS' else
      if self.val = UInt32($9120) then Result := 'BUFFER_MAP_LENGTH' else
      if self.val = UInt32($9121) then Result := 'BUFFER_MAP_OFFSET' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BufferPointerNameARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BUFFER_MAP_POINTER     := new BufferPointerNameARB($88BD);
    private static _BUFFER_MAP_POINTER_ARB := new BufferPointerNameARB($88BD);
    
    public static property BUFFER_MAP_POINTER:     BufferPointerNameARB read _BUFFER_MAP_POINTER;
    public static property BUFFER_MAP_POINTER_ARB: BufferPointerNameARB read _BUFFER_MAP_POINTER_ARB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88BD) then Result := 'BUFFER_MAP_POINTER' else
      if self.val = UInt32($88BD) then Result := 'BUFFER_MAP_POINTER_ARB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BufferTargetARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PARAMETER_BUFFER          := new BufferTargetARB($80EE);
    private static _ARRAY_BUFFER              := new BufferTargetARB($8892);
    private static _ELEMENT_ARRAY_BUFFER      := new BufferTargetARB($8893);
    private static _PIXEL_PACK_BUFFER         := new BufferTargetARB($88EB);
    private static _PIXEL_UNPACK_BUFFER       := new BufferTargetARB($88EC);
    private static _UNIFORM_BUFFER            := new BufferTargetARB($8A11);
    private static _TEXTURE_BUFFER            := new BufferTargetARB($8C2A);
    private static _TRANSFORM_FEEDBACK_BUFFER := new BufferTargetARB($8C8E);
    private static _COPY_READ_BUFFER          := new BufferTargetARB($8F36);
    private static _COPY_WRITE_BUFFER         := new BufferTargetARB($8F37);
    private static _DRAW_INDIRECT_BUFFER      := new BufferTargetARB($8F3F);
    private static _SHADER_STORAGE_BUFFER     := new BufferTargetARB($90D2);
    private static _DISPATCH_INDIRECT_BUFFER  := new BufferTargetARB($90EE);
    private static _QUERY_BUFFER              := new BufferTargetARB($9192);
    private static _ATOMIC_COUNTER_BUFFER     := new BufferTargetARB($92C0);
    
    public static property PARAMETER_BUFFER:          BufferTargetARB read _PARAMETER_BUFFER;
    public static property ARRAY_BUFFER:              BufferTargetARB read _ARRAY_BUFFER;
    public static property ELEMENT_ARRAY_BUFFER:      BufferTargetARB read _ELEMENT_ARRAY_BUFFER;
    public static property PIXEL_PACK_BUFFER:         BufferTargetARB read _PIXEL_PACK_BUFFER;
    public static property PIXEL_UNPACK_BUFFER:       BufferTargetARB read _PIXEL_UNPACK_BUFFER;
    public static property UNIFORM_BUFFER:            BufferTargetARB read _UNIFORM_BUFFER;
    public static property TEXTURE_BUFFER:            BufferTargetARB read _TEXTURE_BUFFER;
    public static property TRANSFORM_FEEDBACK_BUFFER: BufferTargetARB read _TRANSFORM_FEEDBACK_BUFFER;
    public static property COPY_READ_BUFFER:          BufferTargetARB read _COPY_READ_BUFFER;
    public static property COPY_WRITE_BUFFER:         BufferTargetARB read _COPY_WRITE_BUFFER;
    public static property DRAW_INDIRECT_BUFFER:      BufferTargetARB read _DRAW_INDIRECT_BUFFER;
    public static property SHADER_STORAGE_BUFFER:     BufferTargetARB read _SHADER_STORAGE_BUFFER;
    public static property DISPATCH_INDIRECT_BUFFER:  BufferTargetARB read _DISPATCH_INDIRECT_BUFFER;
    public static property QUERY_BUFFER:              BufferTargetARB read _QUERY_BUFFER;
    public static property ATOMIC_COUNTER_BUFFER:     BufferTargetARB read _ATOMIC_COUNTER_BUFFER;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80EE) then Result := 'PARAMETER_BUFFER' else
      if self.val = UInt32($8892) then Result := 'ARRAY_BUFFER' else
      if self.val = UInt32($8893) then Result := 'ELEMENT_ARRAY_BUFFER' else
      if self.val = UInt32($88EB) then Result := 'PIXEL_PACK_BUFFER' else
      if self.val = UInt32($88EC) then Result := 'PIXEL_UNPACK_BUFFER' else
      if self.val = UInt32($8A11) then Result := 'UNIFORM_BUFFER' else
      if self.val = UInt32($8C2A) then Result := 'TEXTURE_BUFFER' else
      if self.val = UInt32($8C8E) then Result := 'TRANSFORM_FEEDBACK_BUFFER' else
      if self.val = UInt32($8F36) then Result := 'COPY_READ_BUFFER' else
      if self.val = UInt32($8F37) then Result := 'COPY_WRITE_BUFFER' else
      if self.val = UInt32($8F3F) then Result := 'DRAW_INDIRECT_BUFFER' else
      if self.val = UInt32($90D2) then Result := 'SHADER_STORAGE_BUFFER' else
      if self.val = UInt32($90EE) then Result := 'DISPATCH_INDIRECT_BUFFER' else
      if self.val = UInt32($9192) then Result := 'QUERY_BUFFER' else
      if self.val = UInt32($92C0) then Result := 'ATOMIC_COUNTER_BUFFER' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BufferUsageARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _STREAM_DRAW  := new BufferUsageARB($88E0);
    private static _STREAM_READ  := new BufferUsageARB($88E1);
    private static _STREAM_COPY  := new BufferUsageARB($88E2);
    private static _STATIC_DRAW  := new BufferUsageARB($88E4);
    private static _STATIC_READ  := new BufferUsageARB($88E5);
    private static _STATIC_COPY  := new BufferUsageARB($88E6);
    private static _DYNAMIC_DRAW := new BufferUsageARB($88E8);
    private static _DYNAMIC_READ := new BufferUsageARB($88E9);
    private static _DYNAMIC_COPY := new BufferUsageARB($88EA);
    
    public static property STREAM_DRAW:  BufferUsageARB read _STREAM_DRAW;
    public static property STREAM_READ:  BufferUsageARB read _STREAM_READ;
    public static property STREAM_COPY:  BufferUsageARB read _STREAM_COPY;
    public static property STATIC_DRAW:  BufferUsageARB read _STATIC_DRAW;
    public static property STATIC_READ:  BufferUsageARB read _STATIC_READ;
    public static property STATIC_COPY:  BufferUsageARB read _STATIC_COPY;
    public static property DYNAMIC_DRAW: BufferUsageARB read _DYNAMIC_DRAW;
    public static property DYNAMIC_READ: BufferUsageARB read _DYNAMIC_READ;
    public static property DYNAMIC_COPY: BufferUsageARB read _DYNAMIC_COPY;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($88E0) then Result := 'STREAM_DRAW' else
      if self.val = UInt32($88E1) then Result := 'STREAM_READ' else
      if self.val = UInt32($88E2) then Result := 'STREAM_COPY' else
      if self.val = UInt32($88E4) then Result := 'STATIC_DRAW' else
      if self.val = UInt32($88E5) then Result := 'STATIC_READ' else
      if self.val = UInt32($88E6) then Result := 'STATIC_COPY' else
      if self.val = UInt32($88E8) then Result := 'DYNAMIC_DRAW' else
      if self.val = UInt32($88E9) then Result := 'DYNAMIC_READ' else
      if self.val = UInt32($88EA) then Result := 'DYNAMIC_COPY' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ClampColorModeARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FALSE          := new ClampColorModeARB($0000);
    private static _TRUE           := new ClampColorModeARB($0001);
    private static _FIXED_ONLY     := new ClampColorModeARB($891D);
    private static _FIXED_ONLY_ARB := new ClampColorModeARB($891D);
    
    public static property FALSE:          ClampColorModeARB read _FALSE;
    public static property TRUE:           ClampColorModeARB read _TRUE;
    public static property FIXED_ONLY:     ClampColorModeARB read _FIXED_ONLY;
    public static property FIXED_ONLY_ARB: ClampColorModeARB read _FIXED_ONLY_ARB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'FALSE' else
      if self.val = UInt32($0001) then Result := 'TRUE' else
      if self.val = UInt32($891D) then Result := 'FIXED_ONLY' else
      if self.val = UInt32($891D) then Result := 'FIXED_ONLY_ARB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ClampColorTargetARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CLAMP_VERTEX_COLOR_ARB   := new ClampColorTargetARB($891A);
    private static _CLAMP_FRAGMENT_COLOR_ARB := new ClampColorTargetARB($891B);
    private static _CLAMP_READ_COLOR         := new ClampColorTargetARB($891C);
    private static _CLAMP_READ_COLOR_ARB     := new ClampColorTargetARB($891C);
    
    public static property CLAMP_VERTEX_COLOR_ARB:   ClampColorTargetARB read _CLAMP_VERTEX_COLOR_ARB;
    public static property CLAMP_FRAGMENT_COLOR_ARB: ClampColorTargetARB read _CLAMP_FRAGMENT_COLOR_ARB;
    public static property CLAMP_READ_COLOR:         ClampColorTargetARB read _CLAMP_READ_COLOR;
    public static property CLAMP_READ_COLOR_ARB:     ClampColorTargetARB read _CLAMP_READ_COLOR_ARB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($891A) then Result := 'CLAMP_VERTEX_COLOR_ARB' else
      if self.val = UInt32($891B) then Result := 'CLAMP_FRAGMENT_COLOR_ARB' else
      if self.val = UInt32($891C) then Result := 'CLAMP_READ_COLOR' else
      if self.val = UInt32($891C) then Result := 'CLAMP_READ_COLOR_ARB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MatrixIndexPointerTypeARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNSIGNED_BYTE  := new MatrixIndexPointerTypeARB($1401);
    private static _UNSIGNED_SHORT := new MatrixIndexPointerTypeARB($1403);
    private static _UNSIGNED_INT   := new MatrixIndexPointerTypeARB($1405);
    
    public static property UNSIGNED_BYTE:  MatrixIndexPointerTypeARB read _UNSIGNED_BYTE;
    public static property UNSIGNED_SHORT: MatrixIndexPointerTypeARB read _UNSIGNED_SHORT;
    public static property UNSIGNED_INT:   MatrixIndexPointerTypeARB read _UNSIGNED_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PointParameterNameARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _POINT_SIZE_MIN_EXT            := new PointParameterNameARB($8126);
    private static _POINT_SIZE_MAX_EXT            := new PointParameterNameARB($8127);
    private static _POINT_FADE_THRESHOLD_SIZE     := new PointParameterNameARB($8128);
    private static _POINT_FADE_THRESHOLD_SIZE_EXT := new PointParameterNameARB($8128);
    
    public static property POINT_SIZE_MIN_EXT:            PointParameterNameARB read _POINT_SIZE_MIN_EXT;
    public static property POINT_SIZE_MAX_EXT:            PointParameterNameARB read _POINT_SIZE_MAX_EXT;
    public static property POINT_FADE_THRESHOLD_SIZE:     PointParameterNameARB read _POINT_FADE_THRESHOLD_SIZE;
    public static property POINT_FADE_THRESHOLD_SIZE_EXT: PointParameterNameARB read _POINT_FADE_THRESHOLD_SIZE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8126) then Result := 'POINT_SIZE_MIN_EXT' else
      if self.val = UInt32($8127) then Result := 'POINT_SIZE_MAX_EXT' else
      if self.val = UInt32($8128) then Result := 'POINT_FADE_THRESHOLD_SIZE' else
      if self.val = UInt32($8128) then Result := 'POINT_FADE_THRESHOLD_SIZE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ProgramPropertyARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COMPUTE_WORK_GROUP_SIZE               := new ProgramPropertyARB($8267);
    private static _PROGRAM_BINARY_LENGTH                 := new ProgramPropertyARB($8741);
    private static _GEOMETRY_VERTICES_OUT                 := new ProgramPropertyARB($8916);
    private static _GEOMETRY_INPUT_TYPE                   := new ProgramPropertyARB($8917);
    private static _GEOMETRY_OUTPUT_TYPE                  := new ProgramPropertyARB($8918);
    private static _ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH  := new ProgramPropertyARB($8A35);
    private static _ACTIVE_UNIFORM_BLOCKS                 := new ProgramPropertyARB($8A36);
    private static _DELETE_STATUS                         := new ProgramPropertyARB($8B80);
    private static _LINK_STATUS                           := new ProgramPropertyARB($8B82);
    private static _VALIDATE_STATUS                       := new ProgramPropertyARB($8B83);
    private static _INFO_LOG_LENGTH                       := new ProgramPropertyARB($8B84);
    private static _ATTACHED_SHADERS                      := new ProgramPropertyARB($8B85);
    private static _ACTIVE_UNIFORMS                       := new ProgramPropertyARB($8B86);
    private static _ACTIVE_UNIFORM_MAX_LENGTH             := new ProgramPropertyARB($8B87);
    private static _ACTIVE_ATTRIBUTES                     := new ProgramPropertyARB($8B89);
    private static _ACTIVE_ATTRIBUTE_MAX_LENGTH           := new ProgramPropertyARB($8B8A);
    private static _TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH := new ProgramPropertyARB($8C76);
    private static _TRANSFORM_FEEDBACK_BUFFER_MODE        := new ProgramPropertyARB($8C7F);
    private static _TRANSFORM_FEEDBACK_VARYINGS           := new ProgramPropertyARB($8C83);
    private static _ACTIVE_ATOMIC_COUNTER_BUFFERS         := new ProgramPropertyARB($92D9);
    
    public static property COMPUTE_WORK_GROUP_SIZE:               ProgramPropertyARB read _COMPUTE_WORK_GROUP_SIZE;
    public static property PROGRAM_BINARY_LENGTH:                 ProgramPropertyARB read _PROGRAM_BINARY_LENGTH;
    public static property GEOMETRY_VERTICES_OUT:                 ProgramPropertyARB read _GEOMETRY_VERTICES_OUT;
    public static property GEOMETRY_INPUT_TYPE:                   ProgramPropertyARB read _GEOMETRY_INPUT_TYPE;
    public static property GEOMETRY_OUTPUT_TYPE:                  ProgramPropertyARB read _GEOMETRY_OUTPUT_TYPE;
    public static property ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH:  ProgramPropertyARB read _ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH;
    public static property ACTIVE_UNIFORM_BLOCKS:                 ProgramPropertyARB read _ACTIVE_UNIFORM_BLOCKS;
    public static property DELETE_STATUS:                         ProgramPropertyARB read _DELETE_STATUS;
    public static property LINK_STATUS:                           ProgramPropertyARB read _LINK_STATUS;
    public static property VALIDATE_STATUS:                       ProgramPropertyARB read _VALIDATE_STATUS;
    public static property INFO_LOG_LENGTH:                       ProgramPropertyARB read _INFO_LOG_LENGTH;
    public static property ATTACHED_SHADERS:                      ProgramPropertyARB read _ATTACHED_SHADERS;
    public static property ACTIVE_UNIFORMS:                       ProgramPropertyARB read _ACTIVE_UNIFORMS;
    public static property ACTIVE_UNIFORM_MAX_LENGTH:             ProgramPropertyARB read _ACTIVE_UNIFORM_MAX_LENGTH;
    public static property ACTIVE_ATTRIBUTES:                     ProgramPropertyARB read _ACTIVE_ATTRIBUTES;
    public static property ACTIVE_ATTRIBUTE_MAX_LENGTH:           ProgramPropertyARB read _ACTIVE_ATTRIBUTE_MAX_LENGTH;
    public static property TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: ProgramPropertyARB read _TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH;
    public static property TRANSFORM_FEEDBACK_BUFFER_MODE:        ProgramPropertyARB read _TRANSFORM_FEEDBACK_BUFFER_MODE;
    public static property TRANSFORM_FEEDBACK_VARYINGS:           ProgramPropertyARB read _TRANSFORM_FEEDBACK_VARYINGS;
    public static property ACTIVE_ATOMIC_COUNTER_BUFFERS:         ProgramPropertyARB read _ACTIVE_ATOMIC_COUNTER_BUFFERS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8267) then Result := 'COMPUTE_WORK_GROUP_SIZE' else
      if self.val = UInt32($8741) then Result := 'PROGRAM_BINARY_LENGTH' else
      if self.val = UInt32($8916) then Result := 'GEOMETRY_VERTICES_OUT' else
      if self.val = UInt32($8917) then Result := 'GEOMETRY_INPUT_TYPE' else
      if self.val = UInt32($8918) then Result := 'GEOMETRY_OUTPUT_TYPE' else
      if self.val = UInt32($8A35) then Result := 'ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH' else
      if self.val = UInt32($8A36) then Result := 'ACTIVE_UNIFORM_BLOCKS' else
      if self.val = UInt32($8B80) then Result := 'DELETE_STATUS' else
      if self.val = UInt32($8B82) then Result := 'LINK_STATUS' else
      if self.val = UInt32($8B83) then Result := 'VALIDATE_STATUS' else
      if self.val = UInt32($8B84) then Result := 'INFO_LOG_LENGTH' else
      if self.val = UInt32($8B85) then Result := 'ATTACHED_SHADERS' else
      if self.val = UInt32($8B86) then Result := 'ACTIVE_UNIFORMS' else
      if self.val = UInt32($8B87) then Result := 'ACTIVE_UNIFORM_MAX_LENGTH' else
      if self.val = UInt32($8B89) then Result := 'ACTIVE_ATTRIBUTES' else
      if self.val = UInt32($8B8A) then Result := 'ACTIVE_ATTRIBUTE_MAX_LENGTH' else
      if self.val = UInt32($8C76) then Result := 'TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH' else
      if self.val = UInt32($8C7F) then Result := 'TRANSFORM_FEEDBACK_BUFFER_MODE' else
      if self.val = UInt32($8C83) then Result := 'TRANSFORM_FEEDBACK_VARYINGS' else
      if self.val = UInt32($92D9) then Result := 'ACTIVE_ATOMIC_COUNTER_BUFFERS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribPointerPropertyARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_ATTRIB_ARRAY_POINTER     := new VertexAttribPointerPropertyARB($8645);
    private static _VERTEX_ATTRIB_ARRAY_POINTER_ARB := new VertexAttribPointerPropertyARB($8645);
    
    public static property VERTEX_ATTRIB_ARRAY_POINTER:     VertexAttribPointerPropertyARB read _VERTEX_ATTRIB_ARRAY_POINTER;
    public static property VERTEX_ATTRIB_ARRAY_POINTER_ARB: VertexAttribPointerPropertyARB read _VERTEX_ATTRIB_ARRAY_POINTER_ARB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8645) then Result := 'VERTEX_ATTRIB_ARRAY_POINTER' else
      if self.val = UInt32($8645) then Result := 'VERTEX_ATTRIB_ARRAY_POINTER_ARB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribPropertyARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_ATTRIB_BINDING              := new VertexAttribPropertyARB($82D4);
    private static _VERTEX_ATTRIB_RELATIVE_OFFSET      := new VertexAttribPropertyARB($82D5);
    private static _VERTEX_ATTRIB_ARRAY_ENABLED        := new VertexAttribPropertyARB($8622);
    private static _VERTEX_ATTRIB_ARRAY_SIZE           := new VertexAttribPropertyARB($8623);
    private static _VERTEX_ATTRIB_ARRAY_STRIDE         := new VertexAttribPropertyARB($8624);
    private static _VERTEX_ATTRIB_ARRAY_TYPE           := new VertexAttribPropertyARB($8625);
    private static _CURRENT_VERTEX_ATTRIB              := new VertexAttribPropertyARB($8626);
    private static _VERTEX_ATTRIB_ARRAY_LONG           := new VertexAttribPropertyARB($874E);
    private static _VERTEX_ATTRIB_ARRAY_NORMALIZED     := new VertexAttribPropertyARB($886A);
    private static _VERTEX_ATTRIB_ARRAY_BUFFER_BINDING := new VertexAttribPropertyARB($889F);
    private static _VERTEX_ATTRIB_ARRAY_INTEGER        := new VertexAttribPropertyARB($88FD);
    private static _VERTEX_ATTRIB_ARRAY_INTEGER_EXT    := new VertexAttribPropertyARB($88FD);
    private static _VERTEX_ATTRIB_ARRAY_DIVISOR        := new VertexAttribPropertyARB($88FE);
    
    public static property VERTEX_ATTRIB_BINDING:              VertexAttribPropertyARB read _VERTEX_ATTRIB_BINDING;
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:      VertexAttribPropertyARB read _VERTEX_ATTRIB_RELATIVE_OFFSET;
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:        VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_ENABLED;
    public static property VERTEX_ATTRIB_ARRAY_SIZE:           VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_SIZE;
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:         VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_STRIDE;
    public static property VERTEX_ATTRIB_ARRAY_TYPE:           VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_TYPE;
    public static property CURRENT_VERTEX_ATTRIB:              VertexAttribPropertyARB read _CURRENT_VERTEX_ATTRIB;
    public static property VERTEX_ATTRIB_ARRAY_LONG:           VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_LONG;
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:     VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_NORMALIZED;
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:        VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_INTEGER;
    public static property VERTEX_ATTRIB_ARRAY_INTEGER_EXT:    VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_INTEGER_EXT;
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:        VertexAttribPropertyARB read _VERTEX_ATTRIB_ARRAY_DIVISOR;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($82D4) then Result := 'VERTEX_ATTRIB_BINDING' else
      if self.val = UInt32($82D5) then Result := 'VERTEX_ATTRIB_RELATIVE_OFFSET' else
      if self.val = UInt32($8622) then Result := 'VERTEX_ATTRIB_ARRAY_ENABLED' else
      if self.val = UInt32($8623) then Result := 'VERTEX_ATTRIB_ARRAY_SIZE' else
      if self.val = UInt32($8624) then Result := 'VERTEX_ATTRIB_ARRAY_STRIDE' else
      if self.val = UInt32($8625) then Result := 'VERTEX_ATTRIB_ARRAY_TYPE' else
      if self.val = UInt32($8626) then Result := 'CURRENT_VERTEX_ATTRIB' else
      if self.val = UInt32($874E) then Result := 'VERTEX_ATTRIB_ARRAY_LONG' else
      if self.val = UInt32($886A) then Result := 'VERTEX_ATTRIB_ARRAY_NORMALIZED' else
      if self.val = UInt32($889F) then Result := 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING' else
      if self.val = UInt32($88FD) then Result := 'VERTEX_ATTRIB_ARRAY_INTEGER' else
      if self.val = UInt32($88FD) then Result := 'VERTEX_ATTRIB_ARRAY_INTEGER_EXT' else
      if self.val = UInt32($88FE) then Result := 'VERTEX_ATTRIB_ARRAY_DIVISOR' else
        Result := self.val.ToString;
    end;
    
  end;
  
  WeightPointerTypeARB = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE           := new WeightPointerTypeARB($1400);
    private static _UNSIGNED_BYTE  := new WeightPointerTypeARB($1401);
    private static _SHORT          := new WeightPointerTypeARB($1402);
    private static _UNSIGNED_SHORT := new WeightPointerTypeARB($1403);
    private static _INT            := new WeightPointerTypeARB($1404);
    private static _UNSIGNED_INT   := new WeightPointerTypeARB($1405);
    private static _FLOAT          := new WeightPointerTypeARB($1406);
    private static _DOUBLE         := new WeightPointerTypeARB($140A);
    
    public static property BYTE:           WeightPointerTypeARB read _BYTE;
    public static property UNSIGNED_BYTE:  WeightPointerTypeARB read _UNSIGNED_BYTE;
    public static property SHORT:          WeightPointerTypeARB read _SHORT;
    public static property UNSIGNED_SHORT: WeightPointerTypeARB read _UNSIGNED_SHORT;
    public static property INT:            WeightPointerTypeARB read _INT;
    public static property UNSIGNED_INT:   WeightPointerTypeARB read _UNSIGNED_INT;
    public static property FLOAT:          WeightPointerTypeARB read _FLOAT;
    public static property DOUBLE:         WeightPointerTypeARB read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion ARB}
  
  {$region EXT}
  
  BinormalPointerTypeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE       := new BinormalPointerTypeEXT($1400);
    private static _SHORT      := new BinormalPointerTypeEXT($1402);
    private static _INT        := new BinormalPointerTypeEXT($1404);
    private static _FLOAT      := new BinormalPointerTypeEXT($1406);
    private static _DOUBLE     := new BinormalPointerTypeEXT($140A);
    private static _DOUBLE_EXT := new BinormalPointerTypeEXT($140A);
    
    public static property BYTE:       BinormalPointerTypeEXT read _BYTE;
    public static property SHORT:      BinormalPointerTypeEXT read _SHORT;
    public static property INT:        BinormalPointerTypeEXT read _INT;
    public static property FLOAT:      BinormalPointerTypeEXT read _FLOAT;
    public static property DOUBLE:     BinormalPointerTypeEXT read _DOUBLE;
    public static property DOUBLE_EXT: BinormalPointerTypeEXT read _DOUBLE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140A) then Result := 'DOUBLE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  BlendEquationModeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FUNC_ADD                  := new BlendEquationModeEXT($8006);
    private static _FUNC_ADD_EXT              := new BlendEquationModeEXT($8006);
    private static _MIN                       := new BlendEquationModeEXT($8007);
    private static _MIN_EXT                   := new BlendEquationModeEXT($8007);
    private static _MAX                       := new BlendEquationModeEXT($8008);
    private static _MAX_EXT                   := new BlendEquationModeEXT($8008);
    private static _FUNC_SUBTRACT             := new BlendEquationModeEXT($800A);
    private static _FUNC_SUBTRACT_EXT         := new BlendEquationModeEXT($800A);
    private static _FUNC_REVERSE_SUBTRACT     := new BlendEquationModeEXT($800B);
    private static _FUNC_REVERSE_SUBTRACT_EXT := new BlendEquationModeEXT($800B);
    private static _ALPHA_MIN_SGIX            := new BlendEquationModeEXT($8320);
    private static _ALPHA_MAX_SGIX            := new BlendEquationModeEXT($8321);
    
    public static property FUNC_ADD:                  BlendEquationModeEXT read _FUNC_ADD;
    public static property FUNC_ADD_EXT:              BlendEquationModeEXT read _FUNC_ADD_EXT;
    public static property MIN:                       BlendEquationModeEXT read _MIN;
    public static property MIN_EXT:                   BlendEquationModeEXT read _MIN_EXT;
    public static property MAX:                       BlendEquationModeEXT read _MAX;
    public static property MAX_EXT:                   BlendEquationModeEXT read _MAX_EXT;
    public static property FUNC_SUBTRACT:             BlendEquationModeEXT read _FUNC_SUBTRACT;
    public static property FUNC_SUBTRACT_EXT:         BlendEquationModeEXT read _FUNC_SUBTRACT_EXT;
    public static property FUNC_REVERSE_SUBTRACT:     BlendEquationModeEXT read _FUNC_REVERSE_SUBTRACT;
    public static property FUNC_REVERSE_SUBTRACT_EXT: BlendEquationModeEXT read _FUNC_REVERSE_SUBTRACT_EXT;
    public static property ALPHA_MIN_SGIX:            BlendEquationModeEXT read _ALPHA_MIN_SGIX;
    public static property ALPHA_MAX_SGIX:            BlendEquationModeEXT read _ALPHA_MAX_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8006) then Result := 'FUNC_ADD' else
      if self.val = UInt32($8006) then Result := 'FUNC_ADD_EXT' else
      if self.val = UInt32($8007) then Result := 'MIN' else
      if self.val = UInt32($8007) then Result := 'MIN_EXT' else
      if self.val = UInt32($8008) then Result := 'MAX' else
      if self.val = UInt32($8008) then Result := 'MAX_EXT' else
      if self.val = UInt32($800A) then Result := 'FUNC_SUBTRACT' else
      if self.val = UInt32($800A) then Result := 'FUNC_SUBTRACT_EXT' else
      if self.val = UInt32($800B) then Result := 'FUNC_REVERSE_SUBTRACT' else
      if self.val = UInt32($800B) then Result := 'FUNC_REVERSE_SUBTRACT_EXT' else
      if self.val = UInt32($8320) then Result := 'ALPHA_MIN_SGIX' else
      if self.val = UInt32($8321) then Result := 'ALPHA_MAX_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ConvolutionParameterEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CONVOLUTION_BORDER_MODE      := new ConvolutionParameterEXT($8013);
    private static _CONVOLUTION_BORDER_MODE_EXT  := new ConvolutionParameterEXT($8013);
    private static _CONVOLUTION_FILTER_SCALE     := new ConvolutionParameterEXT($8014);
    private static _CONVOLUTION_FILTER_SCALE_EXT := new ConvolutionParameterEXT($8014);
    private static _CONVOLUTION_FILTER_BIAS      := new ConvolutionParameterEXT($8015);
    private static _CONVOLUTION_FILTER_BIAS_EXT  := new ConvolutionParameterEXT($8015);
    
    public static property CONVOLUTION_BORDER_MODE:      ConvolutionParameterEXT read _CONVOLUTION_BORDER_MODE;
    public static property CONVOLUTION_BORDER_MODE_EXT:  ConvolutionParameterEXT read _CONVOLUTION_BORDER_MODE_EXT;
    public static property CONVOLUTION_FILTER_SCALE:     ConvolutionParameterEXT read _CONVOLUTION_FILTER_SCALE;
    public static property CONVOLUTION_FILTER_SCALE_EXT: ConvolutionParameterEXT read _CONVOLUTION_FILTER_SCALE_EXT;
    public static property CONVOLUTION_FILTER_BIAS:      ConvolutionParameterEXT read _CONVOLUTION_FILTER_BIAS;
    public static property CONVOLUTION_FILTER_BIAS_EXT:  ConvolutionParameterEXT read _CONVOLUTION_FILTER_BIAS_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8013) then Result := 'CONVOLUTION_BORDER_MODE' else
      if self.val = UInt32($8013) then Result := 'CONVOLUTION_BORDER_MODE_EXT' else
      if self.val = UInt32($8014) then Result := 'CONVOLUTION_FILTER_SCALE' else
      if self.val = UInt32($8014) then Result := 'CONVOLUTION_FILTER_SCALE_EXT' else
      if self.val = UInt32($8015) then Result := 'CONVOLUTION_FILTER_BIAS' else
      if self.val = UInt32($8015) then Result := 'CONVOLUTION_FILTER_BIAS_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ConvolutionTargetEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CONVOLUTION_1D     := new ConvolutionTargetEXT($8010);
    private static _CONVOLUTION_1D_EXT := new ConvolutionTargetEXT($8010);
    private static _CONVOLUTION_2D     := new ConvolutionTargetEXT($8011);
    private static _CONVOLUTION_2D_EXT := new ConvolutionTargetEXT($8011);
    
    public static property CONVOLUTION_1D:     ConvolutionTargetEXT read _CONVOLUTION_1D;
    public static property CONVOLUTION_1D_EXT: ConvolutionTargetEXT read _CONVOLUTION_1D_EXT;
    public static property CONVOLUTION_2D:     ConvolutionTargetEXT read _CONVOLUTION_2D;
    public static property CONVOLUTION_2D_EXT: ConvolutionTargetEXT read _CONVOLUTION_2D_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D' else
      if self.val = UInt32($8010) then Result := 'CONVOLUTION_1D_EXT' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D' else
      if self.val = UInt32($8011) then Result := 'CONVOLUTION_2D_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CullParameterEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CULL_VERTEX_EYE_POSITION_EXT    := new CullParameterEXT($81AB);
    private static _CULL_VERTEX_OBJECT_POSITION_EXT := new CullParameterEXT($81AC);
    
    public static property CULL_VERTEX_EYE_POSITION_EXT:    CullParameterEXT read _CULL_VERTEX_EYE_POSITION_EXT;
    public static property CULL_VERTEX_OBJECT_POSITION_EXT: CullParameterEXT read _CULL_VERTEX_OBJECT_POSITION_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($81AB) then Result := 'CULL_VERTEX_EYE_POSITION_EXT' else
      if self.val = UInt32($81AC) then Result := 'CULL_VERTEX_OBJECT_POSITION_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  DataTypeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SCALAR_EXT := new DataTypeEXT($87BE);
    private static _VECTOR_EXT := new DataTypeEXT($87BF);
    private static _MATRIX_EXT := new DataTypeEXT($87C0);
    
    public static property SCALAR_EXT: DataTypeEXT read _SCALAR_EXT;
    public static property VECTOR_EXT: DataTypeEXT read _VECTOR_EXT;
    public static property MATRIX_EXT: DataTypeEXT read _MATRIX_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87BE) then Result := 'SCALAR_EXT' else
      if self.val = UInt32($87BF) then Result := 'VECTOR_EXT' else
      if self.val = UInt32($87C0) then Result := 'MATRIX_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FogPointerTypeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FLOAT  := new FogPointerTypeEXT($1406);
    private static _DOUBLE := new FogPointerTypeEXT($140A);
    
    public static property FLOAT:  FogPointerTypeEXT read _FLOAT;
    public static property DOUBLE: FogPointerTypeEXT read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetHistogramParameterPNameEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _HISTOGRAM_WIDTH              := new GetHistogramParameterPNameEXT($8026);
    private static _HISTOGRAM_WIDTH_EXT          := new GetHistogramParameterPNameEXT($8026);
    private static _HISTOGRAM_FORMAT             := new GetHistogramParameterPNameEXT($8027);
    private static _HISTOGRAM_FORMAT_EXT         := new GetHistogramParameterPNameEXT($8027);
    private static _HISTOGRAM_RED_SIZE           := new GetHistogramParameterPNameEXT($8028);
    private static _HISTOGRAM_RED_SIZE_EXT       := new GetHistogramParameterPNameEXT($8028);
    private static _HISTOGRAM_GREEN_SIZE         := new GetHistogramParameterPNameEXT($8029);
    private static _HISTOGRAM_GREEN_SIZE_EXT     := new GetHistogramParameterPNameEXT($8029);
    private static _HISTOGRAM_BLUE_SIZE          := new GetHistogramParameterPNameEXT($802A);
    private static _HISTOGRAM_BLUE_SIZE_EXT      := new GetHistogramParameterPNameEXT($802A);
    private static _HISTOGRAM_ALPHA_SIZE         := new GetHistogramParameterPNameEXT($802B);
    private static _HISTOGRAM_ALPHA_SIZE_EXT     := new GetHistogramParameterPNameEXT($802B);
    private static _HISTOGRAM_LUMINANCE_SIZE     := new GetHistogramParameterPNameEXT($802C);
    private static _HISTOGRAM_LUMINANCE_SIZE_EXT := new GetHistogramParameterPNameEXT($802C);
    private static _HISTOGRAM_SINK               := new GetHistogramParameterPNameEXT($802D);
    private static _HISTOGRAM_SINK_EXT           := new GetHistogramParameterPNameEXT($802D);
    
    public static property HISTOGRAM_WIDTH:              GetHistogramParameterPNameEXT read _HISTOGRAM_WIDTH;
    public static property HISTOGRAM_WIDTH_EXT:          GetHistogramParameterPNameEXT read _HISTOGRAM_WIDTH_EXT;
    public static property HISTOGRAM_FORMAT:             GetHistogramParameterPNameEXT read _HISTOGRAM_FORMAT;
    public static property HISTOGRAM_FORMAT_EXT:         GetHistogramParameterPNameEXT read _HISTOGRAM_FORMAT_EXT;
    public static property HISTOGRAM_RED_SIZE:           GetHistogramParameterPNameEXT read _HISTOGRAM_RED_SIZE;
    public static property HISTOGRAM_RED_SIZE_EXT:       GetHistogramParameterPNameEXT read _HISTOGRAM_RED_SIZE_EXT;
    public static property HISTOGRAM_GREEN_SIZE:         GetHistogramParameterPNameEXT read _HISTOGRAM_GREEN_SIZE;
    public static property HISTOGRAM_GREEN_SIZE_EXT:     GetHistogramParameterPNameEXT read _HISTOGRAM_GREEN_SIZE_EXT;
    public static property HISTOGRAM_BLUE_SIZE:          GetHistogramParameterPNameEXT read _HISTOGRAM_BLUE_SIZE;
    public static property HISTOGRAM_BLUE_SIZE_EXT:      GetHistogramParameterPNameEXT read _HISTOGRAM_BLUE_SIZE_EXT;
    public static property HISTOGRAM_ALPHA_SIZE:         GetHistogramParameterPNameEXT read _HISTOGRAM_ALPHA_SIZE;
    public static property HISTOGRAM_ALPHA_SIZE_EXT:     GetHistogramParameterPNameEXT read _HISTOGRAM_ALPHA_SIZE_EXT;
    public static property HISTOGRAM_LUMINANCE_SIZE:     GetHistogramParameterPNameEXT read _HISTOGRAM_LUMINANCE_SIZE;
    public static property HISTOGRAM_LUMINANCE_SIZE_EXT: GetHistogramParameterPNameEXT read _HISTOGRAM_LUMINANCE_SIZE_EXT;
    public static property HISTOGRAM_SINK:               GetHistogramParameterPNameEXT read _HISTOGRAM_SINK;
    public static property HISTOGRAM_SINK_EXT:           GetHistogramParameterPNameEXT read _HISTOGRAM_SINK_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8026) then Result := 'HISTOGRAM_WIDTH' else
      if self.val = UInt32($8026) then Result := 'HISTOGRAM_WIDTH_EXT' else
      if self.val = UInt32($8027) then Result := 'HISTOGRAM_FORMAT' else
      if self.val = UInt32($8027) then Result := 'HISTOGRAM_FORMAT_EXT' else
      if self.val = UInt32($8028) then Result := 'HISTOGRAM_RED_SIZE' else
      if self.val = UInt32($8028) then Result := 'HISTOGRAM_RED_SIZE_EXT' else
      if self.val = UInt32($8029) then Result := 'HISTOGRAM_GREEN_SIZE' else
      if self.val = UInt32($8029) then Result := 'HISTOGRAM_GREEN_SIZE_EXT' else
      if self.val = UInt32($802A) then Result := 'HISTOGRAM_BLUE_SIZE' else
      if self.val = UInt32($802A) then Result := 'HISTOGRAM_BLUE_SIZE_EXT' else
      if self.val = UInt32($802B) then Result := 'HISTOGRAM_ALPHA_SIZE' else
      if self.val = UInt32($802B) then Result := 'HISTOGRAM_ALPHA_SIZE_EXT' else
      if self.val = UInt32($802C) then Result := 'HISTOGRAM_LUMINANCE_SIZE' else
      if self.val = UInt32($802C) then Result := 'HISTOGRAM_LUMINANCE_SIZE_EXT' else
      if self.val = UInt32($802D) then Result := 'HISTOGRAM_SINK' else
      if self.val = UInt32($802D) then Result := 'HISTOGRAM_SINK_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetMinmaxParameterPNameEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MINMAX_FORMAT     := new GetMinmaxParameterPNameEXT($802F);
    private static _MINMAX_FORMAT_EXT := new GetMinmaxParameterPNameEXT($802F);
    private static _MINMAX_SINK       := new GetMinmaxParameterPNameEXT($8030);
    private static _MINMAX_SINK_EXT   := new GetMinmaxParameterPNameEXT($8030);
    
    public static property MINMAX_FORMAT:     GetMinmaxParameterPNameEXT read _MINMAX_FORMAT;
    public static property MINMAX_FORMAT_EXT: GetMinmaxParameterPNameEXT read _MINMAX_FORMAT_EXT;
    public static property MINMAX_SINK:       GetMinmaxParameterPNameEXT read _MINMAX_SINK;
    public static property MINMAX_SINK_EXT:   GetMinmaxParameterPNameEXT read _MINMAX_SINK_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($802F) then Result := 'MINMAX_FORMAT' else
      if self.val = UInt32($802F) then Result := 'MINMAX_FORMAT_EXT' else
      if self.val = UInt32($8030) then Result := 'MINMAX_SINK' else
      if self.val = UInt32($8030) then Result := 'MINMAX_SINK_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetVariantValueEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VARIANT_VALUE_EXT        := new GetVariantValueEXT($87E4);
    private static _VARIANT_DATATYPE_EXT     := new GetVariantValueEXT($87E5);
    private static _VARIANT_ARRAY_STRIDE_EXT := new GetVariantValueEXT($87E6);
    private static _VARIANT_ARRAY_TYPE_EXT   := new GetVariantValueEXT($87E7);
    
    public static property VARIANT_VALUE_EXT:        GetVariantValueEXT read _VARIANT_VALUE_EXT;
    public static property VARIANT_DATATYPE_EXT:     GetVariantValueEXT read _VARIANT_DATATYPE_EXT;
    public static property VARIANT_ARRAY_STRIDE_EXT: GetVariantValueEXT read _VARIANT_ARRAY_STRIDE_EXT;
    public static property VARIANT_ARRAY_TYPE_EXT:   GetVariantValueEXT read _VARIANT_ARRAY_TYPE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E4) then Result := 'VARIANT_VALUE_EXT' else
      if self.val = UInt32($87E5) then Result := 'VARIANT_DATATYPE_EXT' else
      if self.val = UInt32($87E6) then Result := 'VARIANT_ARRAY_STRIDE_EXT' else
      if self.val = UInt32($87E7) then Result := 'VARIANT_ARRAY_TYPE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  HistogramTargetEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _HISTOGRAM           := new HistogramTargetEXT($8024);
    private static _HISTOGRAM_EXT       := new HistogramTargetEXT($8024);
    private static _PROXY_HISTOGRAM     := new HistogramTargetEXT($8025);
    private static _PROXY_HISTOGRAM_EXT := new HistogramTargetEXT($8025);
    
    public static property HISTOGRAM:           HistogramTargetEXT read _HISTOGRAM;
    public static property HISTOGRAM_EXT:       HistogramTargetEXT read _HISTOGRAM_EXT;
    public static property PROXY_HISTOGRAM:     HistogramTargetEXT read _PROXY_HISTOGRAM;
    public static property PROXY_HISTOGRAM_EXT: HistogramTargetEXT read _PROXY_HISTOGRAM_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8024) then Result := 'HISTOGRAM' else
      if self.val = UInt32($8024) then Result := 'HISTOGRAM_EXT' else
      if self.val = UInt32($8025) then Result := 'PROXY_HISTOGRAM' else
      if self.val = UInt32($8025) then Result := 'PROXY_HISTOGRAM_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  IndexFunctionEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NEVER    := new IndexFunctionEXT($0200);
    private static _LESS     := new IndexFunctionEXT($0201);
    private static _EQUAL    := new IndexFunctionEXT($0202);
    private static _LEQUAL   := new IndexFunctionEXT($0203);
    private static _GREATER  := new IndexFunctionEXT($0204);
    private static _NOTEQUAL := new IndexFunctionEXT($0205);
    private static _GEQUAL   := new IndexFunctionEXT($0206);
    private static _ALWAYS   := new IndexFunctionEXT($0207);
    
    public static property NEVER:    IndexFunctionEXT read _NEVER;
    public static property LESS:     IndexFunctionEXT read _LESS;
    public static property EQUAL:    IndexFunctionEXT read _EQUAL;
    public static property LEQUAL:   IndexFunctionEXT read _LEQUAL;
    public static property GREATER:  IndexFunctionEXT read _GREATER;
    public static property NOTEQUAL: IndexFunctionEXT read _NOTEQUAL;
    public static property GEQUAL:   IndexFunctionEXT read _GEQUAL;
    public static property ALWAYS:   IndexFunctionEXT read _ALWAYS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0200) then Result := 'NEVER' else
      if self.val = UInt32($0201) then Result := 'LESS' else
      if self.val = UInt32($0202) then Result := 'EQUAL' else
      if self.val = UInt32($0203) then Result := 'LEQUAL' else
      if self.val = UInt32($0204) then Result := 'GREATER' else
      if self.val = UInt32($0205) then Result := 'NOTEQUAL' else
      if self.val = UInt32($0206) then Result := 'GEQUAL' else
      if self.val = UInt32($0207) then Result := 'ALWAYS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  IndexMaterialParameterEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _INDEX_OFFSET := new IndexMaterialParameterEXT($0D13);
    
    public static property INDEX_OFFSET: IndexMaterialParameterEXT read _INDEX_OFFSET;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0D13) then Result := 'INDEX_OFFSET' else
        Result := self.val.ToString;
    end;
    
  end;
  
  LightTextureModeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRAGMENT_MATERIAL_EXT := new LightTextureModeEXT($8349);
    private static _FRAGMENT_NORMAL_EXT   := new LightTextureModeEXT($834A);
    private static _FRAGMENT_COLOR_EXT    := new LightTextureModeEXT($834C);
    private static _FRAGMENT_DEPTH_EXT    := new LightTextureModeEXT($8452);
    
    public static property FRAGMENT_MATERIAL_EXT: LightTextureModeEXT read _FRAGMENT_MATERIAL_EXT;
    public static property FRAGMENT_NORMAL_EXT:   LightTextureModeEXT read _FRAGMENT_NORMAL_EXT;
    public static property FRAGMENT_COLOR_EXT:    LightTextureModeEXT read _FRAGMENT_COLOR_EXT;
    public static property FRAGMENT_DEPTH_EXT:    LightTextureModeEXT read _FRAGMENT_DEPTH_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8349) then Result := 'FRAGMENT_MATERIAL_EXT' else
      if self.val = UInt32($834A) then Result := 'FRAGMENT_NORMAL_EXT' else
      if self.val = UInt32($834C) then Result := 'FRAGMENT_COLOR_EXT' else
      if self.val = UInt32($8452) then Result := 'FRAGMENT_DEPTH_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  LightTexturePNameEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ATTENUATION_EXT        := new LightTexturePNameEXT($834D);
    private static _SHADOW_ATTENUATION_EXT := new LightTexturePNameEXT($834E);
    
    public static property ATTENUATION_EXT:        LightTexturePNameEXT read _ATTENUATION_EXT;
    public static property SHADOW_ATTENUATION_EXT: LightTexturePNameEXT read _SHADOW_ATTENUATION_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($834D) then Result := 'ATTENUATION_EXT' else
      if self.val = UInt32($834E) then Result := 'SHADOW_ATTENUATION_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MinmaxTargetEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MINMAX     := new MinmaxTargetEXT($802E);
    private static _MINMAX_EXT := new MinmaxTargetEXT($802E);
    
    public static property MINMAX:     MinmaxTargetEXT read _MINMAX;
    public static property MINMAX_EXT: MinmaxTargetEXT read _MINMAX_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($802E) then Result := 'MINMAX' else
      if self.val = UInt32($802E) then Result := 'MINMAX_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ParameterRangeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NORMALIZED_RANGE_EXT := new ParameterRangeEXT($87E0);
    private static _FULL_RANGE_EXT       := new ParameterRangeEXT($87E1);
    
    public static property NORMALIZED_RANGE_EXT: ParameterRangeEXT read _NORMALIZED_RANGE_EXT;
    public static property FULL_RANGE_EXT:       ParameterRangeEXT read _FULL_RANGE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E0) then Result := 'NORMALIZED_RANGE_EXT' else
      if self.val = UInt32($87E1) then Result := 'FULL_RANGE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelTransformPNameEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PIXEL_MAG_FILTER_EXT   := new PixelTransformPNameEXT($8331);
    private static _PIXEL_MIN_FILTER_EXT   := new PixelTransformPNameEXT($8332);
    private static _PIXEL_CUBIC_WEIGHT_EXT := new PixelTransformPNameEXT($8333);
    
    public static property PIXEL_MAG_FILTER_EXT:   PixelTransformPNameEXT read _PIXEL_MAG_FILTER_EXT;
    public static property PIXEL_MIN_FILTER_EXT:   PixelTransformPNameEXT read _PIXEL_MIN_FILTER_EXT;
    public static property PIXEL_CUBIC_WEIGHT_EXT: PixelTransformPNameEXT read _PIXEL_CUBIC_WEIGHT_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8331) then Result := 'PIXEL_MAG_FILTER_EXT' else
      if self.val = UInt32($8332) then Result := 'PIXEL_MIN_FILTER_EXT' else
      if self.val = UInt32($8333) then Result := 'PIXEL_CUBIC_WEIGHT_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelTransformTargetEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PIXEL_TRANSFORM_2D_EXT := new PixelTransformTargetEXT($8330);
    
    public static property PIXEL_TRANSFORM_2D_EXT: PixelTransformTargetEXT read _PIXEL_TRANSFORM_2D_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8330) then Result := 'PIXEL_TRANSFORM_2D_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SamplePatternEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _GL_1PASS_EXT   := new SamplePatternEXT($80A1);
    private static _GL_2PASS_0_EXT := new SamplePatternEXT($80A2);
    private static _GL_2PASS_1_EXT := new SamplePatternEXT($80A3);
    private static _GL_4PASS_0_EXT := new SamplePatternEXT($80A4);
    private static _GL_4PASS_1_EXT := new SamplePatternEXT($80A5);
    private static _GL_4PASS_2_EXT := new SamplePatternEXT($80A6);
    private static _GL_4PASS_3_EXT := new SamplePatternEXT($80A7);
    
    public static property GL_1PASS_EXT:   SamplePatternEXT read _GL_1PASS_EXT;
    public static property GL_2PASS_0_EXT: SamplePatternEXT read _GL_2PASS_0_EXT;
    public static property GL_2PASS_1_EXT: SamplePatternEXT read _GL_2PASS_1_EXT;
    public static property GL_4PASS_0_EXT: SamplePatternEXT read _GL_4PASS_0_EXT;
    public static property GL_4PASS_1_EXT: SamplePatternEXT read _GL_4PASS_1_EXT;
    public static property GL_4PASS_2_EXT: SamplePatternEXT read _GL_4PASS_2_EXT;
    public static property GL_4PASS_3_EXT: SamplePatternEXT read _GL_4PASS_3_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80A1) then Result := 'GL_1PASS_EXT' else
      if self.val = UInt32($80A2) then Result := 'GL_2PASS_0_EXT' else
      if self.val = UInt32($80A3) then Result := 'GL_2PASS_1_EXT' else
      if self.val = UInt32($80A4) then Result := 'GL_4PASS_0_EXT' else
      if self.val = UInt32($80A5) then Result := 'GL_4PASS_1_EXT' else
      if self.val = UInt32($80A6) then Result := 'GL_4PASS_2_EXT' else
      if self.val = UInt32($80A7) then Result := 'GL_4PASS_3_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SeparableTargetEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SEPARABLE_2D     := new SeparableTargetEXT($8012);
    private static _SEPARABLE_2D_EXT := new SeparableTargetEXT($8012);
    
    public static property SEPARABLE_2D:     SeparableTargetEXT read _SEPARABLE_2D;
    public static property SEPARABLE_2D_EXT: SeparableTargetEXT read _SEPARABLE_2D_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8012) then Result := 'SEPARABLE_2D' else
      if self.val = UInt32($8012) then Result := 'SEPARABLE_2D_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TangentPointerTypeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BYTE       := new TangentPointerTypeEXT($1400);
    private static _SHORT      := new TangentPointerTypeEXT($1402);
    private static _INT        := new TangentPointerTypeEXT($1404);
    private static _FLOAT      := new TangentPointerTypeEXT($1406);
    private static _DOUBLE     := new TangentPointerTypeEXT($140A);
    private static _DOUBLE_EXT := new TangentPointerTypeEXT($140A);
    
    public static property BYTE:       TangentPointerTypeEXT read _BYTE;
    public static property SHORT:      TangentPointerTypeEXT read _SHORT;
    public static property INT:        TangentPointerTypeEXT read _INT;
    public static property FLOAT:      TangentPointerTypeEXT read _FLOAT;
    public static property DOUBLE:     TangentPointerTypeEXT read _DOUBLE;
    public static property DOUBLE_EXT: TangentPointerTypeEXT read _DOUBLE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1400) then Result := 'BYTE' else
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
      if self.val = UInt32($140A) then Result := 'DOUBLE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureNormalModeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PERTURB_EXT := new TextureNormalModeEXT($85AE);
    
    public static property PERTURB_EXT: TextureNormalModeEXT read _PERTURB_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($85AE) then Result := 'PERTURB_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VariantCapEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VARIANT_ARRAY_EXT := new VariantCapEXT($87E8);
    
    public static property VARIANT_ARRAY_EXT: VariantCapEXT read _VARIANT_ARRAY_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E8) then Result := 'VARIANT_ARRAY_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexShaderCoordOutEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _X_EXT            := new VertexShaderCoordOutEXT($87D5);
    private static _Y_EXT            := new VertexShaderCoordOutEXT($87D6);
    private static _Z_EXT            := new VertexShaderCoordOutEXT($87D7);
    private static _W_EXT            := new VertexShaderCoordOutEXT($87D8);
    private static _NEGATIVE_X_EXT   := new VertexShaderCoordOutEXT($87D9);
    private static _NEGATIVE_Y_EXT   := new VertexShaderCoordOutEXT($87DA);
    private static _NEGATIVE_Z_EXT   := new VertexShaderCoordOutEXT($87DB);
    private static _NEGATIVE_W_EXT   := new VertexShaderCoordOutEXT($87DC);
    private static _ZERO_EXT         := new VertexShaderCoordOutEXT($87DD);
    private static _ONE_EXT          := new VertexShaderCoordOutEXT($87DE);
    private static _NEGATIVE_ONE_EXT := new VertexShaderCoordOutEXT($87DF);
    
    public static property X_EXT:            VertexShaderCoordOutEXT read _X_EXT;
    public static property Y_EXT:            VertexShaderCoordOutEXT read _Y_EXT;
    public static property Z_EXT:            VertexShaderCoordOutEXT read _Z_EXT;
    public static property W_EXT:            VertexShaderCoordOutEXT read _W_EXT;
    public static property NEGATIVE_X_EXT:   VertexShaderCoordOutEXT read _NEGATIVE_X_EXT;
    public static property NEGATIVE_Y_EXT:   VertexShaderCoordOutEXT read _NEGATIVE_Y_EXT;
    public static property NEGATIVE_Z_EXT:   VertexShaderCoordOutEXT read _NEGATIVE_Z_EXT;
    public static property NEGATIVE_W_EXT:   VertexShaderCoordOutEXT read _NEGATIVE_W_EXT;
    public static property ZERO_EXT:         VertexShaderCoordOutEXT read _ZERO_EXT;
    public static property ONE_EXT:          VertexShaderCoordOutEXT read _ONE_EXT;
    public static property NEGATIVE_ONE_EXT: VertexShaderCoordOutEXT read _NEGATIVE_ONE_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87D5) then Result := 'X_EXT' else
      if self.val = UInt32($87D6) then Result := 'Y_EXT' else
      if self.val = UInt32($87D7) then Result := 'Z_EXT' else
      if self.val = UInt32($87D8) then Result := 'W_EXT' else
      if self.val = UInt32($87D9) then Result := 'NEGATIVE_X_EXT' else
      if self.val = UInt32($87DA) then Result := 'NEGATIVE_Y_EXT' else
      if self.val = UInt32($87DB) then Result := 'NEGATIVE_Z_EXT' else
      if self.val = UInt32($87DC) then Result := 'NEGATIVE_W_EXT' else
      if self.val = UInt32($87DD) then Result := 'ZERO_EXT' else
      if self.val = UInt32($87DE) then Result := 'ONE_EXT' else
      if self.val = UInt32($87DF) then Result := 'NEGATIVE_ONE_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexShaderOpEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _OP_INDEX_EXT           := new VertexShaderOpEXT($8782);
    private static _OP_NEGATE_EXT          := new VertexShaderOpEXT($8783);
    private static _OP_DOT3_EXT            := new VertexShaderOpEXT($8784);
    private static _OP_DOT4_EXT            := new VertexShaderOpEXT($8785);
    private static _OP_MUL_EXT             := new VertexShaderOpEXT($8786);
    private static _OP_ADD_EXT             := new VertexShaderOpEXT($8787);
    private static _OP_MADD_EXT            := new VertexShaderOpEXT($8788);
    private static _OP_FRAC_EXT            := new VertexShaderOpEXT($8789);
    private static _OP_MAX_EXT             := new VertexShaderOpEXT($878A);
    private static _OP_MIN_EXT             := new VertexShaderOpEXT($878B);
    private static _OP_SET_GE_EXT          := new VertexShaderOpEXT($878C);
    private static _OP_SET_LT_EXT          := new VertexShaderOpEXT($878D);
    private static _OP_CLAMP_EXT           := new VertexShaderOpEXT($878E);
    private static _OP_FLOOR_EXT           := new VertexShaderOpEXT($878F);
    private static _OP_ROUND_EXT           := new VertexShaderOpEXT($8790);
    private static _OP_EXP_BASE_2_EXT      := new VertexShaderOpEXT($8791);
    private static _OP_LOG_BASE_2_EXT      := new VertexShaderOpEXT($8792);
    private static _OP_POWER_EXT           := new VertexShaderOpEXT($8793);
    private static _OP_RECIP_EXT           := new VertexShaderOpEXT($8794);
    private static _OP_RECIP_SQRT_EXT      := new VertexShaderOpEXT($8795);
    private static _OP_SUB_EXT             := new VertexShaderOpEXT($8796);
    private static _OP_CROSS_PRODUCT_EXT   := new VertexShaderOpEXT($8797);
    private static _OP_MULTIPLY_MATRIX_EXT := new VertexShaderOpEXT($8798);
    private static _OP_MOV_EXT             := new VertexShaderOpEXT($8799);
    
    public static property OP_INDEX_EXT:           VertexShaderOpEXT read _OP_INDEX_EXT;
    public static property OP_NEGATE_EXT:          VertexShaderOpEXT read _OP_NEGATE_EXT;
    public static property OP_DOT3_EXT:            VertexShaderOpEXT read _OP_DOT3_EXT;
    public static property OP_DOT4_EXT:            VertexShaderOpEXT read _OP_DOT4_EXT;
    public static property OP_MUL_EXT:             VertexShaderOpEXT read _OP_MUL_EXT;
    public static property OP_ADD_EXT:             VertexShaderOpEXT read _OP_ADD_EXT;
    public static property OP_MADD_EXT:            VertexShaderOpEXT read _OP_MADD_EXT;
    public static property OP_FRAC_EXT:            VertexShaderOpEXT read _OP_FRAC_EXT;
    public static property OP_MAX_EXT:             VertexShaderOpEXT read _OP_MAX_EXT;
    public static property OP_MIN_EXT:             VertexShaderOpEXT read _OP_MIN_EXT;
    public static property OP_SET_GE_EXT:          VertexShaderOpEXT read _OP_SET_GE_EXT;
    public static property OP_SET_LT_EXT:          VertexShaderOpEXT read _OP_SET_LT_EXT;
    public static property OP_CLAMP_EXT:           VertexShaderOpEXT read _OP_CLAMP_EXT;
    public static property OP_FLOOR_EXT:           VertexShaderOpEXT read _OP_FLOOR_EXT;
    public static property OP_ROUND_EXT:           VertexShaderOpEXT read _OP_ROUND_EXT;
    public static property OP_EXP_BASE_2_EXT:      VertexShaderOpEXT read _OP_EXP_BASE_2_EXT;
    public static property OP_LOG_BASE_2_EXT:      VertexShaderOpEXT read _OP_LOG_BASE_2_EXT;
    public static property OP_POWER_EXT:           VertexShaderOpEXT read _OP_POWER_EXT;
    public static property OP_RECIP_EXT:           VertexShaderOpEXT read _OP_RECIP_EXT;
    public static property OP_RECIP_SQRT_EXT:      VertexShaderOpEXT read _OP_RECIP_SQRT_EXT;
    public static property OP_SUB_EXT:             VertexShaderOpEXT read _OP_SUB_EXT;
    public static property OP_CROSS_PRODUCT_EXT:   VertexShaderOpEXT read _OP_CROSS_PRODUCT_EXT;
    public static property OP_MULTIPLY_MATRIX_EXT: VertexShaderOpEXT read _OP_MULTIPLY_MATRIX_EXT;
    public static property OP_MOV_EXT:             VertexShaderOpEXT read _OP_MOV_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8782) then Result := 'OP_INDEX_EXT' else
      if self.val = UInt32($8783) then Result := 'OP_NEGATE_EXT' else
      if self.val = UInt32($8784) then Result := 'OP_DOT3_EXT' else
      if self.val = UInt32($8785) then Result := 'OP_DOT4_EXT' else
      if self.val = UInt32($8786) then Result := 'OP_MUL_EXT' else
      if self.val = UInt32($8787) then Result := 'OP_ADD_EXT' else
      if self.val = UInt32($8788) then Result := 'OP_MADD_EXT' else
      if self.val = UInt32($8789) then Result := 'OP_FRAC_EXT' else
      if self.val = UInt32($878A) then Result := 'OP_MAX_EXT' else
      if self.val = UInt32($878B) then Result := 'OP_MIN_EXT' else
      if self.val = UInt32($878C) then Result := 'OP_SET_GE_EXT' else
      if self.val = UInt32($878D) then Result := 'OP_SET_LT_EXT' else
      if self.val = UInt32($878E) then Result := 'OP_CLAMP_EXT' else
      if self.val = UInt32($878F) then Result := 'OP_FLOOR_EXT' else
      if self.val = UInt32($8790) then Result := 'OP_ROUND_EXT' else
      if self.val = UInt32($8791) then Result := 'OP_EXP_BASE_2_EXT' else
      if self.val = UInt32($8792) then Result := 'OP_LOG_BASE_2_EXT' else
      if self.val = UInt32($8793) then Result := 'OP_POWER_EXT' else
      if self.val = UInt32($8794) then Result := 'OP_RECIP_EXT' else
      if self.val = UInt32($8795) then Result := 'OP_RECIP_SQRT_EXT' else
      if self.val = UInt32($8796) then Result := 'OP_SUB_EXT' else
      if self.val = UInt32($8797) then Result := 'OP_CROSS_PRODUCT_EXT' else
      if self.val = UInt32($8798) then Result := 'OP_MULTIPLY_MATRIX_EXT' else
      if self.val = UInt32($8799) then Result := 'OP_MOV_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexShaderParameterEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _CURRENT_VERTEX_EXT := new VertexShaderParameterEXT($87E2);
    private static _MVP_MATRIX_EXT     := new VertexShaderParameterEXT($87E3);
    
    public static property CURRENT_VERTEX_EXT: VertexShaderParameterEXT read _CURRENT_VERTEX_EXT;
    public static property MVP_MATRIX_EXT:     VertexShaderParameterEXT read _MVP_MATRIX_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87E2) then Result := 'CURRENT_VERTEX_EXT' else
      if self.val = UInt32($87E3) then Result := 'MVP_MATRIX_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexShaderStorageTypeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VARIANT_EXT        := new VertexShaderStorageTypeEXT($87C1);
    private static _INVARIANT_EXT      := new VertexShaderStorageTypeEXT($87C2);
    private static _LOCAL_CONSTANT_EXT := new VertexShaderStorageTypeEXT($87C3);
    private static _LOCAL_EXT          := new VertexShaderStorageTypeEXT($87C4);
    
    public static property VARIANT_EXT:        VertexShaderStorageTypeEXT read _VARIANT_EXT;
    public static property INVARIANT_EXT:      VertexShaderStorageTypeEXT read _INVARIANT_EXT;
    public static property LOCAL_CONSTANT_EXT: VertexShaderStorageTypeEXT read _LOCAL_CONSTANT_EXT;
    public static property LOCAL_EXT:          VertexShaderStorageTypeEXT read _LOCAL_EXT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87C1) then Result := 'VARIANT_EXT' else
      if self.val = UInt32($87C2) then Result := 'INVARIANT_EXT' else
      if self.val = UInt32($87C3) then Result := 'LOCAL_CONSTANT_EXT' else
      if self.val = UInt32($87C4) then Result := 'LOCAL_EXT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexShaderWriteMaskEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FALSE := new VertexShaderWriteMaskEXT($0000);
    private static _TRUE  := new VertexShaderWriteMaskEXT($0001);
    
    public static property FALSE: VertexShaderWriteMaskEXT read _FALSE;
    public static property TRUE:  VertexShaderWriteMaskEXT read _TRUE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'FALSE' else
      if self.val = UInt32($0001) then Result := 'TRUE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexWeightPointerTypeEXT = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FLOAT := new VertexWeightPointerTypeEXT($1406);
    
    public static property FLOAT: VertexWeightPointerTypeEXT read _FLOAT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion EXT}
  
  {$region AMD}
  
  TextureStorageMaskAMD = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_STORAGE_SPARSE_BIT_AMD := new TextureStorageMaskAMD($0001);
    
    public static property TEXTURE_STORAGE_SPARSE_BIT_AMD: TextureStorageMaskAMD read _TEXTURE_STORAGE_SPARSE_BIT_AMD;
    
    public static function operator or(f1,f2: TextureStorageMaskAMD) := new TextureStorageMaskAMD(f1.val or f2.val);
    
    public property HAS_FLAG_TEXTURE_STORAGE_SPARSE_BIT_AMD: boolean read self.val and $0001 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'TEXTURE_STORAGE_SPARSE_BIT_AMD+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion AMD}
  
  {$region APPLE}
  
  ObjectTypeAPPLE = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DRAW_PIXELS_APPLE := new ObjectTypeAPPLE($8A0A);
    private static _FENCE_APPLE       := new ObjectTypeAPPLE($8A0B);
    
    public static property DRAW_PIXELS_APPLE: ObjectTypeAPPLE read _DRAW_PIXELS_APPLE;
    public static property FENCE_APPLE:       ObjectTypeAPPLE read _FENCE_APPLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8A0A) then Result := 'DRAW_PIXELS_APPLE' else
      if self.val = UInt32($8A0B) then Result := 'FENCE_APPLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexArrayPNameAPPLE = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _STORAGE_CLIENT_APPLE := new VertexArrayPNameAPPLE($85B4);
    private static _STORAGE_CACHED_APPLE := new VertexArrayPNameAPPLE($85BE);
    private static _STORAGE_SHARED_APPLE := new VertexArrayPNameAPPLE($85BF);
    
    public static property STORAGE_CLIENT_APPLE: VertexArrayPNameAPPLE read _STORAGE_CLIENT_APPLE;
    public static property STORAGE_CACHED_APPLE: VertexArrayPNameAPPLE read _STORAGE_CACHED_APPLE;
    public static property STORAGE_SHARED_APPLE: VertexArrayPNameAPPLE read _STORAGE_SHARED_APPLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($85B4) then Result := 'STORAGE_CLIENT_APPLE' else
      if self.val = UInt32($85BE) then Result := 'STORAGE_CACHED_APPLE' else
      if self.val = UInt32($85BF) then Result := 'STORAGE_SHARED_APPLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion APPLE}
  
  {$region ATI}
  
  ArrayObjectPNameATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _OBJECT_BUFFER_SIZE_ATI  := new ArrayObjectPNameATI($8764);
    private static _OBJECT_BUFFER_USAGE_ATI := new ArrayObjectPNameATI($8765);
    
    public static property OBJECT_BUFFER_SIZE_ATI:  ArrayObjectPNameATI read _OBJECT_BUFFER_SIZE_ATI;
    public static property OBJECT_BUFFER_USAGE_ATI: ArrayObjectPNameATI read _OBJECT_BUFFER_USAGE_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8764) then Result := 'OBJECT_BUFFER_SIZE_ATI' else
      if self.val = UInt32($8765) then Result := 'OBJECT_BUFFER_USAGE_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ArrayObjectUsageATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _STATIC_ATI  := new ArrayObjectUsageATI($8760);
    private static _DYNAMIC_ATI := new ArrayObjectUsageATI($8761);
    
    public static property STATIC_ATI:  ArrayObjectUsageATI read _STATIC_ATI;
    public static property DYNAMIC_ATI: ArrayObjectUsageATI read _DYNAMIC_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8760) then Result := 'STATIC_ATI' else
      if self.val = UInt32($8761) then Result := 'DYNAMIC_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ElementPointerTypeATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNSIGNED_BYTE  := new ElementPointerTypeATI($1401);
    private static _UNSIGNED_SHORT := new ElementPointerTypeATI($1403);
    private static _UNSIGNED_INT   := new ElementPointerTypeATI($1405);
    
    public static property UNSIGNED_BYTE:  ElementPointerTypeATI read _UNSIGNED_BYTE;
    public static property UNSIGNED_SHORT: ElementPointerTypeATI read _UNSIGNED_SHORT;
    public static property UNSIGNED_INT:   ElementPointerTypeATI read _UNSIGNED_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FragmentOpATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MOV_ATI      := new FragmentOpATI($8961);
    private static _ADD_ATI      := new FragmentOpATI($8963);
    private static _MUL_ATI      := new FragmentOpATI($8964);
    private static _SUB_ATI      := new FragmentOpATI($8965);
    private static _DOT3_ATI     := new FragmentOpATI($8966);
    private static _DOT4_ATI     := new FragmentOpATI($8967);
    private static _MAD_ATI      := new FragmentOpATI($8968);
    private static _LERP_ATI     := new FragmentOpATI($8969);
    private static _CND_ATI      := new FragmentOpATI($896A);
    private static _CND0_ATI     := new FragmentOpATI($896B);
    private static _DOT2_ADD_ATI := new FragmentOpATI($896C);
    
    public static property MOV_ATI:      FragmentOpATI read _MOV_ATI;
    public static property ADD_ATI:      FragmentOpATI read _ADD_ATI;
    public static property MUL_ATI:      FragmentOpATI read _MUL_ATI;
    public static property SUB_ATI:      FragmentOpATI read _SUB_ATI;
    public static property DOT3_ATI:     FragmentOpATI read _DOT3_ATI;
    public static property DOT4_ATI:     FragmentOpATI read _DOT4_ATI;
    public static property MAD_ATI:      FragmentOpATI read _MAD_ATI;
    public static property LERP_ATI:     FragmentOpATI read _LERP_ATI;
    public static property CND_ATI:      FragmentOpATI read _CND_ATI;
    public static property CND0_ATI:     FragmentOpATI read _CND0_ATI;
    public static property DOT2_ADD_ATI: FragmentOpATI read _DOT2_ADD_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8961) then Result := 'MOV_ATI' else
      if self.val = UInt32($8963) then Result := 'ADD_ATI' else
      if self.val = UInt32($8964) then Result := 'MUL_ATI' else
      if self.val = UInt32($8965) then Result := 'SUB_ATI' else
      if self.val = UInt32($8966) then Result := 'DOT3_ATI' else
      if self.val = UInt32($8967) then Result := 'DOT4_ATI' else
      if self.val = UInt32($8968) then Result := 'MAD_ATI' else
      if self.val = UInt32($8969) then Result := 'LERP_ATI' else
      if self.val = UInt32($896A) then Result := 'CND_ATI' else
      if self.val = UInt32($896B) then Result := 'CND0_ATI' else
      if self.val = UInt32($896C) then Result := 'DOT2_ADD_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetTexBumpParameterATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BUMP_ROT_MATRIX_ATI      := new GetTexBumpParameterATI($8775);
    private static _BUMP_ROT_MATRIX_SIZE_ATI := new GetTexBumpParameterATI($8776);
    private static _BUMP_NUM_TEX_UNITS_ATI   := new GetTexBumpParameterATI($8777);
    private static _BUMP_TEX_UNITS_ATI       := new GetTexBumpParameterATI($8778);
    
    public static property BUMP_ROT_MATRIX_ATI:      GetTexBumpParameterATI read _BUMP_ROT_MATRIX_ATI;
    public static property BUMP_ROT_MATRIX_SIZE_ATI: GetTexBumpParameterATI read _BUMP_ROT_MATRIX_SIZE_ATI;
    public static property BUMP_NUM_TEX_UNITS_ATI:   GetTexBumpParameterATI read _BUMP_NUM_TEX_UNITS_ATI;
    public static property BUMP_TEX_UNITS_ATI:       GetTexBumpParameterATI read _BUMP_TEX_UNITS_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8775) then Result := 'BUMP_ROT_MATRIX_ATI' else
      if self.val = UInt32($8776) then Result := 'BUMP_ROT_MATRIX_SIZE_ATI' else
      if self.val = UInt32($8777) then Result := 'BUMP_NUM_TEX_UNITS_ATI' else
      if self.val = UInt32($8778) then Result := 'BUMP_TEX_UNITS_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PNTrianglesPNameATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PN_TRIANGLES_POINT_MODE_ATI        := new PNTrianglesPNameATI($87F2);
    private static _PN_TRIANGLES_NORMAL_MODE_ATI       := new PNTrianglesPNameATI($87F3);
    private static _PN_TRIANGLES_TESSELATION_LEVEL_ATI := new PNTrianglesPNameATI($87F4);
    
    public static property PN_TRIANGLES_POINT_MODE_ATI:        PNTrianglesPNameATI read _PN_TRIANGLES_POINT_MODE_ATI;
    public static property PN_TRIANGLES_NORMAL_MODE_ATI:       PNTrianglesPNameATI read _PN_TRIANGLES_NORMAL_MODE_ATI;
    public static property PN_TRIANGLES_TESSELATION_LEVEL_ATI: PNTrianglesPNameATI read _PN_TRIANGLES_TESSELATION_LEVEL_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($87F2) then Result := 'PN_TRIANGLES_POINT_MODE_ATI' else
      if self.val = UInt32($87F3) then Result := 'PN_TRIANGLES_NORMAL_MODE_ATI' else
      if self.val = UInt32($87F4) then Result := 'PN_TRIANGLES_TESSELATION_LEVEL_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PreserveModeATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PRESERVE_ATI := new PreserveModeATI($8762);
    private static _DISCARD_ATI  := new PreserveModeATI($8763);
    
    public static property PRESERVE_ATI: PreserveModeATI read _PRESERVE_ATI;
    public static property DISCARD_ATI:  PreserveModeATI read _DISCARD_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8762) then Result := 'PRESERVE_ATI' else
      if self.val = UInt32($8763) then Result := 'DISCARD_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SwizzleOpATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SWIZZLE_STR_ATI    := new SwizzleOpATI($8976);
    private static _SWIZZLE_STQ_ATI    := new SwizzleOpATI($8977);
    private static _SWIZZLE_STR_DR_ATI := new SwizzleOpATI($8978);
    private static _SWIZZLE_STQ_DQ_ATI := new SwizzleOpATI($8979);
    
    public static property SWIZZLE_STR_ATI:    SwizzleOpATI read _SWIZZLE_STR_ATI;
    public static property SWIZZLE_STQ_ATI:    SwizzleOpATI read _SWIZZLE_STQ_ATI;
    public static property SWIZZLE_STR_DR_ATI: SwizzleOpATI read _SWIZZLE_STR_DR_ATI;
    public static property SWIZZLE_STQ_DQ_ATI: SwizzleOpATI read _SWIZZLE_STQ_DQ_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8976) then Result := 'SWIZZLE_STR_ATI' else
      if self.val = UInt32($8977) then Result := 'SWIZZLE_STQ_ATI' else
      if self.val = UInt32($8978) then Result := 'SWIZZLE_STR_DR_ATI' else
      if self.val = UInt32($8979) then Result := 'SWIZZLE_STQ_DQ_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TexBumpParameterATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BUMP_ROT_MATRIX_ATI := new TexBumpParameterATI($8775);
    
    public static property BUMP_ROT_MATRIX_ATI: TexBumpParameterATI read _BUMP_ROT_MATRIX_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8775) then Result := 'BUMP_ROT_MATRIX_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexStreamATI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_STREAM0_ATI := new VertexStreamATI($876C);
    private static _VERTEX_STREAM1_ATI := new VertexStreamATI($876D);
    private static _VERTEX_STREAM2_ATI := new VertexStreamATI($876E);
    private static _VERTEX_STREAM3_ATI := new VertexStreamATI($876F);
    private static _VERTEX_STREAM4_ATI := new VertexStreamATI($8770);
    private static _VERTEX_STREAM5_ATI := new VertexStreamATI($8771);
    private static _VERTEX_STREAM6_ATI := new VertexStreamATI($8772);
    private static _VERTEX_STREAM7_ATI := new VertexStreamATI($8773);
    
    public static property VERTEX_STREAM0_ATI: VertexStreamATI read _VERTEX_STREAM0_ATI;
    public static property VERTEX_STREAM1_ATI: VertexStreamATI read _VERTEX_STREAM1_ATI;
    public static property VERTEX_STREAM2_ATI: VertexStreamATI read _VERTEX_STREAM2_ATI;
    public static property VERTEX_STREAM3_ATI: VertexStreamATI read _VERTEX_STREAM3_ATI;
    public static property VERTEX_STREAM4_ATI: VertexStreamATI read _VERTEX_STREAM4_ATI;
    public static property VERTEX_STREAM5_ATI: VertexStreamATI read _VERTEX_STREAM5_ATI;
    public static property VERTEX_STREAM6_ATI: VertexStreamATI read _VERTEX_STREAM6_ATI;
    public static property VERTEX_STREAM7_ATI: VertexStreamATI read _VERTEX_STREAM7_ATI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($876C) then Result := 'VERTEX_STREAM0_ATI' else
      if self.val = UInt32($876D) then Result := 'VERTEX_STREAM1_ATI' else
      if self.val = UInt32($876E) then Result := 'VERTEX_STREAM2_ATI' else
      if self.val = UInt32($876F) then Result := 'VERTEX_STREAM3_ATI' else
      if self.val = UInt32($8770) then Result := 'VERTEX_STREAM4_ATI' else
      if self.val = UInt32($8771) then Result := 'VERTEX_STREAM5_ATI' else
      if self.val = UInt32($8772) then Result := 'VERTEX_STREAM6_ATI' else
      if self.val = UInt32($8773) then Result := 'VERTEX_STREAM7_ATI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion ATI}
  
  {$region GDI}
  
  PixelDataTypeGDI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _RGBA       := new PixelDataTypeGDI($0000);
    private static _COLORINDEX := new PixelDataTypeGDI($0001);
    
    public static property RGBA:       PixelDataTypeGDI read _RGBA;
    public static property COLORINDEX: PixelDataTypeGDI read _COLORINDEX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'RGBA' else
      if self.val = UInt32($0001) then Result := 'COLORINDEX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelFormatFlagsGDI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _DOUBLEBUFFER          := new PixelFormatFlagsGDI($0001);
    private static _STEREO                := new PixelFormatFlagsGDI($0002);
    private static _DRAW_TO_WINDOW        := new PixelFormatFlagsGDI($0004);
    private static _DRAW_TO_BITMAP        := new PixelFormatFlagsGDI($0008);
    private static _SUPPORT_GDI           := new PixelFormatFlagsGDI($000A);
    private static _SUPPORT_OPENGL        := new PixelFormatFlagsGDI($0014);
    private static _GENERIC_FORMAT        := new PixelFormatFlagsGDI($0028);
    private static _NEED_PALETTE          := new PixelFormatFlagsGDI($0050);
    private static _NEED_SYSTEM_PALETTE   := new PixelFormatFlagsGDI($0064);
    private static _SWAP_EXCHANGE         := new PixelFormatFlagsGDI($00C8);
    private static _SWAP_COPY             := new PixelFormatFlagsGDI($0190);
    private static _SWAP_LAYER_BUFFERS    := new PixelFormatFlagsGDI($0320);
    private static _GENERIC_ACCELERATED   := new PixelFormatFlagsGDI($03E8);
    private static _SUPPORT_DIRECTDRAW    := new PixelFormatFlagsGDI($07D0);
    private static _DEPTH_DONTCARE        := new PixelFormatFlagsGDI($1312D00);
    private static _DOUBLEBUFFER_DONTCARE := new PixelFormatFlagsGDI($2625A00);
    private static _STEREO_DONTCARE       := new PixelFormatFlagsGDI($4C4B400);
    
    public static property DOUBLEBUFFER:          PixelFormatFlagsGDI read _DOUBLEBUFFER;
    public static property STEREO:                PixelFormatFlagsGDI read _STEREO;
    public static property DRAW_TO_WINDOW:        PixelFormatFlagsGDI read _DRAW_TO_WINDOW;
    public static property DRAW_TO_BITMAP:        PixelFormatFlagsGDI read _DRAW_TO_BITMAP;
    public static property SUPPORT_GDI:           PixelFormatFlagsGDI read _SUPPORT_GDI;
    public static property SUPPORT_OPENGL:        PixelFormatFlagsGDI read _SUPPORT_OPENGL;
    public static property GENERIC_FORMAT:        PixelFormatFlagsGDI read _GENERIC_FORMAT;
    public static property NEED_PALETTE:          PixelFormatFlagsGDI read _NEED_PALETTE;
    public static property NEED_SYSTEM_PALETTE:   PixelFormatFlagsGDI read _NEED_SYSTEM_PALETTE;
    public static property SWAP_EXCHANGE:         PixelFormatFlagsGDI read _SWAP_EXCHANGE;
    public static property SWAP_COPY:             PixelFormatFlagsGDI read _SWAP_COPY;
    public static property SWAP_LAYER_BUFFERS:    PixelFormatFlagsGDI read _SWAP_LAYER_BUFFERS;
    public static property GENERIC_ACCELERATED:   PixelFormatFlagsGDI read _GENERIC_ACCELERATED;
    public static property SUPPORT_DIRECTDRAW:    PixelFormatFlagsGDI read _SUPPORT_DIRECTDRAW;
    public static property DEPTH_DONTCARE:        PixelFormatFlagsGDI read _DEPTH_DONTCARE;
    public static property DOUBLEBUFFER_DONTCARE: PixelFormatFlagsGDI read _DOUBLEBUFFER_DONTCARE;
    public static property STEREO_DONTCARE:       PixelFormatFlagsGDI read _STEREO_DONTCARE;
    
    public static function operator or(f1,f2: PixelFormatFlagsGDI) := new PixelFormatFlagsGDI(f1.val or f2.val);
    
    public property HAS_FLAG_DOUBLEBUFFER:          boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_STEREO:                boolean read self.val and $0002 <> 0;
    public property HAS_FLAG_DRAW_TO_WINDOW:        boolean read self.val and $0004 <> 0;
    public property HAS_FLAG_DRAW_TO_BITMAP:        boolean read self.val and $0008 <> 0;
    public property HAS_FLAG_SUPPORT_GDI:           boolean read self.val and $000A <> 0;
    public property HAS_FLAG_SUPPORT_OPENGL:        boolean read self.val and $0014 <> 0;
    public property HAS_FLAG_GENERIC_FORMAT:        boolean read self.val and $0028 <> 0;
    public property HAS_FLAG_NEED_PALETTE:          boolean read self.val and $0050 <> 0;
    public property HAS_FLAG_NEED_SYSTEM_PALETTE:   boolean read self.val and $0064 <> 0;
    public property HAS_FLAG_SWAP_EXCHANGE:         boolean read self.val and $00C8 <> 0;
    public property HAS_FLAG_SWAP_COPY:             boolean read self.val and $0190 <> 0;
    public property HAS_FLAG_SWAP_LAYER_BUFFERS:    boolean read self.val and $0320 <> 0;
    public property HAS_FLAG_GENERIC_ACCELERATED:   boolean read self.val and $03E8 <> 0;
    public property HAS_FLAG_SUPPORT_DIRECTDRAW:    boolean read self.val and $07D0 <> 0;
    public property HAS_FLAG_DEPTH_DONTCARE:        boolean read self.val and $1312D00 <> 0;
    public property HAS_FLAG_DOUBLEBUFFER_DONTCARE: boolean read self.val and $2625A00 <> 0;
    public property HAS_FLAG_STEREO_DONTCARE:       boolean read self.val and $4C4B400 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'DOUBLEBUFFER+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'STEREO+';
      if self.val and UInt32($0004) = UInt32($0004) then res += 'DRAW_TO_WINDOW+';
      if self.val and UInt32($0008) = UInt32($0008) then res += 'DRAW_TO_BITMAP+';
      if self.val and UInt32($000A) = UInt32($000A) then res += 'SUPPORT_GDI+';
      if self.val and UInt32($0014) = UInt32($0014) then res += 'SUPPORT_OPENGL+';
      if self.val and UInt32($0028) = UInt32($0028) then res += 'GENERIC_FORMAT+';
      if self.val and UInt32($0050) = UInt32($0050) then res += 'NEED_PALETTE+';
      if self.val and UInt32($0064) = UInt32($0064) then res += 'NEED_SYSTEM_PALETTE+';
      if self.val and UInt32($00C8) = UInt32($00C8) then res += 'SWAP_EXCHANGE+';
      if self.val and UInt32($0190) = UInt32($0190) then res += 'SWAP_COPY+';
      if self.val and UInt32($0320) = UInt32($0320) then res += 'SWAP_LAYER_BUFFERS+';
      if self.val and UInt32($03E8) = UInt32($03E8) then res += 'GENERIC_ACCELERATED+';
      if self.val and UInt32($07D0) = UInt32($07D0) then res += 'SUPPORT_DIRECTDRAW+';
      if self.val and UInt32($1312D00) = UInt32($1312D00) then res += 'DEPTH_DONTCARE+';
      if self.val and UInt32($2625A00) = UInt32($2625A00) then res += 'DOUBLEBUFFER_DONTCARE+';
      if self.val and UInt32($4C4B400) = UInt32($4C4B400) then res += 'STEREO_DONTCARE+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion GDI}
  
  {$region HP}
  
  ImageTransformPNameHP = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _IMAGE_SCALE_X_HP         := new ImageTransformPNameHP($8155);
    private static _IMAGE_SCALE_Y_HP         := new ImageTransformPNameHP($8156);
    private static _IMAGE_TRANSLATE_X_HP     := new ImageTransformPNameHP($8157);
    private static _IMAGE_TRANSLATE_Y_HP     := new ImageTransformPNameHP($8158);
    private static _IMAGE_ROTATE_ANGLE_HP    := new ImageTransformPNameHP($8159);
    private static _IMAGE_ROTATE_ORIGIN_X_HP := new ImageTransformPNameHP($815A);
    private static _IMAGE_ROTATE_ORIGIN_Y_HP := new ImageTransformPNameHP($815B);
    private static _IMAGE_MAG_FILTER_HP      := new ImageTransformPNameHP($815C);
    private static _IMAGE_MIN_FILTER_HP      := new ImageTransformPNameHP($815D);
    private static _IMAGE_CUBIC_WEIGHT_HP    := new ImageTransformPNameHP($815E);
    
    public static property IMAGE_SCALE_X_HP:         ImageTransformPNameHP read _IMAGE_SCALE_X_HP;
    public static property IMAGE_SCALE_Y_HP:         ImageTransformPNameHP read _IMAGE_SCALE_Y_HP;
    public static property IMAGE_TRANSLATE_X_HP:     ImageTransformPNameHP read _IMAGE_TRANSLATE_X_HP;
    public static property IMAGE_TRANSLATE_Y_HP:     ImageTransformPNameHP read _IMAGE_TRANSLATE_Y_HP;
    public static property IMAGE_ROTATE_ANGLE_HP:    ImageTransformPNameHP read _IMAGE_ROTATE_ANGLE_HP;
    public static property IMAGE_ROTATE_ORIGIN_X_HP: ImageTransformPNameHP read _IMAGE_ROTATE_ORIGIN_X_HP;
    public static property IMAGE_ROTATE_ORIGIN_Y_HP: ImageTransformPNameHP read _IMAGE_ROTATE_ORIGIN_Y_HP;
    public static property IMAGE_MAG_FILTER_HP:      ImageTransformPNameHP read _IMAGE_MAG_FILTER_HP;
    public static property IMAGE_MIN_FILTER_HP:      ImageTransformPNameHP read _IMAGE_MIN_FILTER_HP;
    public static property IMAGE_CUBIC_WEIGHT_HP:    ImageTransformPNameHP read _IMAGE_CUBIC_WEIGHT_HP;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8155) then Result := 'IMAGE_SCALE_X_HP' else
      if self.val = UInt32($8156) then Result := 'IMAGE_SCALE_Y_HP' else
      if self.val = UInt32($8157) then Result := 'IMAGE_TRANSLATE_X_HP' else
      if self.val = UInt32($8158) then Result := 'IMAGE_TRANSLATE_Y_HP' else
      if self.val = UInt32($8159) then Result := 'IMAGE_ROTATE_ANGLE_HP' else
      if self.val = UInt32($815A) then Result := 'IMAGE_ROTATE_ORIGIN_X_HP' else
      if self.val = UInt32($815B) then Result := 'IMAGE_ROTATE_ORIGIN_Y_HP' else
      if self.val = UInt32($815C) then Result := 'IMAGE_MAG_FILTER_HP' else
      if self.val = UInt32($815D) then Result := 'IMAGE_MIN_FILTER_HP' else
      if self.val = UInt32($815E) then Result := 'IMAGE_CUBIC_WEIGHT_HP' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ImageTransformTargetHP = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _IMAGE_TRANSFORM_2D_HP := new ImageTransformTargetHP($8161);
    
    public static property IMAGE_TRANSFORM_2D_HP: ImageTransformTargetHP read _IMAGE_TRANSFORM_2D_HP;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8161) then Result := 'IMAGE_TRANSFORM_2D_HP' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion HP}
  
  {$region IBM}
  
  FogPointerTypeIBM = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FLOAT  := new FogPointerTypeIBM($1406);
    private static _DOUBLE := new FogPointerTypeIBM($140A);
    
    public static property FLOAT:  FogPointerTypeIBM read _FLOAT;
    public static property DOUBLE: FogPointerTypeIBM read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SecondaryColorPointerTypeIBM = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SHORT  := new SecondaryColorPointerTypeIBM($1402);
    private static _INT    := new SecondaryColorPointerTypeIBM($1404);
    private static _FLOAT  := new SecondaryColorPointerTypeIBM($1406);
    private static _DOUBLE := new SecondaryColorPointerTypeIBM($140A);
    
    public static property SHORT:  SecondaryColorPointerTypeIBM read _SHORT;
    public static property INT:    SecondaryColorPointerTypeIBM read _INT;
    public static property FLOAT:  SecondaryColorPointerTypeIBM read _FLOAT;
    public static property DOUBLE: SecondaryColorPointerTypeIBM read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1402) then Result := 'SHORT' else
      if self.val = UInt32($1404) then Result := 'INT' else
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion IBM}
  
  {$region INTEL}
  
  PerfQueryCapFlagsINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PERFQUERY_SINGLE_CONTEXT_INTEL := new PerfQueryCapFlagsINTEL($0000);
    private static _PERFQUERY_GLOBAL_CONTEXT_INTEL := new PerfQueryCapFlagsINTEL($0001);
    
    public static property PERFQUERY_SINGLE_CONTEXT_INTEL: PerfQueryCapFlagsINTEL read _PERFQUERY_SINGLE_CONTEXT_INTEL;
    public static property PERFQUERY_GLOBAL_CONTEXT_INTEL: PerfQueryCapFlagsINTEL read _PERFQUERY_GLOBAL_CONTEXT_INTEL;
    
    public static function operator or(f1,f2: PerfQueryCapFlagsINTEL) := new PerfQueryCapFlagsINTEL(f1.val or f2.val);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    public property HAS_FLAG_PERFQUERY_GLOBAL_CONTEXT_INTEL: boolean read self.val and $0001 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0000) = UInt32($0000) then res += 'PERFQUERY_SINGLE_CONTEXT_INTEL+';
      if self.val and UInt32($0001) = UInt32($0001) then res += 'PERFQUERY_GLOBAL_CONTEXT_INTEL+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  PerfQueryDataFlagsINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PERFQUERY_DONOT_FLUSH_INTEL := new PerfQueryDataFlagsINTEL($83F9);
    private static _PERFQUERY_FLUSH_INTEL       := new PerfQueryDataFlagsINTEL($83FA);
    private static _PERFQUERY_WAIT_INTEL        := new PerfQueryDataFlagsINTEL($83FB);
    
    public static property PERFQUERY_DONOT_FLUSH_INTEL: PerfQueryDataFlagsINTEL read _PERFQUERY_DONOT_FLUSH_INTEL;
    public static property PERFQUERY_FLUSH_INTEL:       PerfQueryDataFlagsINTEL read _PERFQUERY_FLUSH_INTEL;
    public static property PERFQUERY_WAIT_INTEL:        PerfQueryDataFlagsINTEL read _PERFQUERY_WAIT_INTEL;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($83F9) then Result := 'PERFQUERY_DONOT_FLUSH_INTEL' else
      if self.val = UInt32($83FA) then Result := 'PERFQUERY_FLUSH_INTEL' else
      if self.val = UInt32($83FB) then Result := 'PERFQUERY_WAIT_INTEL' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion INTEL}
  
  {$region NV}
  
  CombinerBiasNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE                         := new CombinerBiasNV($0000);
    private static _BIAS_BY_NEGATIVE_ONE_HALF_NV := new CombinerBiasNV($8541);
    
    public static property NONE:                         CombinerBiasNV read _NONE;
    public static property BIAS_BY_NEGATIVE_ONE_HALF_NV: CombinerBiasNV read _BIAS_BY_NEGATIVE_ONE_HALF_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($8541) then Result := 'BIAS_BY_NEGATIVE_ONE_HALF_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerComponentUsageNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _BLUE  := new CombinerComponentUsageNV($1905);
    private static _ALPHA := new CombinerComponentUsageNV($1906);
    private static _RGB   := new CombinerComponentUsageNV($1907);
    
    public static property BLUE:  CombinerComponentUsageNV read _BLUE;
    public static property ALPHA: CombinerComponentUsageNV read _ALPHA;
    public static property RGB:   CombinerComponentUsageNV read _RGB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1905) then Result := 'BLUE' else
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerMappingNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNSIGNED_IDENTITY_NV := new CombinerMappingNV($8536);
    private static _UNSIGNED_INVERT_NV   := new CombinerMappingNV($8537);
    private static _EXPAND_NORMAL_NV     := new CombinerMappingNV($8538);
    private static _EXPAND_NEGATE_NV     := new CombinerMappingNV($8539);
    private static _HALF_BIAS_NORMAL_NV  := new CombinerMappingNV($853A);
    private static _HALF_BIAS_NEGATE_NV  := new CombinerMappingNV($853B);
    private static _SIGNED_IDENTITY_NV   := new CombinerMappingNV($853C);
    private static _SIGNED_NEGATE_NV     := new CombinerMappingNV($853D);
    
    public static property UNSIGNED_IDENTITY_NV: CombinerMappingNV read _UNSIGNED_IDENTITY_NV;
    public static property UNSIGNED_INVERT_NV:   CombinerMappingNV read _UNSIGNED_INVERT_NV;
    public static property EXPAND_NORMAL_NV:     CombinerMappingNV read _EXPAND_NORMAL_NV;
    public static property EXPAND_NEGATE_NV:     CombinerMappingNV read _EXPAND_NEGATE_NV;
    public static property HALF_BIAS_NORMAL_NV:  CombinerMappingNV read _HALF_BIAS_NORMAL_NV;
    public static property HALF_BIAS_NEGATE_NV:  CombinerMappingNV read _HALF_BIAS_NEGATE_NV;
    public static property SIGNED_IDENTITY_NV:   CombinerMappingNV read _SIGNED_IDENTITY_NV;
    public static property SIGNED_NEGATE_NV:     CombinerMappingNV read _SIGNED_NEGATE_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8536) then Result := 'UNSIGNED_IDENTITY_NV' else
      if self.val = UInt32($8537) then Result := 'UNSIGNED_INVERT_NV' else
      if self.val = UInt32($8538) then Result := 'EXPAND_NORMAL_NV' else
      if self.val = UInt32($8539) then Result := 'EXPAND_NEGATE_NV' else
      if self.val = UInt32($853A) then Result := 'HALF_BIAS_NORMAL_NV' else
      if self.val = UInt32($853B) then Result := 'HALF_BIAS_NEGATE_NV' else
      if self.val = UInt32($853C) then Result := 'SIGNED_IDENTITY_NV' else
      if self.val = UInt32($853D) then Result := 'SIGNED_NEGATE_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerParameterNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COMBINER_INPUT_NV           := new CombinerParameterNV($8542);
    private static _COMBINER_MAPPING_NV         := new CombinerParameterNV($8543);
    private static _COMBINER_COMPONENT_USAGE_NV := new CombinerParameterNV($8544);
    
    public static property COMBINER_INPUT_NV:           CombinerParameterNV read _COMBINER_INPUT_NV;
    public static property COMBINER_MAPPING_NV:         CombinerParameterNV read _COMBINER_MAPPING_NV;
    public static property COMBINER_COMPONENT_USAGE_NV: CombinerParameterNV read _COMBINER_COMPONENT_USAGE_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8542) then Result := 'COMBINER_INPUT_NV' else
      if self.val = UInt32($8543) then Result := 'COMBINER_MAPPING_NV' else
      if self.val = UInt32($8544) then Result := 'COMBINER_COMPONENT_USAGE_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerPortionNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ALPHA := new CombinerPortionNV($1906);
    private static _RGB   := new CombinerPortionNV($1907);
    
    public static property ALPHA: CombinerPortionNV read _ALPHA;
    public static property RGB:   CombinerPortionNV read _RGB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1906) then Result := 'ALPHA' else
      if self.val = UInt32($1907) then Result := 'RGB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerRegisterNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE0_ARB       := new CombinerRegisterNV($84C0);
    private static _TEXTURE1_ARB       := new CombinerRegisterNV($84C1);
    private static _PRIMARY_COLOR_NV   := new CombinerRegisterNV($852C);
    private static _SECONDARY_COLOR_NV := new CombinerRegisterNV($852D);
    private static _SPARE0_NV          := new CombinerRegisterNV($852E);
    private static _SPARE1_NV          := new CombinerRegisterNV($852F);
    private static _DISCARD_NV         := new CombinerRegisterNV($8530);
    
    public static property TEXTURE0_ARB:       CombinerRegisterNV read _TEXTURE0_ARB;
    public static property TEXTURE1_ARB:       CombinerRegisterNV read _TEXTURE1_ARB;
    public static property PRIMARY_COLOR_NV:   CombinerRegisterNV read _PRIMARY_COLOR_NV;
    public static property SECONDARY_COLOR_NV: CombinerRegisterNV read _SECONDARY_COLOR_NV;
    public static property SPARE0_NV:          CombinerRegisterNV read _SPARE0_NV;
    public static property SPARE1_NV:          CombinerRegisterNV read _SPARE1_NV;
    public static property DISCARD_NV:         CombinerRegisterNV read _DISCARD_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84C0) then Result := 'TEXTURE0_ARB' else
      if self.val = UInt32($84C1) then Result := 'TEXTURE1_ARB' else
      if self.val = UInt32($852C) then Result := 'PRIMARY_COLOR_NV' else
      if self.val = UInt32($852D) then Result := 'SECONDARY_COLOR_NV' else
      if self.val = UInt32($852E) then Result := 'SPARE0_NV' else
      if self.val = UInt32($852F) then Result := 'SPARE1_NV' else
      if self.val = UInt32($8530) then Result := 'DISCARD_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerScaleNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _NONE                 := new CombinerScaleNV($0000);
    private static _SCALE_BY_TWO_NV      := new CombinerScaleNV($853E);
    private static _SCALE_BY_FOUR_NV     := new CombinerScaleNV($853F);
    private static _SCALE_BY_ONE_HALF_NV := new CombinerScaleNV($8540);
    
    public static property NONE:                 CombinerScaleNV read _NONE;
    public static property SCALE_BY_TWO_NV:      CombinerScaleNV read _SCALE_BY_TWO_NV;
    public static property SCALE_BY_FOUR_NV:     CombinerScaleNV read _SCALE_BY_FOUR_NV;
    public static property SCALE_BY_ONE_HALF_NV: CombinerScaleNV read _SCALE_BY_ONE_HALF_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($0000) then Result := 'NONE' else
      if self.val = UInt32($853E) then Result := 'SCALE_BY_TWO_NV' else
      if self.val = UInt32($853F) then Result := 'SCALE_BY_FOUR_NV' else
      if self.val = UInt32($8540) then Result := 'SCALE_BY_ONE_HALF_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerStageNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COMBINER0_NV := new CombinerStageNV($8550);
    private static _COMBINER1_NV := new CombinerStageNV($8551);
    private static _COMBINER2_NV := new CombinerStageNV($8552);
    private static _COMBINER3_NV := new CombinerStageNV($8553);
    private static _COMBINER4_NV := new CombinerStageNV($8554);
    private static _COMBINER5_NV := new CombinerStageNV($8555);
    private static _COMBINER6_NV := new CombinerStageNV($8556);
    private static _COMBINER7_NV := new CombinerStageNV($8557);
    
    public static property COMBINER0_NV: CombinerStageNV read _COMBINER0_NV;
    public static property COMBINER1_NV: CombinerStageNV read _COMBINER1_NV;
    public static property COMBINER2_NV: CombinerStageNV read _COMBINER2_NV;
    public static property COMBINER3_NV: CombinerStageNV read _COMBINER3_NV;
    public static property COMBINER4_NV: CombinerStageNV read _COMBINER4_NV;
    public static property COMBINER5_NV: CombinerStageNV read _COMBINER5_NV;
    public static property COMBINER6_NV: CombinerStageNV read _COMBINER6_NV;
    public static property COMBINER7_NV: CombinerStageNV read _COMBINER7_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8550) then Result := 'COMBINER0_NV' else
      if self.val = UInt32($8551) then Result := 'COMBINER1_NV' else
      if self.val = UInt32($8552) then Result := 'COMBINER2_NV' else
      if self.val = UInt32($8553) then Result := 'COMBINER3_NV' else
      if self.val = UInt32($8554) then Result := 'COMBINER4_NV' else
      if self.val = UInt32($8555) then Result := 'COMBINER5_NV' else
      if self.val = UInt32($8556) then Result := 'COMBINER6_NV' else
      if self.val = UInt32($8557) then Result := 'COMBINER7_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  CombinerVariableNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VARIABLE_A_NV := new CombinerVariableNV($8523);
    private static _VARIABLE_B_NV := new CombinerVariableNV($8524);
    private static _VARIABLE_C_NV := new CombinerVariableNV($8525);
    private static _VARIABLE_D_NV := new CombinerVariableNV($8526);
    private static _VARIABLE_E_NV := new CombinerVariableNV($8527);
    private static _VARIABLE_F_NV := new CombinerVariableNV($8528);
    private static _VARIABLE_G_NV := new CombinerVariableNV($8529);
    
    public static property VARIABLE_A_NV: CombinerVariableNV read _VARIABLE_A_NV;
    public static property VARIABLE_B_NV: CombinerVariableNV read _VARIABLE_B_NV;
    public static property VARIABLE_C_NV: CombinerVariableNV read _VARIABLE_C_NV;
    public static property VARIABLE_D_NV: CombinerVariableNV read _VARIABLE_D_NV;
    public static property VARIABLE_E_NV: CombinerVariableNV read _VARIABLE_E_NV;
    public static property VARIABLE_F_NV: CombinerVariableNV read _VARIABLE_F_NV;
    public static property VARIABLE_G_NV: CombinerVariableNV read _VARIABLE_G_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8523) then Result := 'VARIABLE_A_NV' else
      if self.val = UInt32($8524) then Result := 'VARIABLE_B_NV' else
      if self.val = UInt32($8525) then Result := 'VARIABLE_C_NV' else
      if self.val = UInt32($8526) then Result := 'VARIABLE_D_NV' else
      if self.val = UInt32($8527) then Result := 'VARIABLE_E_NV' else
      if self.val = UInt32($8528) then Result := 'VARIABLE_F_NV' else
      if self.val = UInt32($8529) then Result := 'VARIABLE_G_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  EvalMapsModeNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FILL_NV := new EvalMapsModeNV($1B02);
    
    public static property FILL_NV: EvalMapsModeNV read _FILL_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1B02) then Result := 'FILL_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  EvalTargetNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _EVAL_2D_NV            := new EvalTargetNV($86C0);
    private static _EVAL_TRIANGULAR_2D_NV := new EvalTargetNV($86C1);
    
    public static property EVAL_2D_NV:            EvalTargetNV read _EVAL_2D_NV;
    public static property EVAL_TRIANGULAR_2D_NV: EvalTargetNV read _EVAL_TRIANGULAR_2D_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($86C0) then Result := 'EVAL_2D_NV' else
      if self.val = UInt32($86C1) then Result := 'EVAL_TRIANGULAR_2D_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FenceConditionNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _ALL_COMPLETED_NV := new FenceConditionNV($84F2);
    
    public static property ALL_COMPLETED_NV: FenceConditionNV read _ALL_COMPLETED_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84F2) then Result := 'ALL_COMPLETED_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FenceParameterNameNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FENCE_STATUS_NV    := new FenceParameterNameNV($84F3);
    private static _FENCE_CONDITION_NV := new FenceParameterNameNV($84F4);
    
    public static property FENCE_STATUS_NV:    FenceParameterNameNV read _FENCE_STATUS_NV;
    public static property FENCE_CONDITION_NV: FenceParameterNameNV read _FENCE_CONDITION_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($84F3) then Result := 'FENCE_STATUS_NV' else
      if self.val = UInt32($84F4) then Result := 'FENCE_CONDITION_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetMultisamplePNameNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SAMPLE_LOCATION_ARB              := new GetMultisamplePNameNV($8E50);
    private static _SAMPLE_POSITION                  := new GetMultisamplePNameNV($8E50);
    private static _PROGRAMMABLE_SAMPLE_LOCATION_ARB := new GetMultisamplePNameNV($9341);
    
    public static property SAMPLE_LOCATION_ARB:              GetMultisamplePNameNV read _SAMPLE_LOCATION_ARB;
    public static property SAMPLE_POSITION:                  GetMultisamplePNameNV read _SAMPLE_POSITION;
    public static property PROGRAMMABLE_SAMPLE_LOCATION_ARB: GetMultisamplePNameNV read _PROGRAMMABLE_SAMPLE_LOCATION_ARB;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8E50) then Result := 'SAMPLE_LOCATION_ARB' else
      if self.val = UInt32($8E50) then Result := 'SAMPLE_POSITION' else
      if self.val = UInt32($9341) then Result := 'PROGRAMMABLE_SAMPLE_LOCATION_ARB' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MapAttribParameterNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MAP_ATTRIB_U_ORDER_NV := new MapAttribParameterNV($86C3);
    private static _MAP_ATTRIB_V_ORDER_NV := new MapAttribParameterNV($86C4);
    
    public static property MAP_ATTRIB_U_ORDER_NV: MapAttribParameterNV read _MAP_ATTRIB_U_ORDER_NV;
    public static property MAP_ATTRIB_V_ORDER_NV: MapAttribParameterNV read _MAP_ATTRIB_V_ORDER_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($86C3) then Result := 'MAP_ATTRIB_U_ORDER_NV' else
      if self.val = UInt32($86C4) then Result := 'MAP_ATTRIB_V_ORDER_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MapParameterNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _MAP_TESSELLATION_NV := new MapParameterNV($86C2);
    
    public static property MAP_TESSELLATION_NV: MapParameterNV read _MAP_TESSELLATION_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($86C2) then Result := 'MAP_TESSELLATION_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  MapTypeNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FLOAT  := new MapTypeNV($1406);
    private static _DOUBLE := new MapTypeNV($140A);
    
    public static property FLOAT:  MapTypeNV read _FLOAT;
    public static property DOUBLE: MapTypeNV read _DOUBLE;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1406) then Result := 'FLOAT' else
      if self.val = UInt32($140A) then Result := 'DOUBLE' else
        Result := self.val.ToString;
    end;
    
  end;
  
  OcclusionQueryParameterNameNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PIXEL_COUNT_NV           := new OcclusionQueryParameterNameNV($8866);
    private static _PIXEL_COUNT_AVAILABLE_NV := new OcclusionQueryParameterNameNV($8867);
    
    public static property PIXEL_COUNT_NV:           OcclusionQueryParameterNameNV read _PIXEL_COUNT_NV;
    public static property PIXEL_COUNT_AVAILABLE_NV: OcclusionQueryParameterNameNV read _PIXEL_COUNT_AVAILABLE_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8866) then Result := 'PIXEL_COUNT_NV' else
      if self.val = UInt32($8867) then Result := 'PIXEL_COUNT_AVAILABLE_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelDataRangeTargetNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _WRITE_PIXEL_DATA_RANGE_NV := new PixelDataRangeTargetNV($8878);
    private static _READ_PIXEL_DATA_RANGE_NV  := new PixelDataRangeTargetNV($8879);
    
    public static property WRITE_PIXEL_DATA_RANGE_NV: PixelDataRangeTargetNV read _WRITE_PIXEL_DATA_RANGE_NV;
    public static property READ_PIXEL_DATA_RANGE_NV:  PixelDataRangeTargetNV read _READ_PIXEL_DATA_RANGE_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8878) then Result := 'WRITE_PIXEL_DATA_RANGE_NV' else
      if self.val = UInt32($8879) then Result := 'READ_PIXEL_DATA_RANGE_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  VertexAttribEnumNV = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PROGRAM_PARAMETER_NV := new VertexAttribEnumNV($8644);
    
    public static property PROGRAM_PARAMETER_NV: VertexAttribEnumNV read _PROGRAM_PARAMETER_NV;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8644) then Result := 'PROGRAM_PARAMETER_NV' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion NV}
  
  {$region PGI}
  
  HintTargetPGI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _VERTEX_DATA_HINT_PGI       := new HintTargetPGI($1A22A);
    private static _VERTEX_CONSISTENT_HINT_PGI := new HintTargetPGI($1A22B);
    private static _MATERIAL_SIDE_HINT_PGI     := new HintTargetPGI($1A22C);
    private static _MAX_VERTEX_HINT_PGI        := new HintTargetPGI($1A22D);
    
    public static property VERTEX_DATA_HINT_PGI:       HintTargetPGI read _VERTEX_DATA_HINT_PGI;
    public static property VERTEX_CONSISTENT_HINT_PGI: HintTargetPGI read _VERTEX_CONSISTENT_HINT_PGI;
    public static property MATERIAL_SIDE_HINT_PGI:     HintTargetPGI read _MATERIAL_SIDE_HINT_PGI;
    public static property MAX_VERTEX_HINT_PGI:        HintTargetPGI read _MAX_VERTEX_HINT_PGI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1A22A) then Result := 'VERTEX_DATA_HINT_PGI' else
      if self.val = UInt32($1A22B) then Result := 'VERTEX_CONSISTENT_HINT_PGI' else
      if self.val = UInt32($1A22C) then Result := 'MATERIAL_SIDE_HINT_PGI' else
      if self.val = UInt32($1A22D) then Result := 'MAX_VERTEX_HINT_PGI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion PGI}
  
  {$region SGI}
  
  ColorTableParameterPNameSGI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COLOR_TABLE_SCALE              := new ColorTableParameterPNameSGI($80D6);
    private static _COLOR_TABLE_SCALE_SGI          := new ColorTableParameterPNameSGI($80D6);
    private static _COLOR_TABLE_BIAS               := new ColorTableParameterPNameSGI($80D7);
    private static _COLOR_TABLE_BIAS_SGI           := new ColorTableParameterPNameSGI($80D7);
    private static _COLOR_TABLE_FORMAT             := new ColorTableParameterPNameSGI($80D8);
    private static _COLOR_TABLE_FORMAT_SGI         := new ColorTableParameterPNameSGI($80D8);
    private static _COLOR_TABLE_WIDTH              := new ColorTableParameterPNameSGI($80D9);
    private static _COLOR_TABLE_WIDTH_SGI          := new ColorTableParameterPNameSGI($80D9);
    private static _COLOR_TABLE_RED_SIZE           := new ColorTableParameterPNameSGI($80DA);
    private static _COLOR_TABLE_RED_SIZE_SGI       := new ColorTableParameterPNameSGI($80DA);
    private static _COLOR_TABLE_GREEN_SIZE         := new ColorTableParameterPNameSGI($80DB);
    private static _COLOR_TABLE_GREEN_SIZE_SGI     := new ColorTableParameterPNameSGI($80DB);
    private static _COLOR_TABLE_BLUE_SIZE          := new ColorTableParameterPNameSGI($80DC);
    private static _COLOR_TABLE_BLUE_SIZE_SGI      := new ColorTableParameterPNameSGI($80DC);
    private static _COLOR_TABLE_ALPHA_SIZE         := new ColorTableParameterPNameSGI($80DD);
    private static _COLOR_TABLE_ALPHA_SIZE_SGI     := new ColorTableParameterPNameSGI($80DD);
    private static _COLOR_TABLE_LUMINANCE_SIZE     := new ColorTableParameterPNameSGI($80DE);
    private static _COLOR_TABLE_LUMINANCE_SIZE_SGI := new ColorTableParameterPNameSGI($80DE);
    private static _COLOR_TABLE_INTENSITY_SIZE     := new ColorTableParameterPNameSGI($80DF);
    private static _COLOR_TABLE_INTENSITY_SIZE_SGI := new ColorTableParameterPNameSGI($80DF);
    
    public static property COLOR_TABLE_SCALE:              ColorTableParameterPNameSGI read _COLOR_TABLE_SCALE;
    public static property COLOR_TABLE_SCALE_SGI:          ColorTableParameterPNameSGI read _COLOR_TABLE_SCALE_SGI;
    public static property COLOR_TABLE_BIAS:               ColorTableParameterPNameSGI read _COLOR_TABLE_BIAS;
    public static property COLOR_TABLE_BIAS_SGI:           ColorTableParameterPNameSGI read _COLOR_TABLE_BIAS_SGI;
    public static property COLOR_TABLE_FORMAT:             ColorTableParameterPNameSGI read _COLOR_TABLE_FORMAT;
    public static property COLOR_TABLE_FORMAT_SGI:         ColorTableParameterPNameSGI read _COLOR_TABLE_FORMAT_SGI;
    public static property COLOR_TABLE_WIDTH:              ColorTableParameterPNameSGI read _COLOR_TABLE_WIDTH;
    public static property COLOR_TABLE_WIDTH_SGI:          ColorTableParameterPNameSGI read _COLOR_TABLE_WIDTH_SGI;
    public static property COLOR_TABLE_RED_SIZE:           ColorTableParameterPNameSGI read _COLOR_TABLE_RED_SIZE;
    public static property COLOR_TABLE_RED_SIZE_SGI:       ColorTableParameterPNameSGI read _COLOR_TABLE_RED_SIZE_SGI;
    public static property COLOR_TABLE_GREEN_SIZE:         ColorTableParameterPNameSGI read _COLOR_TABLE_GREEN_SIZE;
    public static property COLOR_TABLE_GREEN_SIZE_SGI:     ColorTableParameterPNameSGI read _COLOR_TABLE_GREEN_SIZE_SGI;
    public static property COLOR_TABLE_BLUE_SIZE:          ColorTableParameterPNameSGI read _COLOR_TABLE_BLUE_SIZE;
    public static property COLOR_TABLE_BLUE_SIZE_SGI:      ColorTableParameterPNameSGI read _COLOR_TABLE_BLUE_SIZE_SGI;
    public static property COLOR_TABLE_ALPHA_SIZE:         ColorTableParameterPNameSGI read _COLOR_TABLE_ALPHA_SIZE;
    public static property COLOR_TABLE_ALPHA_SIZE_SGI:     ColorTableParameterPNameSGI read _COLOR_TABLE_ALPHA_SIZE_SGI;
    public static property COLOR_TABLE_LUMINANCE_SIZE:     ColorTableParameterPNameSGI read _COLOR_TABLE_LUMINANCE_SIZE;
    public static property COLOR_TABLE_LUMINANCE_SIZE_SGI: ColorTableParameterPNameSGI read _COLOR_TABLE_LUMINANCE_SIZE_SGI;
    public static property COLOR_TABLE_INTENSITY_SIZE:     ColorTableParameterPNameSGI read _COLOR_TABLE_INTENSITY_SIZE;
    public static property COLOR_TABLE_INTENSITY_SIZE_SGI: ColorTableParameterPNameSGI read _COLOR_TABLE_INTENSITY_SIZE_SGI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80D6) then Result := 'COLOR_TABLE_SCALE' else
      if self.val = UInt32($80D6) then Result := 'COLOR_TABLE_SCALE_SGI' else
      if self.val = UInt32($80D7) then Result := 'COLOR_TABLE_BIAS' else
      if self.val = UInt32($80D7) then Result := 'COLOR_TABLE_BIAS_SGI' else
      if self.val = UInt32($80D8) then Result := 'COLOR_TABLE_FORMAT' else
      if self.val = UInt32($80D8) then Result := 'COLOR_TABLE_FORMAT_SGI' else
      if self.val = UInt32($80D9) then Result := 'COLOR_TABLE_WIDTH' else
      if self.val = UInt32($80D9) then Result := 'COLOR_TABLE_WIDTH_SGI' else
      if self.val = UInt32($80DA) then Result := 'COLOR_TABLE_RED_SIZE' else
      if self.val = UInt32($80DA) then Result := 'COLOR_TABLE_RED_SIZE_SGI' else
      if self.val = UInt32($80DB) then Result := 'COLOR_TABLE_GREEN_SIZE' else
      if self.val = UInt32($80DB) then Result := 'COLOR_TABLE_GREEN_SIZE_SGI' else
      if self.val = UInt32($80DC) then Result := 'COLOR_TABLE_BLUE_SIZE' else
      if self.val = UInt32($80DC) then Result := 'COLOR_TABLE_BLUE_SIZE_SGI' else
      if self.val = UInt32($80DD) then Result := 'COLOR_TABLE_ALPHA_SIZE' else
      if self.val = UInt32($80DD) then Result := 'COLOR_TABLE_ALPHA_SIZE_SGI' else
      if self.val = UInt32($80DE) then Result := 'COLOR_TABLE_LUMINANCE_SIZE' else
      if self.val = UInt32($80DE) then Result := 'COLOR_TABLE_LUMINANCE_SIZE_SGI' else
      if self.val = UInt32($80DF) then Result := 'COLOR_TABLE_INTENSITY_SIZE' else
      if self.val = UInt32($80DF) then Result := 'COLOR_TABLE_INTENSITY_SIZE_SGI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  ColorTableTargetSGI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_COLOR_TABLE_SGI                 := new ColorTableTargetSGI($80BC);
    private static _PROXY_TEXTURE_COLOR_TABLE_SGI           := new ColorTableTargetSGI($80BD);
    private static _COLOR_TABLE                             := new ColorTableTargetSGI($80D0);
    private static _COLOR_TABLE_SGI                         := new ColorTableTargetSGI($80D0);
    private static _POST_CONVOLUTION_COLOR_TABLE            := new ColorTableTargetSGI($80D1);
    private static _POST_CONVOLUTION_COLOR_TABLE_SGI        := new ColorTableTargetSGI($80D1);
    private static _POST_COLOR_MATRIX_COLOR_TABLE           := new ColorTableTargetSGI($80D2);
    private static _POST_COLOR_MATRIX_COLOR_TABLE_SGI       := new ColorTableTargetSGI($80D2);
    private static _PROXY_COLOR_TABLE                       := new ColorTableTargetSGI($80D3);
    private static _PROXY_COLOR_TABLE_SGI                   := new ColorTableTargetSGI($80D3);
    private static _PROXY_POST_CONVOLUTION_COLOR_TABLE      := new ColorTableTargetSGI($80D4);
    private static _PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI  := new ColorTableTargetSGI($80D4);
    private static _PROXY_POST_COLOR_MATRIX_COLOR_TABLE     := new ColorTableTargetSGI($80D5);
    private static _PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI := new ColorTableTargetSGI($80D5);
    
    public static property TEXTURE_COLOR_TABLE_SGI:                 ColorTableTargetSGI read _TEXTURE_COLOR_TABLE_SGI;
    public static property PROXY_TEXTURE_COLOR_TABLE_SGI:           ColorTableTargetSGI read _PROXY_TEXTURE_COLOR_TABLE_SGI;
    public static property COLOR_TABLE:                             ColorTableTargetSGI read _COLOR_TABLE;
    public static property COLOR_TABLE_SGI:                         ColorTableTargetSGI read _COLOR_TABLE_SGI;
    public static property POST_CONVOLUTION_COLOR_TABLE:            ColorTableTargetSGI read _POST_CONVOLUTION_COLOR_TABLE;
    public static property POST_CONVOLUTION_COLOR_TABLE_SGI:        ColorTableTargetSGI read _POST_CONVOLUTION_COLOR_TABLE_SGI;
    public static property POST_COLOR_MATRIX_COLOR_TABLE:           ColorTableTargetSGI read _POST_COLOR_MATRIX_COLOR_TABLE;
    public static property POST_COLOR_MATRIX_COLOR_TABLE_SGI:       ColorTableTargetSGI read _POST_COLOR_MATRIX_COLOR_TABLE_SGI;
    public static property PROXY_COLOR_TABLE:                       ColorTableTargetSGI read _PROXY_COLOR_TABLE;
    public static property PROXY_COLOR_TABLE_SGI:                   ColorTableTargetSGI read _PROXY_COLOR_TABLE_SGI;
    public static property PROXY_POST_CONVOLUTION_COLOR_TABLE:      ColorTableTargetSGI read _PROXY_POST_CONVOLUTION_COLOR_TABLE;
    public static property PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI:  ColorTableTargetSGI read _PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI;
    public static property PROXY_POST_COLOR_MATRIX_COLOR_TABLE:     ColorTableTargetSGI read _PROXY_POST_COLOR_MATRIX_COLOR_TABLE;
    public static property PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI: ColorTableTargetSGI read _PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80BC) then Result := 'TEXTURE_COLOR_TABLE_SGI' else
      if self.val = UInt32($80BD) then Result := 'PROXY_TEXTURE_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE' else
      if self.val = UInt32($80D0) then Result := 'COLOR_TABLE_SGI' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE' else
      if self.val = UInt32($80D1) then Result := 'POST_CONVOLUTION_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE' else
      if self.val = UInt32($80D2) then Result := 'POST_COLOR_MATRIX_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D3) then Result := 'PROXY_COLOR_TABLE' else
      if self.val = UInt32($80D3) then Result := 'PROXY_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D4) then Result := 'PROXY_POST_CONVOLUTION_COLOR_TABLE' else
      if self.val = UInt32($80D4) then Result := 'PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI' else
      if self.val = UInt32($80D5) then Result := 'PROXY_POST_COLOR_MATRIX_COLOR_TABLE' else
      if self.val = UInt32($80D5) then Result := 'PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  GetColorTableParameterPNameSGI = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _COLOR_TABLE_SCALE              := new GetColorTableParameterPNameSGI($80D6);
    private static _COLOR_TABLE_SCALE_SGI          := new GetColorTableParameterPNameSGI($80D6);
    private static _COLOR_TABLE_BIAS               := new GetColorTableParameterPNameSGI($80D7);
    private static _COLOR_TABLE_BIAS_SGI           := new GetColorTableParameterPNameSGI($80D7);
    private static _COLOR_TABLE_FORMAT             := new GetColorTableParameterPNameSGI($80D8);
    private static _COLOR_TABLE_FORMAT_SGI         := new GetColorTableParameterPNameSGI($80D8);
    private static _COLOR_TABLE_WIDTH              := new GetColorTableParameterPNameSGI($80D9);
    private static _COLOR_TABLE_WIDTH_SGI          := new GetColorTableParameterPNameSGI($80D9);
    private static _COLOR_TABLE_RED_SIZE           := new GetColorTableParameterPNameSGI($80DA);
    private static _COLOR_TABLE_RED_SIZE_SGI       := new GetColorTableParameterPNameSGI($80DA);
    private static _COLOR_TABLE_GREEN_SIZE         := new GetColorTableParameterPNameSGI($80DB);
    private static _COLOR_TABLE_GREEN_SIZE_SGI     := new GetColorTableParameterPNameSGI($80DB);
    private static _COLOR_TABLE_BLUE_SIZE          := new GetColorTableParameterPNameSGI($80DC);
    private static _COLOR_TABLE_BLUE_SIZE_SGI      := new GetColorTableParameterPNameSGI($80DC);
    private static _COLOR_TABLE_ALPHA_SIZE         := new GetColorTableParameterPNameSGI($80DD);
    private static _COLOR_TABLE_ALPHA_SIZE_SGI     := new GetColorTableParameterPNameSGI($80DD);
    private static _COLOR_TABLE_LUMINANCE_SIZE     := new GetColorTableParameterPNameSGI($80DE);
    private static _COLOR_TABLE_LUMINANCE_SIZE_SGI := new GetColorTableParameterPNameSGI($80DE);
    private static _COLOR_TABLE_INTENSITY_SIZE     := new GetColorTableParameterPNameSGI($80DF);
    private static _COLOR_TABLE_INTENSITY_SIZE_SGI := new GetColorTableParameterPNameSGI($80DF);
    
    public static property COLOR_TABLE_SCALE:              GetColorTableParameterPNameSGI read _COLOR_TABLE_SCALE;
    public static property COLOR_TABLE_SCALE_SGI:          GetColorTableParameterPNameSGI read _COLOR_TABLE_SCALE_SGI;
    public static property COLOR_TABLE_BIAS:               GetColorTableParameterPNameSGI read _COLOR_TABLE_BIAS;
    public static property COLOR_TABLE_BIAS_SGI:           GetColorTableParameterPNameSGI read _COLOR_TABLE_BIAS_SGI;
    public static property COLOR_TABLE_FORMAT:             GetColorTableParameterPNameSGI read _COLOR_TABLE_FORMAT;
    public static property COLOR_TABLE_FORMAT_SGI:         GetColorTableParameterPNameSGI read _COLOR_TABLE_FORMAT_SGI;
    public static property COLOR_TABLE_WIDTH:              GetColorTableParameterPNameSGI read _COLOR_TABLE_WIDTH;
    public static property COLOR_TABLE_WIDTH_SGI:          GetColorTableParameterPNameSGI read _COLOR_TABLE_WIDTH_SGI;
    public static property COLOR_TABLE_RED_SIZE:           GetColorTableParameterPNameSGI read _COLOR_TABLE_RED_SIZE;
    public static property COLOR_TABLE_RED_SIZE_SGI:       GetColorTableParameterPNameSGI read _COLOR_TABLE_RED_SIZE_SGI;
    public static property COLOR_TABLE_GREEN_SIZE:         GetColorTableParameterPNameSGI read _COLOR_TABLE_GREEN_SIZE;
    public static property COLOR_TABLE_GREEN_SIZE_SGI:     GetColorTableParameterPNameSGI read _COLOR_TABLE_GREEN_SIZE_SGI;
    public static property COLOR_TABLE_BLUE_SIZE:          GetColorTableParameterPNameSGI read _COLOR_TABLE_BLUE_SIZE;
    public static property COLOR_TABLE_BLUE_SIZE_SGI:      GetColorTableParameterPNameSGI read _COLOR_TABLE_BLUE_SIZE_SGI;
    public static property COLOR_TABLE_ALPHA_SIZE:         GetColorTableParameterPNameSGI read _COLOR_TABLE_ALPHA_SIZE;
    public static property COLOR_TABLE_ALPHA_SIZE_SGI:     GetColorTableParameterPNameSGI read _COLOR_TABLE_ALPHA_SIZE_SGI;
    public static property COLOR_TABLE_LUMINANCE_SIZE:     GetColorTableParameterPNameSGI read _COLOR_TABLE_LUMINANCE_SIZE;
    public static property COLOR_TABLE_LUMINANCE_SIZE_SGI: GetColorTableParameterPNameSGI read _COLOR_TABLE_LUMINANCE_SIZE_SGI;
    public static property COLOR_TABLE_INTENSITY_SIZE:     GetColorTableParameterPNameSGI read _COLOR_TABLE_INTENSITY_SIZE;
    public static property COLOR_TABLE_INTENSITY_SIZE_SGI: GetColorTableParameterPNameSGI read _COLOR_TABLE_INTENSITY_SIZE_SGI;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80D6) then Result := 'COLOR_TABLE_SCALE' else
      if self.val = UInt32($80D6) then Result := 'COLOR_TABLE_SCALE_SGI' else
      if self.val = UInt32($80D7) then Result := 'COLOR_TABLE_BIAS' else
      if self.val = UInt32($80D7) then Result := 'COLOR_TABLE_BIAS_SGI' else
      if self.val = UInt32($80D8) then Result := 'COLOR_TABLE_FORMAT' else
      if self.val = UInt32($80D8) then Result := 'COLOR_TABLE_FORMAT_SGI' else
      if self.val = UInt32($80D9) then Result := 'COLOR_TABLE_WIDTH' else
      if self.val = UInt32($80D9) then Result := 'COLOR_TABLE_WIDTH_SGI' else
      if self.val = UInt32($80DA) then Result := 'COLOR_TABLE_RED_SIZE' else
      if self.val = UInt32($80DA) then Result := 'COLOR_TABLE_RED_SIZE_SGI' else
      if self.val = UInt32($80DB) then Result := 'COLOR_TABLE_GREEN_SIZE' else
      if self.val = UInt32($80DB) then Result := 'COLOR_TABLE_GREEN_SIZE_SGI' else
      if self.val = UInt32($80DC) then Result := 'COLOR_TABLE_BLUE_SIZE' else
      if self.val = UInt32($80DC) then Result := 'COLOR_TABLE_BLUE_SIZE_SGI' else
      if self.val = UInt32($80DD) then Result := 'COLOR_TABLE_ALPHA_SIZE' else
      if self.val = UInt32($80DD) then Result := 'COLOR_TABLE_ALPHA_SIZE_SGI' else
      if self.val = UInt32($80DE) then Result := 'COLOR_TABLE_LUMINANCE_SIZE' else
      if self.val = UInt32($80DE) then Result := 'COLOR_TABLE_LUMINANCE_SIZE_SGI' else
      if self.val = UInt32($80DF) then Result := 'COLOR_TABLE_INTENSITY_SIZE' else
      if self.val = UInt32($80DF) then Result := 'COLOR_TABLE_INTENSITY_SIZE_SGI' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion SGI}
  
  {$region SGIS}
  
  PixelTexGenParameterNameSGIS = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PIXEL_FRAGMENT_RGB_SOURCE_SGIS   := new PixelTexGenParameterNameSGIS($8354);
    private static _PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS := new PixelTexGenParameterNameSGIS($8355);
    
    public static property PIXEL_FRAGMENT_RGB_SOURCE_SGIS:   PixelTexGenParameterNameSGIS read _PIXEL_FRAGMENT_RGB_SOURCE_SGIS;
    public static property PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS: PixelTexGenParameterNameSGIS read _PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8354) then Result := 'PIXEL_FRAGMENT_RGB_SOURCE_SGIS' else
      if self.val = UInt32($8355) then Result := 'PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SamplePatternSGIS = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _GL_1PASS_EXT    := new SamplePatternSGIS($80A1);
    private static _GL_1PASS_SGIS   := new SamplePatternSGIS($80A1);
    private static _GL_2PASS_0_EXT  := new SamplePatternSGIS($80A2);
    private static _GL_2PASS_0_SGIS := new SamplePatternSGIS($80A2);
    private static _GL_2PASS_1_EXT  := new SamplePatternSGIS($80A3);
    private static _GL_2PASS_1_SGIS := new SamplePatternSGIS($80A3);
    private static _GL_4PASS_0_EXT  := new SamplePatternSGIS($80A4);
    private static _GL_4PASS_0_SGIS := new SamplePatternSGIS($80A4);
    private static _GL_4PASS_1_EXT  := new SamplePatternSGIS($80A5);
    private static _GL_4PASS_1_SGIS := new SamplePatternSGIS($80A5);
    private static _GL_4PASS_2_EXT  := new SamplePatternSGIS($80A6);
    private static _GL_4PASS_2_SGIS := new SamplePatternSGIS($80A6);
    private static _GL_4PASS_3_EXT  := new SamplePatternSGIS($80A7);
    private static _GL_4PASS_3_SGIS := new SamplePatternSGIS($80A7);
    
    public static property GL_1PASS_EXT:    SamplePatternSGIS read _GL_1PASS_EXT;
    public static property GL_1PASS_SGIS:   SamplePatternSGIS read _GL_1PASS_SGIS;
    public static property GL_2PASS_0_EXT:  SamplePatternSGIS read _GL_2PASS_0_EXT;
    public static property GL_2PASS_0_SGIS: SamplePatternSGIS read _GL_2PASS_0_SGIS;
    public static property GL_2PASS_1_EXT:  SamplePatternSGIS read _GL_2PASS_1_EXT;
    public static property GL_2PASS_1_SGIS: SamplePatternSGIS read _GL_2PASS_1_SGIS;
    public static property GL_4PASS_0_EXT:  SamplePatternSGIS read _GL_4PASS_0_EXT;
    public static property GL_4PASS_0_SGIS: SamplePatternSGIS read _GL_4PASS_0_SGIS;
    public static property GL_4PASS_1_EXT:  SamplePatternSGIS read _GL_4PASS_1_EXT;
    public static property GL_4PASS_1_SGIS: SamplePatternSGIS read _GL_4PASS_1_SGIS;
    public static property GL_4PASS_2_EXT:  SamplePatternSGIS read _GL_4PASS_2_EXT;
    public static property GL_4PASS_2_SGIS: SamplePatternSGIS read _GL_4PASS_2_SGIS;
    public static property GL_4PASS_3_EXT:  SamplePatternSGIS read _GL_4PASS_3_EXT;
    public static property GL_4PASS_3_SGIS: SamplePatternSGIS read _GL_4PASS_3_SGIS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($80A1) then Result := 'GL_1PASS_EXT' else
      if self.val = UInt32($80A1) then Result := 'GL_1PASS_SGIS' else
      if self.val = UInt32($80A2) then Result := 'GL_2PASS_0_EXT' else
      if self.val = UInt32($80A2) then Result := 'GL_2PASS_0_SGIS' else
      if self.val = UInt32($80A3) then Result := 'GL_2PASS_1_EXT' else
      if self.val = UInt32($80A3) then Result := 'GL_2PASS_1_SGIS' else
      if self.val = UInt32($80A4) then Result := 'GL_4PASS_0_EXT' else
      if self.val = UInt32($80A4) then Result := 'GL_4PASS_0_SGIS' else
      if self.val = UInt32($80A5) then Result := 'GL_4PASS_1_EXT' else
      if self.val = UInt32($80A5) then Result := 'GL_4PASS_1_SGIS' else
      if self.val = UInt32($80A6) then Result := 'GL_4PASS_2_EXT' else
      if self.val = UInt32($80A6) then Result := 'GL_4PASS_2_SGIS' else
      if self.val = UInt32($80A7) then Result := 'GL_4PASS_3_EXT' else
      if self.val = UInt32($80A7) then Result := 'GL_4PASS_3_SGIS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  TextureFilterSGIS = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FILTER4_SGIS := new TextureFilterSGIS($8146);
    
    public static property FILTER4_SGIS: TextureFilterSGIS read _FILTER4_SGIS;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8146) then Result := 'FILTER4_SGIS' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion SGIS}
  
  {$region SGIX}
  
  FfdMaskSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TEXTURE_DEFORMATION_BIT_SGIX  := new FfdMaskSGIX($0001);
    private static _GEOMETRY_DEFORMATION_BIT_SGIX := new FfdMaskSGIX($0002);
    
    public static property TEXTURE_DEFORMATION_BIT_SGIX:  FfdMaskSGIX read _TEXTURE_DEFORMATION_BIT_SGIX;
    public static property GEOMETRY_DEFORMATION_BIT_SGIX: FfdMaskSGIX read _GEOMETRY_DEFORMATION_BIT_SGIX;
    
    public static function operator or(f1,f2: FfdMaskSGIX) := new FfdMaskSGIX(f1.val or f2.val);
    
    public property HAS_FLAG_TEXTURE_DEFORMATION_BIT_SGIX:  boolean read self.val and $0001 <> 0;
    public property HAS_FLAG_GEOMETRY_DEFORMATION_BIT_SGIX: boolean read self.val and $0002 <> 0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      if self.val and UInt32($0001) = UInt32($0001) then res += 'TEXTURE_DEFORMATION_BIT_SGIX+';
      if self.val and UInt32($0002) = UInt32($0002) then res += 'GEOMETRY_DEFORMATION_BIT_SGIX+';
      if res.Length<>0 then
      begin
        res.Length -= 1;
        Result := res.ToString;
      end else
        Result := self.val.ToString;
    end;
    
  end;
  
  FfdTargetSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _GEOMETRY_DEFORMATION_SGIX := new FfdTargetSGIX($8194);
    private static _TEXTURE_DEFORMATION_SGIX  := new FfdTargetSGIX($8195);
    
    public static property GEOMETRY_DEFORMATION_SGIX: FfdTargetSGIX read _GEOMETRY_DEFORMATION_SGIX;
    public static property TEXTURE_DEFORMATION_SGIX:  FfdTargetSGIX read _TEXTURE_DEFORMATION_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8194) then Result := 'GEOMETRY_DEFORMATION_SGIX' else
      if self.val = UInt32($8195) then Result := 'TEXTURE_DEFORMATION_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FragmentLightModelParameterSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX         := new FragmentLightModelParameterSGIX($8408);
    private static _FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX             := new FragmentLightModelParameterSGIX($8409);
    private static _FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX              := new FragmentLightModelParameterSGIX($840A);
    private static _FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX := new FragmentLightModelParameterSGIX($840B);
    
    public static property FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX:         FragmentLightModelParameterSGIX read _FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX;
    public static property FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX:             FragmentLightModelParameterSGIX read _FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX;
    public static property FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX:              FragmentLightModelParameterSGIX read _FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX;
    public static property FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX: FragmentLightModelParameterSGIX read _FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8408) then Result := 'FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX' else
      if self.val = UInt32($8409) then Result := 'FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX' else
      if self.val = UInt32($840A) then Result := 'FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX' else
      if self.val = UInt32($840B) then Result := 'FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FragmentLightNameSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _FRAGMENT_LIGHT0_SGIX := new FragmentLightNameSGIX($840C);
    private static _FRAGMENT_LIGHT1_SGIX := new FragmentLightNameSGIX($840D);
    private static _FRAGMENT_LIGHT2_SGIX := new FragmentLightNameSGIX($840E);
    private static _FRAGMENT_LIGHT3_SGIX := new FragmentLightNameSGIX($840F);
    private static _FRAGMENT_LIGHT4_SGIX := new FragmentLightNameSGIX($8410);
    private static _FRAGMENT_LIGHT5_SGIX := new FragmentLightNameSGIX($8411);
    private static _FRAGMENT_LIGHT6_SGIX := new FragmentLightNameSGIX($8412);
    private static _FRAGMENT_LIGHT7_SGIX := new FragmentLightNameSGIX($8413);
    
    public static property FRAGMENT_LIGHT0_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT0_SGIX;
    public static property FRAGMENT_LIGHT1_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT1_SGIX;
    public static property FRAGMENT_LIGHT2_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT2_SGIX;
    public static property FRAGMENT_LIGHT3_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT3_SGIX;
    public static property FRAGMENT_LIGHT4_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT4_SGIX;
    public static property FRAGMENT_LIGHT5_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT5_SGIX;
    public static property FRAGMENT_LIGHT6_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT6_SGIX;
    public static property FRAGMENT_LIGHT7_SGIX: FragmentLightNameSGIX read _FRAGMENT_LIGHT7_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($840C) then Result := 'FRAGMENT_LIGHT0_SGIX' else
      if self.val = UInt32($840D) then Result := 'FRAGMENT_LIGHT1_SGIX' else
      if self.val = UInt32($840E) then Result := 'FRAGMENT_LIGHT2_SGIX' else
      if self.val = UInt32($840F) then Result := 'FRAGMENT_LIGHT3_SGIX' else
      if self.val = UInt32($8410) then Result := 'FRAGMENT_LIGHT4_SGIX' else
      if self.val = UInt32($8411) then Result := 'FRAGMENT_LIGHT5_SGIX' else
      if self.val = UInt32($8412) then Result := 'FRAGMENT_LIGHT6_SGIX' else
      if self.val = UInt32($8413) then Result := 'FRAGMENT_LIGHT7_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  FragmentLightParameterSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _AMBIENT               := new FragmentLightParameterSGIX($1200);
    private static _DIFFUSE               := new FragmentLightParameterSGIX($1201);
    private static _SPECULAR              := new FragmentLightParameterSGIX($1202);
    private static _POSITION              := new FragmentLightParameterSGIX($1203);
    private static _SPOT_DIRECTION        := new FragmentLightParameterSGIX($1204);
    private static _SPOT_EXPONENT         := new FragmentLightParameterSGIX($1205);
    private static _SPOT_CUTOFF           := new FragmentLightParameterSGIX($1206);
    private static _CONSTANT_ATTENUATION  := new FragmentLightParameterSGIX($1207);
    private static _LINEAR_ATTENUATION    := new FragmentLightParameterSGIX($1208);
    private static _QUADRATIC_ATTENUATION := new FragmentLightParameterSGIX($1209);
    
    public static property AMBIENT:               FragmentLightParameterSGIX read _AMBIENT;
    public static property DIFFUSE:               FragmentLightParameterSGIX read _DIFFUSE;
    public static property SPECULAR:              FragmentLightParameterSGIX read _SPECULAR;
    public static property POSITION:              FragmentLightParameterSGIX read _POSITION;
    public static property SPOT_DIRECTION:        FragmentLightParameterSGIX read _SPOT_DIRECTION;
    public static property SPOT_EXPONENT:         FragmentLightParameterSGIX read _SPOT_EXPONENT;
    public static property SPOT_CUTOFF:           FragmentLightParameterSGIX read _SPOT_CUTOFF;
    public static property CONSTANT_ATTENUATION:  FragmentLightParameterSGIX read _CONSTANT_ATTENUATION;
    public static property LINEAR_ATTENUATION:    FragmentLightParameterSGIX read _LINEAR_ATTENUATION;
    public static property QUADRATIC_ATTENUATION: FragmentLightParameterSGIX read _QUADRATIC_ATTENUATION;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1200) then Result := 'AMBIENT' else
      if self.val = UInt32($1201) then Result := 'DIFFUSE' else
      if self.val = UInt32($1202) then Result := 'SPECULAR' else
      if self.val = UInt32($1203) then Result := 'POSITION' else
      if self.val = UInt32($1204) then Result := 'SPOT_DIRECTION' else
      if self.val = UInt32($1205) then Result := 'SPOT_EXPONENT' else
      if self.val = UInt32($1206) then Result := 'SPOT_CUTOFF' else
      if self.val = UInt32($1207) then Result := 'CONSTANT_ATTENUATION' else
      if self.val = UInt32($1208) then Result := 'LINEAR_ATTENUATION' else
      if self.val = UInt32($1209) then Result := 'QUADRATIC_ATTENUATION' else
        Result := self.val.ToString;
    end;
    
  end;
  
  LightEnvParameterSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _LIGHT_ENV_MODE_SGIX := new LightEnvParameterSGIX($8407);
    
    public static property LIGHT_ENV_MODE_SGIX: LightEnvParameterSGIX read _LIGHT_ENV_MODE_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8407) then Result := 'LIGHT_ENV_MODE_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  PixelTexGenModeSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _PIXEL_TEX_GEN_Q_CEILING_SGIX := new PixelTexGenModeSGIX($8184);
    private static _PIXEL_TEX_GEN_Q_ROUND_SGIX   := new PixelTexGenModeSGIX($8185);
    private static _PIXEL_TEX_GEN_Q_FLOOR_SGIX   := new PixelTexGenModeSGIX($8186);
    private static _PIXEL_TEX_GEN_ALPHA_LS_SGIX  := new PixelTexGenModeSGIX($8189);
    private static _PIXEL_TEX_GEN_ALPHA_MS_SGIX  := new PixelTexGenModeSGIX($818A);
    
    public static property PIXEL_TEX_GEN_Q_CEILING_SGIX: PixelTexGenModeSGIX read _PIXEL_TEX_GEN_Q_CEILING_SGIX;
    public static property PIXEL_TEX_GEN_Q_ROUND_SGIX:   PixelTexGenModeSGIX read _PIXEL_TEX_GEN_Q_ROUND_SGIX;
    public static property PIXEL_TEX_GEN_Q_FLOOR_SGIX:   PixelTexGenModeSGIX read _PIXEL_TEX_GEN_Q_FLOOR_SGIX;
    public static property PIXEL_TEX_GEN_ALPHA_LS_SGIX:  PixelTexGenModeSGIX read _PIXEL_TEX_GEN_ALPHA_LS_SGIX;
    public static property PIXEL_TEX_GEN_ALPHA_MS_SGIX:  PixelTexGenModeSGIX read _PIXEL_TEX_GEN_ALPHA_MS_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8184) then Result := 'PIXEL_TEX_GEN_Q_CEILING_SGIX' else
      if self.val = UInt32($8185) then Result := 'PIXEL_TEX_GEN_Q_ROUND_SGIX' else
      if self.val = UInt32($8186) then Result := 'PIXEL_TEX_GEN_Q_FLOOR_SGIX' else
      if self.val = UInt32($8189) then Result := 'PIXEL_TEX_GEN_ALPHA_LS_SGIX' else
      if self.val = UInt32($818A) then Result := 'PIXEL_TEX_GEN_ALPHA_MS_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  SpriteParameterNameSGIX = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _SPRITE_MODE_SGIX := new SpriteParameterNameSGIX($8149);
    
    public static property SPRITE_MODE_SGIX: SpriteParameterNameSGIX read _SPRITE_MODE_SGIX;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($8149) then Result := 'SPRITE_MODE_SGIX' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion SGIX}
  
  {$region SUN}
  
  ReplacementCodeTypeSUN = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _UNSIGNED_BYTE  := new ReplacementCodeTypeSUN($1401);
    private static _UNSIGNED_SHORT := new ReplacementCodeTypeSUN($1403);
    private static _UNSIGNED_INT   := new ReplacementCodeTypeSUN($1405);
    
    public static property UNSIGNED_BYTE:  ReplacementCodeTypeSUN read _UNSIGNED_BYTE;
    public static property UNSIGNED_SHORT: ReplacementCodeTypeSUN read _UNSIGNED_SHORT;
    public static property UNSIGNED_INT:   ReplacementCodeTypeSUN read _UNSIGNED_INT;
    
    public function ToString: string; override;
    begin
      if self.val = UInt32($1401) then Result := 'UNSIGNED_BYTE' else
      if self.val = UInt32($1403) then Result := 'UNSIGNED_SHORT' else
      if self.val = UInt32($1405) then Result := 'UNSIGNED_INT' else
        Result := self.val.ToString;
    end;
    
  end;
  
  {$endregion SUN}
  
  
  