R
The OpenGL Graphics System:
A Specification
(Version 4.6 (Core Pro?le) - February 2, 2019)
Mark Segal
Kurt Akeley
Editor (version 1.1): Chris Frazier
Editor (versions 1.2-4.6 ): Jon Leech
Editor (version 2.0): Pat BrownCopyrightc 2006-2019 The Khronos Group Inc. All Rights Reserved.
This speci?cation is protected by copyright laws and contains material proprietary
to Khronos. Except as described by these terms, it or any components may not be
reproduced, republished, distributed, transmitted, displayed, broadcast or otherwise
exploited in any manner without the express prior written permission of Khronos.
This speci?cation has been created under the Khronos Intellectual Property Rights
Policy, which is Attachment A of the Khronos Group Membership Agreement
available at www.khronos.org/?les/member agreement.pdf. Khronos grants a con-
ditional copyright license to use and reproduce the unmodi?ed speci?cation for
any purpose, without fee or royalty, EXCEPT no licenses to any patent, trade-
mark or other intellectual property rights are granted under these terms. Parties
desiring to implement the speci?cation and make use of Khronos trademarks in
relation to that implementation, and receive reciprocal patent license protection
under the Khronos IP Policy must become Adopters and con?rm the implementa-
tion as conformant under the process de?ned by Khronos for this speci?cation; see
https://www.khronos.org/adopters.
Khronos makes no, and expressly disclaims any, representations or warranties, ex-
press or implied, regarding this speci?cation, including, without limitation: mer-
chantability, ?tness for a particular purpose, non-infringement of any intellectual
property, correctness, accuracy, completeness, timeliness, and reliability. Under no
circumstances will Khronos, or any of its Promoters, Contributors or Members, or
their respective partners, of?cers, directors, employees, agents or representatives be
liable for any damages, whether direct, indirect, special or consequential damages
for lost revenues, lost pro?ts, or otherwise, arising from or in connection with these
materials.
Vulkan and Khronos are registered trademarks, and WebGL and EGL are trade-
marks of The Khronos Group Inc. ASTC is a trademark of ARM Holdings PLC;
OpenCL is a trademark of Apple Inc.; and OpenGL is a registered trademark, and
the OpenGL ES and OpenGL SC logos are trademarks of Hewlett Packard Enter-
prise, all used under license by Khronos. All other product names, trademarks,
and/or company names are used solely for identi?cation and belong to their respec-
tive owners.Contents
1 Introduction 1
1.1 Formatting of the OpenGL Specification . . . . . . . . . . . . . . 1
1.1.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 What is the OpenGL Graphics System? . . . . . . . . . . . . . . 2
1.2.1 Programmer’s View of OpenGL . . . . . . . . . . . . . . 2
1.2.2 Implementor’s View of OpenGL . . . . . . . . . . . . . . 2
1.2.3 Our View . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2.4 Fixed-function Hardware and the Compatibility Pro?le . . 3
1.2.5 The Deprecation Model . . . . . . . . . . . . . . . . . . 3
1.3 Related APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.1 OpenGL Shading Language . . . . . . . . . . . . . . . . 4
1.3.2 OpenGL ES . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.3 OpenGL ES Shading Language . . . . . . . . . . . . . . 5
1.3.4 SPIR-V . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3.5 WebGL . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.3.6 Window System Bindings . . . . . . . . . . . . . . . . . 6
1.3.7 OpenCL . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.4 Filing Bug Reports . . . . . . . . . . . . . . . . . . . . . . . . . 7
2 OpenGL Fundamentals 8
2.1 Execution Model . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.2 Command Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.2.1 Data Conversion For State-Setting Commands . . . . . . 12
2.2.2 Data Conversions For State Query Commands . . . . . . 14
2.3 Command Execution . . . . . . . . . . . . . . . . . . . . . . . . 15
2.3.1 Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.3.2 Graphics Reset Recovery . . . . . . . . . . . . . . . . . . 19
2.3.3 Flush and Finish . . . . . . . . . . . . . . . . . . . . . . 20
iCONTENTS ii
2.3.4 Numeric Representation and Computation . . . . . . . . . 21
2.3.5 Fixed-Point Data Conversions . . . . . . . . . . . . . . . 24
2.4 Rendering Commands . . . . . . . . . . . . . . . . . . . . . . . 26
2.5 Context State . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.5.1 Generic Context State Queries . . . . . . . . . . . . . . . 27
2.6 Objects and the Object Model . . . . . . . . . . . . . . . . . . . 27
2.6.1 Object Management . . . . . . . . . . . . . . . . . . . . 28
2.6.2 Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . 29
2.6.3 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . 29
2.6.4 Program Objects . . . . . . . . . . . . . . . . . . . . . . 29
2.6.5 Program Pipeline Objects . . . . . . . . . . . . . . . . . 30
2.6.6 Texture Objects . . . . . . . . . . . . . . . . . . . . . . . 30
2.6.7 Sampler Objects . . . . . . . . . . . . . . . . . . . . . . 30
2.6.8 Renderbuffer Objects . . . . . . . . . . . . . . . . . . . . 31
2.6.9 Framebuffer Objects . . . . . . . . . . . . . . . . . . . . 31
2.6.10 Vertex Array Objects . . . . . . . . . . . . . . . . . . . . 31
2.6.11 Transform Feedback Objects . . . . . . . . . . . . . . . . 31
2.6.12 Query Objects . . . . . . . . . . . . . . . . . . . . . . . 32
2.6.13 Sync Objects . . . . . . . . . . . . . . . . . . . . . . . . 32
2.6.14 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3 Data?ow Model 33
4 Event Model 36
4.1 Sync Objects and Fences . . . . . . . . . . . . . . . . . . . . . . 36
4.1.1 Waiting for Sync Objects . . . . . . . . . . . . . . . . . . 38
4.1.2 Signaling . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.1.3 Sync Object Queries . . . . . . . . . . . . . . . . . . . . 41
4.2 Query Objects and Asynchronous Queries . . . . . . . . . . . . . 42
4.2.1 Query Object Types and Targets . . . . . . . . . . . . . . 42
4.2.2 Query Object Creation and Activation . . . . . . . . . . . 43
4.2.3 Query Object Queries . . . . . . . . . . . . . . . . . . . 47
4.3 Time Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
5 Shared Objects and Multiple Contexts 53
5.1 Object Deletion Behavior . . . . . . . . . . . . . . . . . . . . . . 54
5.1.1 Side Effects of Shared Context Destruction . . . . . . . . 54
5.1.2 Automatic Unbinding of Deleted Objects . . . . . . . . . 54
5.1.3 Deleted Object and Object Name Lifetimes . . . . . . . . 54
5.2 Sync Objects and Multiple Contexts . . . . . . . . . . . . . . . . 55
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS iii
5.3 Propagating Changes to Objects . . . . . . . . . . . . . . . . . . 55
5.3.1 Determining Completion of Changes to an object . . . . . 56
5.3.2 De?nitions . . . . . . . . . . . . . . . . . . . . . . . . . 57
5.3.3 Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
6 Buffer Objects 59
6.1 Creating and Binding Buffer Objects . . . . . . . . . . . . . . . . 60
6.1.1 Binding Buffer Objects to Indexed Targets . . . . . . . . . 62
6.2 Creating and Modifying Buffer Object Data Stores . . . . . . . . 65
6.2.1 Clearing Buffer Object Data Stores . . . . . . . . . . . . 71
6.3 Mapping and Unmapping Buffer Data . . . . . . . . . . . . . . . 73
6.3.1 Unmapping Buffers . . . . . . . . . . . . . . . . . . . . . 78
6.3.2 Effects of Mapping Buffers on Other GL Commands . . . 79
6.4 Effects of Accessing Outside Buffer Bounds . . . . . . . . . . . . 79
6.5 Invalidating Buffer Data . . . . . . . . . . . . . . . . . . . . . . 80
6.6 Copying Between Buffers . . . . . . . . . . . . . . . . . . . . . . 80
6.7 Buffer Object Queries . . . . . . . . . . . . . . . . . . . . . . . . 81
6.7.1 Indexed Buffer Object Limits and Binding Queries . . . . 83
6.8 Buffer Object State . . . . . . . . . . . . . . . . . . . . . . . . . 84
7 Programs and Shaders 87
7.1 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
7.2 Shader Binaries . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
7.2.1 Shader Specialization . . . . . . . . . . . . . . . . . . . . 93
7.3 Program Objects . . . . . . . . . . . . . . . . . . . . . . . . . . 94
7.3.1 Program Interfaces . . . . . . . . . . . . . . . . . . . . . 102
7.4 Program Pipeline Objects . . . . . . . . . . . . . . . . . . . . . . 121
7.4.1 Shader Interface Matching . . . . . . . . . . . . . . . . . 125
7.4.2 SPIR-V Shader Interface Matching . . . . . . . . . . . . 128
7.4.3 Program Pipeline Object State . . . . . . . . . . . . . . . 129
7.5 Program Binaries . . . . . . . . . . . . . . . . . . . . . . . . . . 130
7.6 Uniform Variables . . . . . . . . . . . . . . . . . . . . . . . . . . 132
7.6.1 Loading Uniform Variables In The Default Uniform Block 138
7.6.2 Uniform Blocks . . . . . . . . . . . . . . . . . . . . . . . 144
7.6.3 Uniform Buffer Object Bindings . . . . . . . . . . . . . . 149
7.7 Atomic Counter Buffers . . . . . . . . . . . . . . . . . . . . . . . 150
7.7.1 Atomic Counter Buffer Object Storage . . . . . . . . . . 150
7.7.2 Atomic Counter Buffer Bindings . . . . . . . . . . . . . . 150
7.8 Shader Buffer Variables and Shader Storage Blocks . . . . . . . . 151
7.9 Invocation Groups . . . . . . . . . . . . . . . . . . . . . . . . . . 153
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS iv
7.10 Subroutine Uniform Variables . . . . . . . . . . . . . . . . . . . 154
7.11 Samplers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
7.12 Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
7.13 Shader Memory Access . . . . . . . . . . . . . . . . . . . . . . . 159
7.13.1 Shader Memory Access Ordering . . . . . . . . . . . . . 159
7.13.2 Shader Memory Access Synchronization . . . . . . . . . 161
7.14 Shader, Program, and Program Pipeline Queries . . . . . . . . . . 166
7.15 Required State . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
8 Textures and Samplers 178
8.1 Texture Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
8.2 Sampler Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
8.3 Sampler Object Queries . . . . . . . . . . . . . . . . . . . . . . . 188
8.4 Pixel Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
8.4.1 Pixel Storage Modes and Pixel Buffer Objects . . . . . . . 189
8.4.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.4.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.4.4 Transfer of Pixel Rectangles . . . . . . . . . . . . . . . . 190
8.4.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
8.5 Texture Image Specification . . . . . . . . . . . . . . . . . . . . 203
8.5.1 Required Texture Formats . . . . . . . . . . . . . . . . . 206
8.5.2 Encoding of Special Internal Formats . . . . . . . . . . . 207
8.5.3 Texture Image Structure . . . . . . . . . . . . . . . . . . 211
8.6 Alternate Texture Image Specification Commands . . . . . . . . . 218
8.6.1 Texture Copying Feedback Loops . . . . . . . . . . . . . 226
8.7 Compressed Texture Images . . . . . . . . . . . . . . . . . . . . 226
8.8 Multisample Textures . . . . . . . . . . . . . . . . . . . . . . . . 233
8.9 Buffer Textures . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
8.10 Texture Parameters . . . . . . . . . . . . . . . . . . . . . . . . . 239
8.11 Texture Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
8.11.1 Active Texture . . . . . . . . . . . . . . . . . . . . . . . 242
8.11.2 Texture Parameter Queries . . . . . . . . . . . . . . . . . 243
8.11.3 Texture Level Parameter Queries . . . . . . . . . . . . . . 244
8.11.4 Texture Image Queries . . . . . . . . . . . . . . . . . . . 246
8.12 Depth Component Textures . . . . . . . . . . . . . . . . . . . . . 253
8.13 Cube Map Texture Selection . . . . . . . . . . . . . . . . . . . . 253
8.13.1 Seamless Cube Map Filtering . . . . . . . . . . . . . . . 254
8.14 Texture Minification . . . . . . . . . . . . . . . . . . . . . . . . 255
8.14.1 Scale Factor and Level-of-Detail . . . . . . . . . . . . . . 257
8.14.2 Coordinate Wrapping and Texel Selection . . . . . . . . . 260
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS v
8.14.3 Mipmapping . . . . . . . . . . . . . . . . . . . . . . . . 265
8.14.4 Manual Mipmap Generation . . . . . . . . . . . . . . . . 267
8.14.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
8.15 Texture Magnification . . . . . . . . . . . . . . . . . . . . . . . . 268
8.16 Combined Depth/Stencil Textures . . . . . . . . . . . . . . . . . 269
8.17 Texture Completeness . . . . . . . . . . . . . . . . . . . . . . . . 269
8.17.1 Effects of Sampler Objects on Texture Completeness . . . 270
8.17.2 Effects of Completeness on Texture Application . . . . . . 271
8.17.3 Effects of Completeness on Texture Image Specification . 271
8.18 Texture Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
8.19 Immutable-Format Texture Images . . . . . . . . . . . . . . . . . 275
8.19.1 Behavior of Immutable-Format Texture Images . . . . . . 282
8.20 Invalidating Texture Image Data . . . . . . . . . . . . . . . . . . 282
8.21 Clearing Texture Image Data . . . . . . . . . . . . . . . . . . . . 283
8.22 Texture State and Proxy State . . . . . . . . . . . . . . . . . . . . 285
8.23 Texture Comparison Modes . . . . . . . . . . . . . . . . . . . . . 288
8.23.1 Depth Texture Comparison Mode . . . . . . . . . . . . . 288
8.24 sRGB Texture Color Conversion . . . . . . . . . . . . . . . . . . 289
8.25 Shared Exponent Texture Color Conversion . . . . . . . . . . . . 290
8.26 Texture Image Loads and Stores . . . . . . . . . . . . . . . . . . 290
8.26.1 Image Unit Queries . . . . . . . . . . . . . . . . . . . . . 299
9 Framebuffers and Framebuffer Objects 300
9.1 Framebuffer Overview . . . . . . . . . . . . . . . . . . . . . . . 300
9.2 Binding and Managing Framebuffer Objects . . . . . . . . . . . . 302
9.2.1 Framebuffer Object Parameters . . . . . . . . . . . . . . 306
9.2.2 Attaching Images to Framebuffer Objects . . . . . . . . . 307
9.2.3 Framebuffer Object Queries . . . . . . . . . . . . . . . . 308
9.2.4 Renderbuffer Objects . . . . . . . . . . . . . . . . . . . . 313
9.2.5 Required Renderbuffer Formats . . . . . . . . . . . . . . 317
9.2.6 Renderbuffer Object Queries . . . . . . . . . . . . . . . . 318
9.2.7 Attaching Renderbuffer Images to a Framebuffer . . . . . 318
9.2.8 Attaching Texture Images to a Framebuffer . . . . . . . . 320
9.3 Feedback Loops Between Textures and the Framebuffer . . . . . . 326
9.3.1 Rendering Feedback Loops . . . . . . . . . . . . . . . . . 326
9.3.2 Texture Copying Feedback Loops . . . . . . . . . . . . . 327
9.4 Framebuffer Completeness . . . . . . . . . . . . . . . . . . . . . 328
9.4.1 Framebuffer Attachment Completeness . . . . . . . . . . 329
9.4.2 Whole Framebuffer Completeness . . . . . . . . . . . . . 330
9.4.3 Required Framebuffer Formats . . . . . . . . . . . . . . . 333
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS vi
9.4.4 Effects of Framebuffer Completeness on Framebuffer Op-
erations . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
9.4.5 Effects of Framebuffer State on Framebuffer Dependent
Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
9.5 Mapping between Pixel and Element in Attached Image . . . . . . 334
9.6 Conversion to Framebuffer-Attachable Image Components . . . . 335
9.7 Conversion to RGBA Values . . . . . . . . . . . . . . . . . . . . 335
9.8 Layered Framebuffers . . . . . . . . . . . . . . . . . . . . . . . . 336
10 Vertex Specification and Drawing Commands 338
10.1 Primitive Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
10.1.1 Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
10.1.2 Line Strips . . . . . . . . . . . . . . . . . . . . . . . . . 340
10.1.3 Line Loops . . . . . . . . . . . . . . . . . . . . . . . . . 340
10.1.4 Separate Lines . . . . . . . . . . . . . . . . . . . . . . . 340
10.1.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
10.1.6 Triangle Strips . . . . . . . . . . . . . . . . . . . . . . . 341
10.1.7 Triangle Fans . . . . . . . . . . . . . . . . . . . . . . . . 342
10.1.8 Separate Triangles . . . . . . . . . . . . . . . . . . . . . 342
10.1.9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
10.1.10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
10.1.11 Lines with Adjacency . . . . . . . . . . . . . . . . . . . 342
10.1.12 Line Strips with Adjacency . . . . . . . . . . . . . . . . . 344
10.1.13 Triangles with Adjacency . . . . . . . . . . . . . . . . . 344
10.1.14 Triangle Strips with Adjacency . . . . . . . . . . . . . . . 345
10.1.15 Separate Patches . . . . . . . . . . . . . . . . . . . . . . 346
10.1.16 General Considerations For Polygon Primitives . . . . . . 347
10.1.17 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
10.2 Current Vertex Attribute Values . . . . . . . . . . . . . . . . . . . 347
10.2.1 Current Generic Attributes . . . . . . . . . . . . . . . . . 347
10.2.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
10.2.3 Vertex Attribute Queries . . . . . . . . . . . . . . . . . . 350
10.2.4 Required State . . . . . . . . . . . . . . . . . . . . . . . 350
10.3 Vertex Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
10.3.1 Vertex Array Objects . . . . . . . . . . . . . . . . . . . . 350
10.3.2 Specifying Arrays for Generic Vertex Attributes . . . . . . 352
10.3.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
10.3.4 Vertex Attribute Divisors . . . . . . . . . . . . . . . . . . 360
10.3.5 Transferring Array Elements . . . . . . . . . . . . . . . . 361
10.3.6 Primitive Restart . . . . . . . . . . . . . . . . . . . . . . 361
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS vii
10.3.7 Robust Buffer Access . . . . . . . . . . . . . . . . . . . . 362
10.3.8 Packed Vertex Data Formats . . . . . . . . . . . . . . . . 362
10.3.9 Vertex Arrays in Buffer Objects . . . . . . . . . . . . . . 363
10.3.10 Array Indices in Buffer Objects . . . . . . . . . . . . . . 364
10.3.11 Indirect Commands in Buffer Objects . . . . . . . . . . . 365
10.4 Drawing Commands Using Vertex Arrays . . . . . . . . . . . . . 365
10.4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377
10.5 Vertex Array and Vertex Array Object Queries . . . . . . . . . . . 377
10.6 Required State . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
10.7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381
10.8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381
10.9 Conditional Rendering . . . . . . . . . . . . . . . . . . . . . . . 381
10.10 Submission Queries . . . . . . . . . . . . . . . . . . . . . . . . . 383
11 Programmable Vertex Processing 384
11.1 Vertex Shaders . . . . . . . . . . . . . . . . . . . . . . . . . . . 384
11.1.1 Vertex Attributes . . . . . . . . . . . . . . . . . . . . . . 384
11.1.2 Vertex Shader Variables . . . . . . . . . . . . . . . . . . 390
11.1.3 Shader Execution . . . . . . . . . . . . . . . . . . . . . . 396
11.1.4 Vertex Shader Queries . . . . . . . . . . . . . . . . . . . 409
11.2 Tessellation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
11.2.1 Tessellation Control Shaders . . . . . . . . . . . . . . . . 410
11.2.2 Tessellation Primitive Generation . . . . . . . . . . . . . 415
11.2.3 Tessellation Evaluation Shaders . . . . . . . . . . . . . . 424
11.2.4 Tessellation Shader Queries . . . . . . . . . . . . . . . . 429
11.3 Geometry Shaders . . . . . . . . . . . . . . . . . . . . . . . . . . 430
11.3.1 Geometry Shader Input Primitives . . . . . . . . . . . . . 430
11.3.2 Geometry Shader Output Primitives . . . . . . . . . . . . 432
11.3.3 Geometry Shader Variables . . . . . . . . . . . . . . . . . 433
11.3.4 Geometry Shader Execution Environment . . . . . . . . . 433
11.3.5 Geometry Shader Queries . . . . . . . . . . . . . . . . . 439
12 440
13 Fixed-Function Vertex Post-Processing 441
13.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
13.2 The Last Vertex Processing Stage . . . . . . . . . . . . . . . . . . 442
13.3 Transform Feedback . . . . . . . . . . . . . . . . . . . . . . . . 442
13.3.1 Transform Feedback Objects . . . . . . . . . . . . . . . . 442
13.3.2 Transform Feedback Primitive Capture . . . . . . . . . . 444
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS viii
13.3.3 Transform Feedback Draw Operations . . . . . . . . . . . 450
13.4 Primitive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . 451
13.5 Transform Feedback Over?ow Queries . . . . . . . . . . . . . . . 452
13.6 Flatshading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
13.7 Primitive Clipping . . . . . . . . . . . . . . . . . . . . . . . . . . 453
13.7.1 Clipping Shader Outputs . . . . . . . . . . . . . . . . . . 456
13.7.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
13.7.3 Primitive Clipping Queries . . . . . . . . . . . . . . . . . 457
13.8 Coordinate Transformations . . . . . . . . . . . . . . . . . . . . 457
13.8.1 Controlling the Viewport . . . . . . . . . . . . . . . . . . 458
13.9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 461
14 Fixed-Function Primitive Assembly and Rasterization 462
14.1 Discarding Primitives Before Rasterization . . . . . . . . . . . . 464
14.2 Invariance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464
14.3 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464
14.3.1 Multisampling . . . . . . . . . . . . . . . . . . . . . . . 466
14.4 Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
14.4.1 Basic Point Rasterization . . . . . . . . . . . . . . . . . . 470
14.4.2 Point Rasterization State . . . . . . . . . . . . . . . . . . 470
14.4.3 Point Multisample Rasterization . . . . . . . . . . . . . . 471
14.5 Line Segments . . . . . . . . . . . . . . . . . . . . . . . . . . . 471
14.5.1 Basic Line Segment Rasterization . . . . . . . . . . . . . 471
14.5.2 Other Line Segment Features . . . . . . . . . . . . . . . . 474
14.5.3 Line Rasterization State . . . . . . . . . . . . . . . . . . 476
14.5.4 Line Multisample Rasterization . . . . . . . . . . . . . . 476
14.6 Polygons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
14.6.1 Basic Polygon Rasterization . . . . . . . . . . . . . . . . 477
14.6.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480
14.6.3 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . 480
14.6.4 Options Controlling Polygon Rasterization . . . . . . . . 480
14.6.5 Depth Offset . . . . . . . . . . . . . . . . . . . . . . . . 480
14.6.6 Polygon Multisample Rasterization . . . . . . . . . . . . 482
14.6.7 Polygon Rasterization State . . . . . . . . . . . . . . . . 483
14.7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
14.8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
14.9 Early Per-Fragment Tests . . . . . . . . . . . . . . . . . . . . . . 483
14.9.1 Pixel Ownership Test . . . . . . . . . . . . . . . . . . . . 484
14.9.2 Scissor Test . . . . . . . . . . . . . . . . . . . . . . . . . 484
14.9.3 Multisample Fragment Operations . . . . . . . . . . . . . 486
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS ix
14.9.4 The Early Fragment Test Quali?er . . . . . . . . . . . . . 487
15 Programmable Fragment Processing 488
15.1 Fragment Shader Variables . . . . . . . . . . . . . . . . . . . . . 488
15.2 Shader Execution . . . . . . . . . . . . . . . . . . . . . . . . . . 489
15.2.1 Texture Access . . . . . . . . . . . . . . . . . . . . . . . 490
15.2.2 Shader Inputs . . . . . . . . . . . . . . . . . . . . . . . . 491
15.2.3 Shader Outputs . . . . . . . . . . . . . . . . . . . . . . . 493
15.2.4 Early Fragment Tests . . . . . . . . . . . . . . . . . . . . 498
15.3 Fragment Shader Queries . . . . . . . . . . . . . . . . . . . . . . 498
16 499
17 Writing Fragments and Samples to the Framebuffer 500
17.1 Antialiasing Application . . . . . . . . . . . . . . . . . . . . . . 500
17.2 Multisample Point Fade . . . . . . . . . . . . . . . . . . . . . . . 500
17.3 Per-Fragment Operations . . . . . . . . . . . . . . . . . . . . . . 501
17.3.1 Alpha To Coverage . . . . . . . . . . . . . . . . . . . . . 501
17.3.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
17.3.3 Stencil Test . . . . . . . . . . . . . . . . . . . . . . . . . 503
17.3.4 Depth Buffer Test . . . . . . . . . . . . . . . . . . . . . . 504
17.3.5 Occlusion Queries . . . . . . . . . . . . . . . . . . . . . 505
17.3.6 Blending . . . . . . . . . . . . . . . . . . . . . . . . . . 506
17.3.7 sRGB Conversion . . . . . . . . . . . . . . . . . . . . . 513
17.3.8 Dithering . . . . . . . . . . . . . . . . . . . . . . . . . . 514
17.3.9 Logical Operation . . . . . . . . . . . . . . . . . . . . . 514
17.3.10 Additional Multisample Fragment Operations . . . . . . . 515
17.4 Whole Framebuffer Operations . . . . . . . . . . . . . . . . . . . 516
17.4.1 Selecting Buffers for Writing . . . . . . . . . . . . . . . . 517
17.4.2 Fine Control of Buffer Updates . . . . . . . . . . . . . . 521
17.4.3 Clearing the Buffers . . . . . . . . . . . . . . . . . . . . 523
17.4.4 Invalidating Framebuffer Contents . . . . . . . . . . . . . 526
17.4.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
18 Reading and Copying Pixels 529
18.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
18.2 Reading Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
18.2.1 Selecting Buffers for Reading . . . . . . . . . . . . . . . 529
18.2.2 ReadPixels . . . . . . . . . . . . . . . . . . . . . . . . . 531
18.2.3 Obtaining Pixels from the Framebuffer . . . . . . . . . . 532
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS x
18.2.4 Conversion of RGBA values . . . . . . . . . . . . . . . . 534
18.2.5 Conversion of Depth values . . . . . . . . . . . . . . . . 534
18.2.6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534
18.2.7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535
18.2.8 Final Conversion . . . . . . . . . . . . . . . . . . . . . . 535
18.2.9 Placement in Pixel Pack Buffer or Client Memory . . . . . 536
18.3 Copying Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
18.3.1 Blitting Pixel Rectangles . . . . . . . . . . . . . . . . . . 538
18.3.2 Copying Between Images . . . . . . . . . . . . . . . . . 541
18.4 Pixel Draw and Read State . . . . . . . . . . . . . . . . . . . . . 544
19 Compute Shaders 546
19.1 Compute Shader Variables . . . . . . . . . . . . . . . . . . . . . 548
19.2 Compute Shader Queries . . . . . . . . . . . . . . . . . . . . . . 548
20 Debug Output 549
20.1 Debug Messages . . . . . . . . . . . . . . . . . . . . . . . . . . 550
20.2 Debug Message Callback . . . . . . . . . . . . . . . . . . . . . . 552
20.3 Debug Message Log . . . . . . . . . . . . . . . . . . . . . . . . 553
20.4 Controlling Debug Messages . . . . . . . . . . . . . . . . . . . . 553
20.5 Externally Generated Messages . . . . . . . . . . . . . . . . . . . 555
20.6 Debug Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555
20.7 Debug Labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
20.8 Asynchronous and Synchronous Debug Output . . . . . . . . . . 558
20.9 Debug Output Queries . . . . . . . . . . . . . . . . . . . . . . . 559
21 Special Functions 562
21.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
21.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
21.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
21.4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
21.5 Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
21.6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563
22 Context State Queries 564
22.1 Simple Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . 564
22.2 Pointer, String, and Related Context Queries . . . . . . . . . . . . 566
22.3 Internal Format Queries . . . . . . . . . . . . . . . . . . . . . . . 569
22.3.1 Supported Operation Queries . . . . . . . . . . . . . . . . 570
22.3.2 Other Internal Format Queries . . . . . . . . . . . . . . . 573
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS xi
22.4 Transform Feedback State Queries . . . . . . . . . . . . . . . . . 580
22.5 Indexed Binding State Queries . . . . . . . . . . . . . . . . . . . 581
23 State Tables 582
A Invariance 657
A.1 Repeatability . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657
A.2 Multi-pass Algorithms . . . . . . . . . . . . . . . . . . . . . . . 658
A.3 Invariance Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . 658
A.4 Tessellation Invariance . . . . . . . . . . . . . . . . . . . . . . . 660
A.5 Atomic Counter Invariance . . . . . . . . . . . . . . . . . . . . . 662
A.6 What All This Means . . . . . . . . . . . . . . . . . . . . . . . . 663
B Corollaries 664
C The OpenGL SPIR-V Execution Environment 666
C.1 Required Versions and Formats . . . . . . . . . . . . . . . . . . . 666
C.2 Valid SPIR-V Built-In Variable Decorations . . . . . . . . . . . . 666
C.3 Valid SPIR-V Capabilities . . . . . . . . . . . . . . . . . . . . . 666
C.4 Validation Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . 667
C.5 Precision and Operation of SPIR-V Instructions . . . . . . . . . . 669
C.6 Precision of GLSL.std.450 Instructions . . . . . . . . . . . . . . . 669
D Compressed Texture Image Formats 674
D.1 RGTC Compressed Texture Image Formats . . . . . . . . . . . . 674
D.2 BPTC Compressed Texture Image Formats . . . . . . . . . . . . 675
D.3 ETC Compressed Texture Image Formats . . . . . . . . . . . . . 675
E Pro?les and the Deprecation Model 677
E.1 Core and Compatibility Pro?les . . . . . . . . . . . . . . . . . . 678
E.2 Deprecated and Removed Features . . . . . . . . . . . . . . . . . 678
E.2.1 Deprecated But Still Supported Features . . . . . . . . . . 678
E.2.2 Removed Features . . . . . . . . . . . . . . . . . . . . . 679
F Version 4.2 684
F.1 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 684
F.2 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 685
F.3 Changed Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . 685
F.4 Change Log for Released Specifications . . . . . . . . . . . . . . 686
F.5 Credits and Acknowledgements . . . . . . . . . . . . . . . . . . 688
OpenGL 4.6 (Core Pro?le) - February 2, 2019CONTENTS xii
G Version 4.3 691
G.1 Restructuring . . . . . . . . . . . . . . . . . . . . . . . . . . . . 691
G.2 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 692
G.3 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 693
G.4 Changed Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
G.5 Change Log for Released Specifications . . . . . . . . . . . . . . 694
G.6 Credits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
G.7 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 703
H Version 4.4 704
H.1 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 704
H.2 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 705
H.3 Change Log for Released Specifications . . . . . . . . . . . . . . 705
H.4 Credits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 716
H.5 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 717
I Version 4.5 718
I.1 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 718
I.2 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 719
I.3 Change Log for Released Specifications . . . . . . . . . . . . . . 719
I.4 Credits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 731
I.5 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 732
J Version 4.6 733
J.1 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 733
J.2 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 734
J.3 Change Log Descriptions . . . . . . . . . . . . . . . . . . . . . . 734
J.4 Change Log for Released Specifications . . . . . . . . . . . . . . 734
J.5 Credits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 741
J.6 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 742
K OpenGL Registry, Header Files, and ARB Extensions 743
K.1 OpenGL Registry . . . . . . . . . . . . . . . . . . . . . . . . . . 743
K.2 Header Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 743
K.3 ARB and Khronos Extensions . . . . . . . . . . . . . . . . . . . 744
K.3.1 Naming Conventions . . . . . . . . . . . . . . . . . . . . 745
K.3.2 Promoting Extensions to Core Features . . . . . . . . . . 745
K.3.3 Extension Summaries . . . . . . . . . . . . . . . . . . . 745
Index 777
OpenGL 4.6 (Core Pro?le) - February 2, 2019List of Figures
3.1 Block diagram of the GL pipeline. . . . . . . . . . . . . . . . . . 34
8.1 Transfer of pixel rectangles. . . . . . . . . . . . . . . . . . . . . 190
8.2 Selecting a subimage from an image . . . . . . . . . . . . . . . . 195
8.3 A texture image and the coordinates used to access it. . . . . . . . 216
8.4 Example of the components returned fortextureGather. . . . . 262
10.1 Vertex processing and primitive assembly. . . . . . . . . . . . . . 338
10.2 Triangle strips, fans, and independent triangles. . . . . . . . . . . 341
10.3 Lines with adjacency. . . . . . . . . . . . . . . . . . . . . . . . . 342
10.4 Triangles with adjacency. . . . . . . . . . . . . . . . . . . . . . . 344
10.5 Triangle strips with adjacency. . . . . . . . . . . . . . . . . . . . 345
11.1 Domain parameterization for tessellation. . . . . . . . . . . . . . 416
11.2 Inner triangle tessellation. . . . . . . . . . . . . . . . . . . . . . . 419
11.3 Inner quad tessellation. . . . . . . . . . . . . . . . . . . . . . . . 422
11.4 Isoline tessellation. . . . . . . . . . . . . . . . . . . . . . . . . . 424
14.1 Rasterization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 462
14.2 Visualization of Bresenham’s algorithm. . . . . . . . . . . . . . . 472
14.3 Rasterization of non-antialiased wide lines. . . . . . . . . . . . . 474
14.4 The region used in rasterizing an antialiased line segment. . . . . 475
17.1 Per-fragment operations. . . . . . . . . . . . . . . . . . . . . . . 501
18.1 Operation of ReadPixels. . . . . . . . . . . . . . . . . . . . . . . 529
xiiiList of Tables
1.1 OpenGL ES to OpenGL version relationship. . . . . . . . . . . . 5
2.1 GL command suf?xes . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2 GL data types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Summary of GL errors . . . . . . . . . . . . . . . . . . . . . . . 18
4.1 Initial properties of a sync object created with FenceSync. . . . . 37
6.1 Buffer object binding targets. . . . . . . . . . . . . . . . . . . . . 61
6.2 Buffer object parameters and their values. . . . . . . . . . . . . . 61
6.3 Buffer object state. . . . . . . . . . . . . . . . . . . . . . . . . . 68
6.4 Buffer object state set by MapBufferRange and MapNamedBuf-
ferRange. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
6.5 Indexed buffer object limits and binding queries . . . . . . . . . . 85
7.1 CreateShader type values and the corresponding shader stages. . 89
7.2 GetProgramResourceiv properties and supported interfaces . . . 112
7.3 OpenGL Shading Language type tokens . . . . . . . . . . . . . . 119
7.4 Query targets for default uniform block storage, in components. . 133
7.5 Query targets for combined uniform block storage, in components. 134
7.6 GetProgramResourceiv properties used by GetActiveUniformsiv. 137
7.7 GetProgramResourceiv properties used by GetActiveUniform-
Blockiv. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
7.8 GetProgramResourceiv properties used by GetActiveAtomic-
CounterBufferiv. . . . . . . . . . . . . . . . . . . . . . . . . . . 140
7.9 Interfaces for active subroutines . . . . . . . . . . . . . . . . . . 155
7.10 Interfaces for active subroutine uniforms . . . . . . . . . . . . . . 155
8.1 PixelStore* parameters. . . . . . . . . . . . . . . . . . . . . . . 189
8.2 Pixel data types. . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
xivLISTOFTABLES xv
8.3 Pixel data formats. . . . . . . . . . . . . . . . . . . . . . . . . . 194
8.4 Swap Bytes bit ordering. . . . . . . . . . . . . . . . . . . . . . . 194
8.5 Packed pixel formats. . . . . . . . . . . . . . . . . . . . . . . . . 197
8.6 UNSIGNED_BYTE formats. Bit numbers are indicated for each
component. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
8.7 UNSIGNED_SHORT formats . . . . . . . . . . . . . . . . . . . . . 199
8.8 UNSIGNED_INT formats . . . . . . . . . . . . . . . . . . . . . . 200
8.9 FLOAT_UNSIGNED_INT formats . . . . . . . . . . . . . . . . . . 201
8.10 Packed pixel ?eld assignments. . . . . . . . . . . . . . . . . . . . 202
8.11 Conversion from RGBA, depth, and stencil pixel components to
internal texture components. . . . . . . . . . . . . . . . . . . . . 205
8.12 Sized internal color formats. . . . . . . . . . . . . . . . . . . . . 210
8.13 Sized internal depth and stencil formats. . . . . . . . . . . . . . . 211
8.14 Generic and speci?c compressed internal formats. . . . . . . . . . 212
8.15 Valid texture target parameters . . . . . . . . . . . . . . . . . . . 222
8.16 Internal formats for buffer textures . . . . . . . . . . . . . . . . . 238
8.17 Texture parameters and their values. . . . . . . . . . . . . . . . . 241
8.18 Texture return values. . . . . . . . . . . . . . . . . . . . . . . . . 249
8.19 Selection of cube map images. . . . . . . . . . . . . . . . . . . . 254
8.20 Texel location wrap mode application. . . . . . . . . . . . . . . . 261
8.21 Legal texture targets for TextureView. . . . . . . . . . . . . . . . 273
8.22 Compatible internal formats for TextureView . . . . . . . . . . . 274
8.23 Depth texture comparison functions. . . . . . . . . . . . . . . . . 289
8.24 sRGB texture internal formats. . . . . . . . . . . . . . . . . . . . 290
8.25 Mapping of image load, store, and atomic texel coordinate compo-
nents to texel numbers. . . . . . . . . . . . . . . . . . . . . . . . 294
8.26 Supported image unit formats, with equivalent format layout
quali?ers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
8.27 Texel sizes, compatibility classes, and pixel format/type combina-
tions for each image format. . . . . . . . . . . . . . . . . . . . . 299
9.1 Buffer selection for default framebuffer attachment queries . . . . 310
9.2 Framebuffer attachment points. . . . . . . . . . . . . . . . . . . . 320
9.3 Layer numbers for cube map texture faces. . . . . . . . . . . . . . 337
10.1 Triangles generated by triangle strips with adjacency. . . . . . . . 346
10.2 Vertex array sizes (values per vertex) and data types for generic
vertex attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . 354
10.3 Packed component layout for non-BGRA formats. . . . . . . . . . 363
10.4 Packed component layout forBGRA format. . . . . . . . . . . . . 363
OpenGL 4.6 (Core Pro?le) - February 2, 2019LISTOFTABLES xvi
10.5 Packed component layout for UNSIGNED_INT_10F_11F_11F_-
REV format. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
10.6 Indirect commands and corresponding indirect buffer targets. . . . 365
11.1 Generic attribute components accessed by attribute variables. . . . 385
11.2 Generic attributes and vector types used by column vectors of ma-
trix variables bound to generic attribute indexi. . . . . . . . . . . 386
11.3 Scalar and vector vertex attribute types . . . . . . . . . . . . . . . 386
13.1 Transform feedback modes . . . . . . . . . . . . . . . . . . . . . 446
13.2 Provoking vertex selection. . . . . . . . . . . . . . . . . . . . . . 453
15.1 Correspondence of ?ltered texture components to texture base
components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
17.1 RGB and alpha blend equations. . . . . . . . . . . . . . . . . . . 509
17.2 Blending functions. . . . . . . . . . . . . . . . . . . . . . . . . . 511
17.3 Logical operations . . . . . . . . . . . . . . . . . . . . . . . . . 515
17.4 Buffer selection for the default framebuffer . . . . . . . . . . . . 518
17.5 Buffer selection for a framebuffer object . . . . . . . . . . . . . . 518
17.6 DrawBuffers buffer selection for the default framebuffer . . . . . 519
18.1 PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . . 532
18.2 ReadPixels GL data types and reversed component conversion for-
mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537
18.3 ReadPixels index masks. . . . . . . . . . . . . . . . . . . . . . . 538
18.4 Compatible internal formats for copying . . . . . . . . . . . . . . 544
20.1 Sources of debug output messages . . . . . . . . . . . . . . . . . 550
20.2 Types of debug output messages . . . . . . . . . . . . . . . . . . 551
20.3 Severity levels of messages . . . . . . . . . . . . . . . . . . . . . 551
20.4 Object namespace identi?ers . . . . . . . . . . . . . . . . . . . . 557
21.1 Hint targets and descriptions . . . . . . . . . . . . . . . . . . . . 563
22.1 Context pro?le bits . . . . . . . . . . . . . . . . . . . . . . . . . 567
22.2 Internal format targets . . . . . . . . . . . . . . . . . . . . . . . . 570
23.1 State Variable Types . . . . . . . . . . . . . . . . . . . . . . . . . 583
23.2 Current Values and Associated Data . . . . . . . . . . . . . . . . 584
23.3 Vertex Array Object State (cont.) . . . . . . . . . . . . . . . . . . 585
23.4 Vertex Array Object State (cont.) . . . . . . . . . . . . . . . . . . 586
OpenGL 4.6 (Core Pro?le) - February 2, 2019LISTOFTABLES xvii
23.5 Vertex Array Data (not in Vertex Array objects) . . . . . . . . . . 587
23.6 Buffer Object State . . . . . . . . . . . . . . . . . . . . . . . . . 588
23.7 Transformation state . . . . . . . . . . . . . . . . . . . . . . . . 589
23.8 Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 590
23.9 Rasterization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 591
23.10Rasterization (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . 592
23.11Multisampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
23.12Textures (state per texture unit) . . . . . . . . . . . . . . . . . . . 594
23.13Textures (state per texture unit) (cont.) . . . . . . . . . . . . . . . 595
23.14Textures (state per texture object) . . . . . . . . . . . . . . . . . . 596
23.15Textures (state per texture object) (cont.) . . . . . . . . . . . . . . 597
23.16Textures (state per texture image) . . . . . . . . . . . . . . . . . . 598
23.17Textures (state per texture image) (cont.) . . . . . . . . . . . . . . 599
23.18Textures (state per sampler object) . . . . . . . . . . . . . . . . . 600
23.19Texture Environment and Generation . . . . . . . . . . . . . . . . 601
23.20Pixel Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 602
23.21Pixel Operations (cont.) . . . . . . . . . . . . . . . . . . . . . . . 603
23.22Framebuffer Control . . . . . . . . . . . . . . . . . . . . . . . . 604
23.23Framebuffer (state per target binding point) . . . . . . . . . . . . 605
23.24Framebuffer (state per framebuffer object) . . . . . . . . . . . . . 606
23.25Framebuffer (state per attachment point) . . . . . . . . . . . . . . 607
23.26Renderbuffer (state per target and binding point) . . . . . . . . . . 608
23.27Renderbuffer (state per renderbuffer object) . . . . . . . . . . . . 609
23.28Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610
23.29Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611
23.30Shader Object State . . . . . . . . . . . . . . . . . . . . . . . . . 612
23.31Program Pipeline Object State . . . . . . . . . . . . . . . . . . . 613
23.32Program Object State . . . . . . . . . . . . . . . . . . . . . . . . 614
23.33Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 615
23.34Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 616
23.35Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 617
23.36Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 618
23.37Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 619
23.38Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 620
23.39Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 621
23.40Program Interface State . . . . . . . . . . . . . . . . . . . . . . . 622
23.41Program Object Resource State . . . . . . . . . . . . . . . . . . . 623
23.42Program Object Resource State (cont.) . . . . . . . . . . . . . . . 624
23.43Vertex and Geometry Shader State . . . . . . . . . . . . . . . . . 625
23.44Query Object State . . . . . . . . . . . . . . . . . . . . . . . . . 626
OpenGL 4.6 (Core Pro?le) - February 2, 2019LISTOFTABLES xviii
23.45Image State (state per image unit) . . . . . . . . . . . . . . . . . 627
23.46Atomic Counter Buffer Binding State . . . . . . . . . . . . . . . 628
23.47Shader Storage Buffer Binding State . . . . . . . . . . . . . . . . 629
23.48Transform Feedback Object State . . . . . . . . . . . . . . . . . . 630
23.49Uniform Buffer Binding State . . . . . . . . . . . . . . . . . . . 631
23.50Sync Object State . . . . . . . . . . . . . . . . . . . . . . . . . . 632
23.51Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633
23.52Compute Dispatch State . . . . . . . . . . . . . . . . . . . . . . 634
23.53Implementation Dependent Values . . . . . . . . . . . . . . . . . 635
23.54Implementation Dependent Values (cont.) . . . . . . . . . . . . . 636
23.55Implementation Dependent Values (cont.) . . . . . . . . . . . . . 637
23.56Implementation Dependent Version and Extension Support . . . . 638
23.57Implementation Dependent Vertex Shader Limits . . . . . . . . . 639
23.58Implementation Dependent Tessellation Shader Limits . . . . . . 640
23.59Implementation Dependent Tessellation Shader Limits (cont.) . . 641
23.60Implementation Dependent Geometry Shader Limits . . . . . . . 642
23.61Implementation Dependent Fragment Shader Limits . . . . . . . . 643
23.62Implementation Dependent Compute Shader Limits . . . . . . . . 644
23.63Implementation Dependent Aggregate Shader Limits . . . . . . . 645
23.64Implementation Dependent Aggregate Shader Limits (cont.) . . . 646
23.65Implementation Dependent Aggregate Shader Limits (cont.) . . . 647
23.66Implementation Dependent Aggregate Shader Limits (cont.) . . . 648
23.67Debug Output State . . . . . . . . . . . . . . . . . . . . . . . . . 649
23.68Implementation Dependent Debug Output State . . . . . . . . . . 650
23.69Implementation Dependent Values (cont.)
y These queries return the maximum no. of samples for all internal
formats required to support multisampled rendering. . . . . . . . . . . 651
23.70Implementation Dependent Values (cont.) . . . . . . . . . . . . . 652
23.71Internal Format Dependent Values . . . . . . . . . . . . . . . . . 653
23.72Implementation Dependent Transform Feedback Limits . . . . . . 654
23.73Framebuffer Dependent Values . . . . . . . . . . . . . . . . . . . 655
23.74Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . 656
C.1 Built-in Variable Decorations . . . . . . . . . . . . . . . . . . . . 671
C.2 Valid SPIR-V Capabilities . . . . . . . . . . . . . . . . . . . . . 672
C.3 32-Bit Precision . . . . . . . . . . . . . . . . . . . . . . . . . . . 673
C.4 GLSL.std.450 Precision . . . . . . . . . . . . . . . . . . . . . . . 673
D.1 Mapping of OpenGL RGTC formats to descriptions. . . . . . . . 675
D.2 Mapping of OpenGL BPTC formats to descriptions. . . . . . . . . 675
OpenGL 4.6 (Core Pro?le) - February 2, 2019LISTOFTABLES xix
D.3 Mapping of OpenGL ETC formats to descriptions. . . . . . . . . 676
F.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 686
G.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 694
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 1
Introduction
This document, referred to as the “OpenGL Specification” or just “Specification”
hereafter, describes the OpenGL graphics system: what it is, how it acts, and what
is required to implement it. We assume that the reader has at least a rudimentary
understanding of computer graphics. This means familiarity with the essentials
of computer graphics algorithms and terminology as well as with modern GPUs
(Graphic Processing Units).
The canonical version of the Specification is available in the of?cial OpenGL
Registry, located at URL
http://www.opengl.org/registry/
1.1 Formatting of the OpenGL Specification
Starting with version 4.3, the OpenGL Specification has undergone major restruc-
turing to focus on programmable shading, and to describe important concepts and
objects in the context of the entire API before describing details of their use in the
graphics pipeline.
1.1.1
This subsection is only de?ned in the compatibility pro?le.
1.1.2
This subsection is only de?ned in the compatibility pro?le.
11.2. WHATISTHEOPENGLGRAPHICSSYSTEM? 2
1.2 What is the OpenGL Graphics System?
OpenGL (for “Open Graphics Library”) is an API (Application Programming Inter-
face) to graphics hardware. The API consists of a set of several hundred procedures
and functions that allow a programmer to specify the shader programs, objects, and
operations involved in producing high-quality graphical images, speci?cally color
images of three-dimensional objects.
Most of OpenGL requires that the graphics hardware contain a framebuffer.
Many OpenGL calls control drawing geometric objects such as points, lines, and
polygons, but the way that some of this drawing occurs (such as when antialiasing
or multisampling is in use) relies on the existence of a framebuffer and its proper-
ties. Some commands explicitly manage the framebuffer.
1.2.1 Programmer’s View of OpenGL
To the programmer, OpenGL is a set of commands that allow the speci?cation of
shader programs or shaders, data used by shaders, and state controlling aspects of
OpenGL outside the scope of shaders. Typically the data represent geometry in two
or three dimensions and texture images, while the shaders control the geometric
processing, rasterization of geometry and the lighting and shading of fragments
generated by rasterization, resulting in rendering geometry into the framebuffer.
A typical program that uses OpenGL begins with calls to open a window into
the framebuffer into which the program will draw. Then, calls are made to allocate
an OpenGL context and associate it with the window. Once a context is allocated,
OpenGL commands to de?ne shaders, geometry, and textures are made, followed
by commands which draw geometry by transferring speci?ed portions of the geom-
etry to the shaders. Drawing commands specify simple geometric objects such as
points, line segments, and polygons, which can be further manipulated by shaders.
There are also commands which directly control the framebuffer by reading and
writing pixels.
1.2.2 Implementor’s View of OpenGL
To the implementor, OpenGL is a set of commands that control the operation of
the GPU. Modern GPUs accelerate almost all OpenGL operations, storing data
and framebuffer images in GPU memory and executing shaders in dedicated GPU
processors. However, OpenGL may be implemented on less capable GPUs, or even
without a GPU, by moving some or all operations into the host CPU.
The implementor’s task is to provide a software library on the CPU which
implements the OpenGL API, while dividing the work for each OpenGL command
OpenGL 4.6 (Core Pro?le) - February 2, 20191.2. WHATISTHEOPENGLGRAPHICSSYSTEM? 3
between the CPU and the graphics hardware as appropriate for the capabilities of
the GPU.
OpenGL contains a considerable amount of information including many types
of objects representing programmable shaders and the data they consume and
generate, as well as other context state controlling non-programmable aspects of
OpenGL. Most of these objects and state are available to the programmer, who can
set, manipulate, and query their values through OpenGL commands. Some of it,
however, is derived state visible only by the effect it has on how OpenGL oper-
ates. One of the main goals of this Specification is to describe OpenGL objects
and context state explicitly, to elucidate how they change in response to OpenGL
commands, and to indicate what their effects are.
1.2.3 Our View
We view OpenGL as a pipeline having some programmable stages and some state-
driven ?xed-function stages that are invoked by a set of speci?c drawing opera-
tions. This model should engender a speci?cation that satis?es the needs of both
programmers and implementors. It does not, however, necessarily provide a model
for implementation. An implementation must produce results conforming to those
produced by the speci?ed methods, but there may be ways to carry out a particular
computation that are more ef?cient than the one speci?ed.
1.2.4 Fixed-function Hardware and the Compatibility Pro?le
Older generations of graphics hardware were not programmable using shaders,
although they were con?gurable by setting state controlling speci?c details of their
operation. The compatibility pro?le of OpenGL continues to support the legacy
OpenGL commands developed for such ?xed-function hardware, although they
are typically implemented by writing shaders which reproduce the operation of
such hardware. Fixed-function OpenGL commands and operations are described
as alternative interfaces following descriptions of the corresponding shader stages.
1.2.5 The Deprecation Model
Features marked as deprecated in one version of the Specification are expected to
be removed in a future version, allowing applications time to transition away from
use of deprecated features. The deprecation model is described in more detail,
together with a summary of the commands and state deprecated from this version
of the API, in appendix E.
OpenGL 4.6 (Core Pro?le) - February 2, 20191.3. RELATEDAPIS 4
1.3 Related APIs
Other APIs and related speci?cations related to OpenGL are described below. Most
of the speci?cations for these APIs are available on the Khronos Group websites,
although some vendor-speci?c APIs are documented on that vendor’s developer
website.
1.3.1 OpenGL Shading Language
The OpenGL Specification should be read together with a companion document
titled The OpenGL Shading Language. The latter document (referred to as the
OpenGL Shading Language Specification hereafter) de?nes the syntax and seman-
tics of the programming language used to write shaders (see chapter 7). Descrip-
tions of shaders later in this document may include references to concepts and
terms (such as shading language variable types) de?ned in the OpenGL Shading
Language Specification.
OpenGL 4.6 implementations are guaranteed to support version 4.60 of the
OpenGL Shading Language. All references to sections of that speci?cation refer to
that version. The latest supported version of the shading language may be queried
as described in section 22.2.
The core pro?le of OpenGL 4.6 is also guaranteed to support all previous ver-
sions of the OpenGL Shading Language back to version 1.40. In some implemen-
tations the core pro?le may also support earlier versions of the OpenGL Shading
Language, and may support compatibility pro?le versions of the OpenGL Shading
Language for versions 1.40 and earlier. In this case, errors will be generated when
using language features such as compatibility pro?le built-ins not supported by the
core pro?le API. The#version strings for all supported versions of the OpenGL
Shading Language may be queried as described in section 22.2.
The OpenGL Shading Language Specification is available in the OpenGL Reg-
istry.
1.3.2 OpenGL ES
OpenGL ES is a royalty-free, cross-platform API for full-function 2D and 3D
graphics on embedded systems such as mobile phones, game consoles, and ve-
hicles. It consists of well-de?ned subsets of OpenGL. Each version of OpenGL ES
implements a subset of a corresponding OpenGL version as shown in table 1.1.
OpenGL ES versions also include some additional functionality taken from
later OpenGL versions or speci?c to OpenGL ES. It is straightforward to port code
written for OpenGL ES to corresponding versions of OpenGL.
OpenGL 4.6 (Core Pro?le) - February 2, 20191.3. RELATEDAPIS 5
OpenGL ES Version OpenGL Version it subsets
OpenGL ES 1.1 OpenGL 1.5
OpenGL ES 2.0 OpenGL 2.0
OpenGL ES 3.0 OpenGL 3.3
OpenGL ES 3.1 OpenGL 4.3
Table 1.1: OpenGL ES to OpenGL version relationship.
OpenGL and OpenGL ES are developed in parallel within the Khronos Group,
which controls both standards.
OpenGL 4.3 and 4.5 include additional functionality initially de?ned in
OpenGL ES 3.0 and OpenGL ES 3.1, respectively, for increased compatibility be-
tween OpenGL and OpenGL ES implementations.
The OpenGL ES Specifications are available in the Khronos API Registry at
URL
http://www.khronos.org/registry/
1.3.3 OpenGL ES Shading Language
The Specification should also be read together with companion documents titled
The OpenGL ES Shading Language. Versions 1.00, 3.00, and 3.10 should be read.
These documents de?ne versions of the OpenGL Shading Language designed for
implementations of OpenGL ES 2.0, 3.0, and 3.1 respectively, but also supported
by OpenGL implementations. References to the OpenGL Shading Language Spec-
i?cation hereafter include both OpenGL and OpenGL ES versions of the Shading
Language; references to speci?c sections are to those sections in version 4.60 of
the OpenGL Shading Language Specification.
OpenGL 4.6 implementations are guaranteed to support versions 1.00, 3.00,
and 3.10 of the OpenGL ES Shading Language.
The#version strings for all supported versions of the OpenGL Shading Lan-
guage may be queried as described in section 22.2.
The OpenGL ES Shading Language Specifications are available in the Khronos
API Registry.
1.3.4 SPIR-V
SPIR-V is a binary intermediate language for representing graphical-shader stages
and compute kernels for multiple Khronos APIs, such as OpenCL, OpenGL, and
Vulkan.
OpenGL 4.6 (Core Pro?le) - February 2, 20191.3. RELATEDAPIS 6
The SPIR-V Specification, and the related SPIR-V Extended Instructions for
the OpenGL Shading Language Specification, are available in the Khronos API
Registry.
1.3.5 WebGL
WebGL is a cross-platform, royalty-free web standard for a low-level 3D graphics
API based on OpenGL ES. Developers familiar with OpenGL ES will recognize
WebGL as a shader-based API using the OpenGL Shading Language, with con-
structs that are semantically similar to those of the underlying OpenGL ES API. It
stays very close to the OpenGL ES speci?cation, with some concessions made for
what developers expect out of memory-managed languages such as JavaScript.
The WebGL Specification and related documentation are available in the
Khronos API Registry.
1.3.6 Window System Bindings
OpenGL requires a companion API to create and manage graphics contexts, win-
dows to render into, and other resources beyond the scope of this Specification.
There are several such APIs supporting different operating and window systems.
1.3.6.1 GLX - X Window System Bindings
OpenGL Graphics with the X Window System, referred to as the GLX Specification
hereafter, describes the GLX API for use of OpenGL in the X Window System. It is
primarily directed at Linux and Unix systems, but GLX implementations also exist
for Microsoft Windows, MacOS X, and some other platforms where X is available.
The GLX Specification is available in the OpenGL Registry.
1.3.6.2 WGL - Microsoft Windows Bindings
The WGL API supports use of OpenGL with Microsoft Windows. WGL is docu-
mented in Microsoft’s MSDN system, although no full speci?cation exists.
1.3.6.3 MacOS X Window System Bindings
Several APIs exist supporting use of OpenGL with Quartz, the MacOS X window
system, including CGL, AGL, and NSOpenGLView. These APIs are documented
on Apple’s developer website.
OpenGL 4.6 (Core Pro?le) - February 2, 20191.4. FILINGBUGREPORTS 7
1.3.6.4 EGL - Mobile and Embedded Device Bindings
The Khronos Native Platform Graphics Interface or “EGL Specification” describes
the EGL API for use of OpenGL ES on mobile and embedded devices. EGL im-
plementations supporting OpenGL may be available on some desktop platforms as
well. The EGL Specification is available in the Khronos API Registry.
1.3.7 OpenCL
OpenCL is an open, royalty-free standard for cross-platform, general-purpose par-
allel programming of processors found in personal computers, servers, and mobile
devices, including GPUs. OpenCL de?nes interop methods to share OpenCL mem-
ory and image objects with corresponding OpenGL buffer and texture objects, and
to coordinate control of and transfer of data between OpenCL and OpenGL. This
allows applications to split processing of data between OpenCL and OpenGL; for
example, by using OpenCL to implement a physics model and then rendering and
interacting with the resulting dynamic geometry using OpenGL.
The OpenCL Specification is available in the Khronos API Registry.
1.4 Filing Bug Reports
Bug reports on the OpenGL API Specification should be ?led in the Khronos
OpenGL-API Github repository, located at URL
https://github.com/KhronosGroup/OpenGL-API
Bug reports on the OpenGL Shading Language Specification should be ?led in
the Khronos OpenGL-GLSL Github repository, located at URL
https://github.com/KhronosGroup/OpenGL-GLSL
It is best to ?le bugs against the most recently released versions, since older
versions are usually not updated for bug?xes.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 2
OpenGL Fundamentals
This chapter introduces fundamental concepts including the OpenGL execution
model, API syntax, contexts and threads, numeric representation, context state and
state queries, and the different types of objects and shaders. It provides a frame-
work for interpreting more speci?c descriptions of commands and behavior in the
remainder of the Specification.
2.1 Execution Model
OpenGL (henceforth, “the GL”) is concerned only with processing data in GPU
memory, including rendering into a framebuffer and reading values stored in that
framebuffer. There is no support for other input or output devices. Programmers
must rely on other mechanisms to obtain user input.
The GL draws primitives processed by a variety of shader programs and ?xed-
function processing units controlled by context state. Each primitive is a point,
line segment, patch, or polygon. Context state may be changed independently; the
setting of one piece of state does not affect the settings of others (although state and
shaders all interact to determine what eventually ends up in the framebuffer). State
is set, primitives drawn, and other GL operations described by sending commands
in the form of function or procedure calls.
Primitives are de?ned by a group of one or more vertices. A vertex de?nes
a point, an endpoint of a line segment, or a corner of a polygon where two edges
meet. Data such as positional coordinates, colors, normals, texture coordinates, etc.
are associated with a vertex and each vertex is processed independently, in order,
and in the same way. The only exception to this rule is if the group of vertices
must be clipped so that the indicated primitive ?ts within a speci?ed region; in this
case vertex data may be modi?ed and new vertices created. The type of clipping
82.1. EXECUTIONMODEL 9
depends on which primitive the group of vertices represents.
Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all
previously invoked GL commands, except where explicitly speci?ed otherwise. In
general, the effects of a GL command on either GL state or the framebuffer must
be complete before any subsequent command can have any such effects.
Data binding occurs on call. This means that data passed to a GL command
are interpreted when that command is received. Even if the command requires a
pointer to data, those data are interpreted when the call is made, and any subsequent
changes to the data have no effect on the GL (unless the same pointer is used in a
subsequent command).
The GL provides direct control over the fundamental operations of 3D and 2D
graphics. This includes speci?cation of parameters of application-de?ned shader
programs performing transformation, lighting, texturing, and shading operations,
as well as built-in functionality such as antialiasing and texture ?ltering. It does not
provide a means for describing or modeling complex geometric objects, although
shaders can be written to generate such objects. In other words, OpenGL provides
mechanisms to describe how complex geometric objects are to be rendered, rather
than mechanisms to describe the complex objects themselves.
The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer or in the same address space as the client. In this sense, the GL is net-
work transparent. A server may maintain a number of GL contexts, each of which
is an encapsulation of current GL state and objects. A client may choose to be
made current to any one of these contexts.
Issuing GL commands when the program does not have a current context re-
sults in unde?ned behavior, up to and including program termination.
There are two classes of framebuffers: a window system-provided framebuffer
associated with a context when the context is made current, and application-created
framebuffers. The window system-provided framebuffer is referred to as the de-
fault framebuffer. Application-created framebuffers, referred to as framebuffer ob-
jects, may be created as desired, A context may be associated with two frame-
buffers, one for each of reading and drawing operations. The default framebuffer
and framebuffer objects are distinguished primarily by the interfaces for con?gur-
ing and managing their state.
The effects of GL commands on the default framebuffer are ultimately con-
OpenGL 4.6 (Core Pro?le) - February 2, 20192.2. COMMANDSYNTAX 10
trolled by the window system, which allocates framebuffer resources, determines
which portions of the default framebuffer the GL may access at any given time, and
communicates to the GL how those portions are structured. Therefore, there are
no GL commands to initialize a GL context or con?gure the default framebuffer.
Similarly, display of framebuffer contents on a physical display device (including
the transformation of individual framebuffer values by such techniques as gamma
correction) is not addressed by the GL.
Allocation and con?guration of the default framebuffer occurs outside of the
GL in conjunction with the window system, using companion APIs described in
section 1.3.6.
Allocation and initialization of GL contexts is also done using these companion
APIs. GL contexts can be associated with different default framebuffers, and some
context state is determined at the time this association is performed.
It is possible to use a GL context without a default framebuffer, in which case
a framebuffer object must be used to perform all rendering. This is useful for
applications needing to perform offscreen rendering.
OpenGL is designed to be run on a range of platforms with varying capabilities,
memory, and performance. To accommodate this variety, we specify ideal behavior
instead of actual behavior for certain GL operations. In cases where deviation from
the ideal is allowed, we also specify the rules that an implementation must obey
if it is to approximate the ideal behavior usefully. This allowed variation in GL
behavior implies that two distinct GL implementations may not agree pixel for
pixel when presented with the same input, even when run on identical framebuffer
con?gurations.
Finally, command names, constants, and types are pre?xed in the C language
binding to OpenGL (by gl,GL_, andGL, respectively), to reduce name clashes with
other packages. The pre?xes are omitted in this document for clarity.
2.2 Command Syntax
The Specification describes OpenGL commands as functions or procedures using
ANSIC syntax. Languages such asC++ andJavascript which allow passing
of argument type information permit language bindings with simpler declarations
and fewer entry points.
Various groups of GL commands perform the same operation but differ in how
arguments are supplied to them. To conveniently accommodate this variation, we
adopt a notation for describing commands and their arguments.
GL commands are formed from a name which may be followed, depending on
the particular command, by a sequence of characters describing a parameter to the
OpenGL 4.6 (Core Pro?le) - February 2, 20192.2. COMMANDSYNTAX 11
command. If present, a digit indicates the required length (number of values) of the
indicated type. Next, a string of characters making up one of the type descriptors
from table 2.1 indicates the speci?c size and data type of parameter values. A
?nal v character, if present, indicates that the command takes a pointer to an array
(a vector) of values rather than a series of individual arguments. Two speci?c
examples are:
void Uniform4f(int location,float v0,float v1,
float v2,float v3 );
and
void GetFloatv(enum pname,float *data );
In general, a command declaration has the form
rtype Namef1234gf b s i i64 f d ub us ui ui64gfvg
( [args ,] T arg1,:::, T argN [, args] );
rtype is the return type of the function. The braces (fg) enclose a series of type
descriptors (see table 2.1), of which one is selected. indicates no type descriptor.
The arguments enclosed in brackets ([args ,] and [, args]) may or may not be
present. TheN arguments arg1 through argN have type T, which corresponds to
one of the type descriptors indicated in table 2.1 (if there are no letters, then the
arguments’ type is given explicitly). If the ?nal character is not v, thenN is given
by the digit 1, 2, 3, or 4 (if there is no digit, then the number of arguments is ?xed).
If the ?nal character is v, then only arg1 is present and it is an array ofN values of
the indicated type.
For example,
void Uniformf1234gfifg(int location,T value );
indicates the eight declarations
void Uniform1i(int location,int value );
void Uniform1f(int location,float value );
void Uniform2i(int location,int v0,int v1 );
void Uniform2f(int location,float v0,float v1 );
void Uniform3i(int location,int v0,int v1,int v2 );
void Uniform3f(int location,float v0,float v1,
float v3 );
OpenGL 4.6 (Core Pro?le) - February 2, 20192.2. COMMANDSYNTAX 12
Type Descriptor CorrespondingGL Type
b byte
s short
i int
i64 int64
f float
d double
ub ubyte
us ushort
ui uint
ui64 uint64
Table 2.1: Correspondence of command suf?x type descriptors to GL argument
types. Refer to table 2.2 for de?nitions of the GL types.
void Uniform4i(int location,int v0,int v1,int v2,
int v3 );
void Uniform4f(int location,float v0,float v1,
float v2,float v3 );
Arguments whose type is ?xed (i.e. not indicated by a suf?x on the command)
are of one of the GL data types summarized in table 2.2, or pointers to one of these
types. Since many GL operations represent bit?elds within these types, transfer
blocks of data in these types to graphics hardware which uses the same data types,
or otherwise requires these sizes, it is not possible to implement the GL API on an
architecture which cannot satisfy the exact bit width requirements in table 2.2.
The types clampf and clampd are no longer used, replaced by float
and double respectively together with speci?cation language requiring param-
1
eter clamping .
2.2.1 Data Conversion For State-Setting Commands
Many GL commands specify a value or values to which GL state of a speci?c type
(boolean, enum, integer, or ?oating-point) is to be set. When multiple versions of
such a command exist, using the type descriptor syntax described above, any such
version may be used to set the state value. When state values are speci?ed using
1
These changes are backwards-compatible at the compilation and linking levels, and are being
propagated to man pages and header ?les as well.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.2. COMMANDSYNTAX 13
GL Type Description
Bit Width
boolean 8 Boolean
byte 8 Signed two’s complement binary inte-
ger
ubyte 8 Unsigned binary integer
char 8 Characters making up strings
short 16 Signed two’s complement binary inte-
ger
ushort 16 Unsigned binary integer
int 32 Signed two’s complement binary inte-
ger
uint 32 Unsigned binary integer
fixed 32 Signed two’s complement 16.16
scaled integer
int64 64 Signed two’s complement binary inte-
ger
uint64 64 Unsigned binary integer
sizei 32 Non-negative binary integer size
enum 32 Enumerated binary integer value
intptr ptrbits Signed twos complement binary inte-
ger
sizeiptr ptrbits Non-negative binary integer size
sync ptrbits Sync object handle (see section 4.1)
bitfield 32 Bit ?eld
half 16 Half-precision ?oating-point value
encoded in an unsigned scalar
float 32 Floating-point value
clampf 32 Floating-point value clamped to [0; 1]
double 64 Floating-point value
clampd 64 Floating-point value clamped to [0; 1]
Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to theC typeint. An implementation must use exactly the number of
bits indicated in the table to represent a GL type.
ptrbits is the number of bits required to represent a pointer type; in other words,
typesintptr,sizeiptr, andsync must be large enough to store any CPU ad-
dress. sync is de?ned as an anonymous struct pointer in theC language bindings
whileintptr andsizeiptr are de?ned as integer types large enough to hold
a pointer.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.2. COMMANDSYNTAX 14
a different parameter type than the actual type of that state, data conversions are
performed as follows:
 When the type of internal state is boolean, zero integer or ?oating-point val-
ues are converted toFALSE and non-zero values are converted toTRUE.
 When the type of internal state is integer or enum, boolean values ofFALSE
and TRUE are converted to 0 and 1, respectively. Floating-point values are
rounded to the nearest integer. If the resulting value is so large in magnitude
that it cannot be represented by the internal state variable, the internal state
value is unde?ned.
 When the type of internal state is ?oating-point, boolean values of FALSE
andTRUE are converted to 0:0 and 1:0, respectively. Integer values are con-
verted to ?oating-point, with or without normalization as described for spe-
ci?c commands.
For commands taking arrays of the speci?ed type, these conversions are per-
formed for each element of the passed array.
Each command following these conversion rules refers back to this section.
Some commands have additional conversion rules speci?c to certain state values
and data types, which are described following the reference.
Validation of values performed by state-setting commands is performed after
conversion, unless speci?ed otherwise for a speci?c command.
2.2.2 Data Conversions For State Query Commands
Query commands (commands whose name begins with Get) return a value or val-
ues to which GL state has been set. Some of these commands exist in multiple
versions returning different data types. When a query command is issued that re-
turns data types different from the actual type of that state, data conversions are
performed as follows. If more than one step is applicable, all relevant steps are
applied in the following order:
 If a command returning boolean data is called, such as GetBooleanv, a
?oating-point or integer value converts to FALSE if and only if it is zero.
Otherwise it converts toTRUE.
 If a command returning unsigned integer data is called, such as GetSam-
plerParameterIuiv, negative values are clamped to zero.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 15
 If a command returning signed or unsigned integer data is called, such as
GetIntegerv or GetInteger64v, a boolean value of TRUE or FALSE is in-
terpreted as one or zero, respectively. A ?oating-point value is rounded
to the nearest integer, unless the value is an RGBA color component, a
DepthRange value, or a depth buffer clear value. In these cases, the query
command converts the ?oating-point value to an integer according to the
INT entry of table 18.2; a value not in [ 1; 1] converts to an unde?ned value.
 If a command returning ?oating-point data is called, such as GetFloatv or
GetDoublev, a boolean value of TRUE or FALSE is interpreted as 1:0 or
0:0, respectively. An integer value is coerced to ?oating-point. Single- and
double-precision ?oating-point values are converted as necessary.
Following these steps, if a value is so large in magnitude that it cannot be
represented by the returned data type, then the nearest value representable using
that type is returned.
When querying bitmasks (such as SAMPLE_MASK_VALUE or STENCIL_-
WRITEMASK) with GetIntegerv, the mask value is treated as a signed integer, so
that mask values with the high bit set will not be clamped when returned as signed
integers.
Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f.
2.3 Command Execution
Most of the Specification discusses the behavior of a single context bound to a
single CPU thread. It is also possible for multiple contexts to share GL objects
and for each such context to be bound to a different thread. This section introduces
concepts related to GL command execution including error reporting, command
queue ?ushing, and synchronization between command streams. Using these tools
can increase performance and utilization of the GPU by separating loosely related
tasks into different contexts.
Methods to create, manage, and destroy CPU threads are de?ned by the host
CPU operating system and are not described in the Specification. Binding of GL
contexts to CPU threads is controlled through a window system binding layer such
as those described in section 1.3.6.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 16
2.3.1 Errors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
mance of an error-free program.
The command
enum GetError(void );
is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a ?ag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
the code is returned and the ?ag is cleared, so that a further error will again record
its code. If a call to GetError returnsNO_ERROR, then there has been no detectable
error since the last call to GetError (or since the GL was initialized).
To allow for distributed implementations, there may be several ?ag-code pairs.
In this case, after a call to GetError returns a value other than NO_ERROR each
subsequent call returns the non-zero code of a distinct ?ag-code pair (in unspeci?ed
order), until all non-NO_ERROR codes have been returned. When there are no more
non-NO_ERROR error codes, all ?ags are reset. This scheme requires some positive
number of pairs of a ?ag bit and an integer. The initial state of all ?ags is cleared
and the initial value of all codes isNO_ERROR.
Table 2.3 summarizes GL errors. Currently, when an error ?ag is set, results
of GL operation are unde?ned only if an OUT_OF_MEMORY error has occurred. In
other cases, there are no side effects unless otherwise noted; the command which
generates the error is ignored so that it has no effect on GL state or framebuffer
contents. Except as otherwise noted, if the generating command returns a value, it
returns zero. If the generating command modi?es values through a pointer argu-
ment, no change is made to these values.
These error semantics apply only to GL errors, not to system errors such as
memory access errors. This behavior is the current behavior; the action of the
GL in the presence of errors is subject to change, and extensions to OpenGL may
de?ne behavior currently considered as an error.
Several error generation conditions are implicit in the description of every GL
2
command .
 If the GL context has been reset as a result of previous GL command, or if
the context is reset as a side effect of execution of a command, aCONTEXT_-
LOST error is generated.
2
For historical reasons, some older errors do not follow the patterns described below, and cannot
easily be changed. The explicit error language with each command always controls behavior when
in con?ict with this section.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 17
 If a command that requires an enumerated value is passed a symbolic con-
stant that is never allowable for that command, an INVALID_ENUM error is
generated. This is the case even if the argument is a pointer to a symbolic
constant, if the value or values pointed to are not allowable for the given
command. In some cases, a symbolic constant is allowable for a command,
but is forbidden in combination with current GL state and/or a value passed
for another parameter of that command. These cases are documented explic-
itly, and anINVALID_OPERATION error is generated instead.
 If a negative number is provided where an argument of type sizei or
sizeiptr is speci?ed, anINVALID_VALUE error is generated.
 If memory is exhausted as a side effect of the execution of a command, an
OUT_OF_MEMORY error may be generated.
The Specification attempts to explicitly describe these implicit error conditions
3 4
(with the exception ofCONTEXT_LOST andOUT_OF_MEMORY wherever they ap-
ply. However, they apply even if not explicitly described, unless a speci?c com-
mand describes different behavior. For example, certain commands use asizei
parameter to indicate the length of a string, and also use negative values of the pa-
rameter to indicate a null-terminated string. These commands do not generate an
INVALID_VALUE error, because they explicitly describe different behavior.
Otherwise, errors are generated only for conditions that are explicitly described
in the Specification.
When a command could potentially generate several different errors (for ex-
ample, when it is passed separate enum and numeric parameters which are both
out of range), the GL implementation may choose to generate any of the applicable
errors.
Errors based solely on one or more argument values to a command must be
5
detected before any processing based on current state .
When an error is generated, the GL may also generate a debug output message
describing its cause (see chapter 20). The message has sourceDEBUG_SOURCE_-
API, typeDEBUG_TYPE_ERROR, and an implementation-dependent ID.
Most commands include a complete summary of errors at the end of their de-
scription, including even the implicit errors described above.
3
CONTEXT_LOST is not described because it can potentially be generated by almost all GL
commands, and occurs for reasons not directly related to the affected commands.
4
OUT_OF_MEMORY is not described because it can potentially be generated by any GL com-
mand, even those which do not explicitly allocate GPU memory.
5
This ensures consistent behavior for commands including language which ignores certain pa-
rameters under some conditions, such as glBlitFramebuffer treatment of mask and ?lter.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 18
Error Description Offending com-
mand ignored?
CONTEXT_LOST Context has been lost and reset Except as noted
by the driver for speci?c
commands
INVALID_ENUM enum argument out of range Yes
INVALID_VALUE Numeric argument out of range Yes
INVALID_OPERATION Operation illegal in current state Yes
INVALID_FRAMEBUFFER_OPERATION Framebuffer object is not com- Yes
plete
OUT_OF_MEMORY Not enough memory left to exe- Unknown
cute command
STACK_OVERFLOW Command would cause a stack Yes
over?ow
STACK_UNDERFLOW Command would cause a stack Yes
under?ow
Table 2.3: Summary of GL errors
Such error summaries are set in a distinct style, like this sentence.
In some cases, however, errors may be generated for a single command for
reasons not directly related to that command. One such example is that deferred
processing for shader programs may result in link errors detected only when at-
tempting to draw primitives using vertex speci?cation commands. In such cases,
errors generated by a command may be described elsewhere in the speci?cation
than the command itself.
2.3.1.1 No Error Mode
If the GL context was created with the no error mode enabled, then any place where
the driver would have generated an error instead has unde?ned behavior. This could
include application termination. All calls to GetError will return NO_ERROR or
OUT_OF_MEMORY.OUT_OF_MEMORY errors are a special case because they already
allow for unde?ned behavior and are more dif?cult for application developers to
predict than other errors. OUT_OF_MEMORY errors may be delayed, which can be
useful for optimizing multithreaded drivers, but eventually the OUT_OF_MEMORY
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 19
error will be reported if an implementation would have reported this error. Since
behavior of OUT_OF_MEMORY errors are unde?ned there is some implementation
?exibility here. However, this behavior may provide useful information on some
6
implementations that do reportOUT_OF_MEMORY without crashing.
2.3.2 Graphics Reset Recovery
Certain events can result in a reset of the GL context. After such an event, it is
referred to as a lost context and is unusable for almost all purposes. Recovery re-
quires creating a new context and recreating all relevant state from the lost context.
The current status of the graphics reset state is returned by
enum GetGraphicsResetStatus(void );
The value returned indicates if the GL context has been in a reset state at any
point since the last call to GetGraphicsResetStatus:
 NO_ERROR indicates that the GL context has not been in a reset state since
the last call.
 GUILTY_CONTEXT_RESET indicates that a reset has been detected that is
attributable to the current GL context.
 INNOCENT_CONTEXT_RESET indicates a reset has been detected that is not
attributable to the current GL context.
 UNKNOWN_CONTEXT_RESET indicates a detected graphics reset whose cause
is unknown.
If a reset status other than NO_ERROR is returned and subsequent calls return
NO_ERROR, the context reset was encountered and completed. If a reset status is
repeatedly returned, the context may be in the process of resetting.
Reset noti?cation behavior is determined at context creation time, and may be
queried by calling GetIntegerv with pnameRESET_NOTIFICATION_STRATEGY.
If the reset noti?cation behavior is NO_RESET_NOTIFICATION, then the im-
plementation will never deliver noti?cation of reset events, and GetGraphicsRe-
7
setStatus will always returnNO_ERROR .
6
Jon - “should” be reported?
7
In this case, it is recommended that implementations should not allow loss of context state no
matter what events occur. However, this is only a recommendation, and cannot be relied upon by
applications.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 20
If the behavior is LOSE_CONTEXT_ON_RESET, a graphics reset will result in
the loss of all context state, requiring the recreation of all associated objects. In
this case GetGraphicsResetStatus may return any of the values described above.
If a graphics reset noti?cation occurs in a context, a noti?cation must also occur
8
in all other contexts which share objects with that context .
After a graphics reset has occurred on a context, subsequent GL commands
on that context (or any context which shares with that context) will generate a
CONTEXT_LOST error. Such commands will not have side effects (in particular,
they will not modify memory passed by pointer for query results), and may not
block inde?nitely or cause termination of the application. Exceptions to this be-
havior include:
 GetError and GetGraphicsResetStatus behave normally following a
graphics reset, so that the application can determine a reset has occurred,
and when it is safe to destroy and re-create the context.
 Any commands which might cause a polling application to block inde?nitely
will generate aCONTEXT_LOST error, but will also return a value indicating
completion to the application. Such commands include:
– GetSynciv with pname SYNC_STATUS ignores the other parameters
and returnsSIGNALED in values.
– GetQueryObjectuiv with pname QUERY_RESULT_AVAILABLE ig-
nores the other parameters and returnsTRUE in params.
2.3.3 Flush and Finish
Implementations may buffer multiple commands in a command queue before send-
ing them to the GL server for execution. This may happen in places such as the
network stack (for network transparent implementations), CPU code executing as
part of the GL client or the GL server, or internally to the GPU hardware. Coarse
control over command queues is available using the command
void Flush(void );
9
which causes all previously issued GL commands to complete in ?nite time (al-
8
The values returned by GetGraphicsResetStatus in the different contexts may differ.
9
Historically, use of Flush has had negative performance implications for some implementa-
tions, and subsequently it does not universally operate as described here. One exception to this is
when the default framebuffer is bound, and it is single-buffered; in this case, ?ush behaves as ex-
pected. Other references to the ?ush operation in the speci?cation, such as that in section 4.1.2, will
behave as expected. Waiting on a fence sync object withSYNC_FLUSH_COMMANDS_BIT is
thus recommended as a way to perform a guaranteed ?ush.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 21
though such commands may still be executing when Flush returns).
The command
void Finish(void );
forces all previously issued GL commands to complete. Finish does not return
until all effects from such commands on GL client and server state and the frame-
buffer are fully realized.
Finer control over command execution can be expressed using fence commands
and sync objects, as discussed in section 4.1.
2.3.4 Numeric Representation and Computation
The GL must perform a number of ?oating-point operations during the course of
its operation.
Implementations normally perform computations in ?oating-point, and must
meet the range and precision requirements de?ned under ”Floating-Point Com-
putation” below.
These requirements only apply to computations performed in GL operations
outside of shader execution, such as texture image speci?cation and sampling, and
per-fragment operations. Range and precision requirements during shader execu-
tion differ and are speci?ed by the OpenGL Shading Language Specification.
In some cases, the representation and/or precision of operations is implicitly
limited by the speci?ed format of vertex, texture, or renderbuffer data consumed
by the GL. Speci?c ?oating-point formats are described later in this section.
2.3.4.1 Floating-Point Computation
We do not specify how ?oating-point numbers are to be represented, or the details
of how operations on them are performed.
We require simply that numbers’ ?oating-point parts contain enough bits and
that their exponent ?elds are large enough so that individual results of ?oating-
5
point operations are accurate to about 1 part in 10 . The maximum representable
32
magnitude for all ?oating-point values must be at least 2 . x 0 = 0x = 0 for
0
any non-in?nite and non-NaNx. 1x = x 1 = x. x + 0 = 0 +x = x. 0 =
1. (Occasionally further requirements will be speci?ed.) Most single-precision
?oating-point formats meet these requirements.
The special values Inf and Inf encode values with magnitudes too large to
be represented; the special value NaN encodes “Not A Number” values resulting
0
from unde?ned arithmetic operations such as . Implementations are permitted,
0
but not required, to support Inf s and NaN s in their ?oating-point computations.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 22
Any representable ?oating-point value is legal as input to a GL command that
requires ?oating-point data. The result of providing a value that is not a ?oating-
point number to such a command is unspeci?ed, but must not lead to GL interrup-
tion or termination. In IEEE arithmetic, for example, providing a negative zero or a
denormalized number to a GL command yields predictable results, while providing
a NaN or an in?nity yields unspeci?ed results.
2.3.4.2 16-Bit Floating-Point Numbers
A 16-bit ?oating-point number has a 1-bit sign (S), a 5-bit exponent (E), and a
10-bit mantissa (M). The valueV of a 16-bit ?oating-point number is determined
by the following:
8
S
>( 1)  0:0; E = 0;M = 0
>
>
>
M
> S  14
>( 1)  2  ; E = 0;M6= 0
10
<
2
  
S E 15 M
V =
( 1)  2  1 + ; 0<E < 31
10
2
>
>
S
>
>( 1)  Inf; E = 31;M = 0
>
>
:
NaN; E = 31;M =6 0
If the ?oating-point number is interpreted as an unsigned 16-bit integerN, then
 
N mod 65536
S =
32768
 
N mod 32768
E =
1024
M =N mod 1024:
Any representable 16-bit ?oating-point value is legal as input to a GL command
that accepts 16-bit ?oating-point data. The result of providing a value that is not a
?oating-point number (such as Inf or NaN ) to such a command is unspeci?ed, but
must not lead to GL interruption or termination. Providing a denormalized number
or negative zero to GL must yield predictable results.
2.3.4.3 Unsigned 11-Bit Floating-Point Numbers
An unsigned 11-bit ?oating-point number has no sign bit, a 5-bit exponent (E), and
a 6-bit mantissa (M). The valueV of an unsigned 11-bit ?oating-point number is
determined by the following:
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 23
8
>
0:0; E = 0;M = 0
>
>
>
 14 M
>
>2  ; E = 0;M =6 0
<
64
  
E 15 M
V = 2  1 + ; 0<E < 31
64
>
>
>
Inf; E = 31;M = 0
>
>
>
:
NaN; E = 31;M6= 0
If the ?oating-point number is interpreted as an unsigned 11-bit integerN, then
 
N
E =
64
M =N mod 64:
When a ?oating-point value is converted to an unsigned 11-bit ?oating-point
representation, ?nite values are rounded to the closest representable ?nite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, ?nite posi-
tive values greater than 65024 (the maximum ?nite representable unsigned 11-bit
?oating-point value) are converted to 65024. Additionally: negative in?nity is con-
verted to zero; positive in?nity is converted to positive in?nity; and both positive
and negative NaN are converted to positive NaN .
Any representable unsigned 11-bit ?oating-point value is legal as input to a
GL command that accepts 11-bit ?oating-point data. The result of providing a
value that is not a ?oating-point number (such as Inf or NaN ) to such a command
is unspeci?ed, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.
2.3.4.4 Unsigned 10-Bit Floating-Point Numbers
An unsigned 10-bit ?oating-point number has no sign bit, a 5-bit exponent (E), and
a 5-bit mantissa (M). The valueV of an unsigned 10-bit ?oating-point number is
determined by the following:
8
>0:0; E = 0;M = 0
>
>
>
 14 M
>
>2  ; E = 0;M =6 0
< 32
  
M
E 15
V =
2  1 + ; 0<E < 31
32
>
>
>
>Inf; E = 31;M = 0
>
>
:
NaN; E = 31;M6= 0
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 24
If the ?oating-point number is interpreted as an unsigned 10-bit integerN, then
 
N
E =
32
M =N mod 32:
When a ?oating-point value is converted to an unsigned 10-bit ?oating-point
representation, ?nite values are rounded to the closest representable ?nite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, ?nite posi-
tive values greater than 64512 (the maximum ?nite representable unsigned 10-bit
?oating-point value) are converted to 64512. Additionally: negative in?nity is con-
verted to zero; positive in?nity is converted to positive in?nity; and both positive
and negative NaN are converted to positive NaN .
Any representable unsigned 10-bit ?oating-point value is legal as input to a
GL command that accepts 10-bit ?oating-point data. The result of providing a
value that is not a ?oating-point number (such as Inf or NaN ) to such a command
is unspeci?ed, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.
2.3.4.5 Fixed-Point Computation
Vertex attributes may be speci?ed using a 32-bit two’s-complement signed repre-
sentation with 16 bits to the right of the binary point (fraction bits).
2.3.4.6 General Requirements
Some calculations require division. In such cases (including implied divisions re-
quired by vector normalizations), a division by zero produces an unspeci?ed result
but must not lead to GL interruption or termination.
2.3.5 Fixed-Point Data Conversions
When generic vertex attributes and pixel color or depth components are repre-
sented as integers, they are often (but not always) considered to be normalized.
Normalized integer values are treated specially when being converted to and from
?oating-point values, and are usually referred to as normalized ?xed-point. Such
values are always either signed or unsigned.
In the remainder of this section,b denotes the bit width of the ?xed-point inte-
ger representation. When the integer is one of the types de?ned in table 2.2,b is
OpenGL 4.6 (Core Pro?le) - February 2, 20192.3. COMMANDEXECUTION 25
the required bit width of that type. When the integer is a texture or renderbuffer
color or depth component (see section 8.5),b is the number of bits allocated to that
component in the internal format of the texture or renderbuffer. When the integer is
a framebuffer color or depth component (see section 9),b is the number of bits allo-
cated to that component in the framebuffer. For framebuffer and renderbuffer alpha
components,b must be at least 2 if the buffer does not contain an alpha component,
or if there is only one bit of alpha in the buffer.
The signed and unsigned ?xed-point representations are assumed to be b-bit
binary twos-complement integers and binary unsigned integers, respectively.
2.3.5.1 Conversion from Normalized Fixed-Point to Floating-Point
Unsigned normalized ?xed-point integers represent numbers in the range [0; 1].
The conversion from an unsigned normalized ?xed-point valuec to the correspond-
ing ?oating-point valuef is de?ned as
c
f = : (2.1)
b
2   1
Signed normalized ?xed-point integers represent numbers in the range [ 1; 1].
The conversion from a signed normalized ?xed-point valuec to the corresponding
?oating-point valuef is performed using
 
c
f = max ; 1:0 : (2.2)
b 1
2   1
b 1 b 1
Only the range [ 2 + 1; 2   1] is used to represent signed ?xed-point
values in the range [ 1; 1]. For example, if b = 8, then the integer value 127
corresponds to 1:0 and the value 127 corresponds to 1:0. Note that while zero
can be exactly expressed in this representation, one value ( 128 in the example)
is outside the representable range, and must be clamped before use. This equa-
tion is used everywhere that signed normalized ?xed-point values are converted
to ?oating-point, including for all signed normalized ?xed-point parameters in GL
10
commands, such as vertex attribute values , as well as for texture sampling or
framebuffer values used for blending.
2.3.5.2 Conversion from Floating-Point to Normalized Fixed-Point
The conversion from a ?oating-point valuef to the corresponding unsigned nor-
malized ?xed-point valuec is de?ned by ?rst clampingf to the range [0; 1], then
10
This is a behavior change in OpenGL 4.2. In previous versions, a different conversion for signed
normalized values was used in which 128 mapped to 1:0, 127 mapped to 1.0, and 0.0 was not
exactly representable.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.4. RENDERINGCOMMANDS 26
computing
0 b
f =convert float uint(f (2   1);b) (2.3)
where convert float uint(r;b) returns one of the two unsigned binary integer
values with exactly b bits which are closest to the ?oating-point value r (where
rounding to nearest is preferred).
The conversion from a ?oating-point valuef to the corresponding signed nor-
malized ?xed-point valuec is performed by clampingf to the range [ 1; 1], then
computing
0 b 1
f =convert float int(f (2   1);b) (2.4)
where convert float int(r;b) returns one of the two signed two’s-complement
binary integer values with exactly b bits which are closest to the ?oating-point
valuer (where rounding to nearest is preferred).
This equation is used everywhere that ?oating-point values are converted to
signed normalized ?xed-point, including when querying ?oating-point state (see
11
section 2.2.2) and returning integers , as well as for specifying signed normalized
texture or framebuffer values using ?oating-point.
2.4 Rendering Commands
GL commands performing rendering into a framebuffer are sometimes treated spe-
cially by other GL operations such as conditional rendering (see section 10.9).
Such commands are called rendering commands, and include the drawing com-
mands *Draw* (see section 10.4), as well as these additional commands:
 BlitFramebuffer (see section 18.3.1)
 Clear (see section 17.4.3)
 ClearBuffer* (see section 17.4.3.1)
 DispatchCompute* (see section 19)
11
This is a behavior change in OpenGL 4.2. In previous versions, a different conversion for signed
normalized values was used in which 1:0 mapped to 128, 1.0 mapped to 127, and 0.0 was not
exactly representable.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.5. CONTEXTSTATE 27
2.5 Context State
Context state is state that belongs to the GL context as a whole, rather than to
instances of the different object types described in section 2.6. Context state con-
trols ?xed-function stages of the GPU, such as clipping, primitive rasterization, and
framebuffer clears, and also speci?es bindings of objects to the context specifying
which objects are used during command execution.
The Specification describes all visible context state variables and describes how
each one can be changed. State variables are grouped somewhat arbitrarily by their
function. Although we describe operations that the GL performs on the frame-
buffer, the framebuffer is not a part of GL state.
There are two types of context state. Server state resides in the GL server;
the majority of GL state falls into this category. Client state resides in the GL
client. Unless otherwise speci?ed, all state is server state; client state is speci?cally
identi?ed. Each instance of a context includes a complete set of server state; each
connection from a client to a server also includes a complete set of client state.
While an implementation of OpenGL may be hardware dependent, the Speci?-
cation is independent of any speci?c hardware on which it is implemented. We are
concerned with the state of graphics hardware only when it corresponds precisely
to GL state.
2.5.1 Generic Context State Queries
Context state queries are described in detail in chapter 22.
2.6 Objects and the Object Model
Many types of objects are de?ned in the remainder of the Specification. Applica-
tions may create, modify, query, and destroy many instances of each of these object
types, limited in most cases only by available graphics memory. Speci?c instances
of different object types are bound to a context. The set of bound objects de?ne
the shaders which are invoked by GL drawing operations; specify the buffer data,
texture image, and framebuffer memory that is accessed by shaders and directly
by GL commands; and contain the state used by other operations such as fence
synchronization and timer queries.
Each object type corresponds to a distinct set of commands which manage ob-
jects of that type. However, there is an object model describing how most types
of objects are managed, described below. Exceptions to the object model for spe-
ci?c object types are described later in the Specification together with those object
types.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.6. OBJECTSANDTHEOBJECTMODEL 28
Following the description of the object model, each type of object is brie?y
described below, together with forward references to full descriptions of that ob-
ject type in later chapters of the Specification. Objects are described in an order
corresponding to the structure of the remainder of the Specification.
2.6.1 Object Management
2.6.1.1 Name Spaces, Name Generation, and Object Creation
Each object type has a corresponding name space. Names of objects are repre-
sented by unsigned integers of typeuint. The name zero is reserved by the GL;
for some object types, zero names a default object of that type, and in others zero
will never correspond to an actual instance of that object type.
Names of most types of objects are created by generating unused names us-
ing commands starting with Gen followed by the object type. For example, the
command GenBuffers returns one or more previously unused buffer object names.
Generated names are marked by the GL as used, for the purpose of name gener-
ation only. Object names marked in this fashion will not be returned by additional
calls to generate names of the same type until the names are marked unused again
by deleting them (see below).
Generated names do not initially correspond to an instance of an object. Ob-
jects with generated names are created by binding a generated name to the context.
For example, a buffer object is created by calling the command BindBuffer with
a name returned by GenBuffers, which allocates resources for the buffer object
and its state, and associate the name with that object. Sampler objects may also be
created by commands in addition to BindSampler, as described in section 8.2.
Objects may also be created directly by functions that return a new name or
names representing a freshly initialized object. Some functions return a single ob-
ject name directly whereas others are able to create a large number of new objects,
returning their names in an array. Examples of the former are CreateProgram
for program objects and FenceSync for fence sync objects. Examples of the latter
are CreateBuffers, CreateTextures and CreateVertexArrays for buffers, textures
and vertex arrays, respectively.
2.6.1.2 Name Deletion and Object Deletion
Objects are deleted by calling deletion commands speci?c to that object type. For
example, the command DeleteBuffers is passed an array of buffer object names
to delete. After an object is deleted it has no contents, and its name is once again
marked unused for the purpose of name generation. If names are deleted that do not
correspond to an object, but have been marked for the purpose of name generation,
OpenGL 4.6 (Core Pro?le) - February 2, 20192.6. OBJECTSANDTHEOBJECTMODEL 29
such names are marked as unused again. If unused and unmarked names are deleted
they are silently ignored, as is the name zero.
If an object is deleted while it is currently in use by a GL context, its name
is immediately marked as unused, and some types of objects are automatically
unbound from binding points in the current context, as described in section 5.1.2.
However, the actual underlying object is not deleted until it is no longer in use.
This situation is discussed in more detail in section 5.1.3.
2.6.1.3 Shared Object State
It is possible for groups of contexts to share some server state. Enabling such shar-
ing between contexts is done through window system binding APIs such as those
described in section 1.3.6. These APIs are responsible for creation and manage-
ment of contexts, and are not discussed further here. More detailed discussion of
the behavior of shared objects is included in chapter 5. Except as de?ned below
for speci?c object types, all state in a context is speci?c to that context only.
2.6.2 Buffer Objects
The GL uses many types of data supplied by the client. Some of this data must be
stored in server memory, and it is desirable to store other types of frequently used
client data, such as vertex array and pixel data, in server memory for performance
reasons, even if the option to store it in client memory exists.
Buffer objects contain a data store holding a ?xed-sized allocation of server
memory, and provide a mechanism to allocate, initialize, read from, and write to
such memory. Under certain circumstances, the data store of a buffer object may
be shared between the client and server and accessed simultaneously by both.
Buffer objects may be shared. They are described in detail in chapter 6.
2.6.3 Shader Objects
The source and/or binary code representing part or all of a shader program that is
executed by one of the programmable stages de?ned by the GL (such as a vertex
or fragment shader) is encapsulated in one or more shader objects.
Shader objects may be shared. They are described in detail in chapter 7.
2.6.4 Program Objects
Shader objects that are to be used by one or more of the programmable stages of
the GL are linked together to form a program object. The shader programs that
OpenGL 4.6 (Core Pro?le) - February 2, 20192.6. OBJECTSANDTHEOBJECTMODEL 30
are executed by these programmable stages are called executables. All information
necessary for de?ning each executable is encapsulated in a program object.
Program objects may be shared. They are described in detail in chapter 7.
2.6.5 Program Pipeline Objects
Program pipeline objects contain a separate program object binding point for each
programmable stage. They allow a primitive to be processed by independent pro-
grams in each programmable stage, instead of requiring a single program object
for each combination of shader operations. They allow greater ?exibility when
combining different shaders in various ways, without requiring a program object
for each such combination.
Program pipeline objects are container objects including references to program
objects, and are not shared. They are described in detail in chapter 7.
2.6.6 Texture Objects
Texture objects or textures include a data store containing a collection of texture
images built from arrays of image elements. The image elements are referred to
as texels. There are many types of texture objects varying by dimensionality and
structure; the different texture types are described in detail in the introduction to
chapter 8.
Texture objects also include state describing the image parameters of the tex-
ture images, and state describing how sampling is performed when a shader ac-
cesses a texture.
Shaders may sample a texture at a location indicated by speci?ed texture co-
ordinates, with details of sampling determined by the sampler state of the texture.
The resulting texture samples are typically used to modify a fragment’s color, in
order to map an image onto a geometric primitive being drawn, but may be used
for any purpose in a shader.
Texture objects may be shared. They are described in detail in chapter 8.
2.6.7 Sampler Objects
Sampler objects contain the subset of texture object state controlling how sampling
is performed when a shader accesses a texture. Sampler and texture objects may be
bound together so that the sampler object state is used by shaders when sampling
the texture, overriding equivalent state in the texture object. Separating texture
image data from the method of sampling that data allows reuse of the same sampler
OpenGL 4.6 (Core Pro?le) - February 2, 20192.6. OBJECTSANDTHEOBJECTMODEL 31
state with many different textures without needing to set the sampler state in each
texture.
Sampler objects may be shared. They are described in detail in chapter 8.
2.6.8 Renderbuffer Objects
Renderbuffer objects contain a single image in a format which can be rendered
to. Renderbuffer objects are attached to framebuffer objects (see below) when
performing off-screen rendering.
Renderbuffer objects may be shared. They are described in detail in chapter 9.
2.6.9 Framebuffer Objects
Framebuffer objects encapsulate the state of a framebuffer, including a collection of
color, depth, and stencil buffers. Each such buffer is represented by a renderbuffer
object or texture object attached to the framebuffer object.
Framebuffer objects are container objects including references to renderbuffer
12
and/or texture objects, and are not shared . They are described in detail in chap-
ter 9.
2.6.10 Vertex Array Objects
Vertex array objects represent a collection of sets of vertex attributes. Each set
is stored as an array in a buffer object data store, with each element of the array
having a speci?ed format and component count. The attributes of the currently
bound vertex array object are used as inputs to the vertex shader when executing
drawing commands.
Vertex array objects are container objects including references to buffer objects,
and are not shared. They are described in detail in chapter 10.
2.6.11 Transform Feedback Objects
Transform feedback objects are used to capture attributes of the vertices of trans-
formed primitives passed to the transform feedback stage when transform feedback
mode is active. They include state required for transform feedback together with
references to buffer objects in which attributes are captured.
12
Framebuffer objects created with the commands de?ned by the GL_EXT_-
framebuffer_object extension are de?ned to be shared, while FBOs created with
commands de?ned by the OpenGL core orGL_ARB_framebuffer_object extension are
de?ned to not be shared. Unde?ned behavior results when using FBOs created by EXT commands
through non-EXT interfaces, or vice-versa.
OpenGL 4.6 (Core Pro?le) - February 2, 20192.6. OBJECTSANDTHEOBJECTMODEL 32
Transform feedback objects are container objects including references to buffer
objects, and are not shared. They are described in detail in section 13.3.1.
2.6.12 Query Objects
Query objects return information about the processing of a sequence of GL com-
mands, such as the number of primitives processed by drawing commands; the
number of primitives written to transform feedback buffers; the number of sam-
ples that pass the depth test during fragment processing; and the amount of time
required to process commands.
Query objects are not shared. They are described in detail in section 4.2.
2.6.13 Sync Objects
A sync object acts as a synchronization primitive – a representation of events whose
completion status can be tested or waited upon. Sync objects may be used for syn-
chronization with operations occurring in the GL state machine or in the graphics
pipeline, and for synchronizing between multiple graphics contexts, among other
purposes.
Sync objects may be shared. They are described in detail in section 4.1.
2.6.14
This subsection is only de?ned in the compatibility pro?le.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 3
Data?ow Model
Figure 3.1 shows a block diagram of the GL. Some commands specify geometric
objects to be drawn while others specify state controlling how objects are han-
dled by the various stages, or specify data contained in textures and buffer objects.
Commands are effectively sent through a processing pipeline. Different stages of
the pipeline use data contained in different types of buffer objects.
The ?rst stage assembles vertices to form geometric primitives such as points,
line segments, and polygons. In the next stage vertices may be transformed, fol-
lowed by assembly into geometric primitives. Tessellation and geometry shaders
may then generate multiple primitives from a single input primitive. Optionally, the
results of these pipeline stages may be fed back into buffer objects using transform
feedback.
The ?nal resulting primitives are clipped to a clip volume in preparation for the
next stage, rasterization. The rasterizer produces a series of framebuffer addresses
and values using a two-dimensional description of a point, line segment, or poly-
gon. Each fragment so produced is fed to the next stage that performs operations
on individual fragments before they ?nally alter the framebuffer. These operations
include conditional updates into the framebuffer based on incoming and previously
stored depth values (to effect depth buffering), blending of incoming fragment col-
ors with stored colors, as well as masking, stenciling, and other logical operations
on fragment values.
Pixels may also be read back from the framebuffer or copied from one portion
of the framebuffer to another. These transfers may include some type of decoding
or encoding.
Finally, compute shaders which may read from and write to buffer objects may
be executed independently of the pipeline shown in ?gure 3.1.
This ordering is meant only as a tool for describing the GL, not as a strict rule
3334
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL.
OpenGL 4.6 (Core Pro?le) - February 2, 201935
Figure 3.1. Block diagram of the GL pipeline.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
From Application From Application 
Dispatch Indirect 
Vertex Puller Dispatch 
Element Array Buffer b 
Buffer b 
Vertex Shader 
Draw Indirect Buffer b 
Image Load / Store t/b 
Compute Shader 
Tessellation Control Shader 
Vertex Buffer Object b 
Atomic Counter b 
Tessellation Primitive Gen. 
Shader Storage b 
Tessellation Eval. Shader 
Texture Fetch t/b 
Geometry Shader 
Uniform Block b 
Transform Feedback 
Transform Feedback 
Buffer b 
Rasterization 
Legend 
From Application 
Fixed Function Stage 
Fragment Shader Pixel Unpack Buffer b 
Pixel Assembly 
Programmable Stage 
b – Buffer Binding Per-Fragment Operations Texture Image t 
Pixel Operations 
t – Texture Binding 
Pixel Pack Buffer b 
Framebuffer 
Pixel Pack Chapter 4
Event Model
4.1 Sync Objects and Fences
A sync object acts as a synchronization primitive – a representation of events whose
completion status can be tested or waited upon. Sync objects may be used for syn-
chronization with operations occurring in the GL state machine or in the graphics
pipeline, and for synchronizing between multiple graphics contexts, among other
purposes.
Sync objects have a status value with two possible states: signaled and
unsignaled. Events are associated with a sync object. When a sync object is cre-
ated, its status is set to unsignaled. When the associated event occurs, the sync
object is signaled (its status is set to signaled). The GL may be asked to wait for a
sync object to become signaled.
Initially, only one speci?c type of sync object is de?ned: the fence sync object,
whose associated event is triggered by a fence command placed in the GL com-
mand stream. Fence sync objects are used to wait for partial completion of the GL
command stream, as a more ?exible form of Finish.
The command
sync FenceSync(enum condition,bitfield ?ags );
creates a new fence sync object, inserts a fence command in the GL command
stream and associates it with that sync object, and returns a non-zero name corre-
sponding to the sync object.
When the speci?ed condition of the sync object is satis?ed by the fence com-
mand, the sync object is signaled by the GL, causing any ClientWaitSync or Wait-
Sync commands (see below) blocking on sync to unblock. No other state is affected
by FenceSync or by execution of the associated fence command.
364.1. SYNCOBJECTSANDFENCES 37
Property Name Property Value
OBJECT_TYPE SYNC_FENCE
SYNC_CONDITION condition
SYNC_STATUS UNSIGNALED
SYNC_FLAGS ?ags
Table 4.1: Initial properties of a sync object created with FenceSync.
condition must beSYNC_GPU_COMMANDS_COMPLETE. This condition is satis-
?ed by completion of the fence command corresponding to the sync object and all
preceding commands in the same command stream. The sync object will not be
signaled until all effects from these commands on GL client and server state and the
framebuffer are fully realized. Note that completion of the fence command occurs
once the state of the corresponding sync object has been changed, but commands
waiting on that sync object may not be unblocked until some time after the fence
command completes.
?ags must be zero.
Each sync object contains a number of properties which determine the state of
the object and the behavior of any commands associated with it. Each property has
a property name and property value. The initial property values for a sync object
created by FenceSync are shown in table 4.1.
Properties of a sync object may be queried with GetSynciv (see section 4.1.3).
TheSYNC_STATUS property will be changed toSIGNALED when condition is sat-
is?ed.
Errors
If FenceSync fails to create a sync object, zero will be returned and a GL
error is generated.
An INVALID_ENUM error is generated if condition is not SYNC_GPU_-
COMMANDS_COMPLETE.
AnINVALID_VALUE error is generated if ?ags is not zero.
A sync object can be deleted by passing its name to the command
void DeleteSync(sync sync );
If the fence command corresponding to the speci?ed sync object has com-
pleted, or if no ClientWaitSync or WaitSync commands are blocking on sync, the
object is deleted immediately. Otherwise, sync is ?agged for deletion and will be
OpenGL 4.6 (Core Pro?le) - February 2, 20194.1. SYNCOBJECTSANDFENCES 38
deleted when it is no longer associated with any fence command and is no longer
blocking any ClientWaitSync or WaitSync command. In either case, after return-
ing from DeleteSync the sync name is invalid and can no longer be used to refer to
the sync object.
DeleteSync will silently ignore a sync value of zero.
Errors
AnINVALID_VALUE error is generated if sync is neither zero nor the name
of a sync object.
4.1.1 Waiting for Sync Objects
The command
enum ClientWaitSync(sync sync,bitfield ?ags,
uint64 timeout );
causes the GL to block, and will not return until the sync object sync is signaled,
or until the speci?ed timeout period expires. timeout is in units of nanoseconds.
timeout is adjusted to the closest value allowed by the implementation-dependent
timeout accuracy, which may be substantially longer than one nanosecond, and
may be longer than the requested period.
If sync is signaled at the time ClientWaitSync is called, then ClientWait-
Sync returns immediately. If sync is unsignaled at the time ClientWaitSync is
called, then ClientWaitSync will block and will wait up to timeout nanoseconds
for sync to become signaled. ?ags controls command ?ushing behavior, and may
beSYNC_FLUSH_COMMANDS_BIT, as discussed in section 4.1.2.
ClientWaitSync returns one of four status values. A return value of
ALREADY_SIGNALED indicates that sync was signaled at the time ClientWait-
Sync was called. ALREADY_SIGNALED will always be returned if sync was sig-
naled, even if the value of timeout is zero. A return value of TIMEOUT_EXPIRED
indicates that the speci?ed timeout period expired before sync was signaled. A re-
turn value ofCONDITION_SATISFIED indicates that sync was signaled before the
timeout expired. Finally, if an error occurs, in addition to generating a GL error
as speci?ed below, ClientWaitSync immediately returns WAIT_FAILED without
blocking.
If the value of timeout is zero, then ClientWaitSync does not block, but simply
tests the current state of sync. TIMEOUT_EXPIRED will be returned in this case if
sync is not signaled, even though no actual wait was performed.
OpenGL 4.6 (Core Pro?le) - February 2, 20194.1. SYNCOBJECTSANDFENCES 39
Errors
An INVALID_VALUE error is generated if sync is not the name of a sync
object.
AnINVALID_VALUE error is generated if ?ags contains any bits other than
SYNC_FLUSH_COMMANDS_BIT.
The command
void WaitSync(sync sync,bitfield ?ags,
uint64 timeout );
is similar to ClientWaitSync, but instead of blocking and not returning to the ap-
plication until sync is signaled, WaitSync returns immediately, instead causing the
1 2
GL server to block until sync is signaled .
sync has the same meaning as for ClientWaitSync.
timeout must currently be the special value TIMEOUT_IGNORED, and is not
used. Instead, WaitSync will always wait no longer than an implementation-
dependent timeout. The duration of this timeout in nanoseconds may be queried
by calling GetInteger64v with pname MAX_SERVER_WAIT_TIMEOUT. There is
currently no way to determine whether WaitSync unblocked because the timeout
expired or because the sync object being waited on was signaled.
?ags must be zero.
If an error occurs, WaitSync generates a GL error as speci?ed below, and does
not cause the GL server to block.
Errors
An INVALID_VALUE error is generated if sync is not the name of a sync
object.
An INVALID_VALUE error is generated if timeout is not TIMEOUT_-
a
IGNORED or ?ags is not zero .
a
?ags and timeout are placeholders for anticipated future extensions of sync object capa-
bilities. They must have these reserved values in order that existing code calling WaitSync
operate properly in the presence of such extensions.
1
The GL server may choose to wait either in the CPU executing server-side code, or in the GPU
hardware if it supports this operation.
2
WaitSync allows applications to continue to queue commands from the client in anticipation of
the sync being signaled, increasing client-server parallelism.
OpenGL 4.6 (Core Pro?le) - February 2, 20194.1. SYNCOBJECTSANDFENCES 40
4.1.1.1 Multiple Waiters
It is possible for both the GL client to be blocked on a sync object in a ClientWait-
Sync command, the GL server to be blocked as the result of a previous WaitSync
command, and for additional WaitSync commands to be queued in the GL server,
all for a single sync object. When such a sync object is signaled in this situation,
the client will be unblocked, the server will be unblocked, and all such queued
WaitSync commands will continue immediately when they are reached.
See section 5.2 for more information about blocking on a sync object in multi-
ple GL contexts.
4.1.2 Signaling
A fence sync object enters the signaled state only once the corresponding fence
command has completed and signaled the sync object.
If the sync object being blocked upon will not be signaled in ?nite time (for
example, by an associated fence command issued previously, but not yet ?ushed
to the graphics pipeline), then ClientWaitSync may hang forever. To help prevent
3
this behavior , if ClientWaitSync is called and all of the following are true:
 theSYNC_FLUSH_COMMANDS_BIT bit is set in ?ags,
 sync is unsignaled when ClientWaitSync is called,
 and the calls to ClientWaitSync and FenceSync were issued from the same
context,
then the GL will behave as if the equivalent of Flush were inserted immediately
after the creation of sync.
Additional constraints on the use of sync objects are discussed in chapter 5.
State must be maintained to indicate which sync object names are currently
in use. The state required for each sync object in use is an integer for the speci?c
type, an integer for the condition, and a bit indicating whether the object is signaled
or unsignaled. The initial values of sync object state are de?ned as speci?ed by
FenceSync.
3
The simple ?ushing behavior de?ned by SYNC_FLUSH_COMMANDS_BIT will not help
when waiting for a fence command issued in another context’s command stream to complete. Ap-
plications which block on a fence sync object must take additional steps to assure that the context
from which the corresponding fence command was issued has ?ushed that command to the graphics
pipeline.
OpenGL 4.6 (Core Pro?le) - February 2, 20194.1. SYNCOBJECTSANDFENCES 41
4.1.3 Sync Object Queries
Properties of sync objects may be queried using the command
void GetSynciv(sync sync,enum pname,sizei bufSize,
sizei *length,int *values );
The value or values being queried are returned in the parameters length and
values.
On success, GetSynciv replaces up to bufSize integers in values with the cor-
responding property values of the object being queried. The actual number of
integers replaced is returned in *length. If length isNULL, no length is returned.
If pname isOBJECT_TYPE, a single value representing the speci?c type of the
sync object is placed in values. The only type supported isSYNC_FENCE.
If pname is SYNC_STATUS, a single value representing the status of the sync
object (SIGNALED orUNSIGNALED) is placed in values.
If pname is SYNC_CONDITION, a single value representing the condition of
the sync object is placed in values. The only condition supported isSYNC_GPU_-
COMMANDS_COMPLETE.
If pname isSYNC_FLAGS, a single value representing the ?ags with which the
sync object was created is placed in values. No ?ags are currently supported.
Errors
An INVALID_VALUE error is generated if sync is not the name of a sync
object.
An INVALID_ENUM error is generated if pname is not one of the values
described above.
AnINVALID_VALUE error is generated if bufSize is negative.
The command
boolean IsSync(sync sync );
returnsTRUE if sync is the name of a sync object. If sync is not the name of a sync
object, or if an error condition occurs, IsSync returnsFALSE (note that zero is not
the name of a sync object).
Sync object names immediately become invalid after calling DeleteSync, as
discussed in sections 4.1 and 5.2, but the underlying sync object will not be deleted
until it is no longer associated with any fence command and no longer blocking
any *WaitSync command.
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 42
4.2 Query Objects and Asynchronous Queries
Asynchronous queries provide a mechanism to return information about the pro-
cessing of a sequence of GL commands.
4.2.1 Query Object Types and Targets
Query types supported by the GL include:
 Primitive queries with a target of PRIMITIVES_GENERATED (see sec-
tion 13.4) return information on the number of primitives processed by
the GL. There may be at most the value of MAX_VERTEX_STREAMS active
queries of this type.
 Primitive queries with a target ofTRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN (see section 13.4) return information on the number of primitives
written to one or more buffer objects. There may be at most the value of
MAX_VERTEX_STREAMS active queries of this type.
 Transform feedback over?ow queries with a target of TRANSFORM_-
FEEDBACK_OVERFLOW or TRANSFORM_FEEDBACK_STREAM_OVERFLOW
return information on whether or not transform feedback over?ow happened
for one or more streams (see section 13.5).
 Occlusion queries with a target of SAMPLES_PASSED, ANY_SAMPLES_-
PASSED or ANY_SAMPLES_PASSED_CONSERVATIVE (see section 17.3.5)
count the number of fragments or samples that pass the depth test, or set a
boolean to true when any fragments or samples pass the depth test. There
may be at most one active query of this type.
 Time elapsed queries with a target of TIME_ELAPSED (see section 4.3)
record the amount of time needed to fully process a sequence of commands.
There may be at most one active query of this type.
 Timer queries with a target of TIMESTAMP (see section 4.3) record the cur-
rent time of the GL. There may be at most one active query of this type.
 Submission queries with a target of VERTICES_SUBMITTED and
PRIMITIVES_SUBMITTED return information on the number of vertices and
primitives transferred to the GL, respectively (see section 10.10).
 Vertex shader queries with a target ofVERTEX_SHADER_INVOCATIONS re-
turn information on the number of times the vertex shader has been invoked
(see section 11.1.4).
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 43
 Tessellation shader queries with a target of TESS_CONTROL_SHADER_-
PATCHES and TESS_EVALUATION_SHADER_INVOCATIONS return infor-
mation on the number of patches processed by the tessellation control shader
stage and the number of times the tessellation evaluation shader has been in-
voked, respectively (see section 11.2.4).
 Geometry shader queries with a target of GEOMETRY_SHADER_-
INVOCATIONS andGEOMETRY_SHADER_PRIMITIVES_EMITTED return in-
formation on the number of times the geometry shader has been invoked and
the number of primitives it emitted (see section 11.3.5).
 Primitive clipping queries with a target ofCLIPPING_INPUT_PRIMITIVES
andCLIPPING_OUTPUT_PRIMITIVES return information on the number of
primitives that were processed in the primitive clipping stage and the number
of primitives that were output by the primitive clipping stage and are further
processed by the rasterization stage, respectively (see section 13.7.3).
 Fragment shader queries with a target of FRAGMENT_SHADER_-
INVOCATIONS return information on the number of times the fragment
shader has been invoked (see section 15.3).
 Compute shader queries with a target ofCOMPUTE_SHADER_INVOCATIONS
return information on the number of times the compute shader has been in-
voked (see section 19.2).
4.2.2 Query Object Creation and Activation
The results of asynchronous queries are not returned by the GL immediately after
the completion of the last command in the set; subsequent commands can be pro-
cessed while the query results are not complete. When available, the query results
are stored in an associated query object. The commands described in section 4.2.3
provide mechanisms to determine when query results are available and return the
actual results of the query. The name space for query objects is the unsigned inte-
gers, with zero reserved by the GL.
The command
void GenQueries(sizei n,uint *ids );
returns n previously unused query object names in ids. These names are marked
as used, for the purposes of GenQueries only, but no object is associated with
them until the ?rst time they are used by BeginQuery, BeginQueryIndexed, or
QueryCounter (see section 4.3).
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 44
Errors
AnINVALID_VALUE error is generated if n is negative.
Query objects may also be created with the command
void CreateQueries(enum target,sizei n,uint *ids );
CreateQueries returns n previously unused query object names in ids, each
representing a new query object with the speci?ed target. target must be one of the
query object targets described in section 4.2.1.
The initial state of the resulting query object is that the result is marked avail-
able (the value ofQUERY_RESULT_AVAILABLE for the query object isTRUE) and
the result value (the value ofQUERY_RESULT) is zero.
Errors
An INVALID_ENUM error is generated if target is not one of the query
object targets described in section 4.2.1.
AnINVALID_VALUE error is generated if n is negative.
Query objects are deleted by calling
void DeleteQueries(sizei n,const uint *ids );
ids contains n names of query objects to be deleted. After a query object is deleted,
its name is again unused. If an active query object is deleted its name immediately
becomes unused, but the underlying object is not deleted until it is no longer active
(see section 5.1). Unused names in ids that have been marked as used for the
purposes of GenQueries are marked as unused again. Unused names in ids are
silently ignored, as is the value zero.
Errors
AnINVALID_VALUE error is generated if n is negative.
Each type of query, other than timer queries of typeTIMESTAMP, supported by
the GL has an active query object name for each of the possible active queries. If
an active query object name is non-zero, the GL is currently tracking the corre-
sponding information, and the query results will be written into that query object.
If an active query object name is zero, no such information is being tracked.
A query object may be created and made active with the command
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 45
void BeginQueryIndexed(enum target,uint index,
uint id );
target indicates the type of query to be performed. The valid values of target are
discussed in more detail in subsequent sections.
If id is an unused query object name, the name is marked as used and associated
with a new query object of the type speci?ed by target. Otherwise id must be the
name of an existing query object of that type. Note that occlusion query objects
speci?ed by either of the two targetsANY_SAMPLES_PASSED orANY_SAMPLES_-
PASSED_CONSERVATIVE may be reused for either target in future queries. Objects
speci?ed with targetSAMPLES_PASSED may only be reused for that target.
index is the index of the query, and must be between zero and a target-speci?c
maximum. The state of the query object named id, whether newly created or not,
is that the result is marked unavailable (the value ofQUERY_RESULT_AVAILABLE
for the query object isFALSE), and the result value (the value ofQUERY_RESULT)
is zero.
The active query object name for target and index is set to id.
Errors
An INVALID_ENUM error is generated if target is TIMESTAMP, or is not
one of the query object targets described in section 4.2.1.
An INVALID_VALUE error is generated if tar-
get is PRIMITIVES_GENERATED, TRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN, or TRANSFORM_FEEDBACK_STREAM_OVERFLOW, and index is not
in the range zero to the value ofMAX_VERTEX_STREAMS minus one.
An INVALID_VALUE error is generated if target is a valid target other
than PRIMITIVES_GENERATED, TRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN, or TRANSFORM_FEEDBACK_STREAM_OVERFLOW, and index is not
zero.
An INVALID_OPERATION error is generated if id is not a name returned
from a previous call to GenQueries or CreateQueries, or if such a name has
since been deleted with DeleteQueries.
AnINVALID_OPERATION error is generated if id is any of:
 zero
 the name of an existing query object whose type does not match target
 an active query object name for any target and index
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 46
 the active query object for conditional rendering (see section 10.9).
An INVALID_OPERATION error is generated if the active query object
name for target and index is non-zero.
The command
void BeginQuery(enum target,uint id );
is equivalent to
BeginQueryIndexed(target, 0, id);
The command
void EndQueryIndexed(enum target,uint index );
marks the end of the sequence of commands to be tracked for the active query
speci?ed by target and index. target and index have the same meaning as for Be-
ginQueryIndexed.
The corresponding active query object is updated to indicate that query results
are not available, and the active query object name for target and index is reset to
zero. When the commands issued prior to EndQueryIndexed have completed and
a ?nal query result is available, the query object active when EndQueryIndexed
was called is updated to contain the query result and to indicate that the query result
is available.
Errors
An INVALID_ENUM error is generated if target is TIMESTAMP, or is not
one of the query object targets described in section 4.2.1.
An INVALID_VALUE error is generated if tar-
get is PRIMITIVES_GENERATED TRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN, or TRANSFORM_FEEDBACK_STREAM_OVERFLOW, and index is not
in the range zero to the value ofMAX_VERTEX_STREAMS minus one.
An INVALID_VALUE error is generated if target is a valid target other
than PRIMITIVES_GENERATED, TRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN, or TRANSFORM_FEEDBACK_STREAM_OVERFLOW, and index is not
zero.
An INVALID_OPERATION error is generated if the active query object
name for target and index is zero.
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 47
The command
void EndQuery(enum target );
is equivalent to
EndQueryIndexed(target, 0);
Query objects contain two pieces of state: a single bit indicating whether a
query result is available, and an integer containing the query result value. The
number of bits,n, used to represent the query result is implementation-dependent
and may be determined as described in section 4.2.3. The initial state of a query
object depends on whether it was created with CreateQueries or BeginQueryIn-
dexed, as described above.
n
If the query result over?ows (exceeds the value 2   1), its value becomes
unde?ned. It is recommended, but not required, that implementations handle this
n
over?ow case by saturating at 2   1 and incrementing no further.
The necessary state for each possible active query target and index is an un-
signed integer holding the active query object name (zero if no query object is ac-
tive), and any state necessary to keep the current results of an asynchronous query
in progress. Only a single type of occlusion query can be active at one time, so the
required state for occlusion queries is shared.
4.2.3 Query Object Queries
The command
boolean IsQuery(uint id );
returnsTRUE if id is the name of a query object. If id is zero, or if id is a non-zero
value that is not the name of a query object, IsQuery returnsFALSE.
Information about an active query object may be queried with the command
void GetQueryIndexediv(enum target,uint index,
enum pname,int *params );
target and index specify the active query, and have the same meaning as for Begin-
QueryIndexed.
If pname isCURRENT_QUERY, the name of the currently active query object for
target and index, or zero if no query is active, will be placed in params. If target is
TIMESTAMP, zero is always returned.
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 48
If pname isQUERY_COUNTER_BITS, index is ignored and the implementation-
dependent number of bits used to hold the query result for target will be placed in
params. The number of query counter bits may be zero, in which case the counter
contains no useful information.
For primitive queries (PRIMITIVES_GENERATED and TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN) if the number of bits is non-zero, the
minimum number of bits allowed is 32.
For transform feedback over?ow queries (TRANSFORM_-
FEEDBACK_OVERFLOW and TRANSFORM_FEEDBACK_STREAM_OVERFLOW) if the
number of bits is non-zero, the minimum number of bits is 1.
For occlusion queries with target ANY_SAMPLES_PASSED or ANY_-
SAMPLES_PASSED_CONSERVATIVE, if the number of bits is non-zero, the min-
imum number of bits is 1. For occlusion queries with targetSAMPLES_PASSED, if
the number of bits is non-zero, the minimum number of bits allowed is 32.
For timer queries (target TIME_ELAPSED and TIMESTAMP), if the number of
bits is non-zero, the minimum number of bits allowed is 30. This will allow at least
one second of timing.
For pipeline statistics queries (target VERTICES_SUBMITTED,
PRIMITIVES_SUBMITTED, VERTEX_SHADER_INVOCATIONS, TESS_-
CONTROL_SHADER_PATCHES, TESS_EVALUATION_SHADER_INVOCATIONS,
GEOMETRY_SHADER_INVOCATIONS, FRAGMENT_SHADER_INVOCATIONS,
COMPUTE_SHADER_INVOCATIONS, GEOMETRY_SHADER_PRIMITIVES_-
EMITTED, CLIPPING_INPUT_PRIMITIVES, and CLIPPING_OUTPUT_-
PRIMITIVES), if the number of bits is non-zero, the minimum number of bits
allowed is 32.
Errors
An INVALID_ENUM error is generated if target is not one of the query
object targets described in section 4.2.1.
An INVALID_VALUE error is generated if tar-
get is PRIMITIVES_GENERATED, TRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN, or TRANSFORM_FEEDBACK_STREAM_OVERFLOW, and index is not
in the range zero to the value ofMAX_VERTEX_STREAMS minus one.
An INVALID_VALUE error is generated if target is a valid target other
than PRIMITIVES_GENERATED, TRANSFORM_FEEDBACK_PRIMITIVES_-
WRITTEN, or TRANSFORM_FEEDBACK_STREAM_OVERFLOW, and index is not
zero.
An INVALID_ENUM error is generated if pname is not CURRENT_QUERY
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 49
orQUERY_COUNTER_BITS.
The command
void GetQueryiv(enum target,enum pname,int *params );
is equivalent to
GetQueryIndexediv(target, 0, pname, params);
The state of a query object may be queried with the commands
void GetQueryObjectiv(uint id,enum pname,
int *params );
void GetQueryObjectuiv(uint id,enum pname,
uint *params );
void GetQueryObjecti64v(uint id,enum pname,
int64 *params );
void GetQueryObjectui64v(uint id,enum pname,
uint64 *params );
void GetQueryBufferObjectiv(uint id,uint buffer,
enum pname,intptr offset );
void GetQueryBufferObjectuiv(uint id,uint buffer,
enum pname,intptr offset );
void GetQueryBufferObjecti64v(uint id,uint buffer,
enum pname,intptr offset );
void GetQueryBufferObjectui64v(uint id,uint buffer,
enum pname,intptr offset );
id is the name of a query object.
For GetQueryBufferObject*, buffer is the name of a buffer object and offset
is an offset into buffer at which the queried value is written.
For GetQueryObject*, the queried value may be returned either in client
memory or in a buffer object. If zero is bound to the current query result buffer
binding point (see QUERY_RESULT in section 6.1), then params is treated as a
pointer into client memory at which the queried value is written. Otherwise,
params is treated as an offset into the query result buffer object at which the queried
value is written.
There may be an indeterminate delay before a query object’s result value is
available. If pname is QUERY_RESULT_AVAILABLE, FALSE is returned if such a
delay would be required; otherwise TRUE is returned. It must always be true that
OpenGL 4.6 (Core Pro?le) - February 2, 20194.2. QUERYOBJECTSANDASYNCHRONOUSQUERIES 50
if any query object returns a result available ofTRUE, all queries of the same type
issued prior to that query must also return TRUE. Repeatedly querying QUERY_-
RESULT_AVAILABLE for any given query object is guaranteed to return TRUE
eventually.
If pname is QUERY_TARGET, then the target of the query object is returned as
a single integer.
If pname isQUERY_RESULT, then the query object’s result value is returned as
a single integer. If the value is so large in magnitude that it cannot be represented
with the requested type, then the nearest value representable using the requested
type is returned. If the number of query counter bits for target is zero, then the
result is returned as a single integer with the value zero. QueryingQUERY_RESULT
for any given query object forces that query to complete within a ?nite amount of
time.
If pname is QUERY_RESULT_NO_WAIT, then the query object’s result value is
returned as a single integer if the result is available at the time of the state query. If
the result is not available then the query return value is not written.
If multiple queries are issued using the same object name prior to calling these
query commands, the result and availability information returned will always be
from the last query issued. The results from any queries before the last one will be
lost if they are not retrieved before starting a new query on the same target and id.
Errors
An INVALID_OPERATION error is generated if id is not the name of a
query object, or if the query object named by id is currently active.
An INVALID_OPERATION error is generated by GetQueryBufferOb-
ject* if buffer is not the name of an existing buffer object.
An INVALID_ENUM error is generated if pname is not QUERY_RESULT,
QUERY_RESULT_AVAILABLE, QUERY_RESULT_NO_WAIT, or
QUERY_TARGET.
AnINVALID_OPERATION error is generated if the query writes to a buffer
object, and the speci?ed buffer offset would cause data to be written beyond
the bounds of that buffer object.
An INVALID_VALUE error is generated by GetQueryBufferObject* if
offset is negative.
OpenGL 4.6 (Core Pro?le) - February 2, 20194.3. TIMEQUERIES 51
4.3 Time Queries
Query objects may also be used to track the amount of time needed to fully com-
plete a set of GL commands (a time elapsed query), or to determine the current
time of the GL (a timer query).
When BeginQuery and EndQuery are called with a target ofTIME_ELAPSED,
the GL prepares to start and stop the timer used for time elapsed queries. The timer
is started or stopped when the effects from all previous commands on the GL client
and server state and the framebuffer have been fully realized. The BeginQuery and
EndQuery commands may return before the timer is actually started or stopped.
When the time elapsed query timer is ?nally stopped, the elapsed time (in nanosec-
onds) is written to the corresponding query object as the query result value, and the
query result for that object is marked as available.
A timer query object is created with the command
void QueryCounter(uint id,enum target );
target must be TIMESTAMP. If id is an unused query object name, the name is
marked as used and associated with a new query object of typeTIMESTAMP. Oth-
erwise id must be the name of an existing query object of that type.
Alternatively, TIMESTAMP query objects can be created by calling Create-
Queries with target set toTIMESTAMP.
When QueryCounter is called, the GL records the current time into the cor-
responding query object. The time is recorded after all previous commands on
the GL client and server state and the framebuffer have been fully realized. When
the time is recorded, the query result for that object is marked available. Timer
queries can be used within a BeginQuery / EndQuery block where the target is
TIME_ELAPSED, and it does not affect the result of that query object.
The current time of the GL may be queried by calling GetIntegerv or Get-
Integer64v with the symbolic constant TIMESTAMP. This will return the GL time
after all previous commands have reached the GL server but have not yet neces-
sarily executed. By using a combination of this synchronous get command and the
asynchronous timestamp query object target, applications can measure the latency
between when commands reach the GL server and when they are realized in the
framebuffer.
Errors
AnINVALID_ENUM error is generated if target is notTIMESTAMP.
An INVALID_OPERATION error is generated if id is not a name returned
OpenGL 4.6 (Core Pro?le) - February 2, 20194.3. TIMEQUERIES 52
from a previous call to GenQueries, or if such a name has since been deleted
with DeleteQueries.
AnINVALID_OPERATION error is generated if id is the name of an exist-
ing query object whose type is notTIMESTAMP.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 5
Shared Objects and Multiple
Contexts
This chapter describes special considerations for objects shared between multiple
OpenGL contexts, including deletion behavior and how changes to shared objects
are propagated between contexts.
Objects that may be shared between contexts include buffer objects, program
and shader objects, renderbuffer objects, sampler objects, sync objects, and texture
objects (except for the texture objects named zero).
Some of these objects may contain views (alternate interpretations) of part or
all of the data store of another object. Examples are texture buffer objects, which
contain a view of a buffer object’s data store, and texture views, which contain a
view of another texture object’s data store. Views act as references on the object
whose data store is viewed.
Objects which contain references to other objects include framebuffer, program
pipeline, query, transform feedback, and vertex array objects. Such objects are
called container objects and are not shared.
Implementations may allow sharing between contexts implementing differ-
ent OpenGL versions or different pro?les of the same OpenGL version (see ap-
pendix E). However, implementation-dependent behavior may result when aspects
and/or behaviors of such shared objects do not apply to, and/or are not described
by more than one version or pro?le.
535.1. OBJECTDELETIONBEHAVIOR 54
5.1 Object Deletion Behavior
5.1.1 Side Effects of Shared Context Destruction
The share list is the group of all contexts which share objects. If a shared object
is not explicitly deleted, then destruction of any individual context has no effect
on that object unless it is the only remaining context in the share list. Once the
last context on the share list is destroyed, all shared objects, and all other resources
allocated for that context or share list, will be deleted and reclaimed by the imple-
mentation as soon as possible.
5.1.2 Automatic Unbinding of Deleted Objects
When a buffer, texture, or renderbuffer object is deleted, it is unbound from any
bind points it is bound to in the current context, and detached from any attachments
of container objects that are bound to the current context, as described for Delete-
Buffers, DeleteTextures, and DeleteRenderbuffers. If the object binding was
established with other related state (such as a buffer range in BindBufferRange or
selected level and layer information in FramebufferTexture or BindImageTex-
ture), all such related state are restored to default values by the automatic unbind.
Bind points in other contexts are not affected. Attachments to unbound container
objects, such as deletion of a buffer attached to a vertex array object which is not
bound to the context, are not affected and continue to act as references on the
deleted object, as described in the following section.
5.1.3 Deleted Object and Object Name Lifetimes
When a buffer, texture, sampler, renderbuffer, query, or sync object is deleted, its
name immediately becomes invalid (e.g. is marked unused), but the underlying
object will not be deleted until it is no longer in use.
A buffer, texture, sampler, or renderbuffer object is in use if any of the follow-
ing conditions are satis?ed:
 the object is attached to any container object
 the object is bound to a context bind point in any context
 any other object contains a view of the data store of the object.
A sync object is in use while there is a corresponding fence command which
has not yet completed and signaled the sync object, or while there are any GL
OpenGL 4.6 (Core Pro?le) - February 2, 20195.2. SYNCOBJECTSANDMULTIPLECONTEXTS 55
clients and/or servers blocked on the sync object as a result of ClientWaitSync or
WaitSync commands.
Query objects are in use so long as they are active, as described in section 4.2.
When a shader object or program object is deleted, it is ?agged for deletion, but
its name remains valid until the underlying object can be deleted because it is no
longer in use. A shader object is in use while it is attached to any program object.
A program object is in use while it is attached to any program pipeline object or is
a current program in any context.
Caution should be taken when deleting an object while it is in use (as de?ned
above). Following its deletion, the object’s name may be returned by Gen* or
Create* commands. The underlying object state and data for such a deleted, but
still in use object may still be read and written by the GL, but cannot be accessed
by name. The underlying storage backing a deleted object will not be reclaimed by
the GL until all references to the object from container object attachment points,
context binding points, views, fence commands, active queries, etc. are removed.
Since the name is marked unused, binding the name will create a new object with
the same name, and attaching the name will generate an error.
5.2 Sync Objects and Multiple Contexts
When multiple GL clients and/or servers are blocked on a single sync object and
that sync object is signaled, all such blocks are released. The order in which blocks
are released is implementation-dependent.
5.3 Propagating Changes to Objects
GL objects contain two types of information, data and state. Collectively these
are referred to below as the contents of an object. For the purposes of propagating
changes to object contents as described below, data and state are treated consis-
tently.
Data is information the GL implementation does not have to inspect, and does
not have an operational effect. Currently, data consists of:
 Pixels in the framebuffer.
 The contents of the data stores of buffer objects, renderbuffers, and textures.
State determines the con?guration of the rendering pipeline, and the GL imple-
mentation does have to inspect it.
OpenGL 4.6 (Core Pro?le) - February 2, 20195.3. PROPAGATINGCHANGESTOOBJECTS 56
In hardware-accelerated GL implementations, state typically lives in GPU reg-
isters, while data typically lives in GPU memory.
When the contents of an object T are changed, such changes are not always
immediately visible, and do not always immediately affect GL operations involving
that object. Changes may occur via any of the following means:
 State-setting commands, such as TexParameter.
 Data-setting commands, such as TexSubImage* or BufferSubData.
 Data-setting through rendering to renderbuffers or textures attached to a
framebuffer object.
 Data-setting through transform feedback operations followed by an End-
TransformFeedback command.
 Commands that affect both state and data, such as TexImage* and Buffer-
Data.
 Changes to mapped buffer data followed by a command such as Unmap-
Buffer or FlushMappedBufferRange.
 Rendering commands that trigger shader invocations, where the shader per-
forms image or buffer variable stores or atomic operations, or built-in atomic
counter functions.
When T is a texture, the contents of T are construed to include the contents of
the data store of T, even if T’s data store was modi?ed via a different view of the
data store.
5.3.1 Determining Completion of Changes to an object
The contents of an object T are considered to have been changed once a command
1
such as described in section 5.3 has completed. Completion of a command may
be determined either by calling Finish, or by calling FenceSync and executing a
WaitSync command on the associated sync object. The second method does not
require a round trip to the GL server and may be more ef?cient, particularly when
changes to T in one context must be known to have completed before executing
commands dependent on those changes in another context. In cases where a feed-
back loop has been established (see sections 8.6.1, 8.14.2.1, and 9.3, as well as the
1
The GL already speci?es that a single context processes commands in the order they are received.
This means that a change to an object in a context at time t must be completed by the time a command
issued in the same context at timet+1 uses the result of that change.
OpenGL 4.6 (Core Pro?le) - February 2, 20195.3. PROPAGATINGCHANGESTOOBJECTS 57
discussion of rule 1 below in section 5.3.3) the resulting contents of an object may
be unde?ned.
5.3.2 De?nitions
In the remainder of this section, the following terminology is used:
 An object T is directly attached to the current context if it has been bound to
one of the context binding points. Examples include but are not limited to
bound textures, bound framebuffers, bound vertex arrays, and current pro-
grams.
 T is indirectly attached to the current context if it is attached to another ob-
ject C, referred to as a container object, and C is itself directly or indirectly
attached. Examples include but are not limited to renderbuffers or textures
attached to framebuffers; buffers attached to vertex arrays; and shaders at-
tached to programs.
 An object T which is directly attached to the current context may be re-
attached by re-binding T at the same bind point. An object T which is indi-
rectly attached to the current context may be re-attached by re-attaching the
container object C to which T is attached.
Corollary: re-binding C to the current context re-attaches C and its hierarchy
of contained objects.
5.3.3 Rules
The following rules must be obeyed by all GL implementations:
Rule 1 If the contents of an object T are changed in the current context while T is
directly or indirectly attached, then all operations on T will use the new contents
in the current context.
Note: The intent of this rule is to address changes in a single context only. The
multi-context case is handled by the other rules.
Note: “Updates” via rendering or transform feedback are treated consistently
with updates via GL commands. Once EndTransformFeedback has been issued,
any subsequent command in the same context that uses the results of the trans-
form feedback operation will see the results. If a feedback loop is setup between
rendering and transform feedback (see section 13.3.3), results will be unde?ned.
OpenGL 4.6 (Core Pro?le) - February 2, 20195.3. PROPAGATINGCHANGESTOOBJECTS 58
Rule 2 While a container object C is bound, any changes made to the contents of
C’s attachments in the current context are guaranteed to be seen. To guarantee see-
ing changes made in another context to objects attached to C, such changes must be
completed in that other context (see section 5.3.1) prior to C being bound. Changes
made in another context but not determined to have completed as described in sec-
tion 5.3.1, or after C is bound in the current context, are not guaranteed to be
seen.
Rule 3 Changes to the contents of shared objects are not automatically propa-
gated between contexts. If the contents of a shared object T are changed in a
context other than the current context, and T is already directly or indirectly at-
tached to the current context, any operations on the current context involving T via
those attachments are not guaranteed to use its new contents.
Rule 4 If the contents of an object T are changed in a context other than the cur-
rent context, T must be attached or re-attached to at least one binding point in the
current context, or at least one attachment point of a currently bound container
object C, in order to guarantee that the new contents of T are visible in the current
context.
Note: “Attached or re-attached” means either attaching an object to a binding
point it wasn’t already attached to, or attaching an object again to a binding point
it was already attached.
Example: If a texture image is bound to multiple texture bind points and the
texture is changed in another context, re-binding the texture at any one of the tex-
ture bind points is suf?cient to cause the changes to be visible at all texture bind
points.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 6
Buffer Objects
Buffer objects contain a data store holding a ?xed-sized allocation of server mem-
ory. This chapter speci?es commands to create, manage, and destroy buffer objects.
Speci?c types of buffer objects and their uses are brie?y described together with
references to their full speci?cation.
The command
void GenBuffers(sizei n,uint *buffers );
returns n previously unused buffer object names in buffers. These names are
marked as used, for the purposes of GenBuffers only, but they acquire buffer state
only when they are ?rst bound with BindBuffer (see below), just as if they were
unused.
Errors
AnINVALID_VALUE error is generated if n is negative.
In addition to generating an unused name and then binding it to a target with
BindBuffer, a buffer object may also be created with the command
void CreateBuffers(sizei n,uint *buffers );
CreateBuffers returns n previously unused buffer names in buffers, each rep-
resenting a new buffer object initialized as if it had been bound to an unspeci?ed
target.
596.1. CREATINGANDBINDINGBUFFEROBJECTS 60
Errors
AnINVALID_VALUE error is generated if n is negative.
Buffer objects are deleted by calling
void DeleteBuffers(sizei n,const uint *buffers );
buffers contains n names of buffer objects to be deleted. After a buffer object is
deleted it has no contents, and its name is again unused. If any portion of a buffer
object being deleted is mapped in the current context or any context current to
another thread, it is as though UnmapBuffer (see section 6.3.1) is executed in
each such context prior to deleting the data store of the buffer.
Unused names in buffers that have been marked as used for the purposes of
GenBuffers are marked as unused again. Unused names in buffers are silently
ignored, as is the value zero.
Errors
AnINVALID_VALUE error is generated if n is negative.
The command
boolean IsBuffer(uint buffer );
returnsTRUE if buffer is the name of a buffer object. If buffer is zero, or if buffer is
a non-zero value that is not the name of a buffer object, IsBuffer returnsFALSE.
6.1 Creating and Binding Buffer Objects
A buffer object is created by binding a name returned by GenBuffers to a buffer
target. The binding is effected by calling
void BindBuffer(enum target,uint buffer );
target must be one of the targets listed in table 6.1. If the buffer object named buffer
has not been previously bound, the GL creates a new state vector, initialized with
a zero-sized memory buffer and comprising all the state and with the same initial
values listed in table 6.2.
Buffer objects created by binding a name returned by GenBuffers to any of the
valid targets are formally equivalent.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.1. CREATINGANDBINDINGBUFFEROBJECTS 61
Target name Purpose Described in
section(s)
ARRAY_BUFFER Vertex attributes 10.3.9
ATOMIC_COUNTER_BUFFER Atomic counter storage 7.7
COPY_READ_BUFFER Buffer copy source 6.6
COPY_WRITE_BUFFER Buffer copy destination 6.6
DISPATCH_INDIRECT_BUFFER Indirect compute dispatch commands 19
DRAW_INDIRECT_BUFFER Indirect command arguments 10.3.11
ELEMENT_ARRAY_BUFFER Vertex array indices 10.3.10
PARAMETER_BUFFER Draw parameters 10.4
PIXEL_PACK_BUFFER Pixel read target 18.2, 22
PIXEL_UNPACK_BUFFER Texture data source 8.4
QUERY_BUFFER Query result buffer 4.2.3
SHADER_STORAGE_BUFFER Read-write storage for shaders 7.8
TEXTURE_BUFFER Texture data buffer 8.9
TRANSFORM_FEEDBACK_BUFFER Transform feedback buffer 13.3
UNIFORM_BUFFER Uniform block storage 7.6.2
Table 6.1: Buffer object binding targets.
Name Type Initial Value Legal Values
BUFFER_SIZE int64 0 any non-negative integer
BUFFER_USAGE enum STATIC_DRAW STREAM_DRAW,STREAM_READ,
STREAM_COPY,STATIC_DRAW,
STATIC_READ,STATIC_COPY,
DYNAMIC_DRAW,DYNAMIC_READ,
DYNAMIC_COPY
BUFFER_ACCESS enum READ_WRITE READ_ONLY,WRITE_ONLY,
READ_WRITE
BUFFER_ACCESS_FLAGS int 0 See section 6.3
BUFFER_IMMUTABLE_STORAGE boolean FALSE TRUE,FALSE
BUFFER_MAPPED boolean FALSE TRUE,FALSE
BUFFER_MAP_POINTER void* NULL address
BUFFER_MAP_OFFSET int64 0 any non-negative integer
BUFFER_MAP_LENGTH int64 0 any non-negative integer
BUFFER_STORAGE_FLAGS int 0 See section 6.2
Table 6.2: Buffer object parameters and their values.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.1. CREATINGANDBINDINGBUFFEROBJECTS 62
BindBuffer may also be used to bind an existing buffer object. If the bind is
successful no change is made to the state of the newly bound buffer object, and any
previous binding to target is broken.
While a buffer object is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which a buffer object is
bound return state from the bound object. Operations on the target also affect any
other bindings of that object.
If a buffer object is deleted while it is bound, all bindings to that object in
the current context (i.e. in the thread that called DeleteBuffers) are reset to zero.
Bindings to that buffer in other contexts are not affected, and the deleted buffer
may continue to be used at any places it remains bound or attached, as described
in section 5.1.
Initially, each buffer object target is bound to zero.
Errors
An INVALID_ENUM error is generated if target is not one of the targets
listed in table 6.1.
AnINVALID_OPERATION error is generated if buffer is not zero or a name
returned from a previous call to GenBuffers, or if such a name has since been
deleted with DeleteBuffers.
AnINVALID_OPERATION error is generated by client attempts to modify
or query buffer object state for a target bound to zero, since there is no buffer
object corresponding to the name zero,
6.1.1 Binding Buffer Objects to Indexed Targets
Buffer objects may be created and bound to indexed targets by calling one of the
commands
void BindBufferRange(enum target,uint index,
uint buffer,intptr offset,sizeiptr size );
void BindBufferBase(enum target,uint index,uint buffer );
target must be one of ATOMIC_COUNTER_BUFFER, SHADER_STORAGE_BUFFER,
TRANSFORM_FEEDBACK_BUFFER or UNIFORM_BUFFER. Additional language
speci?c to each target is included in sections referred to for each target in table 6.1.
Each target represents an indexed array of buffer object binding points, as well
as a single general binding point that can be used by other buffer object manip-
ulation functions, such as BindBuffer or MapBuffer. Both commands bind the
OpenGL 4.6 (Core Pro?le) - February 2, 20196.1. CREATINGANDBINDINGBUFFEROBJECTS 63
buffer object named by buffer to both the general binding point, and to the binding
point in the array given by index. If the binds are successful no change is made
to the state of the bound buffer object, and any previous bindings to the general
binding point or to the binding point in the array are broken.
If the buffer object named buffer has not been previously bound, the GL creates
a new state vector, initialized with a zero-sized memory buffer and comprising all
the state and with the same initial values listed in table 6.2.
For BindBufferRange, offset speci?es a starting offset into the buffer object
buffer, and size speci?es the amount of data that can be read from or written to
the buffer object while used as an indexed target. Both offset and size are in basic
machine units.
BindBufferBase binds the entire buffer, even when the size of the buffer is
changed after the binding is established. The starting offset is zero, and the amount
of data that can be read from or written to the buffer is determined by the size of
the bound buffer at the time the binding is used.
Regardless of the size speci?ed with BindBufferRange, the GL will never read
or write beyond the end of a bound buffer. In some cases this constraint may result
in visibly different behavior when a buffer over?ow would otherwise result, such
as described for transform feedback operations in section 13.3.2.
Errors
An INVALID_ENUM error is generated if target is not one of the targets
listed above.
An INVALID_VALUE error is generated if index is greater than or equal
to the number of target-speci?c indexed binding points, as described in sec-
tion 6.7.1.
AnINVALID_OPERATION error is generated if buffer is not zero or a name
returned from a previous call to GenBuffers, or if such a name has since been
deleted with DeleteBuffers.
An INVALID_VALUE error is generated by BindBufferRange if offset is
negative.
An INVALID_VALUE error is generated by BindBufferRange if buffer is
non-zero and size is less than or equal to zero.
An INVALID_VALUE error is generated by BindBufferRange if buffer is
non-zero and offset or size do not respectively satisfy the constraints described
for those parameters for the speci?ed target, as described in section 6.7.1.
The commands
void BindBuffersBase(enum target,uint ?rst,sizei count,
OpenGL 4.6 (Core Pro?le) - February 2, 20196.1. CREATINGANDBINDINGBUFFEROBJECTS 64
const uint *buffers );
void BindBuffersRange(enum target,uint ?rst,
sizei count,const uint *buffers,const
intptr *offsets,const sizeiptr *sizes );
bind count existing buffer objects to bindings numbered ?rst through first +
count  1 in the array of buffer binding points corresponding to target. If buffers
is not NULL, it speci?es an array of count values, each of which must be zero or
the name of an existing buffer object. For BindBuffersRange, offsets and sizes
specify arrays of count values indicating the range of each buffer to bind. If buffers
is NULL, all bindings from ?rst to first +count  1 are reset to their unbound
(zero) state. In this case, the offsets and sizes associated with the binding points
are set to default values, ignoring offsets and sizes.
BindBuffersBase is equivalent (assuming no errors are generated) to:
for (i = 0; i < count; i++) f
if (buffers == NULL) f
BindBufferBase(target, first + i, 0);
g else f
BindBufferBase(target, first + i, buffers[i]);
g
g
except that the single general buffer binding corresponding to target is unmodi?ed,
and that buffers will not be created if they do not exist.
BindBuffersRange is equivalent (assuming no errors are generated) to:
for (i = 0; i < count; i++) f
if (buffers == NULL) f
BindBufferRange(target, first + i, 0, 0, 0);
g else f
BindBufferRange(target, first + i, buffers[i],
offsets[i], sizes[i]);
g
g
except that the single general buffer binding corresponding to target is unmodi?ed,
and that buffers will not be created if they do not exist.
The values speci?ed in buffers, offsets, and sizes will be checked separately for
each binding point. When values for a speci?c binding point are invalid, the state
for that binding point will be unchanged and an error will be generated. When
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 65
such an error occurs, state for other binding points will still be changed if their
corresponding values are valid.
Errors
An INVALID_ENUM error is generated if target is not one of the targets
listed above.
An INVALID_OPERATION error is generated iffirst +count is greater
than the number of target-speci?c indexed binding points, as described in sec-
tion 6.7.1.
AnINVALID_VALUE error is generated if count is negative.
AnINVALID_OPERATION error is generated if any value in buffers is not
zero or the name of an existing buffer object.
An INVALID_VALUE error is generated by BindBuffersRange if any
value in offsets is less than zero (per binding).
An INVALID_VALUE error is generated by BindBuffersRange if any
value in sizes is less than or equal to zero (per binding).
AnINVALID_VALUE error is generated by BindBuffersRange if any pair
of values in offsets and sizes does not respectively satisfy the constraints
described for those parameters for the speci?ed target, as described in sec-
tion 6.7.1 (per binding).
6.2 Creating and Modifying Buffer Object Data Stores
The data store of a buffer object is created by calling one of
void BufferStorage(enum target,sizeiptr size,const
void *data,bitfield ?ags );
void NamedBufferStorage(uint buffer,sizeiptr size,
const void *data,bitfield ?ags );
For BufferStorage, the buffer object is that bound to target, which must be one
of the values listed in table 6.1. For NamedBufferStorage, buffer is the name of
the buffer object. size is the size of the data store in basic machine units, and ?ags
containing a bit?eld describing the intended usage of the data store.
The data store of the buffer object is allocated as a result of these commands,
and cannot be de-allocated until the buffer is deleted with a call to DeleteBuffers.
Such a store may not be re-allocated through further calls to *BufferStorage or
BufferData.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 66
data speci?es the address in client memory of the data that should be used to
initialize the buffer object’s data store. If data isNULL, the data store of the buffer
object is created, but contains unde?ned data. Otherwise, data should point to an
array of at least size basic machine units.
?ags is the bitwise OR of ?ags describing the intended usage of the buffer
object’s data store by the application. Valid ?ags and their meanings are as follows:
DYNAMIC_STORAGE_BIT The contents of the data store may be updated after cre-
ation through calls to BufferSubData. If this bit is not set, the buffer content
may not be directly updated by the client. The data argument may be used
to specify the initial content of the buffer’s data store regardless of the pres-
ence of theDYNAMIC_STORAGE_BIT. Regardless of the presence of this bit,
buffers may always be updated with server-side calls such as CopyBuffer-
SubData and ClearBufferSubData.
MAP_READ_BIT The data store may be mapped by the client for read access and a
pointer in the client’s address space obtained that may be read from.
MAP_WRITE_BIT The data store may be mapped by the client for write access and
a pointer in the client’s address space obtained that may be written to.
MAP_PERSISTENT_BIT The client may request that the server read from or write
to the buffer while it is mapped. The client’s pointer to the data store remains
valid so long as the data store is mapped, even during execution of drawing
or dispatch commands.
MAP_COHERENT_BIT Shared access to buffers that are simultaneously mapped
for client access and are used by the server will be coherent, so long as
that mapping is performed using MapBufferRange or MapNamedBuffer-
Range. That is, data written to the store by either the client or server will
be visible to any subsequently issued GL commands with no further action
taken by the application. In particular,
 If MAP_COHERENT_BIT is not set and the client performs a write fol-
lowed by a call to one of the FlushMapped*BufferRange commands
with a range including the written range, then in subsequent commands
the server will see the writes.
 If MAP_COHERENT_BIT is set and the client performs a write, then in
subsequent commands the server will see the writes.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 67
 IfMAP_COHERENT_BIT is not set and the server performs a write, the
application must call MemoryBarrier with the CLIENT_MAPPED_-
BUFFER_BARRIER_BIT set and then call FenceSync with SYNC_-
GPU_COMMANDS_COMPLETE (or Finish). Then the CPU will see the
writes after the sync is complete.
 IfMAP_COHERENT_BIT is set and the server does a write, the applica-
tion must call FenceSync withSYNC_GPU_COMMANDS_COMPLETE (or
Finish). Then the CPU will see the writes after the sync is complete.
CLIENT_STORAGE_BIT When all other criteria for the buffer storage allocation
are met, this bit may be used by an implementation to determine whether to
use storage that is local to the server or to the client to serve as the backing
store for the buffer.
If ?ags contains MAP_PERSISTENT_BIT, it must also contain at least one of
MAP_READ_BIT orMAP_WRITE_BIT.
It is an error to specify MAP_COHERENT_BIT without also specifying MAP_-
PERSISTENT_BIT.
BufferStorage and NamedBufferStorage delete any existing data store, and
set the values of the buffer object’s state variables as shown in table 6.3.
If any portion of the buffer object is mapped in the current context or any
context current to another thread, it is as though UnmapBuffer (see section 6.3.1)
is executed in each such context prior to deleting the existing data store.
Errors
AnINVALID_OPERATION error is generated by BufferStorage if zero is
bound to target.
AnINVALID_OPERATION error is generated by NamedBufferStorage if
buffer is not the name of an existing buffer object.
AnINVALID_VALUE error is generated if size is less than or equal to zero.
AnINVALID_VALUE error is generated if ?ags has any bits set other than
those de?ned above.
An INVALID_VALUE error is generated if ?ags contains MAP_-
PERSISTENT_BIT but does not contain at least one of MAP_READ_BIT or
MAP_WRITE_BIT.
An INVALID_VALUE error is generated if ?ags contains MAP_-
COHERENT_BIT, but does not also containMAP_PERSISTENT_BIT.
An INVALID_OPERATION error is generated if the BUFFER_-
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 68
Name Value for Value for
BufferData *BufferStorage
BUFFER_SIZE size size
BUFFER_USAGE usage DYNAMIC_DRAW
BUFFER_ACCESS READ_WRITE READ_WRITE
BUFFER_ACCESS_FLAGS 0 0
BUFFER_IMMUTABLE_STORAGE FALSE TRUE
BUFFER_MAPPED FALSE FALSE
BUFFER_MAP_POINTER NULL NULL
BUFFER_MAP_OFFSET 0 0
BUFFER_MAP_LENGTH 0 0
BUFFER_STORAGE_FLAGS MAP_READ_BITj ?ags
MAP_WRITE_BITj
DYNAMIC_STORAGE_BIT
Table 6.3: Buffer object state after calling BufferData, BufferStorage, or Named-
BufferStorage.
IMMUTABLE_STORAGE ?ag of the buffer bound to target isTRUE.
A mutable data store may be allocated for a buffer object with the commands
void BufferData(enum target,sizeiptr size,const
void *data,enum usage );
void NamedBufferData(uint buffer,sizeiptr size,const
void *data,enum usage );
For BufferData, the buffer object is that bound to target, which must be one
of the targets listed in table 6.1. For NamedBufferData, buffer is the name of the
buffer object.
size is the size of the data store in basic machine units, data points to the source
data in client memory, and usage indicates the expected application usage pattern
of the data store.
If data is non-NULL, then the source data is copied to the buffer object’s data
store. If data isNULL, then the contents of the buffer object’s data store are unde-
?ned.
usage is speci?ed as one of nine enumerated values. In the following descrip-
tions, a buffer’s data store is sourced when if is read from as a result of GL com-
mands which specify images, or invoke shaders accessing buffer data as a result of
drawing commands or compute shader dispatch.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 69
The values are:
STREAM_DRAW The data store contents will be speci?ed once by the application,
and sourced at most a few times.
STREAM_READ The data store contents will be speci?ed once by reading data from
the GL, and queried at most a few times by the application.
STREAM_COPY The data store contents will be speci?ed once by reading data from
the GL, and sourced at most a few times
STATIC_DRAW The data store contents will be speci?ed once by the application,
and sourced many times.
STATIC_READ The data store contents will be speci?ed once by reading data from
the GL, and queried many times by the application.
STATIC_COPY The data store contents will be speci?ed once by reading data from
the GL, and sourced many times.
DYNAMIC_DRAW The data store contents will be respeci?ed repeatedly by the ap-
plication, and sourced many times.
DYNAMIC_READ The data store contents will be respeci?ed repeatedly by reading
data from the GL, and queried many times by the application.
DYNAMIC_COPY The data store contents will be respeci?ed repeatedly by reading
data from the GL, and sourced many times.
usage is provided as a performance hint only. The speci?ed usage value does
not constrain the actual usage pattern of the data store.
BufferData and NamedBufferData delete any existing data store, and set the
values of the buffer object’s state variables as shown in table 6.3.
If any portion of the buffer object is mapped in the current context or any
context current to another thread, it is as though UnmapBuffer (see section 6.3.1)
is executed in each such context prior to deleting the existing data store.
Clients must align data elements consistent with the requirements of the client
platform, with an additional base-level requirement that an offset within a buffer to
a datum comprisingN basic machine units be a multiple ofN.
Calling *BufferData is equivalent to calling BufferStorage with target, size
and data as speci?ed, and ?ags set to the logical OR ofDYNAMIC_STORAGE_BIT,
MAP_READ_BIT andMAP_WRITE_BIT. The GL will use the value of the usage pa-
rameter to *BufferData as a hint to further determine the intended use of the buffer.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 70
However, BufferStorage allocates immutable storage whereas *BufferData allo-
cates mutable storage. Thus, when a buffer’s data store is allocated through a call
to *BufferData, the buffer’sBUFFER_IMMUTABLE_STORAGE ?ag is set toFALSE.
Errors
An INVALID_OPERATION error is generated by BufferData if zero is
bound to target.
An INVALID_OPERATION error is generated by NamedBufferData if
buffer is not the name of an existing buffer object.
AnINVALID_VALUE error is generated if size is negative.
An INVALID_ENUM error is generated by BufferData if target is not one
of the targets listed in table 6.1.
An INVALID_OPERATION error is generated if the BUFFER_-
IMMUTABLE_STORAGE ?ag of the buffer object isTRUE.
An INVALID_ENUM error is generated if usage is not one of the nine us-
ages described above.
To modify some or all of the data contained in a buffer object’s data store, the
client may use the commands
void BufferSubData(enum target,intptr offset,
sizeiptr size,const void *data );
void NamedBufferSubData(uint buffer,intptr offset,
sizeiptr size,const void *data );
For BufferSubData, target speci?es the target to which the buffer object is
bound, and must be one of the values listed in table 6.1. For NamedBufferSub-
Data, buffer is the name of the buffer object.
offset and size indicate the range of data in the buffer object that is to be re-
placed, in terms of basic machine units. data speci?es a region of client memory
size basic machine units in length, containing the data that replace the speci?ed
buffer range.
Errors
AnINVALID_OPERATION error is generated by BufferSubData if zero is
bound to target.
An INVALID_OPERATION error is generated by NamedBufferSubData
if buffer is not the name of an existing buffer object.
An INVALID_ENUM error is generated by BufferSubData if target is not
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 71
one of the targets listed in table 6.1.
An INVALID_VALUE error is generated if offset or size is negative, or if
oset + size is greater than the value ofBUFFER_SIZE for the buffer object.
An INVALID_OPERATION error is generated if any part of the speci-
?ed buffer range is mapped with MapBufferRange or MapBuffer (see sec-
tion 6.3), unless it was mapped withMAP_PERSISTENT_BIT set in the Map-
BufferRange access ?ags.
An INVALID_OPERATION error is generated if the BUFFER_-
IMMUTABLE_STORAGE ?ag of the buffer object is TRUE and the value of
BUFFER_STORAGE_FLAGS for the buffer does not have the DYNAMIC_-
STORAGE_BIT set.
6.2.1 Clearing Buffer Object Data Stores
To ?ll all or part of a buffer object’s data store with constant values, use the com-
mands
void ClearBufferSubData(enum target,enum internalformat,
intptr offset,sizeiptr size,enum format,enum type,
const void *data );
void ClearNamedBufferSubData(uint buffer,
enum internalformat,intptr offset,sizeiptr size,
enum format,enum type,const void *data );
For ClearBufferSubData, the buffer object is that bound to target, which must
be one of the values listed in table 6.1. For ClearNamedBufferSubData, buffer is
the name of the buffer object.
internalformat must be set to one of the format tokens listed in table 8.16. for-
mat and type specify the format and type of the source data and are interpreted as
described in section 8.4.4. Unlike the related ClearTexImageSubData command
described in section 8.21, all de?ned conversions between the clear value’s for-
mat and type, and the speci?ed internalformat are allowed, including conversions
between ?oating-point and integer components.
offset is the offset, measured in basic machine units, into the buffer object’s
data store from which to begin ?lling, and size is the size, also in basic machine
units, of the range to ?ll.
data is a pointer to an array of between one and four components containing
the data to be used as the source of the constant ?ll value. The elements of data
are converted by the GL into the format speci?ed by internalformat in the manner
described in section 2.2.1, and then used to ?ll the speci?ed range of the destination
OpenGL 4.6 (Core Pro?le) - February 2, 20196.2. CREATINGANDMODIFYINGBUFFEROBJECTDATASTORES 72
buffer. If data isNULL, then the pointer is ignored and the sub-range of the buffer
is ?lled with zeros.
Errors
An INVALID_ENUM error is generated by ClearBufferSubData if target
is not one of the targets listed in table 6.1.
An INVALID_VALUE error is generated by ClearBufferSubData if zero
is bound to target.
AnINVALID_OPERATION error is generated by ClearNamedBufferData
if buffer is not the name of an existing buffer object.
An INVALID_ENUM error is generated if internalformat is not one of the
format tokens listed in table 8.16.
An INVALID_VALUE error is generated if offset or size are not multiples
of the number of basic machine units for the internal format speci?ed by inter-
nalformat. This value may be computed by multiplying the number of com-
ponents for internalformat from table 8.16 by the size of the base type from
that table.
An INVALID_VALUE error is generated if offset or size is negative, or if
oset + size is greater than the value ofBUFFER_SIZE for the buffer object.
An INVALID_OPERATION error is generated if any part of the speci-
?ed buffer range is mapped with MapBufferRange or MapBuffer (see sec-
tion 6.3), unless it was mapped withMAP_PERSISTENT_BIT set in the Map-
BufferRange access ?ags.
An INVALID_VALUE error is generated if type is not one of the types in
table 8.2.
AnINVALID_VALUE error is generated if format is not one of the formats
in table 8.3.
The commands
void ClearBufferData(enum target,enum internalformat,
enum format,enum type,const void *data );
void ClearNamedBufferData(uint buffer,
enum internalformat,enum format,enum type,const
void *data );
are respectively equivalent to
ClearBufferSubData(target, internalformat, 0, size, format, type, data);
and
OpenGL 4.6 (Core Pro?le) - February 2, 20196.3. MAPPINGANDUNMAPPINGBUFFERDATA 73
ClearNamedBufferSubData(buffer, internalformat, 0, size, format, type, data);
wheresize is the value ofBUFFER_SIZE for the destination buffer object.
6.3 Mapping and Unmapping Buffer Data
All or part of the data store of a buffer object may be mapped into the client’s
address space with the commands
void *MapBufferRange(enum target,intptr offset,
sizeiptr length,bitfield acesss );
void *MapNamedBufferRange(uint buffer,intptr offset,
sizeiptr length,bitfield access );
For MapBufferRange, the buffer object is that bound to target, which must be
one of the values listed in table 6.1. For MapNamedBufferRange, buffer is the
name of the buffer object.
offset and length indicate the range of data in the buffer object that is to be
mapped, in terms of basic machine units. access is a bit?eld containing ?ags which
describe the requested mapping. These ?ags are described below.
If no error occurs, a pointer to the beginning of the mapped range is returned
once all pending operations on that buffer have completed, and may be used to
modify and/or query the corresponding range of the buffer, according to the fol-
lowing ?ag bits set in access:
 MAP_READ_BIT indicates that the returned pointer may be used to read
buffer object data. No GL error is generated if the pointer is used to query
a mapping which excludes this ?ag, but the result is unde?ned and system
errors (possibly including program termination) may occur.
 MAP_WRITE_BIT indicates that the returned pointer may be used to modify
buffer object data. No GL error is generated if the pointer is used to modify
a mapping which excludes this ?ag, but the result is unde?ned and system
errors (possibly including program termination) may occur.
 MAP_PERSISTENT_BIT indicates that it is not an error for the GL to read
data from or write data to the buffer while it is mapped (see section 6.3.2).
If this bit is set, the value ofBUFFER_STORAGE_FLAGS for the buffer being
mapped must includeMAP_PERSISTENT_BIT.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.3. MAPPINGANDUNMAPPINGBUFFERDATA 74
 MAP_COHERENT_BIT indicates that the mapping should be performed co-
herently. That is, such a mapping follows the rules set forth in section 6.2.
If this bit is set, the value ofBUFFER_STORAGE_FLAGS for the buffer being
mapped must includeMAP_COHERENT_BIT.
If no error occurs, the pointer values returned by Map*BufferRange must
re?ect an allocation aligned to the value ofMIN_MAP_BUFFER_ALIGNMENT basic
machine units. Subtracting offset basic machine units from the returned pointer
will always produce a multiple of the value ofMIN_MAP_BUFFER_ALIGNMENT.
The returned pointer values may not be passed as parameter values to GL com-
mands. For example, they may not be used to specify array pointers, or to specify or
query pixel or texture image data; such actions produce unde?ned results, although
implementations may not check for such behavior for performance reasons.
Mappings to the data stores of buffer objects may have nonstandard perfor-
mance characteristics. For example, such mappings may be marked as uncacheable
regions of memory, and in such cases reading from them may be very slow. To en-
sure optimal performance, the client should use the mapping in a fashion consistent
with the values of BUFFER_USAGE and access. Using a mapping in a fashion in-
consistent with these values is liable to be multiple orders of magnitude slower
than using normal memory.
The following optional ?ag bits in access may be used to modify the mapping:
 MAP_INVALIDATE_RANGE_BIT indicates that the previous contents of the
speci?ed range may be discarded. Data within this range are unde?ned with
the exception of subsequently written data. No GL error is generated if sub-
sequent GL operations access unwritten data, but the result is unde?ned and
system errors (possibly including program termination) may occur. This ?ag
may not be used in combination withMAP_READ_BIT.
 MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the
entire buffer may be discarded. Data within the entire buffer are unde?ned
with the exception of subsequently written data. No GL error is generated if
subsequent GL operations access unwritten data, but the result is unde?ned
and system errors (possibly including program termination) may occur. This
?ag may not be used in combination withMAP_READ_BIT.
 MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges
of the mapping may be modi?ed. When this ?ag is set, modi?cations to
each subrange must be explicitly ?ushed by calling FlushMappedBuffer-
Range. No GL error is set if a subrange of the mapping is modi?ed and
OpenGL 4.6 (Core Pro?le) - February 2, 20196.3. MAPPINGANDUNMAPPINGBUFFERDATA 75
Name Value
1
BUFFER_ACCESS Depends on access
BUFFER_ACCESS_FLAGS access
BUFFER_MAPPED TRUE
BUFFER_MAP_POINTER pointer to the data store
BUFFER_MAP_OFFSET offset
BUFFER_MAP_LENGTH length
Table 6.4: Buffer object state set by MapBufferRange and MapNamedBuffer-
Range.
1
BUFFER_ACCESS is set toREAD_ONLY,WRITE_ONLY, orREAD_WRITE if access
& (MAP_READ_BITjMAP_WRITE_BIT) is respectively MAP_READ_BIT, MAP_-
WRITE_BIT, orMAP_READ_BITjMAP_WRITE_BIT.
not ?ushed, but data within the corresponding subrange of the buffer are un-
de?ned. This ?ag may only be used in conjunction with MAP_WRITE_BIT.
When this option is selected, ?ushing is strictly limited to regions that are
explicitly indicated with calls to FlushMappedBufferRange prior to un-
map; if this option is not selected UnmapBuffer will automatically ?ush the
entire mapped range when called.
 MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt
to synchronize pending operations on the buffer prior to returning from
Map*BufferRange. No GL error is generated if pending operations which
source or modify the buffer overlap the mapped region, but the result of such
previous and any subsequent operations is unde?ned.
A successful Map*BufferRange sets buffer object state values as shown in
table 6.4.
Errors
If an error occurs, aNULL pointer is returned.
An INVALID_ENUM error is generated by MapBufferRange if target is
not one of the valid targets listed above.
AnINVALID_OPERATION error is generated by MapBufferRange if zero
is bound to target.
An INVALID_OPERATION error is generated by MapNamedBuffer-
Range if buffer is not the name of an existing buffer object.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.3. MAPPINGANDUNMAPPINGBUFFERDATA 76
An INVALID_VALUE error is generated if offset or length is negative, if
oset + length is greater than the value of BUFFER_SIZE, or if access has
any bits set other than those de?ned above.
AnINVALID_OPERATION error is generated for any of the following con-
ditions:
 length is zero.
 The buffer is already in a mapped state.
 NeitherMAP_READ_BIT norMAP_WRITE_BIT is set.
 MAP_READ_BIT is set and any of MAP_INVALIDATE_RANGE_BIT,
MAP_INVALIDATE_BUFFER_BIT, or MAP_UNSYNCHRONIZED_BIT is
set.
 MAP_FLUSH_EXPLICIT_BIT is set andMAP_WRITE_BIT is not set.
 Any of MAP_READ_BIT, MAP_WRITE_BIT, MAP_PERSISTENT_BIT,
orMAP_COHERENT_BIT are set, but the same bit is not set in the buffer’s
storage ?ags.
No error is generated if memory outside the mapped range is modi?ed
or queried, but the result is unde?ned and system errors (possibly including
program termination) may occur.
The entire data store of a buffer object can be mapped into the client’s address
space with the commands
void *MapBuffer(enum target,enum access );
void *MapNamedBuffer(uint buffer,enum access );
These commands are respectively equivalent to
MapBufferRange(target, 0, length, flags);
and
MapNamedBufferRange(buffer, 0, length, flags);
where length is equal to the value of BUFFER_SIZE for the target buffer and
flags is equal to
 MAP_READ_BIT, if access isREAD_ONLY
OpenGL 4.6 (Core Pro?le) - February 2, 20196.3. MAPPINGANDUNMAPPINGBUFFERDATA 77
 MAP_WRITE_BIT, if access isWRITE_ONLY
 MAP_READ_BITjMAP_WRITE_BIT, if access isREAD_WRITE.
The pointer value returned by MapBuffer and MapNamedBuffer must be
aligned to the value ofMIN_MAP_BUFFER_ALIGNMENT basic machine units.
Errors
An INVALID_ENUM error is generated if access is not READ_ONLY,
WRITE_ONLY, orREAD_WRITE.
Other errors are generated as described above for MapBufferRange and
MapNamedBufferRange.
If a buffer object is mapped with theMAP_FLUSH_EXPLICIT_BIT ?ag, mod-
i?cations to the mapped range may be indicated with the commands
void FlushMappedBufferRange(enum target,intptr offset,
sizeiptr length );
void FlushMappedNamedBufferRange(uint buffer,
intptr offset,sizeiptr length );
For FlushMappedBufferRange, the buffer object is that bound to target,
which must be one of the targets listed in table 6.1. For FlushMappedNamed-
BufferRange, buffer is the name of the buffer object.
offset and length indicate a modi?ed subrange of the mapping, in basic machine
units. The speci?ed subrange to ?ush is relative to the start of the currently mapped
range of the buffer object. FlushMapped*BufferRange may be called multiple
times to indicate distinct subranges of the mapping which require ?ushing.
If a buffer range is mapped with both MAP_PERSISTENT_BIT and MAP_-
FLUSH_EXPLICIT_BIT set, then FlushMapped*BufferRange may be called to
ensure that data written by the client into the ?ushed region becomes visible to the
server. Data written to a coherent store will always become visible to the server
after an unspeci?ed period of time.
Errors
An INVALID_ENUM error is generated by FlushMappedBufferRange if
target is not one of the targets listed in table 6.1.
An INVALID_OPERATION error is generated by FlushMappedBuffer-
Range if zero is bound to target.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.3. MAPPINGANDUNMAPPINGBUFFERDATA 78
An INVALID_OPERATION error is generated by FlushMappedNamed-
BufferRange if buffer is not the name of an existing buffer object.
An INVALID_OPERATION error is generated if the buffer object is not
mapped, or is mapped without theMAP_FLUSH_EXPLICIT_BIT ?ag.
AnINVALID_VALUE error is generated if offset or length is negative, or if
oset + length exceeds the size of the mapping.
6.3.1 Unmapping Buffers
After the client has speci?ed the contents of a mapped range of a buffer object, and
before the data in that range are dereferenced by any GL commands, the mapping
must be relinquished with one of the commands
boolean UnmapBuffer(enum target );
boolean UnmapNamedBuffer(uint buffer );
For UnmapBuffer, the buffer object is that bound to target, which must be one
of the targets listed in table 6.1. For UnmapNamedBuffer, buffer is the name of
the buffer object.
Unmapping a mapped buffer object invalidates the pointer to its data store and
sets the object’sBUFFER_MAPPED,BUFFER_MAP_POINTER,BUFFER_ACCESS_-
FLAGS, BUFFER_MAP_OFFSET, and BUFFER_MAP_LENGTH state variables to the
initial values shown in table 6.3.
Unmap*Buffer returnsTRUE unless data values in the buffer object’s data store
have become corrupted during the period that the buffer object was mapped. Such
corruption can be the result of a screen resolution change or other window system-
dependent event that causes system heaps such as those for high-performance
graphics memory to be discarded. GL implementations must guarantee that such
corruption can occur only during the periods that a buffer object’s data store is
mapped. If such corruption has occurred, Unmap*Buffer return FALSE, and the
contents of the data store become unde?ned.
Unmapping that occurs as a side effect of buffer deletion (see section 5.1.2) or
reinitialization by BufferData is not an error.
Buffer mappings are buffer object state, and are not affected by whether or not
a context owing a buffer object is current.
If an error is generated,FALSE is returned.
Errors
An INVALID_ENUM error is generated by UnmapBuffer if target is not
OpenGL 4.6 (Core Pro?le) - February 2, 20196.4. EFFECTSOFACCESSINGOUTSIDEBUFFERBOUNDS 79
one of the targets listed in table 6.1.
An INVALID_OPERATION error is generated by UnmapBuffer if zero is
bound to target.
AnINVALID_OPERATION error is generated by UnmapNamedBuffer if
buffer is not the name of an existing buffer object.
An INVALID_OPERATION error is generated if the buffer object’s data
store is already in the unmapped state.
6.3.2 Effects of Mapping Buffers on Other GL Commands
Any GL command which attempts to read from, write to, or change the state of
a buffer object may generate an INVALID_OPERATION error if all or part of the
buffer object is mapped, unless it was allocated by a call to *BufferStorage with
the MAP_PERSISTENT_BIT included in ?ags. However, only commands which
explicitly describe this error are required to do so. If an error is not generated,
such commands will have unde?ned results and may result in GL interruption or
termination.
6.4 Effects of Accessing Outside Buffer Bounds
Most, but not all GL commands operating on buffer objects will detect attempts to
read from or write to a location in a bound buffer object at an offset less than zero,
or greater than or equal to the buffer’s size. When such an attempt is detected, a
GL error is generated. Any command which does not detect these attempts, and
performs such an invalid read or write, has unde?ned results, and may result in GL
interruption or termination.
Robust buffer access can be enabled by creating a context with robust access
enabled through the window system binding APIs. When enabled, any command
unable to generate a GL error as described above, such as buffer object accesses
from the active program, will not read or modify memory outside of the data store
of the buffer object and will not result in GL interruption or termination. Out-
of-bounds reads may return values from within the buffer object or zero values.
Out-of-bounds writes may modify values within the buffer object or be discarded.
Accesses made through resources attached to binding points are only protected
within the buffer object from which the binding point is declared. For example,
for an out-of-bounds access to a member variable of a uniform block, the access
protection is provided within the uniform buffer object, and not for the bound buffer
range for this uniform block.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.5. INVALIDATINGBUFFERDATA 80
6.5 Invalidating Buffer Data
All or part of the data store of a buffer object may be invalidated by calling
void InvalidateBufferSubData(uint buffer,intptr offset,
sizeiptr length );
with buffer set to the name of the buffer whose data store is being invalidated. offset
and length specify the range of the data in the buffer object that is to be invalidated.
Data in the speci?ed range have unde?ned values after calling InvalidateBuffer-
SubData.
Errors
AnINVALID_VALUE error is generated if buffer is zero or is not the name
of an existing buffer object.
AnINVALID_VALUE error is generated if offset or length is negative, or if
oset + length is greater than the value ofBUFFER_SIZE for buffer.
AnINVALID_OPERATION error is generated if buffer is currently mapped
by MapBuffer or if the invalidate range intersects the range currently mapped
by MapBufferRange, unless it was mapped withMAP_PERSISTENT_BIT set
in the MapBufferRange access ?ags.
The command
void InvalidateBufferData(uint buffer );
is equivalent to calling InvalidateBufferSubData with offset equal to zero and
length equal to the value ofBUFFER_SIZE for buffer.
6.6 Copying Between Buffers
All or part of the data store of a buffer object may be copied to the data store of
another buffer object with the commands
void CopyBufferSubData(enum readTarget,enum writeTarget,
intptr readOffset,intptr writeOffset,sizeiptr size );
void CopyNamedBufferSubData(uint readBuffer,
uint writeBuffer,intptr readOffset,intptr writeOffset,
sizeiptr size );
OpenGL 4.6 (Core Pro?le) - February 2, 20196.7. BUFFEROBJECTQUERIES 81
For CopyBufferSubData, readTarget and writeTarget are the targets to which
the source and destination buffers are bound, and each must be one of the targets
listed in table 6.1. For CopyNamedBufferSubData, readBuffer and writeBuffer
are the names of the source and destination buffers, respectively.
While any of these targets may be used, theCOPY_READ_BUFFER andCOPY_-
WRITE_BUFFER targets are provided speci?cally for copies, so that they can be
done without affecting other buffer binding targets that may be in use.
writeOffset and size specify the range of data in the destination buffer object
that is to be replaced, in terms of basic machine units. readOffset and size specify
the range of data in the source buffer object that is to be copied to the corresponding
region of writeTarget.
Errors
An INVALID_OPERATION error is generated by CopyBufferSubData if
zero is bound to readTarget or writeTarget.
An INVALID_ENUM error is generated by CopyBufferSubData if read-
Target or writeTarget is not one of the targets listed in table 6.1.
AnINVALID_OPERATION error is generated by CopyNamedBufferSub-
Data if readBuffer or writeBuffer is not the name of an existing buffer object.
An INVALID_VALUE error is generated if any of readOffset, writeOffset,
or size are negative, if readOset + size exceeds the size of the source buffer
object, or if writeOset+size exceeds the size of the destination buffer object.
An INVALID_VALUE error is generated if the source and destination are
the same buffer object, and the ranges [readOset; readOset + size) and
[writeOset; writeOset + size) overlap.
An INVALID_OPERATION error is generated if either the source or des-
tination buffer objects is mapped, unless they were mapped with MAP_-
PERSISTENT_BIT set in the Map*BufferRange access ?ags.
6.7 Buffer Object Queries
To query information about a buffer object, use the commands
void GetBufferParameteriv(enum target,enum pname,
int *data );
void GetBufferParameteri64v(enum target,enum pname,
int64 *data );
void GetNamedBufferParameteriv(uint buffer,
enum pname,int *data );
OpenGL 4.6 (Core Pro?le) - February 2, 20196.7. BUFFEROBJECTQUERIES 82
void GetNamedBufferParameteri64v(uint buffer,
enum pname,int64 *data );
For GetBufferParameter*, the buffer object is that bound to target, which must
be one of the targets listed in table 6.1. For GetNamedBufferParameter*, buffer
is the name of the buffer object.
pname must be one of the buffer object parameters in table 6.2, other than
BUFFER_MAP_POINTER. The value of the speci?ed parameter of the buffer object
bound to target is returned in data.
Errors
AnINVALID_ENUM error is generated by GetBufferParameter* if target
is not one of the targets listed in table 6.1.
AnINVALID_OPERATION error is generated by GetBufferParameter* if
zero is bound to target.
An INVALID_OPERATION error is generated by GetNamedBufferPa-
rameter* if buffer is not the name of an existing buffer object.
An INVALID_ENUM error is generated if pname is not one of the buffer
object parameters other thanBUFFER_MAP_POINTER.
To query the data store of a buffer object, use the commands
void GetBufferSubData(enum target,intptr offset,
sizeiptr size,void *data );
void GetNamedBufferSubData(uint buffer,intptr offset,
sizeiptr size,void *data );
For GetBufferSubData, target speci?es the target to which the source buffer ob-
ject is bound, and must be one of the values listed in table 6.1. For GetNamed-
BufferSubData, buffer speci?es the name of the source buffer object.
offset and size indicate the range of data in the source buffer object that is to be
queried, in terms of basic machine units. data speci?es a region of client memory,
size basic machine units in length, into which the data is to be retrieved.
Errors
An INVALID_ENUM error is generated by GetBufferSubData if target is
not one of the targets listed in table 6.1.
An INVALID_OPERATION error is generated by GetBufferSubData if
zero is bound to target.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.7. BUFFEROBJECTQUERIES 83
An INVALID_OPERATION error is generated by GetNamedBufferSub-
Data if buffer is not the name of an existing buffer object.
An INVALID_VALUE error is generated if offset or size is negative, or if
oset + size is greater than the value ofBUFFER_SIZE for the source buffer
object.
AnINVALID_OPERATION error is generated if the source buffer object is
currently mapped, unless it was mapped with MAP_PERSISTENT_BIT set in
the Map*BufferRange access ?ags.
While part or all of the data store of a buffer object is mapped, the pointer to
the mapped range of the data store may be queried with the commands
void GetBufferPointerv(enum target,enum pname,const
void **params );
void GetNamedBufferPointerv(uint buffer,enum pname,
const void **params );
For GetBufferPointerv, the buffer object is that bound to target, which must
be one of the targets listed in table 6.1. For GetNamedBufferPointerv, buffer is
the name of the buffer object.
pname must be BUFFER_MAP_POINTER. The single buffer map pointer is re-
turned in params. ANULL pointer value is returned if the buffer object’s data store
is not currently mapped; or if the requesting context did not map the buffer ob-
ject’s data store, and the implementation is unable to support mappings on multiple
clients.
Errors
An INVALID_ENUM error is generated by GetBufferPointerv if target is
not one of the targets listed in table 6.1.
An INVALID_OPERATION error is generated by GetBufferPointerv if
zero is bound to target.
AnINVALID_OPERATION error is generated by GetNamedBufferPoint-
erv if buffer is not the name of an existing buffer object.
An INVALID_ENUM error is generated if pname is not BUFFER_MAP_-
POINTER.
6.7.1 Indexed Buffer Object Limits and Binding Queries
Several types of buffer bindings support an indexed array of binding points for
speci?c use by the GL, in addition to a single generic binding point for general
OpenGL 4.6 (Core Pro?le) - February 2, 20196.8. BUFFEROBJECTSTATE 84
management of buffers of that type. Each type of binding is described in table 6.5
together with the token names used to refer to each buffer in the array of binding
points, the starting offset of the binding for each buffer in the array, any constraints
on the corresponding offset value passed to BindBufferRange (see section 6.1.1),
the size of the binding for each buffer in the array, any constraints on the corre-
sponding size value passed to BindBufferRange, and the size of the array (the
number of bind points supported).
To query which buffer objects are bound to an indexed array, call GetIntegeri -
v with target set to the name of the array of binding points. index must be in the
range zero to the number of bind points supported minus one. The name of the
buffer object bound to index is returned in values. If no buffer object is bound for
index, zero is returned in values.
To query the starting offset or size of the range of a buffer object binding in
an indexed array, call GetInteger64i v with target set to respectively the starting
offset or binding size name from table 6.5 for that array. index must be in the range
zero to the number of bind points supported minus one. If the starting offset or
size was not speci?ed when the buffer object was bound (e.g. if it was bound with
BindBufferBase), or if no buffer object is bound to the target array at index, zero
1
is returned .
Errors
An INVALID_VALUE error is generated by GetIntegeri v and GetInte-
ger64i v if target is one of the array binding point names, starting offset
names, or binding size names from table 6.5 and index is greater than or equal
to the number of binding points for target as described in the same table.
6.8 Buffer Object State
The state required to support buffer objects consists of binding names for each of
the buffer targets in table 6.1, and for each of the indexed buffer targets in sec-
tion 6.1.1. The state required for index buffer targets for atomic counters, shader
storage, transform feedback, and uniform buffer array bindings is summarized in
tables 23.46, 23.47, 23.48, and 23.49 respectively.
Additionally, each vertex array has an associated binding so there is a buffer
object binding for each of the vertex attribute arrays. The initial values for all
buffer object bindings is zero.
1
A zero size is a sentinel value indicating that the actual binding range size is determined by the
size of the bound buffer at the time the binding is used.
OpenGL 4.6 (Core Pro?le) - February 2, 20196.8. BUFFEROBJECTSTATE 85
Atomic counter array bindings (see sec. 7.7.2)
binding points ATOMIC_COUNTER_BUFFER_BINDING
starting offset ATOMIC_COUNTER_BUFFER_START
offset restriction multiple of 4
binding size ATOMIC_COUNTER_BUFFER_SIZE
size restriction none
no. of bind points value of MAX_ATOMIC_COUNTER_BUFFER_-
BINDINGS
Shader storage array bindings (see sec. 7.8)
binding points SHADER_STORAGE_BUFFER_BINDING
starting offset SHADER_STORAGE_BUFFER_START
offset restriction multiple of value of SHADER_STORAGE_-
BUFFER_OFFSET_ALIGNMENT
binding size SHADER_STORAGE_BUFFER_SIZE
size restriction none
no. of bind points value of MAX_SHADER_STORAGE_BUFFER_-
BINDINGS
Transform feedback array bindings (see sec. 13.3.2)
binding points TRANSFORM_FEEDBACK_BUFFER_BINDING
starting offset TRANSFORM_FEEDBACK_BUFFER_START
offset restriction multiple of 4
binding size TRANSFORM_FEEDBACK_BUFFER_SIZE
size restriction multiple of 4
no. of bind points value ofMAX_TRANSFORM_FEEDBACK_BUFFERS
Uniform buffer array bindings (see sec. 7.6.3)
binding points UNIFORM_BUFFER_BINDING
starting offset UNIFORM_BUFFER_START
offset restriction multiple of value of UNIFORM_BUFFER_-
OFFSET_ALIGNMENT
binding size UNIFORM_BUFFER_SIZE
size restriction none
no. of bind points value ofMAX_UNIFORM_BUFFER_BINDINGS
Table 6.5: Indexed buffer object limits and binding queries
OpenGL 4.6 (Core Pro?le) - February 2, 20196.8. BUFFEROBJECTSTATE 86
The state of each buffer object consists of a buffer size in basic machine units,
a usage parameter, an access parameter, a boolean indicating whether or not buffer
storage is immutable, an unsigned integer storing the ?ags with which it was allo-
cated, a mapped boolean, two integers for the offset and size of the mapped region,
a pointer to the mapped buffer (NULL if unmapped), and the sized array of basic
machine units for the buffer data.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 7
Programs and Shaders
This chapter speci?es commands to create, manage, and destroy program and
shader objects. Commands and functionality applicable only to speci?c shader
stages (for example, vertex attributes used as inputs by vertex shaders) are de-
scribed together with those stages in chapters 10 and 15.
A shader speci?es operations that are meant to occur on data as it moves
through different programmable stages of the OpenGL processing pipeline, start-
ing with vertices speci?ed by the application and ending with fragments prior to
being written to the framebuffer. The programming language used for shaders is
described in the OpenGL Shading Language Specification.
To use a shader, shader source code is ?rst loaded into a shader object and then
compiled. A shader object corresponds to a stage in the rendering pipeline referred
to as its shader stage or shader type.
Alternatively, pre-compiled shader binary code can be loaded into a shader ob-
ject. A SPIR-V module can also be associated with a shader and then specialized.
An implementation must support shader compilation (the boolean valueSHADER_-
COMPILER must be TRUE). If the integer value of NUM_SHADER_BINARY_-
FORMATS is greater than zero, then shader binary loading is supported.
One or more shader objects are attached to a program object. The program
object is then linked, which generates executable code from all the compiled shader
objects attached to the program. Alternatively, pre-compiled program binary code
may be directly loaded into a program object (see section 7.5).
When program objects are bound to a shader stage, they become the current
program object for that stage. When the current program object for a shader stage
includes a shader of that type, it is considered the active program object for that
stage.
The current program object for all stages may be set at once using a single
877.1. SHADEROBJECTS 88
uni?ed program object, or the current program object may be set for each stage
individually using a separable program object where different separable program
objects may be current for other stages. The set of separable program objects
current for all stages are collected in a program pipeline object that must be bound
for use. When a linked program object is made active for one of the stages, the
corresponding executable code is used to perform processing for that stage.
Shader stages including vertex shaders, tessellation control shaders, tessella-
tion evaluation shaders, geometry shaders, fragment shaders, and compute shaders
can be created, compiled, and linked into program objects.
Vertex shaders describe the operations that occur on vertex attributes. Tessel-
lation control and evaluation shaders are used to control the operation of the tes-
sellator, and are described in section 11.2. Geometry shaders affect the processing
of primitives assembled from vertices (see section 11.3). Fragment shaders affect
the processing of fragments during rasterization (see section 15). A single program
object can contain all of these shaders, or any subset thereof.
Compute shaders perform general-purpose computation for dispatched arrays
of shader invocations (see section 19), but do not operate on primitives processed
by the other shader types.
Shaders can reference several types of variables as they execute. Uniforms are
per-program variables that are constant during program execution (see section 7.6).
Buffer variables (see section 7.8) are similar to uniforms, but are stored in buffer
object memory which may be written to, and is persistent across multiple shader
invocations. Subroutine uniform variables (see section 7.10) are similar to uni-
forms but are context state, rather than program object state. Samplers (see sec-
tion 7.11) are a special form of uniform used for texturing (see chapter 8). Images
(see section 7.12) are a special form of uniform identifying a level of a texture to
be accessed using built-in shader functions as described in section 8.26. Output
variables hold the results of shader execution that are used later in the pipeline.
Each of these variable types is described in more detail below.
7.1 Shader Objects
The name space for shader objects is the unsigned integers, with zero reserved for
the GL. This name space is shared with program objects. The following sections
de?ne commands that operate on shader and program objects.
To create a shader object, use the command
uint CreateShader(enum type );
OpenGL 4.6 (Core Pro?le) - February 2, 20197.1. SHADEROBJECTS 89
type Shader Stage
VERTEX_SHADER Vertex shader
TESS_CONTROL_SHADER Tessellation control shader
TESS_EVALUATION_SHADER Tessellation evaluation shader
GEOMETRY_SHADER Geometry shader
FRAGMENT_SHADER Fragment shader
COMPUTE_SHADER Compute shader
Table 7.1: CreateShader type values and the corresponding shader stages.
The shader object is empty when it is created. The type argument speci?es the type
of shader object to be created and must be one of the values in table 7.1 indicating
the corresponding shader stage. A non-zero name that can be used to reference the
shader object is returned.
Errors
An INVALID_ENUM error is generated and zero is returned if type is not
one of the values in table 7.1.
The command
void ShaderSource(uint shader,sizei count,const
char *const *string,const int *length );
loads source code into the shader object named shader. string is an array of count
pointers to optionally null-terminated character strings that make up the source
code. The length argument is an array with the number ofchars in each string (the
string length). If an element in length is negative, its accompanying string is null-
terminated. If length isNULL, all strings in the string argument are considered null-
terminated. The ShaderSource command sets the source code for the shader to
the text strings in the string array. If shader previously had source code loaded into
it, the existing source code is completely replaced. Any length passed in excludes
the null terminator in its count.
The strings that are loaded into a shader object are expected to form the source
code for a valid shader as de?ned in the OpenGL Shading Language Specification.
If shader was previously associated with a SPIR-V module (via the
ShaderBinary command), that association is broken. Upon successful comple-
tion of this command theSPIR_V_BINARY state of shader is set toFALSE.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.1. SHADEROBJECTS 90
Errors
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
AnINVALID_VALUE error is generated if count is negative.
Once the source code for a shader has been loaded, a shader object can be
compiled with the command
void CompileShader(uint shader );
Each shader object has a boolean status, COMPILE_STATUS, that is modi?ed as
a result of compilation. This status may be queried with GetShaderiv (see sec-
tion 7.14). This status will be set to TRUE if shader was compiled without errors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification. If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compile does not restore the old state of shader.
Changing the source code of a shader object with ShaderSource does not
change its compile status or the compiled shader code.
Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log may be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section 7.14).
Errors
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
AnINVALID_OPERATION error is generated if theSPIR_V_BINARY state
of shader isTRUE.
Resources allocated by the shader compiler may be released with the command
void ReleaseShaderCompiler(void );
This is a hint from the application, and does not prevent later use of the shader
compiler. If shader source is loaded and compiled after ReleaseShaderCompiler
OpenGL 4.6 (Core Pro?le) - February 2, 20197.2. SHADERBINARIES 91
has been called, CompileShader must succeed provided there are no errors in the
shader source.
The range and precision for different numeric formats supported by the shader
compiler may be determined with the command GetShaderPrecisionFormat (see
section 7.14).
Shader objects can be deleted with the command
void DeleteShader(uint shader );
If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is ?agged for deletion and will be deleted when it is no longer
attached to any program object. If an object is ?agged for deletion, its boolean
status bit DELETE_STATUS is set to true. The value of DELETE_STATUS may be
queried with GetShaderiv (see section 7.14). DeleteShader will silently ignore
the value zero.
Errors
An INVALID_VALUE error is generated if shader is neither zero nor the
name of either a program or shader object.
An INVALID_OPERATION error is generated if shader is not zero and is
the name of a program object.
The command
boolean IsShader(uint shader );
returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
error is generated if shader is not a valid shader object name.
7.2 Shader Binaries
Precompiled shader binaries may be loaded with the command
void ShaderBinary(sizei count,const uint *shaders,
enum binaryformat,const void *binary,sizei length );
shaders contains a list of count shader object handles. Each handle refers to a
unique shader type, and may correspond to any of the shader stages in table 7.1.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.2. SHADERBINARIES 92
binary points to length bytes of pre-compiled binary shader code in client memory,
and binaryformat denotes the format of the pre-compiled code.
The binary image will be decoded according to the extension speci?cation
de?ning the speci?ed binaryformat.
GL de?nes an execution environment for shaders created from SPIR-V mod-
ules. To load a SPIR-V binary into GL, set binaryformat to SHADER_BINARY_-
FORMAT_SPIR_V. binary should point to the start of a valid SPIR-V module binary
and length should contain the length of that binary, in bytes. Upon successful con-
sumption of the SPIR-V module:
 each entry of shaders will be associated with that SPIR-V module,
 theSPIR_V_BINARY state of each shader is set toTRUE,
 theCOMPILE_STATUS of each of these shaders is set toFALSE,
 any existing source string (speci?ed by ShaderSource) is removed, and
 any information about a previous compile is lost.
Shaders associated with SPIR-V modules must be ?nalized by calling Special-
izeShader, as described in section 7.2.1.
GL also provides a mechanism to obtain token values for such formats pro-
vided by extensions. The number of binary formats supported can be obtained by
querying the value ofNUM_SHADER_BINARY_FORMATS. The list of speci?c binary
formats supported can be obtained by querying the value of SHADER_BINARY_-
FORMATS.
Depending on the types of the shader objects in shaders, ShaderBinary will
individually load binary shaders, or load an executable binary that contains an op-
timized set of shaders stored in the same binary.
Errors
AnINVALID_VALUE error is generated if count or length is negative.
An INVALID_ENUM error is generated if binaryformat is not a supported
format returned inSHADER_BINARY_FORMATS.
An INVALID_VALUE error is generated if the data pointed to by binary
does not match the speci?ed binaryformat.
AnINVALID_VALUE error is generated if any of the handles in shaders is
not the name of either a program or shader object.
An INVALID_OPERATION error is generated if any of the handles in
shaders is the name of a program object.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.2. SHADERBINARIES 93
An INVALID_OPERATION error is generated if binaryformat is not
SHADER_BINARY_FORMAT_SPIR_V and more than one of the handles in
shaders refers to the same type of shader object.
Additional errors corresponding to speci?c binary formats may be gener-
ated as speci?ed by the extensions de?ning those formats.
If ShaderBinary fails, the old state of shader objects for which the binary was
being loaded will not be restored.
Note that if shader binary interfaces are supported, then a GL implementation
may require that an optimized set of shader binaries that were compiled together be
speci?ed to LinkProgram. Not specifying an optimized set may cause LinkPro-
gram to fail.
7.2.1 Shader Specialization
Shaders associated with SPIR-V modules must be specialized before they can be
linked into a program object. It is not necessary to specialize the shader before it
is attached to a program object. Once specialized, a shader may not be special-
ized again without ?rst re-associating the original SPIR-V module with it, through
ShaderBinary.
Specialization does two things:
 Selects the name of the entry point, for that shader’s stage, from the SPIR-V
module.
 Sets the values of all, or a subset of, the specialization constants in the SPIR-
V module.
To specialize a shader created from a SPIR-V module, call:
void SpecializeShader(uint shader,const
char *pEntryPoint,uint numSpecializationConstants,
const uint *pConstantIndex,const
uint *pConstantValue );
shader is the name of a shader object containing unspecialized SPIR-V as
created from a successful call to ShaderBinary to which a SPIR-V module was
passed. pEntryPoint is a pointer to a null-terminated UTF-8 string specifying the
name of the entry point in the SPIR-V module to use for this shader. numSpecial-
izationConstants is the number of specialization constants whose values to set in
this call. pConstantIndex is a pointer to an array of numSpecializationConstants
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 94
unsigned integers, each holding the index of a specialization constant in the SPIR-
V module whose value to set. The corresponding entry in pConstantValue is used to
set the value of the specialization constant indexed by the entry in pConstantIndex.
Although this array is of unsigned integer, each entry is bitcast to the appropriate
type for the module, and therefore, ?oating-point constants may be set by includ-
ing their IEEE-754 bit representation in the pConstantValue array. Specialization
constants not referenced by pConstantIndex retain their default values as speci?ed
in the SPIR-V module.
On successful shader specialization, the compile status for shader is set to
TRUE. On failure, the compile status for shader is set to FALSE and additional in-
formation about the cause of the failure may be available in the shader compilation
log. Specialization can fail if the SPIR-V module fails to meet the requirements
listed in appendix C.
Errors
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
An INVALID_OPERATION error is generated if the value of SPIR_V_-
BINARY for shader is notTRUE, or if the shader has already been specialized.
AnINVALID_VALUE error is generated if pEntryPoint does not match the
Name of any OpEntryPoint declaration in the SPIR-V module associated
with shader.
An INVALID_OPERATION error is generated if the ExecutionMode of
the OpEntryPoint indicated by pEntryPoint does not match the type of
shader.
AnINVALID_VALUE error is generated if any element of pConstantIndex
refers to a specialization constant that does not exist in the shader module
contained in shader.
7.3 Program Objects
A program object is created with the command
uint CreateProgram(void );
Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, zero will be
returned.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 95
To attach a shader object to a program object, use the command
void AttachShader(uint program,uint shader );
Shader objects may be attached to program objects before source code has
been loaded into the shader object, or before the shader object has been compiled
or specialized. Multiple shader objects of the same type may be attached to a
single program object, and a single shader object may be attached to more than
one program object.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
AnINVALID_OPERATION error is generated if shader is already attached
to program.
To detach a shader object from a program object, use the command
void DetachShader(uint program,uint shader );
If shader has been ?agged for deletion and is not attached to any other program
object, it is deleted.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
An INVALID_OPERATION error is generated if shader is not attached to
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 96
program.
In order to use the shader objects contained in a program object, the program
object must be linked. The command
void LinkProgram(uint program );
will link the program object named program. Each program object has a boolean
status, LINK_STATUS, that is modi?ed as a result of linking. This status may be
queried with GetProgramiv (see section 7.14). This status will be set toTRUE if a
valid executable is created, andFALSE otherwise.
Linking can fail for a variety of reasons as speci?ed in the OpenGL Shading
Language Specification for source shaders, or if the requirements in appendix C
are not met for SPIR-V shaders, as well as any of the following reasons:
 No shader objects are attached to program.
 One or more of the shader objects attached to program are not compiled or
specialized successfully.
 More active uniform or active sampler variables are used in program than
allowed (see sections 7.6, 7.11, and 11.3.3).
 program contains objects to form a tessellation control shader (see sec-
tion 11.2.1), and
– the program is not separable and contains no objects to form a vertex
shader;
– the output patch vertex count is not speci?ed in any compiled tessella-
tion control shader object; or
– the output patch vertex count is speci?ed differently in multiple tessel-
lation control shader objects.
 program contains objects to form a tessellation evaluation shader (see sec-
tion 11.2.3), and
– the program is not separable and contains no objects to form a vertex
shader;
– the tessellation primitive mode is not speci?ed in any compiled tessel-
lation evaluation shader object; or
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 97
– the tessellation primitive mode, spacing, vertex order, or point mode is
speci?ed differently in multiple tessellation evaluation shader objects.
 program contains objects to form a geometry shader (see section 11.3), and
– the program is not separable and contains no objects to form a vertex
shader;
– the input primitive type, output primitive type, or maximum output ver-
tex count is not speci?ed in any compiled geometry shader object; or
– the input primitive type, output primitive type, or maximum output ver-
tex count is speci?ed differently in multiple geometry shader objects.
 program contains objects to form a compute shader (see section 19) and,
– program also contains objects to form any other type of shader.
 All the shader objects attached to program do not have the same value for
theSPIR_V_BINARY state.
If LinkProgram failed, any information about a previous link of that program
object is lost. Thus, a failed link does not restore the old state of program.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
When program objects which have been linked successfully are used for ren-
dering operations, they may access GL state and interface with other stages of the
GL pipeline through active variables and active interface blocks. The GL provides
various commands allowing applications to enumerate and query properties of ac-
tive variables and interface blocks for a speci?ed program. If one of these com-
mands is called with a program for which LinkProgram succeeded, the informa-
tion recorded when the program was linked is returned. If one of these commands is
called with a program for which LinkProgram failed, no error is generated unless
otherwise noted. Implementations may return information on variables and inter-
face blocks that would have been active had the program been linked successfully.
In cases where the link failed because the program required too many resources,
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 98
these commands may help applications determine why limits were exceeded. How-
ever, the information returned in this case is implementation-dependent and may be
incomplete. If one of these commands is called with a program for which LinkPro-
gram had never been called, no error is generated unless otherwise noted, and the
program object is considered to have no active variables or interface blocks.
Each program object has an information log that is overwritten as a result of a
link operation. This information log may be queried with GetProgramInfoLog to
obtain more information about the link operation or the validation information (see
section 7.14).
If a program has been linked successfully by LinkProgram or loaded by Pro-
gramBinary (see section 7.5), it can be made part of the current rendering state
for all shader stages with the command
void UseProgram(uint program );
If program is non-zero, this command will make program the current program ob-
ject. This will install executable code as part of the current rendering state for each
shader stage present when the program was last linked successfully. If UsePro-
gram is called with program set to zero, then there is no current program object.
The executable code for an individual shader stage is taken from the current
program for that stage. If there is a current program object established by Use-
Program, that program is considered current for all stages. Otherwise, if there is
a bound program pipeline object (see section 7.4), the program bound to the ap-
propriate stage of the pipeline object is considered current. If there is no current
program object or bound program pipeline object, no program is current for any
stage. The current program for a stage is considered active if it contains exe-
cutable code for that stage; otherwise, no program is considered active for that
stage. If there is no active program for the vertex or fragment shader stages, the
results of vertex and/or fragment processing will be unde?ned. However, this is
not an error. If there is no active program for the tessellation control, tessellation
evaluation, or geometry shader stages, those stages are ignored. If there is no active
program for the compute shader stage, compute dispatches will generate an error.
The active program for the compute shader stage has no effect on the processing of
vertices, geometric primitives, and fragments, and the active program for all other
shader stages has no effect on compute dispatches.
Errors
AnINVALID_VALUE error is generated if program is neither zero nor the
name of either a program or shader object.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 99
AnINVALID_OPERATION error is generated if program is not zero and is
the name of a shader object.
An INVALID_OPERATION error is generated if program has not been
linked successfully. The current rendering state is not modi?ed.
While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutable code of the program object.
If LinkProgram or ProgramBinary successfully re-links a program object
that is active for any shader stage, then the newly generated executable code will
be installed as part of the current rendering state for all shader stages where the
program is active. Additionally, the newly generated executable code is made part
of the state of any program pipeline for all stages where the program is attached.
If a program object that is active for any shader stage is re-linked unsuccess-
fully, the link status will be set toFALSE, but any existing executables and associ-
ated state will remain part of the current rendering state until a subsequent call to
UseProgram, UseProgramStages, or BindProgramPipeline removes them from
use. If such a program is attached to any program pipeline object, the existing exe-
cutables and associated state will remain part of the program pipeline object until a
subsequent call to UseProgramStages removes them from use. A program which
has not been linked successfully may not be made part of the current rendering state
by UseProgram or added to program pipeline objects by UseProgramStages until
it is re-linked successfully. If such a program was attached to a program pipeline
at the time of a failed link, its existing executable may still be made part of the
current rendering state indirectly by BindProgramPipeline.
To set a program object parameter, call
void ProgramParameteri(uint program,enum pname,
int value );
pname identi?es which parameter to set for program. value holds the value
being set.
If pname is PROGRAM_SEPARABLE, value must be TRUE or FALSE, and indi-
cates whether program can be bound for individual pipeline stages using UsePro-
gramStages after it is next linked.
If pname isPROGRAM_BINARY_RETRIEVABLE_HINT, value must beTRUE or
FALSE, and indicates whether a program binary is likely to be retrieved later, as
described for ProgramBinary in section 7.5.
State set with this command does not take effect until after the next time
LinkProgram or ProgramBinary is called successfully.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 100
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_ENUM error is generated if pname is not PROGRAM_-
SEPARABLE orPROGRAM_BINARY_RETRIEVABLE_HINT.
AnINVALID_VALUE error is generated if value is notTRUE orFALSE.
Program objects can be deleted with the command
void DeleteProgram(uint program );
If program is not current for any GL context, is not the active program for any pro-
gram pipeline object, and is not the current program for any stage of any program
pipeline object, it is deleted immediately. Otherwise, program is ?agged for dele-
tion and will be deleted after all of these conditions become true. When a program
object is deleted, all shader objects attached to it are detached. DeleteProgram
will silently ignore the value zero.
Errors
AnINVALID_VALUE error is generated if program is neither zero nor the
name of either a program or shader object.
AnINVALID_OPERATION error is generated if program is not zero and is
the name of a shader object.
The command
boolean IsProgram(uint program );
returnsTRUE if program is the name of a program object. If program is zero, or a
non-zero value that is not the name of a program object, IsProgram returnsFALSE.
No error is generated if program is not a valid program object name.
The command
uint CreateShaderProgramv(enum type,sizei count,
const char *const *strings );
creates a stand-alone program from an array of null-terminated source code strings
for a single shader type. CreateShaderProgramv is equivalent (assuming no er-
rors are generated) to:
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 101
const uint shader = CreateShader(type);
if (shader) f
ShaderSource(shader, count, strings, NULL);
CompileShader(shader);
const uint program = CreateProgram();
if (program) f
int compiled = FALSE;
GetShaderiv(shader, COMPILE_STATUS, &compiled);
ProgramParameteri(program, PROGRAM_SEPARABLE, TRUE);
if (compiled) f
AttachShader(program, shader);
LinkProgram(program);
DetachShader(program, shader);
g
append-shader-info-log-to-program-info-log
g
DeleteShader(shader);
return program;
g else f
return 0;
g
Because no shader is returned by CreateShaderProgramv and the shader that
is created is deleted in the course of the command sequence, the info log of the
shader object is copied to the program so the shader’s failed info log for the failed
compilation is accessible to the application.
If an error is generated, zero is returned.
Errors
An INVALID_ENUM error is generated if type is not one of the values in
table 7.1.
AnINVALID_VALUE error is generated if count is negative.
Other errors are generated if the supplied shader code fails to compile
and link, as described for the commands in the pseudocode sequence above,
but all such errors are generated without any side effects of executing those
commands.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 102
7.3.1 Program Interfaces
When a program object is made part of the current rendering state, its executable
code may communicate with other GL pipeline stages or application code through
a variety of interfaces. When a program is linked, the GL builds a list of active
resources for each interface. Examples of active resources include variables, inter-
face blocks, and subroutines used by shader code. Resources referenced in shader
code are considered active unless the compiler and linker can conclusively deter-
mine that they have no observable effect on the results produced by the executable
code of the program. For example, variables might be considered inactive if they
are declared but not used in executable code, used only in a clause of anif state-
ment that would never be executed, used only in functions that are never called, or
used only in computations of temporary variables having no effect on any shader
output. In cases where the compiler or linker cannot make a conclusive determina-
tion, any resource referenced by shader code will be considered active. The set of
active resources for any interface is implementation-dependent because it depends
on various analysis and optimizations performed by the compiler and linker.
If a program is linked successfully, the GL will generate lists of active resources
based on the executable code produced by the link. If a program is not linked suc-
cessfully, the link may have failed for a number of reasons, including cases where
the program required more resources than supported by the implementation. Imple-
mentations are permitted, but not required, to record lists of resources that would
have been considered active had the program linked successfully. If an implemen-
tation does not record information for any given interface, the corresponding list of
active resources is considered empty. If a program has never been linked, all lists
of active resources are considered empty.
The GL provides a number of commands to query properties of the interfaces of
a program object. Each such command accepts a programInterface token, identify-
ing a speci?c interface. The supported values for programInterface are as follows:
 UNIFORM corresponds to the set of active uniform variables (see section 7.6)
used by program.
 UNIFORM_BLOCK corresponds to the set of active uniform blocks (see sec-
tion 7.6) used by program.
 ATOMIC_COUNTER_BUFFER corresponds to the set of active atomic counter
buffer binding points (see section 7.6) used by program.
 PROGRAM_INPUT corresponds to the set of active input variables used by the
?rst shader stage of program. If program includes multiple shader stages,
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 103
input variables from any shader stage other than the ?rst will not be enumer-
ated.
 PROGRAM_OUTPUT corresponds to the set of active output variables (see sec-
tion 11.1.2.1) used by the last shader stage of program. If program includes
multiple shader stages, output variables from any shader stage other than the
last will not be enumerated.
 VERTEX_SUBROUTINE, TESS_CONTROL_SUBROUTINE, TESS_-
EVALUATION_SUBROUTINE, GEOMETRY_SUBROUTINE, FRAGMENT_-
SUBROUTINE, and COMPUTE_SUBROUTINE correspond to the set of active
subroutines for the vertex, tessellation control, tessellation evaluation, ge-
ometry, fragment, and compute shader stages of program, respectively (see
section 7.10).
 VERTEX_SUBROUTINE_UNIFORM, TESS_CONTROL_SUBROUTINE_-
UNIFORM, TESS_EVALUATION_SUBROUTINE_UNIFORM,
GEOMETRY_SUBROUTINE_UNIFORM, FRAGMENT_SUBROUTINE_UNIFORM,
and COMPUTE_SUBROUTINE_UNIFORM correspond to the set of active sub-
routine uniform variables used by the vertex, tessellation control, tessellation
evaluation, geometry, fragment, and compute shader stages of program, re-
spectively (see section 7.10).
 TRANSFORM_FEEDBACK_VARYING corresponds to the set of output vari-
ables in the last non-fragment stage of program that would be captured when
transform feedback is active (see section 13.3.3). The resources enumerated
by this query are listed as speci?ed by the most recent call to Transform-
FeedbackVaryings before the last call to LinkProgram. When the resource
names an output array variable either a single element of the array or the
whole array is captured. If the variable name is speci?ed with an array in-
dex syntax "name[x]", name is the name of the array resource and x is
the constant-integer index of the element captured. If the resource name is
an array and has no array index and square bracket, then the whole array is
captured.
 TRANSFORM_FEEDBACK_BUFFER corresponds to the set of active buffer
binding points to which output variables in the TRANSFORM_FEEDBACK_-
VARYING interface are written.
 BUFFER_VARIABLE corresponds to the set of active buffer variables used by
program (see section 7.8).
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 104
 SHADER_STORAGE_BLOCK corresponds to the set of active shader storage
blocks used by program (see section 7.8)
7.3.1.1 Naming Active Resources
When building a list of active variable or interface blocks, resources with aggre-
gate types (such as arrays or structures) may produce multiple entries in the active
resource list for the corresponding interface. Additionally, each active variable,
interface block, or subroutine in the list is assigned an associated name string that
can be used by applications to refer to the resource.
For interfaces enumerating active variables, resource list entries for variables
declared outside interface blocks are generated as follows:
 For an active variable declared as a single instance of a basic type, a single
entry will be generated, using the variable name from the shader source.
 For an active variable declared as an array of basic types (e.g. not an array
of stuctures or an array of arrays), a single entry will be generated, with its
name string formed by concatenating the name of the array and the string
"[0]".
 For an active variable declared as a structure, a separate entry will be gener-
ated for each active structure member. The name of each entry is formed by
concatenating the name of the structure, the"." character, and the name of
the structure member. If a structure member to enumerate is itself a structure
or array, these enumeration rules are applied recursively.
 For an active variable declared as an array of an aggregate data type (struc-
tures or arrays), a separate entry will be generated for each active array ele-
ment, unless noted immediately below. The name of each entry is formed
by concatenating the name of the array, the"[" character, an integer identi-
fying the element number, and the"]" character. These enumeration rules
are applied recursively, treating each enumerated array element as a separate
active variable.
For interfaces enumerating active variables, resource list entries for active
members of interface blocks are generated as follows:
 For active members of an interface block with no instance name, resource
list entries will be generated by treating the block member as though it were
declared as a variable outside an interface block. The name strings for these
entries will not include the block name.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 105
 For active members of an interface block with an instance name, resource
list entries will be generated by applying the rules for variables declared
outside an interface block. The name string for each such entry is formed by
concatenating the name of the interface block (not the instance name), the
"." character, and the name string that would be generated for an equivalent
variable declared outside an interface block.
 For active members of an array of interface blocks, entries will be gener-
ated using the same rules as for members of a single interface block with an
instance name. There will not be separate entries for each instance of the
interface block, and the name strings will not contain any text like"[0]" to
indicate that the member belongs to an array of interface blocks.
 For active shader storage block members that are declared as arrays of an
aggregate type, entries will not be generated for each array element. Such
block members are referred to as top-level arrays and will generate entries
only for the ?rst array element.
For interfaces enumerating active interface blocks, the entries of active resource
lists are generated as follows:
 For an active interface block not declared as an array of block instances, a
single entry will be generated, using the block name from the shader source.
 For an active interface block declared as an array of arrays, a separate en-
try will be generated for each active instance. The name of each instance is
formed by concatenating the block name, the"[" character, an integer iden-
tifying the instance number, and the"]" character. These enumeration rules
are applied recursively, treating each enumerated array element as a separate
active interface block.
For interfaces enumerating active subroutines, a single entry will be generated
for each active subroutine, using the subroutine name from the shader source.
When an integer array element or block instance number is part of the name
string, it will be speci?ed in decimal form without a "+" or "-" sign or any
extra leading zeroes. Additionally, the name string will not include white space
anywhere in the string.
For shaders constructed from SPIR-V binaries (that is with a state of SPIR_-
V_BINARY equal to TRUE), variables may not have names associated with them,
as the OpName and OpMemberName debug instructions are optional and may not
be present in a SPIR-V module. When the Op Name instructions are present, it is
*
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 106
implementation-dependent if these are reported via the name re?ection APIs. If
no name re?ection information is available, the name string associated with each
active variable is the empty string (""). In this case, any queries that operate with
a name as input will returnINVALID_INDEX or -1 as appropriate, and any queries
that return information about the name of a resource will report a name length of
one (for the null character) and return an empty string with a length of zero.
The order of the active resource list is implementation-dependent for all
interfaces except for TRANSFORM_FEEDBACK_VARYING. If variables in the
TRANSFORM_FEEDBACK_VARYING interface were speci?ed using the Transform-
FeedbackVaryings command, the active resource list will be arranged in the vari-
able order speci?ed in the most recent call to TransformFeedbackVaryings be-
fore the last call to LinkProgram. If variables in the TRANSFORM_FEEDBACK_-
VARYING interface were speci?ed usinglayout quali?ers in shader code, the or-
der of the active resource list is implementation-dependent.
For theATOMIC_COUNTER_BUFFER interface, the list of active buffer binding
points is built by identifying each unique binding point associated with one or more
active atomic counter uniform variables. Active atomic counter buffers do not have
an associated name string.
For the UNIFORM, PROGRAM_INPUT, PROGRAM_OUTPUT, and TRANSFORM_-
FEEDBACK_VARYING interfaces, the active resource list will include all active vari-
ables for the interface, including any active built-in variables.
For PROGRAM_INPUT and PROGRAM_OUTPUT interfaces for shaders that re-
cieve or produce patch primitves, the active resource list will include both per-
vertex and per-patch inputs and outputs.
For the TRANSFORM_FEEDBACK_BUFFER interface, the list of active buffer
binding points is built by identifying each unique binding point to which one or
more active output variables will be written in transform feedback mode. Active
transform feedback buffers do not have an associated name string.
For the TRANSFORM_FEEDBACK_VARYING interface, the active resource
list will include entries for the special variable names gl_NextBuffer,
gl_SkipComponents1, gl_SkipComponents2, gl_SkipComponents3, and
gl_SkipComponents4 (see section 11.1.2.1). These variables are used to control
how output values are written to transform feedback buffers. When enumerating
the properties of such resources, these variables are considered to have a TYPE of
NONE and anARRAY_SIZE of 0 (gl_NextBuffer), 1, 2, 3, and 4, respectively.
When a program is linked successfully, active variables in the UNIFORM,
PROGRAM_INPUT,PROGRAM_OUTPUT, or any of the subroutine uniform interfaces,
are assigned one or more signed integer locations. These locations can be used
by commands to assign values to uniforms and subroutine uniforms, to identify
generic vertex attributes associated with vertex shader inputs, or to identify frag-
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 107
ment color output numbers and indices associated with fragment shader outputs.
For such variables declared as arrays, separate locations will be assigned to each ac-
tive array element and are not required to be sequential. The location for"a[1]"
may or may not be equal to the location for"a[0]" +1. Furthermore, since un-
used elements at the end of uniform arrays may be trimmed, the location of the
i + 1’th array element may not be valid even if the location of the i’th element
is valid. As a direct consequence, the value of the location of "a[0]" +1 may
refer to a different uniform entirely. Applications that wish to set individual array
elements should query the locations of each element separately.
Not all active variables are assigned valid locations; the following variables
will have an effective location of -1:
 uniforms declared as atomic counters
 members of a uniform block
 built-in inputs, outputs, and uniforms (starting withgl_)
 inputs (except for vertex shader inputs) not declared with a location
layout quali?er
 outputs (except for fragment shader outputs) not declared with alocation
layout quali?er
If a program has not been linked successfully, no locations will be assigned.
The command
void GetProgramInterfaceiv(uint program,
enum programInterface,enum pname,int *params );
queries a property of the interface programInterface in program program, returning
its value in params. The property to return is speci?ed by pname.
If pname is ACTIVE_RESOURCES, the value returned is the number of re-
sources in the active resource list for programInterface. If the list of active re-
sources for programInterface is empty, zero is returned.
If pname isMAX_NAME_LENGTH, the value returned is the length of the longest
active name string for an active resource in programInterface. This length includes
an extra character for the null terminator. If the list of active resources for pro-
gramInterface is empty, zero is returned.
If pname is MAX_NUM_ACTIVE_VARIABLES, the value returned is the num-
ber of active variables belonging to the interface block or atomic counter buffer
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 108
resource in programInterface with the most active variables. If the list of active
resources for programInterface is empty, zero is returned.
If pname isMAX_NUM_COMPATIBLE_SUBROUTINES, the value returned is the
number of compatible subroutines for the active subroutine uniform in program-
Interface with the most compatible subroutines. If the list of active resources for
programInterface is empty, zero is returned.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_ENUM error is generated if programInterface is not one of
the interfaces described in the introduction to section 7.3.1.
An INVALID_ENUM error is
generated if pname is notACTIVE_RESOURCES,MAX_NAME_LENGTH,MAX_-
NUM_ACTIVE_VARIABLES, orMAX_NUM_COMPATIBLE_SUBROUTINES.
An INVALID_OPERATION error is generated if pname is MAX_-
NAME_LENGTH and programInterface is ATOMIC_COUNTER_BUFFER or
TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform
feedback buffer resources are not assigned name strings.
An INVALID_OPERATION error is generated if pname is MAX_NUM_-
ACTIVE_VARIABLES and programInterface is not ATOMIC_COUNTER_-
BUFFER, SHADER_STORAGE_BLOCK, TRANSFORM_FEEDBACK_BUFFER, or
UNIFORM_BLOCK.
An INVALID_OPERATION error is generated if pname is MAX_-
NUM_COMPATIBLE_SUBROUTINES and programInterface is not VERTEX_-
SUBROUTINE_-
UNIFORM,TESS_CONTROL_SUBROUTINE_UNIFORM,TESS_EVALUATION_-
SUBROUTINE_UNIFORM,GEOMETRY_SUBROUTINE_UNIFORM,FRAGMENT_-
SUBROUTINE_UNIFORM, orCOMPUTE_SUBROUTINE_UNIFORM.
Each entry in the active resource list for an interface is assigned a unique un-
signed integer index in the range zero toN  1, whereN is the number of entries
in the active resource list. The command
uint GetProgramResourceIndex(uint program,
enum programInterface,const char *name );
returns the unsigned integer index assigned to a resource named name in the inter-
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 109
face type programInterface of program object program.
If name exactly matches the name string of one of the active resources for
programInterface, the index of the matched resource is returned.
 ForTRANSFORM_FEEDBACK_VARYING resources, name must match one of
the variables to be captured as speci?ed by a previous call to Transform-
FeedbackVaryings, other than the special names gl_NextBuffer, gl_-
SkipComponents1, gl_SkipComponents2, gl_SkipComponents3,
andgl_SkipComponents4 (see section 11.1.2.1). Otherwise,INVALID_-
INDEX is returned.
 For all other resource types, if name would exactly match the name string
of an active resource if "[0]" were appended to name, the index of the
matched resource is returned. Otherwise, name is considered not to be the
name of an active resource, andINVALID_INDEX is returned. Note that if an
interface enumerates a single active resource list entry for an array variable
(e.g., "a[0]"), a name identifying any array element other than the ?rst
(e.g.,"a[1]") is not considered to match.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_ENUM error is generated if programInterface is not one of
the interfaces described in the introduction to section 7.3.1.
An INVALID_ENUM error is generated if programInterface is ATOMIC_-
COUNTER_BUFFER or TRANSFORM_FEEDBACK_BUFFER, since active atomic
counter and transform feedback buffer resources are not assigned name strings.
If name does not match a resource as described above, the value
INVALID_INDEX is returned, but no GL error is generated.
The command
void GetProgramResourceName(uint program,
enum programInterface,uint index,sizei bufSize,
sizei *length,char *name );
returns the name string assigned to the single active resource with an index of index
in the interface programInterface of program object program.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 110
The name string assigned to the active resource identi?ed by index is returned
as a null-terminated string in name. The actual number of characters written into
name, excluding the null terminator, is returned in length. If length is NULL,
no length is returned. The maximum number of characters that may be written
into name, including the null terminator, is speci?ed by bufSize. If the length of
the name string (including the null terminator) is greater than bufSize, the ?rst
bufSize  1 characters of the name string will be written to name, followed by a
null terminator. If bufSize is zero, no error is generated but no characters will be
written to name. The length of the longest name string for programInterface, in-
cluding a null terminator, may be queried by calling GetProgramInterfaceiv with
a pname ofMAX_NAME_LENGTH.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_ENUM error is generated if programInterface is not one of
the interfaces described in the introduction to section 7.3.1.
An INVALID_ENUM error is generated if programInterface is ATOMIC_-
COUNTER_BUFFER or TRANSFORM_FEEDBACK_BUFFER, since active atomic
counter and transform feedback buffer resources are not assigned name strings.
AnINVALID_VALUE error is generated if index is greater than or equal to
the number of entries in the active resource list for programInterface.
AnINVALID_VALUE error is generated if bufSize is negative.
The command
void GetProgramResourceiv(uint program,
enum programInterface,uint index,sizei propCount,
const enum *props,sizei bufSize,sizei *length,
int *params );
returns values for multiple properties of a single active resource with an index of
index in the interface programInterface of program object program. Values for
propCount properties speci?ed by the array props are returned.
The values associated with the properties of the active resource are written to
consecutive entries in params, in increasing order according to position in props. If
no error is generated, only the ?rst bufSize integer values will be written to params;
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 111
any extra values will not be written. If length is not NULL, the actual number of
values written to params will be written to length.
Property Supported Interfaces
ACTIVE_VARIABLES, BUFFER_- ATOMIC_COUNTER_BUFFER, SHADER_-
BINDING,NUM_ACTIVE_VARIABLES STORAGE_BLOCK, TRANSFORM_-
FEEDBACK_BUFFER,UNIFORM_BLOCK
ARRAY_SIZE BUFFER_VARIABLE, COMPUTE_-
SUBROUTINE_UNIFORM, FRAGMENT_-
SUBROUTINE_UNIFORM, GEOMETRY_-
SUBROUTINE_UNIFORM, PROGRAM_-
INPUT, PROGRAM_OUTPUT, TESS_-
CONTROL_SUBROUTINE_UNIFORM,
TESS_EVALUATION_SUBROUTINE_-
UNIFORM, TRANSFORM_FEEDBACK_-
VARYING, UNIFORM, VERTEX_-
SUBROUTINE_UNIFORM
ARRAY_STRIDE, BLOCK_INDEX, IS_- BUFFER_VARIABLE,UNIFORM
ROW_MAJOR,MATRIX_STRIDE
ATOMIC_COUNTER_BUFFER_INDEX UNIFORM
BUFFER_DATA_SIZE ATOMIC_COUNTER_BUFFER, SHADER_-
STORAGE_BLOCK,UNIFORM_BLOCK
NUM_COMPATIBLE_SUBROUTINES, COMPUTE_SUBROUTINE_UNIFORM,
COMPATIBLE_SUBROUTINES FRAGMENT_SUBROUTINE_UNIFORM,
GEOMETRY_SUBROUTINE_UNIFORM,
TESS_CONTROL_SUBROUTINE_-
UNIFORM, TESS_EVALUATION_-
SUBROUTINE_UNIFORM, VERTEX_-
SUBROUTINE_UNIFORM
IS_PER_PATCH PROGRAM_INPUT,PROGRAM_OUTPUT
LOCATION COMPUTE_SUBROUTINE_UNIFORM,
FRAGMENT_SUBROUTINE_UNIFORM,
GEOMETRY_SUBROUTINE_UNIFORM,
PROGRAM_INPUT, PROGRAM_OUTPUT,
TESS_CONTROL_SUBROUTINE_-
UNIFORM, TESS_EVALUATION_-
SUBROUTINE_UNIFORM, UNIFORM,
VERTEX_SUBROUTINE_UNIFORM
GetProgramResourceiv properties continued on next page
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 112
GetProgramResourceiv properties continued from previous page
Property Supported Interfaces
LOCATION_COMPONENT PROGRAM_INPUT,PROGRAM_OUTPUT
LOCATION_INDEX PROGRAM_OUTPUT
NAME_LENGTH all but ATOMIC_COUNTER_BUFFER and
TRANSFORM_FEEDBACK_BUFFER
OFFSET BUFFER_VARIABLE, TRANSFORM_-
FEEDBACK_VARYING,UNIFORM
REFERENCED_BY_VERTEX_- ATOMIC_COUNTER_BUFFER, BUFFER_-
SHADER, REFERENCED_BY_TESS_- VARIABLE, PROGRAM_INPUT,
CONTROL_SHADER, REFERENCED_- PROGRAM_OUTPUT, SHADER_-
BY_TESS_EVALUATION_SHADER, STORAGE_BLOCK, UNIFORM,
REFERENCED_BY_GEOMETRY_SHADER, UNIFORM_BLOCK
REFERENCED_BY_FRAGMENT_SHADER,
REFERENCED_BY_COMPUTE_SHADER
TRANSFORM_FEEDBACK_BUFFER_- TRANSFORM_FEEDBACK_VARYING
INDEX
TRANSFORM_FEEDBACK_BUFFER_- TRANSFORM_FEEDBACK_BUFFER
STRIDE
TOP_LEVEL_ARRAY_SIZE, TOP_- BUFFER_VARIABLE
LEVEL_ARRAY_STRIDE
TYPE BUFFER_VARIABLE, PROGRAM_INPUT,
PROGRAM_OUTPUT, TRANSFORM_-
FEEDBACK_VARYING,UNIFORM
Table 7.2: GetProgramResourceiv properties and supported in-
terfaces
For the property ACTIVE_VARIABLES, an array of active variable indices as-
sociated with an atomic counter buffer, active uniform block, shader storage block,
or transform feedback buffer is written to params. The number of values written to
params for an active resource is given by the value of the propertyNUM_ACTIVE_-
VARIABLES for the resource.
For the propertyARRAY_SIZE, a single integer identifying the number of active
array elements of an active variable is written to params. The array size returned
is in units of the type associated with the property TYPE. For active variables not
corresponding to an array of basic types, the value one is written to params. If the
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 113
variable is an array whose size is not declared or determined when the program is
linked, the value zero is written to params.
For the property ARRAY_STRIDE, a single integer identifying the stride be-
tween array elements in an active variable is written to params. For active variables
declared as an array of basic types, the value written is the difference, in basic ma-
chine units, between the offsets of consecutive elements in an array. For active
variables not declared as an array of basic types, zero is written to params. For
active variables not backed by a buffer object, -1 is written to params, regardless
of the variable type.
For the property ATOMIC_COUNTER_BUFFER_INDEX, a single integer identi-
fying the index of the active atomic counter buffer containing an active variable is
written to params. If the variable is not an atomic counter uniform, the value -1 is
written to params.
For the property BLOCK_INDEX, a single integer identifying the index of the
active interface block containing an active variable is written to params. The index
written for a member of an interface block declared as an array of block instances
is the index of the ?rst block of the array. If the variable is not the member of an
interface block, the value -1 is written to params.
For the property BUFFER_BINDING, a single integer identifying the index of
the buffer binding point associated with the active uniform block, atomic counter
buffer, shader storage block, or transform feedback buffer is written to params.
For the property BUFFER_DATA_SIZE, a single integer identifying the
implementation-dependent minimum total buffer object size is written to params.
This value is the size, in basic machine units, required to hold all active variables
associated with an active uniform block, shader storage block, or atomic counter
buffer. If the ?nal member of an active shader storage block is an array with no de-
clared size, the minimum buffer size is computed assuming the array was declared
as an array with one element.
For the propertyIS_PER_PATCH, a single integer identifying whether the input
or output is a per-patch attribute is written to params. If the active variable is a
per-patch attribute (declared with the patch quali?er), the value one is written to
params; otherwise, the value zero is written to params.
For the propertyIS_ROW_MAJOR, a single integer identifying whether an active
variable is a row-major matrix is written to params. For active variables backed by
a buffer object, declared as a single matrix or array of matrices, and stored in row-
major order, one is written to params. For all other active variables, zero is written
to params.
For the property LOCATION, a single integer identifying the assigned location
for an active uniform, input, output, or subroutine uniform variable is written to
params. For input, output, or uniform variables with locations speci?ed by a
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 114
layout quali?er, the speci?ed location is used. For vertex shader input, frag-
ment shader output, or uniform variables without a layout quali?er, the location
assigned when a program is linked is written to params. For all other input and
output variables, the value -1 is written to params. For atomic counter uniforms
and uniforms in uniform blocks, the value -1 is written to params.
For the property LOCATION_COMPONENT, a single integer indicating the ?rst
component of the location assigned to an active input or output variable is writ-
ten to params. For input and output variables with a component speci?ed by a
layout quali?er, the speci?ed component is written. For all other input and output
variables, the value zero is written.
For the property LOCATION_INDEX, a single integer identifying the fragment
color index of an active fragment shader output variable is written to params. If the
active variable is not an output for a fragment shader, the value -1 will be written
to params.
For the property MATRIX_STRIDE, a single integer identifying the stride be-
tween columns of a column-major matrix or rows of a row-major matrix is written
to params. For active variables declared a single matrix or array of matrices, the
value written is the difference, in basic machine units, between the offsets of con-
secutive columns or rows in each matrix. For active variables not declared as a
matrix or array of matrices, zero is written to params. For active variables not
backed by a buffer object, -1 is written to params, regardless of the variable type.
For the property NAME_LENGTH, a single integer identifying the length of the
name string associated with an active variable, interface block, or subroutine is
written to params. The name length includes a terminating null character.
For the property NUM_ACTIVE_VARIABLES, a single integer identifying the
number of active variables associated with an active uniform block, atomic counter
buffer, shader storage block, or transform feedback buffer is written to params.
For the property OFFSET, a single integer identifying the offset of an ac-
tive variable is written to params. For variables in the BUFFER_VARIABLE and
UNIFORM interfaces that are backed by a buffer object, the value written is the
offset of that variable relative to the base of the buffer range holding its value.
For variables in the TRANSFORM_FEEDBACK_VARYING interface, the value writ-
ten is the offset in the transform feedback buffer storage assigned to each ver-
tex captured in transform feedback mode where the value of the variable will
be stored. Such offsets are speci?ed via the xfb_offset layout quali?er
or assigned according to the variables position in the list of strings passed to
TransformFeedbackVaryings. Offsets are expressed in basic machine units.
For all variables not recorded in transform feedback mode, including the spe-
cial names gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2,
gl_SkipComponents3, andgl_SkipComponents4, -1 is written to params.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 115
For the properties REFERENCED_BY_VERTEX_SHADER, REFERENCED_-
BY_TESS_CONTROL_SHADER, REFERENCED_BY_TESS_EVALUATION_SHADER,
REFERENCED_BY_GEOMETRY_SHADER, REFERENCED_BY_FRAGMENT_SHADER,
and REFERENCED_BY_COMPUTE_SHADER, a single integer is written to params,
identifying whether the active resource is referenced by the vertex, tessellation con-
trol, tessellation evaluation, geometry, fragment, or compute shaders, respectively,
in the program object. The value one is written to params if an active variable is
referenced by the corresponding shader, or if an active uniform block, shader stor-
age block, or atomic counter buffer contains at least one variable referenced by the
corresponding shader. Otherwise, the value zero is written to params.
For the property TOP_LEVEL_ARRAY_SIZE, a single integer identifying the
number of active array elements of the top-level shader storage block member con-
taining the active variable is written to params. If the top-level block member is not
declared as an array f an aggregate type, the value one is written to params. If the
top-level block member is an array of an aggregate type whose size is not declared
or determined when the program is linked, the value zero is written to params.
For the propertyTOP_LEVEL_ARRAY_STRIDE, a single integer identifying the
stride between array elements of the top-level shader storage block member con-
taining the active variable is written to params. For top-level block members de-
clared as arrays of an aggregate type, the value written is the difference, in basic
machine units, between the offsets of the active variable for consecutive elements
in the top-level array. For top-level block members not declared as an array of an
aggregate type, zero is written to params.
For the property TRANSFORM_FEEDBACK_BUFFER_INDEX, a single integer
identifying the index of the active transform feedback buffer associated with an
active variable is written to params. For variables corresponding to the spe-
cial names gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2,
gl_SkipComponents3, andgl_SkipComponents4, -1 is written to params.
For the property TRANSFORM_FEEDBACK_BUFFER_STRIDE, a single integer
identifying the stride, in basic machine units, between consecutive vertices written
to the transform feedback buffer is written to params.
For the propertyTYPE, a single integer identifying the type of an active variable
is written to params. The integer returned is one of the values found in table 7.3.
Type Name Token Keyword Attrib Xfb Buffer
FLOAT float   
FLOAT_VEC2 vec2   
FLOAT_VEC3 vec3   
(Continued on next page)
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 116
OpenGL Shading Language Type Tokens (continued)
Type Name Token Keyword Attrib Xfb Buffer
FLOAT_VEC4 vec4   
DOUBLE double   
DOUBLE_VEC2 dvec2   
DOUBLE_VEC3 dvec3   
DOUBLE_VEC4 dvec4   
INT int   
INT_VEC2 ivec2   
INT_VEC3 ivec3   
INT_VEC4 ivec4   
UNSIGNED_INT uint   
UNSIGNED_INT_VEC2 uvec2   
UNSIGNED_INT_VEC3 uvec3   
UNSIGNED_INT_VEC4 uvec4   
BOOL bool 
BOOL_VEC2 bvec2 
BOOL_VEC3 bvec3 
BOOL_VEC4 bvec4 
FLOAT_MAT2 mat2   
FLOAT_MAT3 mat3   
FLOAT_MAT4 mat4   
FLOAT_MAT2x3 mat2x3   
FLOAT_MAT2x4 mat2x4   
FLOAT_MAT3x2 mat3x2   
FLOAT_MAT3x4 mat3x4   
FLOAT_MAT4x2 mat4x2   
FLOAT_MAT4x3 mat4x3   
DOUBLE_MAT2 dmat2   
DOUBLE_MAT3 dmat3   
DOUBLE_MAT4 dmat4   
DOUBLE_MAT2x3 dmat2x3   
DOUBLE_MAT2x4 dmat2x4   
DOUBLE_MAT3x2 dmat3x2   
DOUBLE_MAT3x4 dmat3x4   
DOUBLE_MAT4x2 dmat4x2   
DOUBLE_MAT4x3 dmat4x3   
(Continued on next page)
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 117
OpenGL Shading Language Type Tokens (continued)
Type Name Token Keyword Attrib Xfb Buffer
SAMPLER_1D sampler1D
SAMPLER_2D sampler2D
SAMPLER_3D sampler3D
SAMPLER_CUBE samplerCube
SAMPLER_1D_SHADOW sampler1DShadow
SAMPLER_2D_SHADOW sampler2DShadow
SAMPLER_1D_ARRAY sampler1DArray
SAMPLER_2D_ARRAY sampler2DArray
SAMPLER_CUBE_MAP_ARRAY samplerCubeArray
SAMPLER_1D_ARRAY_SHADOW sampler1DArrayShadow
SAMPLER_2D_ARRAY_SHADOW sampler2DArrayShadow
SAMPLER_2D_MULTISAMPLE sampler2DMS
SAMPLER_2D_MULTISAMPLE_- sampler2DMSArray
ARRAY
SAMPLER_CUBE_SHADOW samplerCubeShadow
SAMPLER_CUBE_MAP_ARRAY_- samplerCube-
SHADOW ArrayShadow
SAMPLER_BUFFER samplerBuffer
SAMPLER_2D_RECT sampler2DRect
SAMPLER_2D_RECT_SHADOW sampler2DRectShadow
INT_SAMPLER_1D isampler1D
INT_SAMPLER_2D isampler2D
INT_SAMPLER_3D isampler3D
INT_SAMPLER_CUBE isamplerCube
INT_SAMPLER_1D_ARRAY isampler1DArray
INT_SAMPLER_2D_ARRAY isampler2DArray
INT_SAMPLER_CUBE_MAP_- isamplerCubeArray
ARRAY
INT_SAMPLER_2D_- isampler2DMS
MULTISAMPLE
INT_SAMPLER_2D_- isampler2DMSArray
MULTISAMPLE_ARRAY
INT_SAMPLER_BUFFER isamplerBuffer
INT_SAMPLER_2D_RECT isampler2DRect
UNSIGNED_INT_SAMPLER_1D usampler1D
(Continued on next page)
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 118
OpenGL Shading Language Type Tokens (continued)
Type Name Token Keyword Attrib Xfb Buffer
UNSIGNED_INT_SAMPLER_2D usampler2D
UNSIGNED_INT_SAMPLER_3D usampler3D
UNSIGNED_INT_SAMPLER_- usamplerCube
CUBE
UNSIGNED_INT_SAMPLER_- usampler1DArray
1D_ARRAY
UNSIGNED_INT_SAMPLER_- usampler2DArray
2D_ARRAY
UNSIGNED_INT_SAMPLER_- usamplerCubeArray
CUBE_MAP_ARRAY
UNSIGNED_INT_SAMPLER_- usampler2DMS
2D_MULTISAMPLE
UNSIGNED_INT_SAMPLER_- usampler2DMSArray
2D_MULTISAMPLE_ARRAY
UNSIGNED_INT_SAMPLER_- usamplerBuffer
BUFFER
UNSIGNED_INT_SAMPLER_- usampler2DRect
2D_RECT
IMAGE_1D image1D
IMAGE_2D image2D
IMAGE_3D image3D
IMAGE_2D_RECT image2DRect
IMAGE_CUBE imageCube
IMAGE_BUFFER imageBuffer
IMAGE_1D_ARRAY image1DArray
IMAGE_2D_ARRAY image2DArray
IMAGE_CUBE_MAP_ARRAY imageCubeArray
IMAGE_2D_MULTISAMPLE image2DMS
IMAGE_2D_MULTISAMPLE_- image2DMSArray
ARRAY
INT_IMAGE_1D iimage1D
INT_IMAGE_2D iimage2D
INT_IMAGE_3D iimage3D
INT_IMAGE_2D_RECT iimage2DRect
INT_IMAGE_CUBE iimageCube
(Continued on next page)
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 119
OpenGL Shading Language Type Tokens (continued)
Type Name Token Keyword Attrib Xfb Buffer
INT_IMAGE_BUFFER iimageBuffer
INT_IMAGE_1D_ARRAY iimage1DArray
INT_IMAGE_2D_ARRAY iimage2DArray
INT_IMAGE_CUBE_MAP_ARRAY iimageCubeArray
INT_IMAGE_2D_MULTISAMPLE iimage2DMS
INT_IMAGE_2D_- iimage2DMSArray
MULTISAMPLE_ARRAY
UNSIGNED_INT_IMAGE_1D uimage1D
UNSIGNED_INT_IMAGE_2D uimage2D
UNSIGNED_INT_IMAGE_3D uimage3D
UNSIGNED_INT_IMAGE_2D_- uimage2DRect
RECT
UNSIGNED_INT_IMAGE_CUBE uimageCube
UNSIGNED_INT_IMAGE_- uimageBuffer
BUFFER
UNSIGNED_INT_IMAGE_1D_- uimage1DArray
ARRAY
UNSIGNED_INT_IMAGE_2D_- uimage2DArray
ARRAY
UNSIGNED_INT_IMAGE_- uimageCubeArray
CUBE_MAP_ARRAY
UNSIGNED_INT_IMAGE_2D_- uimage2DMS
MULTISAMPLE
UNSIGNED_INT_IMAGE_2D_- uimage2DMSArray
MULTISAMPLE_ARRAY
UNSIGNED_INT_ATOMIC_- atomic_uint
COUNTER
Table 7.3: OpenGL Shading Language type tokens, and corre-
sponding shading language keywords declaring each such type.
Types whose “Attrib” column is marked may be declared as ver-
tex attributes (see section 11.1.1). Types whose “Xfb” column
is marked may be the types of variables returned by transform
feedback (see section 11.1.2.1). Types whose “Buffer” column is
marked may be declared as buffer variables (see section 7.8).
OpenGL 4.6 (Core Pro?le) - February 2, 20197.3. PROGRAMOBJECTS 120
For the property COMPATIBLE_SUBROUTINES, an array of integers is writ-
ten to params, with each integer specifying the index of an active subroutine that
can be assigned to the selected subroutine uniform. The number of values written
to params for an active subroutine is given by the value of the property NUM_-
COMPATIBLE_SUBROUTINES for the resource.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_ENUM error is generated if programInterface is not one of
the interfaces described in the introduction to section 7.3.1.
AnINVALID_VALUE error is generated if propCount is less than or equal
to zero, or if bufSize is negative.
An INVALID_ENUM error is generated if any value in props is not one of
the properties described above.
An INVALID_OPERATION error is generated if any value in props is not
allowed for programInterface. The set of allowed programInterface values for
each property can be found in table 7.2.
The commands
int GetProgramResourceLocation(uint program,
enum programInterface,const char *name );
int GetProgramResourceLocationIndex(uint program,
enum programInterface,const char *name );
return the location or the fragment color index, respectively, assigned to the
variable named name in interface programInterface of program object program.
For GetProgramResourceLocation, programInterface must be one ofUNIFORM,
PROGRAM_INPUT, PROGRAM_OUTPUT, VERTEX_SUBROUTINE_UNIFORM,
TESS_CONTROL_SUBROUTINE_UNIFORM, TESS_EVALUATION_SUBROUTINE_-
UNIFORM, GEOMETRY_SUBROUTINE_UNIFORM, FRAGMENT_SUBROUTINE_-
UNIFORM, or COMPUTE_SUBROUTINE_UNIFORM. For GetProgramResourceLo-
cationIndex, programInterface must be PROGRAM_OUTPUT. The value -1 will be
returned by either command if an error occurs, if name does not identify an ac-
tive variable on programInterface, or if name identi?es an active variable that does
not have a valid location assigned, as described above. The locations returned by
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 121
these commands are the same locations returned when querying theLOCATION and
LOCATION_INDEX resource properties.
A string provided to GetProgramResourceLocation or GetProgramRe-
sourceLocationIndex is considered to match an active variable if
 the string exactly matches the name of the active variable;
 if the string identi?es the base name of an active array, where the string
would exactly match the name of the variable if the suf?x"[0]" were ap-
pended to the string; or
 if the string identi?es an active element of the array, where the string ends
with the concatenation of the"[" character, an integer (with no"+" sign,
extra leading zeroes, or whitespace) identifying an array element, and the
"]" character, the integer is less than the number of active elements of the
array variable, and where the string would exactly match the enumerated
name of the array if the decimal integer were replaced with zero.
Any other string is considered not to identify an active variable. If the string
speci?es an element of an array variable, GetProgramResourceLocation and
GetProgramResourceLocationIndex return the location or fragment color index
assigned to that element. If it speci?es the base name of an array, it identi?es the
resources associated with the ?rst element of the array.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_OPERATION error is generated if program has not been
linked successfully.
An INVALID_ENUM error is generated if programInterface is not one of
the interfaces named above.
7.4 Program Pipeline Objects
Instead of packaging all shader stages into a single program object, shader types
might be contained in multiple program objects each consisting of part of the com-
plete pipeline. A program object may even contain only a single shader stage.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 122
This facilitates greater ?exibility when combining different shaders in various ways
without requiring a program object for each combination.
A program pipeline object contains bindings for each shader type associating
that shader type with a program object.
The command
void GenProgramPipelines(sizei n,uint *pipelines );
returns n previously unused program pipeline object names in pipelines. These
names are marked as used, for the purposes of GenProgramPipelines only, but
they acquire state only when they are ?rst bound.
Errors
AnINVALID_VALUE error is generated if n is negative.
Program pipeline objects are deleted by calling
void DeleteProgramPipelines(sizei n,const
uint *pipelines );
pipelines contains n names of program pipeline objects to be deleted. Once a
program pipeline object is deleted, it has no contents and its name becomes un-
used. If an object that is currently bound is deleted, the binding for that object
reverts to zero and no program pipeline object becomes current. Unused names in
pipelines that have been marked as used for the purposes of GenProgramPipelines
are marked as unused again. Unused names in pipelines are silently ignored, as is
the value zero.
Errors
AnINVALID_VALUE error is generated if n is negative.
The command
boolean IsProgramPipeline(uint pipeline );
returns TRUE if pipeline is the name of a program pipeline object. If pipeline
is zero, or a non-zero value that is not the name of a program pipeline object,
IsProgramPipeline returnsFALSE. No error is generated if pipeline is not a valid
program pipeline object name.
A program pipeline object is created by binding a name returned by GenPro-
gramPipelines with the command
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 123
void BindProgramPipeline(uint pipeline );
pipeline is the program pipeline object name. The resulting program pipeline
object is a new state vector, comprising all the state and with the same initial values
listed in table 23.31.
BindProgramPipeline may also be used to bind an existing program pipeline
object. If the bind is successful, no change is made to the state of the bound
program pipeline object, and any previous binding is broken. If BindPro-
gramPipeline is called with pipeline set to zero, then there is no current program
pipeline object.
If no current program object has been established by UseProgram, the pro-
gram objects used for each shader stage and for uniform updates are taken from
the bound program pipeline object, if any. If there is a current program object
established by UseProgram, the bound program pipeline object has no effect on
rendering or uniform updates. When a bound program pipeline object is used for
rendering, individual shader executables are taken from its program objects as de-
scribed in the discussion of UseProgram in section 7.3).
Errors
An INVALID_OPERATION error is generated if pipeline is not zero or a
name returned from a previous call to GenProgramPipelines, or if such a
name has since been deleted with DeleteProgramPipelines.
Program pipeline objects may also be created with the command
void CreateProgramPipelines(sizei n,uint *pipelines );
CreateProgramPipelines returns n previously unused program pipeline names
in pipelines, each representing a new program pipeline object which is a state vec-
tor comprising all the state and with the same initial values listed in table 23.31.
Errors
AnINVALID_VALUE error is generated if n is negative.
The executables in a program object associated with one or more shader stages
can be made part of the program pipeline state for those shader stages with the
command
void UseProgramStages(uint pipeline,bitfield stages,
uint program );
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 124
where pipeline is the program pipeline object to be updated, stages is the bitwise
OR of accepted constants representing shader stages, and program identi?es the
program from which the executables are taken.
The bits set in stages indicate the program stages for which the pro-
gram object named by program becomes current. These stages may in-
clude compute, vertex, tessellation control, tessellation evaluation, geome-
try, or fragment, indicated respectively by COMPUTE_SHADER_BIT, VERTEX_-
SHADER_BIT, TESS_CONTROL_SHADER_BIT, TESS_EVALUATION_SHADER_-
BIT,GEOMETRY_SHADER_BIT, orFRAGMENT_SHADER_BIT. The constantALL_-
SHADER_BITS indicates program is to be made current for all shader stages.
If program refers to a program object with a valid shader attached for an indi-
cated shader stage, this call installs the executable code for that stage in the indi-
cated program pipeline object state. If UseProgramStages is called with program
set to zero or with a program object that contains no executable code for any stage
in stages, it is as if the pipeline object has no programmable stage con?gured for
that stage.
If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL ?rst creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.
Errors
An INVALID_VALUE error is generated if stages is not the special value
ALL_SHADER_BITS, and has any bits set other than VERTEX_SHADER_BIT,
COMPUTE_SHADER_BIT, TESS_-
CONTROL_SHADER_BIT, TESS_EVALUATION_SHADER_BIT, GEOMETRY_-
SHADER_BIT, andFRAGMENT_SHADER_BIT.
An INVALID_VALUE error is generated if program is not zero and is not
the name of either a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_OPERATION error is generated if program is not zero and
was linked without thePROGRAM_SEPARABLE parameter set, or has not been
linked successfully. The corresponding shader stages in pipeline are not mod-
i?ed.
AnINVALID_OPERATION error is generated if pipeline is not a name re-
turned from a previous call to GenProgramPipelines or if such a name has
since been deleted by DeleteProgramPipelines.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 125
The command
void ActiveShaderProgram(uint pipeline,uint program );
sets the linked program named by program to be the active program (see sec-
tion 7.6.1) used for uniform updates for the program pipeline object pipeline. If
program is zero, then it is as if there is no active program for pipeline.
If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL ?rst creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.
Errors
AnINVALID_OPERATION error is generated if pipeline is not a name re-
turned from a previous call to GenProgramPipelines or if such a name has
since been deleted by DeleteProgramPipelines.
An INVALID_VALUE error is generated if program is not zero and is not
the name of either a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_OPERATION error is generated if program is not zero and
has not been linked successfully. The active program is not modi?ed.
7.4.1 Shader Interface Matching
When multiple shader stages are active, the outputs of one stage form an interface
with the inputs of the next stage. At each such interface, shader inputs are matched
up against outputs from the previous stage:
 An output block is considered to match an input block in the subsequent
shader if the two blocks have the same block name, and the members of the
block match exactly in name, type, quali?cation, and declaration order.
– For the purposes of shader interface matching, the gl_PointSize
member of the intrinsically declared gl_PerVertex shader interface
block is ignored.
– Output blocks that do not match in name, but have a location and match
in every other way listed above may be considered to match by some
implementations, but not all - so this behaviour should not be relied
upon.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 126
 An output variable is considered to match an input variable in the subsequent
shader if:
– the two variables match in name, type, and quali?cation, and neither
has alocation quali?er, or
– the two variables are declared with the same location and
componentlayout quali?ers and match in type and quali?cation.
For the purposes of interface matching, variables declared with a location
layout quali?er but without a component layout quali?er are considered to
have declared a component layout quali?er of zero. Variables or block mem-
bers declared as structures are considered to match in type if and only if structure
members match in name, type, quali?cation, and declaration order. Variables or
block members declared as arrays are considered to match in type only if both
declarations specify the same element type and array size. The rules for determin-
ing if variables or block members match in quali?cation are found in the OpenGL
Shading Language Specification.
Tessellation control shader per-vertex output variables and blocks and tessella-
tion control, tessellation evaluation, and geometry shader per-vertex input variables
and blocks are required to be declared as arrays, with each element representing
input or output values for a single vertex of a multi-vertex primitive. For the pur-
poses of interface matching, such variables and blocks are treated as though they
were not declared as arrays.
For program objects containing multiple shaders, LinkProgram will check
for mismatches on interfaces between shader stages in the program being linked
and generate a link error if a mismatch is detected. A link error is generated if
any statically referenced input variable or block does not have a matching out-
put. If either shader redeclares the built-in arrays gl_ClipDistance[] orgl_-
CullDistance[], the array must have the same size in both shaders.
With separable program objects, interfaces between shader stages may involve
the outputs from one program object and the inputs from a second program object.
For such interfaces, it is not possible to detect mismatches at link time, because the
programs are linked separately. When each such program is linked, all inputs or
outputs interfacing with another program stage are treated as active. The linker will
generate an executable that assumes the presence of a compatible program on the
other side of the interface. If a mismatch between programs occurs, no GL error is
generated, but some or all of the inputs on the interface will be unde?ned.
At an interface between program objects, the set of inputs and outputs are con-
sidered to match exactly if and only if:
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 127
 Every declared input block or variable has a matching output, as described
above. However, the intrinsically declaredgl_PerVertex shader interface
block must be redeclared, and all members of the redeclaredgl_PerVertex
shader interface block, including the gl_PointSize member if present in
the redeclaration, must match exactly in name, type, quali?cation and decla-
ration order.
 There are no output blocks or user-de?ned output variables declared without
a matching input block or variable declaration.
When the set of inputs and outputs on an interface between programs matches
exactly, all inputs are well-de?ned except when the corresponding outputs were
not written in the previous shader. However, any mismatch between inputs and
outputs results in all inputs being unde?ned except for cases noted below. Even
if an input has a corresponding output that matches exactly, mismatches on other
inputs or outputs may adversely affect the executable code generated to read or
write the matching variable.
The inputs and outputs on an interface between programs need not match ex-
actly when input and output location quali?ers (sections 4.4.1(“Input Layout Qual-
i?ers”) and 4.4.2(“Output Layout Quali?ers”) of the OpenGL Shading Language
Specification) are used. When using location quali?ers, any input with an input
location quali?er will be well-de?ned as long as the other program writes to a
matching output, as described above. The names of variables need not match when
matching by location.
Additionally, scalar and vector inputs with location layout quali?ers will
be well-de?ned if there is a corresponding output satisfying all of the following
conditions:
 the input and output match exactly in quali?cation, including in the
locationlayout quali?er;
 the output is a vector with the same basic component type and has more
components than the input; and
 the common component type of the input and output isint,uint, orfloat
(scalars, vectors, and matrices withdouble component type are excluded).
In this case, the components of the input will be taken from the ?rst components
of the matching output, and the extra components of the output will be ignored.
To use any built-in input or output in the gl_PerVertex block in separable
program objects, shader code must redeclare that block prior to use. A separable
program will fail to link if:
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 128
 it contains multiple shaders of a single type with different redeclarations of
this built-in block; or
 any shader uses a built-in block member not found in the redeclaration of
that block.
There is one exception to this rule described below.
As described above, an exact interface match requires matching built-in input
and output blocks. At an interface between two non-fragment shader stages, the
gl_PerVertex input and output blocks are considered to match if and only if the
block members match exactly in name, type, quali?cation, and declaration order.
At an interface involving the fragment shader stage, the presence or absence of any
built-in output does not affect interface matching.
Built-in inputs or outputs not found in blocks do not affect interface match-
ing. Any such built-in inputs are well-de?ned unless they are derived from built-in
outputs not written by the previous shader stage.
7.4.2 SPIR-V Shader Interface Matching
SPIR-V shaders must also follow the rules in this section, whether they add to
or override those given in section 7.4.1. Most importantly, SPIR-V variables and
structure members do not have names and so no interface matching is done by
name strings.
All variables forming the input or output interfaces of shader stages must be
listed as operands to the OpEntryPoint instruction and are declared with the
Input orOutput Storage Classes, respectively, in the SPIR-V module.
Shader built-in variables meeting the following requirements de?ne the built-in
interface block. They must:
 be explicitly declared (there are no implicit built-ins),
 be decorated with theBuiltIn decoration,
 be declared in a block whose top-level members are the built-ins, and
 not have anyLocation orComponent decorations.
Built-ins only participate in interface matching if they are declared in such a
block. There must be no more than one built-in interface block per shader per
interface.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.4. PROGRAMPIPELINEOBJECTS 129
User-de?ned interface variables must be decorated with a Location and can
also be decorated with a Component. These correspond to the location and com-
ponent discussed in section 7.4.1. Uniform and shader storage block variables
must also be decorated with aBinding.
A user-de?ned output variable is considered to match an input variable in the
subsequent stage only if the two variables are declared with the same Location
andComponent decoration and match in type and decoration, except that interpo-
lation decorations are not required to match.
Variables or block members declared as structures are considered to match in
type if and only if the structure members match in type, decoration, number, and
declaration order. Variables or block members declared as arrays are considered to
match in type only if both declarations specify the same element type and size.
At an interface between two non-fragment shader stages, the built-in interface
block must match exactly, as described above. At an interface involving the frag-
ment shader inputs, the presence or absence of any built-in output does not affect
the interface matching.
At an interface between two shader stages, the user-de?ned variable interface
must match exactly. Additionally, scalar and vector inputs are well-de?ned if there
is a corresponding output satisfying all of the following conditions:
 the input and output match exactly in decoration,
 the output is a vector with the same basic type and has at least as many
components as the input, and
 the common component type of the input and output is 32-bit integer or
?oating-point (64-bit component types are excluded).
In this case, the components of the input will be taken from the ?rst components
of the output, and any extra components of the output will be ignored.
7.4.3 Program Pipeline Object State
The state required to support program pipeline objects consists of a single binding
name of the current program pipeline object. This binding is initially zero indicat-
ing no program pipeline object is bound.
The state of each program pipeline object consists of:
 Unsigned integers holding the names of the active program and each of the
current vertex, tessellation control, tessellation evaluation, geometry, frag-
ment, and compute stage programs. Each integer is initially zero.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.5. PROGRAMBINARIES 130
 A boolean holding the status of the last validation attempt, initially false.
 An array of type char containing the information log (see section 7.14),
initially empty.
 An integer holding the length of the information log.
7.5 Program Binaries
The command
void GetProgramBinary(uint program,sizei bufSize,
sizei *length,enum *binaryFormat,void *binary );
returns a binary representation of the program object’s compiled and linked exe-
cutable source, henceforth referred to as its program binary. The maximum number
of bytes that may be written into binary is speci?ed by bufSize. The actual num-
ber of bytes written into binary is returned in length and its format is returned in
binaryFormat. If length isNULL, then no length is returned.
The number of bytes in the program binary may be queried by calling GetPro-
gramiv with pnamePROGRAM_BINARY_LENGTH.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_OPERATION error is generated if the value of NUM_-
PROGRAM_BINARY_FORMATS is zero.
An INVALID_OPERATION error is generated if program has not been
linked successfully. In this case its program binary length is zero.
AnINVALID_VALUE error is generated if bufSize is negative.
An INVALID_OPERATION error is generated if bufSize is less than the
number of bytes in the program binary.
The command
void ProgramBinary(uint program,enum binaryFormat,
const void *binary,sizei length );
OpenGL 4.6 (Core Pro?le) - February 2, 20197.5. PROGRAMBINARIES 131
loads a program object with a program binary previously returned from GetPro-
gramBinary. This is useful to avoid online compilation, while still using OpenGL
Shading Language source shaders as a portable initial format. binaryFormat and
binary must be those returned by a previous call to GetProgramBinary, and length
must be the length of the program binary as returned by GetProgramBinary or
GetProgramiv with pnamePROGRAM_BINARY_LENGTH. Loading the program bi-
nary will fail, setting theLINK_STATUS of program toFALSE, if these conditions
are not met.
Loading a program binary may also fail if the implementation determines that
there has been a change in hardware or software con?guration from when the pro-
gram binary was produced such as having been compiled with an incompatible
or outdated version of the compiler. In this case the application should fall back
to providing the original OpenGL Shading Language source shaders, and perhaps
again retrieve the program binary for future use.
A program object’s program binary is replaced by calls to LinkProgram or
ProgramBinary. Where linking success or failure is concerned, ProgramBinary
can be considered to perform an implicit linking operation. LinkProgram and
ProgramBinary both set the program object’sLINK_STATUS toTRUE orFALSE,
as queried with GetProgramiv, to re?ect success or failure and update the infor-
mation log, queried with GetProgramInfoLog, to provide details about warnings
or errors.
A successful call to ProgramBinary will reset all uniform variables in the
default uniform block, all uniform block buffer bindings, and all shader storage
block buffer bindings to their initial values. The initial value is either the value
of the variable’s initializer as speci?ed in the original shader source, or zero if no
initializer was present.
Additionally, all vertex shader input and fragment shader output assignments
and atomic counter binding, offset and stride assignments that were in effect when
the program was linked before saving are restored when ProgramBinary is called
successfully.
If ProgramBinary fails to load a binary, no error is generated, but any infor-
mation about a previous link or load of that program object is lost. Thus, a failed
load does not restore the old state of program. The failure does not alter other
program state not affected by linking such as the attached shaders, and the vertex
attribute and fragment data location bindings as set by BindAttribLocation and
BindFragDataLocation.
OpenGL de?nes no speci?c binary formats. Queries of values NUM_-
PROGRAM_BINARY_FORMATS and PROGRAM_BINARY_FORMATS return the num-
ber of program binary formats and the list of program binary format values sup-
ported by an implementation. The binaryFormat returned by GetProgramBinary
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 132
must be present in this list.
Any program binary retrieved using GetProgramBinary and submitted using
ProgramBinary under the same con?guration must be successful. Any programs
loaded successfully by ProgramBinary must be run properly with any legal GL
state vector.
If an implementation needs to recompile or otherwise modify program exe-
cutables based on GL state outside the program, GetProgramBinary is required
to save enough information to allow such recompilation.
To indicate that a program binary is likely to be retrieved, ProgramParameteri
should be called with pname set toPROGRAM_BINARY_RETRIEVABLE_HINT and
value set to TRUE. This setting will not be in effect until the next time LinkPro-
gram or ProgramBinary has been called successfully. Additionally, the appli-
cation may defer GetProgramBinary calls until after using the program with all
non-program state vectors that it is likely to encounter. Such deferral may allow
implementations to save additional information in the program binary that would
minimize recompilation in future uses of the program binary.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_ENUM error is generated if binaryFormat is not a binary for-
mat present in the list of speci?c binary formats supported.
AnINVALID_VALUE error is generated if length is negative.
7.6 Uniform Variables
Shaders can declare named uniform variables, as described in the OpenGL Shading
Language Specification. A uniform is considered an active uniform if the compiler
and linker determine that the uniform will actually be accessed when the executable
code is executed. In cases where the compiler and linker cannot make a conclusive
determination, the uniform will be considered active.
Sets of uniforms, except for atomic counters, images, samplers, and subroutine
uniforms, can be grouped into uniform blocks.
Named uniform blocks, as described in the OpenGL Shading Language Speci-
?cation, store uniform values in the data store of a buffer object corresponding to
the uniform block. Such blocks are assigned a uniform block index.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 133
Shader Stage pname for querying default uniform
block storage, in components
Vertex (see section 11.1.2) MAX_VERTEX_UNIFORM_COMPONENTS
Tessellation control (see section 11.2.1.1) MAX_TESS_CONTROL_UNIFORM_COMPONENTS
Tessellation evaluation (see section 11.2.3.1) MAX_TESS_EVALUATION_UNIFORM_COMPONENTS
Geometry (see section 11.3.3) MAX_GEOMETRY_UNIFORM_COMPONENTS
Fragment (see section 15.1) MAX_FRAGMENT_UNIFORM_COMPONENTS
Compute (see section 19.1) MAX_COMPUTE_UNIFORM_COMPONENTS
Table 7.4: Query targets for default uniform block storage, in components.
Uniforms that are declared outside of a named uniform block are part of the
default uniform block. The default uniform block has no name or uniform block
index. Uniforms in the default uniform block, except for subroutine uniforms, are
program object-speci?c state. They retain their values once loaded, and their values
are restored whenever a program object is used, as long as the program object has
not been re-linked.
Like uniforms, uniform blocks can be active or inactive. Active uniform blocks
are those that contain active uniforms after a program has been compiled and
linked. Uniform blocks declared in an array are considered active if any member
of the array would otherwise be considered active.
All members of a named uniform block declared with a shared or std140
layout quali?er are considered active, even if they are not referenced in any shader
in the program. The uniform block itself is also considered active, even if no
member of the block is referenced.
The implementation-dependent amount of storage available for uniform vari-
ables, except for subroutine uniforms and atomic counters, in the default uniform
block accessed by a shader for a particular shader stage may be queried by calling
GetIntegerv with pname as speci?ed in table 7.4 for that stage.
The implementation-dependent constants MAX_VERTEX_UNIFORM_VECTORS
and MAX_FRAGMENT_UNIFORM_VECTORS have values respectively equal to
the values of MAX_VERTEX_UNIFORM_COMPONENTS and MAX_FRAGMENT_-
UNIFORM_COMPONENTS divided by four.
The total amount of combined storage available for uniform variables in all
uniform blocks accessed by a shader for a particular shader stage can be queried
by calling GetIntegerv with pname as speci?ed in table 7.5 for that stage.
These values represent the numbers of individual ?oating-point, integer, or
boolean values that can be held in uniform variable storage for a shader. For uni-
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 134
Shader Stage pname for querying combined uniform
block storage, in components
Vertex MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
Tessellation control MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS
Tessellation evaluation MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS
Geometry MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS
Fragment MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
Compute MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS
Table 7.5: Query targets for combined uniform block storage, in components.
forms with boolean, integer, or ?oating-point components,
 A scalar uniform will consume no more than 1 component
 A vector uniform will consume no more thann components, wheren is the
vector component count
 A matrix uniform will consume no more than 4min(r;c) components,
wherer andc are the number of rows and columns in the matrix.
Scalar, vector, and matrix uniforms with double-precision components will
consume no more than twice the number of components of equivalent uniforms
with ?oating-point components.
Errors
A link error is generated if an attempt is made to utilize more than the
space available for uniform variables in a shader stage.
When a program is linked successfully, all active uniforms, except for atomic
counters, belonging to the program object’s default uniform block are initialized
as de?ned by the version of the OpenGL Shading Language used to compile the
program. A successful link will also generate a location for each active uniform in
the default uniform block which doesn’t already have an explicit location de?ned
in the shader. The generated locations will never take the location of a uniform
with an explicit location de?ned in the shader, even if that uniform is determined
to be inactive. The values of active uniforms in the default uniform block can be
changed using this location and the appropriate Uniform* or ProgramUniform*
command (see section 7.6.1). These generated locations are invalidated and new
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 135
ones assigned after each successful re-link. The explicitly de?ned locations and the
generated locations must be in the range of zero to the value of MAX_UNIFORM_-
LOCATIONS minus one.
Similarly, when a program is linked successfully, all active atomic counters are
assigned bindings, offsets (and strides for arrays of atomic counters) according to
layout rules described in section 7.6.2.2. Atomic counter uniform buffer objects
provide the storage for atomic counters, so the values of atomic counters may be
changed by modifying the contents of the buffer object using the commands in
sections 6.2, 6.2.1, 6.3, 6.5, and 6.6. Atomic counters are not assigned a location
and may not be modi?ed using the Uniform* commands. The bindings, offsets,
and strides belonging to atomic counters of a program object are invalidated and
new ones assigned after each successful re-link.
Similarly, when a program is linked successfully, all active uniforms belong-
ing to the program’s named uniform blocks are assigned offsets (and strides for
array and matrix type uniforms) within the uniform block according to layout rules
described below. Uniform buffer objects provide the storage for named uniform
blocks, so the values of active uniforms in named uniform blocks may be changed
by modifying the contents of the buffer object. Uniforms in a named uniform
block are not assigned a location and may not be modi?ed using the Uniform*
commands. The offsets and strides of all active uniforms belonging to named uni-
form blocks of a program object are invalidated and new ones assigned after each
successful re-link.
To determine the set of active uniform variables used by a program, applica-
tions can query the properties and active resources of the UNIFORM interface of a
program.
Additionally, several dedicated commands are provided to query properties of
active uniforms. The command
int GetUniformLocation(uint program,const
char *name );
is equivalent to
GetProgramResourceLocation(program, UNIFORM, name);
The command
void GetActiveUniformName(uint program,
uint uniformIndex,sizei bufSize,sizei *length,
char *uniformName );
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 136
is equivalent to
GetProgramResourceName(program, UNIFORM, uniformIndex,
bufSize, length, uniformName);
The command
void GetUniformIndices(uint program,
sizei uniformCount,const char *const
*uniformNames,uint *uniformIndices );
is equivalent (assuming no errors are generated) to:
for (int i = 0; i < uniformCount; i++) f
uniformIndices[i] = GetProgramResourceIndex(program,
UNIFORM, uniformNames[i]);
g
The command
void GetActiveUniform(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name );
is equivalent (assuming no errors are generated) to:
const enum props[] = f ARRAY_SIZE, TYPE g;
GetProgramResourceName(program, UNIFORM, index,
bufSize, length, name);
GetProgramResourceiv(program, UNIFORM, index,
1, &props[0], 1, NULL, size);
GetProgramResourceiv(program, UNIFORM, index,
1, &props[1], 1, NULL, (int )type);
*
The command
void GetActiveUniformsiv(uint program,
sizei uniformCount,const uint *uniformIndices,
enum pname,int *params );
is equivalent (assuming no errors are generated) to:
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 137
pname prop
UNIFORM_TYPE TYPE
UNIFORM_SIZE ARRAY_SIZE
UNIFORM_NAME_LENGTH NAME_LENGTH
UNIFORM_BLOCK_INDEX BLOCK_INDEX
UNIFORM_OFFSET OFFSET
UNIFORM_ARRAY_STRIDE ARRAY_STRIDE
UNIFORM_MATRIX_STRIDE MATRIX_STRIDE
UNIFORM_IS_ROW_MAJOR IS_ROW_MAJOR
UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX ATOMIC_COUNTER_BUFFER_INDEX
Table 7.6: GetProgramResourceiv properties used by GetActiveUniformsiv.
GLenum prop;
for (int i = 0; i < uniformCount; i++) f
GetProgramResourceiv(program, UNIFORM, uniformIndices[i],
1, &prop, 1, NULL, &params[i]);
g
where the value of prop is taken from table 7.6, based on the value of pname.
To determine the set of active uniform blocks used by a program, applications
can query the properties and active resources of theUNIFORM_BLOCK interface.
Additionally, several commands are provided to query properties of active uni-
form blocks. The command
uint GetUniformBlockIndex(uint program,const
char *uniformBlockName );
is equivalent to
GetProgramResourceIndex(program, UNIFORM_BLOCK, uniformBlockName);
The command
void GetActiveUniformBlockName(uint program,
uint uniformBlockIndex,sizei bufSize,sizei length,
char *uniformBlockName );
is equivalent to
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 138
GetProgramResourceName(program, UNIFORM_BLOCK,
uniformBlockIndex, bufSize, length, uniformBlockName);
The command
void GetActiveUniformBlockiv(uint program,
uint uniformBlockIndex,enum pname,int *params );
is equivalent to
GLenum prop;
GetProgramResourceiv(program, UNIFORM_BLOCK,
uniformBlockIndex, 1, &prop, maxSize, NULL, params);
where the value of prop is taken from table 7.7, based on the value of pname,
and maxSize is taken to specify a suf?ciently large buffer to receive all values that
would be written to params.
To determine the set of active atomic counter buffer binding points used
by a program, applications can query the properties and active resources of the
ATOMIC_COUNTER_BUFFER interface of a program.
Additionally, the command
void GetActiveAtomicCounterBufferiv(uint program,
uint bufferIndex,enum pname,int *params );
can be used to determine properties of active atomic counter buffer bindings used
by program and is equivalent to
GLenum prop;
GetProgramResourceiv(program, ATOMIC_COUNTER_BUFFER,
buerIndex, 1, &prop, maxSize, NULL, params);
where the value of prop is taken from table 7.8, based on the value of pname,
and maxSize is taken to specify a suf?ciently large buffer to receive all values that
would be written to params.
7.6.1 Loading Uniform Variables In The Default Uniform Block
To load values into the uniform variables except for subroutine uniforms and
atomic counters, of the default uniform block of the active program object, use
the commands
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 139
pname prop
UNIFORM_BLOCK_BINDING BUFFER_BINDING
UNIFORM_BLOCK_DATA_SIZE BUFFER_DATA_SIZE
UNIFORM_BLOCK_NAME_LENGTH NAME_LENGTH
UNIFORM_BLOCK_ACTIVE_UNIFORMS NUM_ACTIVE_VARIABLES
UNIFORM_BLOCK_ACTIVE_UNIFORM_- ACTIVE_VARIABLES
INDICES
UNIFORM_BLOCK_REFERENCED_BY_- REFERENCED_BY_VERTEX_SHADER
VERTEX_SHADER
UNIFORM_BLOCK_REFERENCED_BY_- REFERENCED_BY_TESS_CONTROL_-
TESS_CONTROL_SHADER SHADER
UNIFORM_BLOCK_REFERENCED_BY_- REFERENCED_BY_TESS_-
TESS_EVALUATION_SHADER EVALUATION_SHADER
UNIFORM_BLOCK_REFERENCED_BY_- REFERENCED_BY_GEOMETRY_SHADER
GEOMETRY_SHADER
UNIFORM_BLOCK_REFERENCED_BY_- REFERENCED_BY_FRAGMENT_SHADER
FRAGMENT_SHADER
UNIFORM_BLOCK_REFERENCED_BY_- REFERENCED_BY_COMPUTE_SHADER
COMPUTE_SHADER
Table 7.7: GetProgramResourceiv properties used by GetActiveUniform-
Blockiv.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 140
pname prop
ATOMIC_COUNTER_BUFFER_BINDING BUFFER_BINDING
ATOMIC_COUNTER_BUFFER_DATA_- BUFFER_DATA_SIZE
SIZE
ATOMIC_COUNTER_BUFFER_ACTIVE_- NUM_ACTIVE_VARIABLES
ATOMIC_COUNTERS
ATOMIC_COUNTER_BUFFER_ACTIVE_- ACTIVE_VARIABLES
ATOMIC_COUNTER_INDICES
ATOMIC_COUNTER_BUFFER_- REFERENCED_BY_VERTEX_SHADER
REFERENCED_BY_VERTEX_SHADER
ATOMIC_COUNTER_BUFFER_- REFERENCED_BY_TESS_CONTROL_-
REFERENCED_BY_TESS_CONTROL_- SHADER
SHADER
ATOMIC_COUNTER_BUFFER_- REFERENCED_BY_TESS_-
REFERENCED_BY_TESS_- EVALUATION_SHADER
EVALUATION_SHADER
ATOMIC_COUNTER_BUFFER_- REFERENCED_BY_GEOMETRY_SHADER
REFERENCED_BY_GEOMETRY_SHADER
ATOMIC_COUNTER_BUFFER_- REFERENCED_BY_FRAGMENT_SHADER
REFERENCED_BY_FRAGMENT_SHADER
ATOMIC_COUNTER_BUFFER_- REFERENCED_BY_COMPUTE_SHADER
REFERENCED_BY_COMPUTE_SHADER
Table 7.8: GetProgramResourceiv properties used by GetActiveAtomicCoun-
terBufferiv.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 141
void Uniformf1234gfifd uig(int location,T value );
void Uniformf1234gfifd uigv(int location,sizei count,
const T *value );
void UniformMatrixf234gffdgv(int location,sizei count,
boolean transpose,const float *value );
void UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gffdgv(
int location,sizei count,boolean transpose,const
float *value );
If a non-zero program object is bound by UseProgram, it is the active pro-
gram object whose uniforms are updated by these commands. If no program ob-
ject is bound using UseProgram, the active program object of the current program
pipeline object set by ActiveShaderProgram is the active program object. If the
current program pipeline object has no active program or there is no current pro-
gram pipeline object, then there is no active program.
The given values are loaded into the default uniform block uniform variable
location identi?ed by location and associated with a uniform variable.
The Uniform*ffvg commands will load count sets of one to four ?oating-point
values into a uniform de?ned as a ?oat, a ?oating-point vector, or an array of either
of these types.
The Uniform*dfvg commands will load count sets of one to four double-
precision ?oating-point values into a uniform de?ned as a double, a double vector,
or an array of either of these types.
The Uniform*ifvg commands will load count sets of one to four integer values
into a uniform de?ned as a sampler, an image, an integer, an integer vector, or an
array of any of these types. Only the Uniform1ifvg commands can be used to load
sampler and image values (see sections 7.11 and 7.12).
The Uniform*uifvg commands will load count sets of one to four unsigned
integer values into a uniform de?ned as a unsigned integer, an unsigned integer
vector, or an array of either of these types.
The UniformMatrixf234gfv and UniformMatrixf234gdv commands will
load count 2 2, 3 3, or 4 4 matrices (corresponding to 2, 3, or 4 in the
command name) of single- or double-precision ?oating-point values, respectively,
into a uniform de?ned as a matrix or an array of matrices. If transpose is FALSE,
the matrix is speci?ed in column major order, otherwise in row major order.
The UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gfv and UniformMa-
trixf2x3,3x2,2x4,4x2,3x4,4x3gdv commands will load count 2 3, 3 2, 2 4,
4 2, 3 4, or 4 3 matrices (corresponding to the numbers in the command
name) of single- or double-precision ?oating-point values, respectively, into a
uniform de?ned as a matrix or an array of matrices. The ?rst number in the
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 142
command name is the number of columns; the second is the number of rows.
For example, UniformMatrix2x4fv is used to load a single-precision matrix
consisting of two columns and four rows. If transpose is FALSE, the matrix is
speci?ed in column major order, otherwise in row major order.
When loading values for a uniform declared as a boolean, a boolean vector,
or an array of either of these types, any of the Uniform*ifvg, Uniform*uifvg,
and Uniform*ffvg commands can be used. Type conversion is done by the GL.
Boolean values are set to FALSE if the corresponding input value is 0 or 0.0f, and
set to TRUE otherwise. The Uniform* command used must match the size of the
uniform, as declared in the shader. For example, to load a uniform declared as a
bvec2, any of the Uniform2fif uig* commands may be used.
For all other uniform types loadable with Uniform* commands, the command
used must match the size and type of the uniform, as declared in the shader, and
no type conversions are done. For example, to load a uniform declared as avec4,
Uniform4ffvg must be used, and to load a uniform declared as admat3, Unifor-
mMatrix3dv must be used.
When loadingN elements starting at an arbitrary positionk in a uniform de-
clared as an array, elements k through k +N  1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
element index used, as reported by GetActiveUniform, will be ignored by the GL.
If the value of location is -1, the Uniform* commands will silently ignore the
data passed in, and the current uniform values will not be changed.
Errors
AnINVALID_VALUE error is generated if count is negative.
An INVALID_VALUE error is generated if Uniform1ifvg is used to set a
sampler uniform to a value less than zero or greater than or equal to the value
ofMAX_COMBINED_TEXTURE_IMAGE_UNITS.
AnINVALID_VALUE error is generated if Uniform1ifvg is used to set an
image uniform to a value less than zero or greater than or equal to the value of
MAX_IMAGE_UNITS.
AnINVALID_OPERATION error is generated if any of the following con-
ditions occur:
 the size indicated in the name of the Uniform* command used does not
match the size of the uniform declared in the shader,
 the component type and count indicated in the name of the Uniform*
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 143
command used does not match the type of the uniform declared in
the shader, where a boolean uniform component type is considered
to match any of the Uniform*ifvg, Uniform*uifvg, or Uniform*ffvg
commands.
 count is greater than one, and the uniform declared in the shader is not
an array variable,
 no variable with a location of location exists in the program object cur-
rently in use and location is not -1, or
 a sampler or image uniform is loaded with any of the Uniform* com-
mands other than Uniform1ifvg.
 there is no active program object in use.
To load values into the uniform variables of the default uniform block of a
program which may not necessarily be bound, use the commands
void ProgramUniformf1234gfifdg(uint program,
int location,T value );
void ProgramUniformf1234gfifdgv(uint program,
int location,sizei count,const T *value );
void ProgramUniformf1234gui(uint program,int location,
T value );
void ProgramUniformf1234guiv(uint program,
int location,sizei count,const T *value );
void ProgramUniformMatrixf234gffdgv(uint program,
int location,sizei count,boolean transpose,const
T *value );
void ProgramUniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gffdgv(
uint program,int location,sizei count,
boolean transpose,const T *value );
These commands operate identically to the corresponding commands above
without Program in the command name except, rather than updating the cur-
rently active program object, these Program commands update the program ob-
ject named by the initial program parameter. The remaining parameters following
the initial program parameter match the parameters for the corresponding non-
Program uniform command.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 144
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_OPERATION error is generated if program has not been
linked successfully.
In addition, all errors described for the corresponding Uniform* com-
mands apply.
7.6.2 Uniform Blocks
The values of uniforms arranged in named uniform blocks are extracted from buffer
object storage. The mechanisms for placing individual uniforms in a buffer object
and connecting a uniform block to an individual buffer object are described below.
If the number of active uniform blocks referenced by the shaders in a pro-
gram exceeds implementation-dependent limits, the program will fail to link. The
limits for vertex, tessellation control, tessellation evaluation, geometry, fragment,
and compute shaders can be obtained by calling GetIntegerv with pname values
of MAX_VERTEX_UNIFORM_BLOCKS, MAX_TESS_CONTROL_UNIFORM_BLOCKS,
MAX_TESS_EVALUATION_UNIFORM_BLOCKS, MAX_-
GEOMETRY_UNIFORM_BLOCKS,MAX_FRAGMENT_UNIFORM_BLOCKS, andMAX_-
COMPUTE_UNIFORM_BLOCKS, respectively.
Additionally, a program will fail to link if the sum of the number of active
uniform blocks referenced by each shader stage in a program exceeds the value of
the implementation-dependent limitMAX_COMBINED_UNIFORM_BLOCKS. If a uni-
form block is referenced by multiple shaders, each such reference counts separately
against this combined limit.
Finally, the total amount of buffer object storage available for any given uni-
form block is subject to an implementation-dependent limit. The maximum amount
of available space, in basic machine units, can be queried by calling GetIntegerv
with a pname of MAX_UNIFORM_BLOCK_SIZE. If the amount of storage required
for a uniform block exceeds this limit, a program will fail to link.
When a named uniform block is declared by multiple shaders in a program, it
must be declared identically in each shader. The uniforms within the block must
be declared with the same names, types and layout quali?ers, and in the same
order. If a program contains multiple shaders with different declarations for the
same named uniform block, the program will fail to link.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 145
7.6.2.1 Uniform Buffer Object Storage
When stored in buffer objects associated with uniform blocks, uniforms are repre-
sented in memory as follows:
 Members of type bool, int, uint, float, and double are respectively
extracted from a buffer object by reading a singleuint,int,uint,float,
ordouble value at the speci?ed offset.
 Vectors withN elements with basic data types ofbool,int,uint,float,
or double are extracted asN values in consecutive memory locations be-
ginning at the speci?ed offset, with components stored in order with the ?rst
(X) component at the lowest offset. The GL data type used for component
extraction is derived according to the rules for scalar members above.
 Column-major matrices with C columns and R rows (using the types
dmatCxR andmatCxR for double-precision and ?oating-point components
respectively, or simplydmatC andmatC respectively ifC =R) are treated
as an array ofC column vectors, each consisting ofR double-precision or
?oating-point components. The column vectors will be stored in order, with
column zero at the lowest offset. The difference in offsets between consecu-
tive columns of the matrix will be referred to as the column stride, and is con-
stant across the matrix. The column stride is an implementation-dependent
function of the matrix type, and may be determined after a program is linked
by querying the MATRIX_STRIDE property using GetProgramResourceiv
(see section 7.3.1).
 Row-major matrices withC columns andR rows (using the typesdmatCxR
and matCxR for double-precision and ?oating-point components respec-
tively, or simply dmatC and matC respectively if C = R) are treated as
an array ofR row vectors, each consisting ofC double-precision or ?oating-
point components. The row vectors will be stored in order, with row zero at
the lowest offset. The difference in offsets between consecutive rows of the
matrix will be referred to as the row stride, and is constant across the matrix.
The row stride is an implementation-dependent function of the matrix type,
and may be determined after a program is linked by querying theMATRIX_-
STRIDE property using GetProgramResourceiv (see section 7.3.1).
 Arrays of scalars, vectors, and matrices are stored in memory by element
order, with array member zero at the lowest offset. The difference in offsets
between each pair of elements in the array in basic machine units is referred
to as the array stride, and is constant across the entire array. The array stride
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 146
(the value of UNIFORM_ARRAY_STRIDE) is an implementation-dependent
value and may be queried after a program is linked.
7.6.2.2 Standard Uniform Block Layout
By default, uniforms contained within a uniform block are extracted from buffer
storage in an implementation-dependent manner. Applications may query the off-
sets assigned to uniforms inside uniform blocks with query functions provided by
the GL.
The layout quali?er provides shaders with control of the layout of uniforms
within a uniform block. When the std140 layout is speci?ed, the offset of each
uniform in a uniform block can be derived from the de?nition of the uniform block
by applying the set of rules described below.
When using the std140 storage layout, structures will be laid out in buffer
storage with their members stored in monotonically increasing order based on their
location in the declaration. A structure and each structure member have a base
offset and a base alignment, from which an aligned offset is computed by rounding
the base offset up to a multiple of the base alignment. The base offset of the ?rst
member of a structure is taken from the aligned offset of the structure itself. The
base offset of all other structure members is derived by taking the offset of the
last basic machine unit consumed by the previous member and adding one. Each
structure member is stored in memory at its aligned offset. The members of a top-
level uniform block are laid out in buffer storage by treating the uniform block as
a structure with a base offset of zero.
1. If the member is a scalar consumingN basic machine units, the base align-
ment isN.
2. If the member is a two- or four-component vector with components consum-
ingN basic machine units, the base alignment is 2N or 4N, respectively.
3. If the member is a three-component vector with components consumingN
basic machine units, the base alignment is 4N.
4. If the member is an array of scalars or vectors, the base alignment and array
stride are set to match the base alignment of a single array element, according
to rules (1), (2), and (3), and rounded up to the base alignment of avec4. The
array may have padding at the end; the base offset of the member following
the array is rounded up to the next multiple of the base alignment.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 147
5. If the member is a column-major matrix with C columns and R rows, the
matrix is stored identically to an array ofC column vectors withR compo-
nents each, according to rule (4).
6. If the member is an array ofS column-major matrices withC columns and
R rows, the matrix is stored identically to a row ofSC column vectors
withR components each, according to rule (4).
7. If the member is a row-major matrix withC columns andR rows, the matrix
is stored identically to an array ofR row vectors withC components each,
according to rule (4).
8. If the member is an array ofS row-major matrices withC columns andR
rows, the matrix is stored identically to a row ofSR row vectors withC
components each, according to rule (4).
9. If the member is a structure, the base alignment of the structure isN, where
N is the largest base alignment value of any of its members, and rounded
up to the base alignment of a vec4. The individual members of this sub-
structure are then assigned offsets by applying this set of rules recursively,
where the base offset of the ?rst member of the sub-structure is equal to the
aligned offset of the structure. The structure may have padding at the end;
the base offset of the member following the sub-structure is rounded up to
the next multiple of the base alignment of the structure.
10. If the member is an array ofS structures, theS elements of the array are laid
out in order, according to rule (9).
Shader storage blocks (see section 7.8) also support thestd140layout qual-
i?er, as well as astd430 quali?er not supported for uniform blocks. When using
thestd430 storage layout, shader storage blocks will be laid out in buffer storage
identically to uniform and shader storage blocks using the std140 layout, except
that the base alignment and stride of arrays of scalars and vectors in rule 4 and of
structures in rule 9 are not rounded up a multiple of the base alignment of avec4.
7.6.2.3 SPIR-V Uniform Offsets and Strides
The SPIR-V decorationsGLSLShared orGLSLPacked must not be used. A vari-
able in theUniform Storage Class decorated as aBlock orBufferBlock must
be explicitly laid out using theOffset,ArrayStride, andMatrixStride dec-
orations. These must follow the alignment rules listed above, but not necessarily
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 148
the packing rules. More speci?cally, explicit SPIR-V offsets and strides must obey
the following:
De?ne the base alignment recursively as:
 A scalar of sizeN has a base alignment ofN.
 A two-component vector, with components of sizeN, has a base alignment
of 2N.
 A three- or four-component vector, with components of sizeN, has a base
alignment of 4N.
 An array has a base alignment equal to the base alignment of its element
type, rounded up to a multiple of 16.
 A structure has a base alignment equal to the largest base alignment of any
of its members, rounded up to a multiple of 16.
 A row-major matrix of C columns has a base alignment equal to the base
alignment of a vector ofC matrix components.
 A column-major matrix has a base alignment equal to the base alignment of
the matrix column type.
Given this de?nition, blocks must be laid out such that:
 TheOffset decoration must be a multiple of its base alignment.
 Any ArrayStride or MatrixStride decoration must be an integer mul-
tiple of the base alignment of the array or matrix.
 The Offset decoration of a member must not place it between the end of
a structure or an array and the next multiple of the base alignment of that
structure or array.
 The numeric order ofOffset decorations need not follow member declara-
tion order.
With one exception: variables in theUniform storage class with a decoration
of BufferBlock do not need their base alignments rounded up to a multiple of
16.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.6. UNIFORMVARIABLES 149
7.6.3 Uniform Buffer Object Bindings
The value of an active uniform inside a named uniform block is extracted from the
data store of a buffer object bound to one of an array of uniform buffer binding
points. The number of binding points may be queried using GetIntegerv with the
constantMAX_UNIFORM_BUFFER_BINDINGS.
Regions of buffer objects are bound as storage for uniform blocks by calling
BindBuffer* commands (see section 6) with target set toUNIFORM_BUFFER.
Each of a program’s active uniform blocks has a corresponding uniform buffer
object binding point. The binding is established when a program is linked or re-
linked, and the initial value of the binding is speci?ed by a layout quali?er (if
present), or zero otherwise. The binding point can be assigned by calling
void UniformBlockBinding(uint program,
uint uniformBlockIndex,uint uniformBlockBinding );
program is a name of a program object for which the command LinkProgram has
been issued in the past.
If successful, UniformBlockBinding speci?es that program will use the data
store of the buffer object bound to the binding point uniformBlockBinding to extract
the values of the uniforms in the uniform block identi?ed by uniformBlockIndex.
When executing shaders that access uniform blocks, the binding point corre-
sponding to each active uniform block must be populated with a buffer object with
a size no smaller than the minimum required size of the uniform block (the value
ofUNIFORM_BLOCK_DATA_SIZE). For binding points populated by BindBuffer-
Range, the size in question is the value of the size parameter. If any active uniform
block is not backed by a suf?ciently large buffer object, the results of shader ex-
ecution may be unde?ned or modi?ed, as described in section 6.4. Shaders may
be executed to process the primitives and vertices speci?ed by any command that
transfers vertices to the GL.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_VALUE error is generated if uniformBlockIndex is not an
active uniform block index of program, or if uniformBlockBinding is greater
than or equal to the value ofMAX_UNIFORM_BUFFER_BINDINGS.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.7. ATOMICCOUNTERBUFFERS 150
7.7 Atomic Counter Buffers
The values of atomic counters are backed by buffer object storage. The mecha-
nisms for accessing individual atomic counters in a buffer object and connecting to
an atomic counter are described in this section.
There is a set of implementation-dependent maximums for the number of active
atomic counter buffers referenced by each shader. If the number of atomic counter
buffer bindings referenced by any shader in the program exceeds the corresponding
limit, the program will fail to link. The limits for vertex, tessellation control, tes-
sellation evaluation, geometry, fragment, and compute shaders can be obtained by
calling GetIntegerv with pname values of MAX_VERTEX_ATOMIC_COUNTER_-
BUFFERS, MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS, MAX_-
TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS, MAX_GEOMETRY_ATOMIC_-
COUNTER_BUFFERS,MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS, andMAX_-
COMPUTE_ATOMIC_COUNTER_BUFFERS, respectively.
Additionally, there is an implementation-dependent limit on the sum of the
number of active atomic counter buffers used by each shader stage of a program.
If an atomic counter buffer is used by multiple shader stages, each such use counts
separately against this combined limit. The combined atomic counter buffer use
limit can be obtained by calling GetIntegerv with a pname ofMAX_COMBINED_-
ATOMIC_COUNTER_BUFFERS.
7.7.1 Atomic Counter Buffer Object Storage
Atomic counters stored in buffer objects are represented in memory as follows:
 Members of typeatomic_uint are extracted from a buffer object by read-
ing a singleuint-typed value at the speci?ed offset.
 Arrays of type atomic_uint are stored in memory by element order, with
array element member zero at the lowest offset. The difference in offsets
between each pair of elements in the array in basic machine units is referred
to as the array stride, and is constant across the entire array. The array stride,
(the value of UNIFORM_ARRAY_STRIDE) is always 4, and may be queried
after a program is linked.
7.7.2 Atomic Counter Buffer Bindings
The value of an active atomic counter is extracted from or written to the data store
of a buffer object bound to one of an array of atomic counter buffer binding points.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.8. SHADERBUFFERVARIABLESANDSHADERSTORAGEBLOCKS151
The number of binding points may be queried by calling GetIntegerv with a pname
ofMAX_ATOMIC_COUNTER_BUFFER_BINDINGS.
Regions of buffer objects are bound as storage for atomic counters by calling
one of the BindBuffer* commands (see section 6) with target set to ATOMIC_-
COUNTER_BUFFER.
Each of a program’s active atomic counter buffer bindings has a corresponding
atomic counter buffer binding point. This binding point is established with the
layout quali?er in the shader text, either explicitly or implicitly, as described in
the OpenGL Shading Language Specification.
When executing shaders that access atomic counters, each active atomic
counter buffer must be populated with a buffer object with a size no smaller than the
minimum required size for that buffer (the value ofBUFFER_DATA_SIZE returned
by GetProgramResourceiv). For binding points populated by BindBufferRange,
the size in question is the value of the size parameter. If any active atomic counter
buffer is not backed by a suf?ciently large buffer object, the results of shader exe-
cution may be unde?ned or modi?ed, as described in section 6.4.
7.8 Shader Buffer Variables and Shader Storage Blocks
Shaders can declare named buffer variables, as described in the OpenGL Shading
Language Specification. Sets of buffer variables are grouped into interface blocks
called shader storage blocks. The values of each buffer variable in a shader storage
block are read from or written to the data store of a buffer object bound to the
binding point associated with the block. Buffer variables are considered active
in the same way as uniform variables (see section 7.6). The values of active
buffer variables may be changed by executing shaders that assign values to them
or perform atomic memory operations on them; by modifying the contents of the
bound buffer object’s data store with the commands in sections 6.2, 6.2.1, 6.3, 6.5,
and 6.6; by binding a new buffer object to the binding point associated with the
block; or by changing the binding point associated with the block.
Like buffer variables, shader storage blocks can be active or inactive. Whether
a shader storage block is active or inactive is determined in the same way as for
uniform blocks (see section 7.6). Additionally though, all members of a named
shader storage block declared with astd430 layout quali?er are considered active,
even if they are not referenced in any shader in the program.
Buffer variables in shader storage blocks are represented in memory in the
same way as uniforms stored in uniform blocks, as described in section 7.6.2.1.
When a program is linked successfully, each active buffer variable is assigned an
offset relative to the base of the buffer object binding associated with its shader
OpenGL 4.6 (Core Pro?le) - February 2, 20197.8. SHADERBUFFERVARIABLESANDSHADERSTORAGEBLOCKS 152
storage block. For buffer variables declared as arrays and matrices, strides between
array elements or matrix columns or rows will also be assigned. Offsets and strides
of buffer variables will be assigned in an implementation-dependent manner unless
the shader storage block is declared using thestd140 orstd430 storagelayout
quali?ers. Forstd140 andstd430 shader storage blocks, offsets will be assigned
using the method described in section 7.6.2.2. If a program is re-linked, existing
buffer variable offsets and strides are invalidated, and a new set of active variables,
offsets, and strides will be generated.
The total amount of buffer object storage that can be accessed in any shader
storage block is subject to an implementation-dependent limit. The maximum
amount of available space, in basic machine units, may be queried by calling
GetIntegerv with pname MAX_SHADER_STORAGE_BLOCK_SIZE. If the amount
of storage required for any shader storage block exceeds this limit, a program will
fail to link.
If the number of active shader storage blocks referenced by the
shaders in a program exceeds implementation-dependent limits, the pro-
gram will fail to link. The limits for vertex, tessellation control, tes-
sellation evaluation, geometry, fragment, and compute shaders can be ob-
tained by calling GetIntegerv with pname values of MAX_VERTEX_SHADER_-
STORAGE_BLOCKS, MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS, MAX_-
TESS_EVALUATION_SHADER_STORAGE_BLOCKS, MAX_GEOMETRY_SHADER_-
STORAGE_BLOCKS, MAX_FRAGMENT_SHADER_STORAGE_BLOCKS, and MAX_-
COMPUTE_SHADER_STORAGE_BLOCKS, respectively.
Additionally, a program will fail to link if the sum of the number of ac-
tive shader storage blocks referenced by each shader stage in a program exceeds
the value of the implementation-dependent limit MAX_COMBINED_SHADER_-
STORAGE_BLOCKS. If a shader storage block in a program is referenced by multiple
shaders, each such reference counts separately against this combined limit.
When a named shader storage block is declared by multiple shaders in a pro-
gram, it must be declared identically in each shader. The buffer variables within
the block must be declared with the same names, types, quali?cation, and decla-
ration order. If a program contains multiple shaders with different declarations for
the same named shader storage block, the program will fail to link.
Regions of buffer objects are bound as storage for shader storage blocks by
calling one of the BindBuffer* commands (see section 6) with target SHADER_-
STORAGE_BUFFER.
Each of a program’s active shader storage blocks has a corresponding shader
storage buffer object binding point. When a program object is linked, the shader
storage buffer object binding point assigned to each of its active shader storage
blocks is reset to the value speci?ed by the correspondingbindinglayout qual-
OpenGL 4.6 (Core Pro?le) - February 2, 20197.9. INVOCATIONGROUPS 153
i?er, if present, or zero otherwise. After a program is linked, the command
void ShaderStorageBlockBinding(uint program,
uint storageBlockIndex,uint storageBlockBinding );
changes the active shader storage block with an assigned index of storage-
BlockIndex in program object program. ShaderStorageBlockBinding speci?es
that program will use the data store of the buffer object bound to the binding point
storageBlockBinding to read and write the values of the buffer variables in the
shader storage block identi?ed by storageBlockIndex.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_VALUE error is generated if storageBlockIndex is not an
active shader storage block index in program, or if storageBlockBinding is
greater than or equal to the value of MAX_SHADER_STORAGE_BUFFER_-
BINDINGS.
When executing shaders that access shader storage blocks, the binding point
corresponding to each active shader storage block must be populated with a buffer
object with a size no smaller than the minimum required size of the shader storage
block (the value ofBUFFER_SIZE for the appropriateSHADER_STORAGE_BUFFER
resource). For binding points populated by BindBufferRange, the size in question
is the value of the size parameter or the size of the buffer minus the value of the
offset parameter, whichever is smaller. If any active shader storage block is not
backed by a suf?ciently large buffer object, the results of shader execution may be
unde?ned or modi?ed, as described in section 6.4.
7.9 Invocation Groups
An invocation group (see section 8.18(“Shader Invocation Group Functions”) of
the OpenGL Shading Language Specification) for a compute shader is the set of
invocations in a single workgroup. For graphics shaders, an invocation group is
1
an implementation-dependent subset of the set of shader invocations of a given
1
Because the partitioning of invocations into invocation groups is implementation-dependent
and not observable, applications generally need to assume the worst case of all invocations in a draw
belong to a single invocation group.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.10. SUBROUTINEUNIFORMVARIABLES 154
shader stage which are produced by a single drawing command. For MultiDraw*
commands with drawcount greater than one, invocations from separate draws are
in distinct invocation groups.
7.10 Subroutine Uniform Variables
Subroutine uniform variables are similar to uniform variables, except they are con-
text state rather than program state, and apply only to a single program stage. Hav-
ing subroutine uniforms be context state allows them to have different values if the
program is used in multiple contexts simultaneously. There is a set of subroutine
uniforms for each shader stage.
A subroutine uniform may have an explicit location speci?ed in the shader.
At link time, all active subroutine uniforms without an explicit location will be
assigned a unique location. The value of ACTIVE_SUBROUTINE_UNIFORM_-
LOCATIONS for a program object is the largest speci?ed or assigned location plus
one. An assigned location will never take the location of an explicitly speci?ed
location, even if that subroutine uniform is inactive. Between the location zero and
the value ofACTIVE_SUBROUTINE_UNIFORM_LOCATIONS minus one there may
be unused locations, either because they were not assigned a subroutine uniform or
because the subroutine uniform was determined to be inactive by the linker. These
locations will be ignored when assigning the subroutine index as described below.
There is an implementation-dependent limit on the number of active subrou-
tine uniform locations in each shader stage; a program will fail to link if the num-
ber of subroutine uniform locations required is greater than the value of MAX_-
SUBROUTINE_UNIFORM_LOCATIONS or if an explicit subroutine uniform location
is outside this limit. For active subroutine uniforms declared as arrays, the declared
array elements are assigned consecutive locations.
Each function in a shader associated with a subroutine type is considered an
active subroutine, unless the compiler conclusively determines that the function
could never be assigned to an active subroutine uniform. The subroutine func-
tions can be assigned an explicit index in the shader between zero and the value
of MAX_SUBROUTINES minus one. At link time, all active subroutines without an
explicit index will be assigned an index between zero and the value ofACTIVE_-
SUBROUTINES minus one. An assigned index will never take the same index of
an explicitly speci?ed index in the shader, even if that subroutine is inactive. Be-
tween index zero and the vaue of ACTIVE_SUBROUTINES minus one there may
be unused indices either because they weren’t assigned an index by the linker or
because the subroutine was determined to be inactive by the linker. If there are no
explicitly de?ned subroutine indices in the shader the implementation must assign
OpenGL 4.6 (Core Pro?le) - February 2, 20197.10. SUBROUTINEUNIFORMVARIABLES 155
Interface Shader Type
VERTEX_SUBROUTINE VERTEX_SHADER
TESS_CONTROL_SUBROUTINE TESS_CONTROL_SHADER
TESS_EVALUATION_SUBROUTINE TESS_EVALUATION_SHADER
GEOMETRY_SUBROUTINE GEOMETRY_SHADER
FRAGMENT_SUBROUTINE FRAGMENT_SHADER
COMPUTE_SUBROUTINE COMPUTE_SHADER
Table 7.9: Interfaces for active subroutines for a particular shader type in a pro-
gram.
Interface Shader Type
VERTEX_SUBROUTINE_UNIFORM VERTEX_SHADER
TESS_CONTROL_SUBROUTINE_UNIFORM TESS_CONTROL_SHADER
TESS_EVALUATION_SUBROUTINE_UNIFORM TESS_EVALUATION_SHADER
GEOMETRY_SUBROUTINE_UNIFORM GEOMETRY_SHADER
FRAGMENT_SUBROUTINE_UNIFORM FRAGMENT_SHADER
COMPUTE_SUBROUTINE_UNIFORM COMPUTE_SHADER
Table 7.10: Interfaces for active subroutine uniforms for a particular shader type in
a program.
indices between zero and the value ofACTIVE_SUBROUTINES minus one with no
index unused. It is recommended, but not required, that the application assigns a
range of tightly packed indices starting from zero to avoid indices between zero
and the value ofACTIVE_SUBROUTINES minus one being unused.
To determine the set of active subroutines and subroutines used by a partic-
ular shader stage of a program, applications can query the properties and active
resources of the interfaces for the shader type, as listed in tables 7.9 and 7.10.
Additionally, dedicated commands are provided to determine properties of ac-
tive subroutines and active subroutine uniforms. The commands
uint GetSubroutineIndex(uint program,enum shadertype,
const char *name );
void GetActiveSubroutineName(uint program,
enum shadertype,uint index,sizei bufSize,
sizei *length,char *name );
are equivalent to
OpenGL 4.6 (Core Pro?le) - February 2, 20197.10. SUBROUTINEUNIFORMVARIABLES 156
GetProgramResourceIndex(program, programInterface, name);
and
GetProgramResourceName(program, programInterface,
index, bufSize, length, name);
respectively, where programInterface is taken from table 7.9 according to the value
of shadertype.
The commands
int GetSubroutineUniformLocation(uint program,
enum shadertype,const char *name );
void GetActiveSubroutineUniformName(uint program,
enum shadertype,uint index,sizei bufSize,
sizei *length,char *name );
void GetActiveSubroutineUniformiv(uint program,
enum shadertype,uint index,enum pname,int *values );
are equivalent to
GetProgramResourceLocation(program, programInterface, name);
GetProgramResourceName(program, programInterface,
index, bufSize, length, name);
and
GetProgramResourceiv(program, programInterface,
index, 1, &pname, maxSize, NULL, values);
respectively, where programInterface is taken from table 7.10 according to the
value of shadertype. For GetActiveSubroutineUniformiv, pname must be one of
NUM_COMPATIBLE_SUBROUTINES orCOMPATIBLE_SUBROUTINES, and maxSize
is taken to specify a suf?ciently large buffer to receive all values that would be
written to params.
The command
void UniformSubroutinesuiv(enum shadertype,sizei count,
const uint *indices );
will load all active subroutine uniforms for shader stage shadertype with subrou-
tine indices from indices, storing indices[i] into the uniform at location i. The
indices for any locations between zero and the value ofACTIVE_SUBROUTINE_-
UNIFORM_LOCATIONS minus one which are not used will be ignored.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.11. SAMPLERS 157
Errors
AnINVALID_ENUM error is generated if shadertype is not one of the val-
ues in table 7.1.
AnINVALID_VALUE error is generated if count is negative, is not equal to
the value of ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the program
currently in use at shader stage shadertype, or if the uniform at location i
is used and the value in indices[i] is greater than or equal to the value of
ACTIVE_SUBROUTINES for the shader stage.
AnINVALID_VALUE error is generated if the value of indices[i] for a used
uniform location speci?es an unused subroutine index.
An INVALID_OPERATION error is generated if, for any subroutine index
being loaded to a particular uniform location, the function corresponding to the
subroutine index was not associated (as de?ned in section 6.1.2 of the OpenGL
Shading Language Specification) with the type of the subroutine variable at
that location.
An INVALID_OPERATION error is generated if no program is active for
the shader stage identi?ed by shadertype.
Each subroutine uniform must have at least one subroutine to assign to the uni-
form. A program will fail to link if any stage has one or more subroutine uniforms
that has no subroutine associated with the subroutine type of the uniform.
When the active program for a shader stage is re-linked or changed by a call
to UseProgram, BindProgramPipeline, or UseProgramStages, subroutine uni-
forms for that stage are reset to arbitrarily chosen default functions with compatible
subroutine types.
7.11 Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates
the texture image unit being accessed. Setting a sampler’s value toi selects texture
image unit numberi. The value ofi may range from zero to the implementation-
dependent maximum supported number of texture image units minus one.
The type of the sampler identi?es the target on the texture image unit, as shown
in table 7.3 for sampler types. The texture object bound to that texture image
*
unit’s target is then used for the texture lookup. For example, a variable of type
sampler2D selects targetTEXTURE_2D on its texture image unit. Binding of tex-
ture objects to targets is done as usual with BindTexture. Selecting the texture
image unit to bind to is done as usual with ActiveTexture.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.12. IMAGES 158
The location of a sampler is queried with GetUniformLocation, just like any
uniform variable. Sampler values must be set by calling Uniform1ifvg.
Errors
It is not allowed to have variables of different sampler types pointing to
the same texture image unit within a program object. This situation can only
be detected at the next rendering command issued which triggers shader invo-
cations, and anINVALID_OPERATION error will then be generated.
Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)
contained in the program object exceed the maximum allowable limits. If it deter-
mines that the count of active samplers exceeds the allowable limits, then the link
fails (these limits can be different for different types of shaders). Each active sam-
pler variable counts against the limit, even if multiple samplers refer to the same
texture image unit.
7.12 Images
Images are special uniforms used in the OpenGL Shading Language to identify a
level of a texture to be read or written using built-in image load, store, or atomic
functions in the manner described in section 8.26. The value of an image uniform is
an integer specifying the image unit accessed. Image units are numbered beginning
at zero, and there is an implementation-dependent number of available image units
(the value ofMAX_IMAGE_UNITS).
Note that image units used for image variables are independent of the texture
image units used for sampler variables; the number of units provided by the imple-
mentation may differ. Textures are bound independently and separately to image
and texture image units.
The type of an image variable must match the texture target of the image cur-
rently bound to the image unit; otherwise the result of a load, store, or atomic
operation is unde?ned (see section 4.1.7.2 of the OpenGL Shading Language Spec-
i?cation for more details).
The location of an image variable needs to be queried with GetUniformLo-
cation, just like any uniform variable. Image values must be set by calling Uni-
form1ifvg.
Unlike samplers, there is no limit on the number of active image variables that
may be used by a program or by any particular shader. However, given that there
OpenGL 4.6 (Core Pro?le) - February 2, 20197.13. SHADERMEMORYACCESS 159
is an implementation-dependent limit on the number of unique image units, the
actual number of images that may be used by all shaders in a program is limited.
7.13 Shader Memory Access
As described in the OpenGL Shading Language Specification, shaders may per-
form random-access reads and writes to buffer object memory by reading from,
assigning to, or performing atomic memory operation on shader buffer variables,
or to texture or buffer object memory by using built-in image load, store, and
atomic functions operating on shader image variables. The ability to perform such
random-access reads and writes in systems that may be highly pipelined results in
ordering and synchronization issues discussed in the sections below.
7.13.1 Shader Memory Access Ordering
The order in which texture or buffer object memory is read or written by shaders
is largely unde?ned. For some shader types (vertex, tessellation evaluation, and in
some cases, fragment), even the number of shader invocations that might perform
loads and stores is unde?ned.
In particular, the following rules apply:
 While a vertex or tessellation evaluation shader will be executed at least once
for each unique vertex speci?ed by the application (vertex shaders) or gener-
ated by the tessellation primitive generator (tessellation evaluation shaders),
it may be executed more than once for implementation-dependent reasons.
Additionally, if the same vertex is speci?ed multiple times in a collection
of primitives (e.g., repeating an index in DrawElements), the vertex shader
might be run only once.
 For each fragment generated by the GL, the number of fragment shader in-
vocations depends on a number of factors. If the fragment fails the pixel
ownership test (see section 14.9.1), scissor test (see section 14.9.2), or is dis-
carded by any of the multisample fragment operations (see section 14.9.3),
the fragment shader will not be executed
In addition, if early per-fragment tests are enabled (see section 14.9), the
fragment shader will not be executed if the fragment is discarded during the
early per-fragment tests.
When fragment shaders are executed, the number of invocations per frag-
ment is exactly one when the framebuffer has no multisample buffer (the
OpenGL 4.6 (Core Pro?le) - February 2, 20197.13. SHADERMEMORYACCESS 160
value of SAMPLE_BUFFERS is zero). Otherwise, the number of invocations
is in the range [1;N] whereN is the number of samples covered by the frag-
ment; if the fragment shader speci?es per-sample shading, it will be invoked
exactlyN times.
 If a fragment shader is invoked to process fragments or samples not covered
by a primitive being rasterized to facilitate the approximation of derivatives
for texture lookups, then stores, atomics, and atomic counter updates have
no effect.
 The relative order of invocations of the same shader type are unde?ned. A
store issued by a shader when working on primitive B might complete prior
to a store for primitive A, even if primitive A is speci?ed prior to primitive
B. This applies even to fragment shaders; while fragment shader outputs
are always written to the framebuffer in primitive order, stores executed by
fragment shader invocations are not.
 The relative order of invocations of different shader types is largely unde-
?ned. However, when executing a shader whose inputs are generated from
a previous programmable stage, the shader invocations from the previous
stage are guaranteed to have executed far enough to generate ?nal values
for all next-stage inputs. That implies shader completion for all stages ex-
cept geometry; geometry shaders are guaranteed only to have executed far
enough to emit all vertices used to generate the primitive being processed by
the fragment shader.
The above limitations on shader invocation order also make some forms of
synchronization between shader invocations within a single set of primitives unim-
plementable. For example, having one invocation poll memory written by another
invocation assumes that the other invocation has been launched and can complete
its writes. The only case where such a guarantee is made is when the inputs of
one shader invocation are generated from the outputs of a shader invocation in a
previous stage.
Stores issued to different memory locations within a single shader invocation
may not be visible to other invocations in the order they were performed. The built-
in function memoryBarrier may be used to provide stronger ordering of reads
and writes performed by a single invocation. Calling memoryBarrier guaran-
tees that any memory transactions issued by the shader invocation prior to the call
complete prior to the memory transactions issued after the call. Memory barriers
may be needed for algorithms that require multiple invocations to access the same
memory and require the operations to be performed in a partially-de?ned relative
OpenGL 4.6 (Core Pro?le) - February 2, 20197.13. SHADERMEMORYACCESS 161
order. For example, if one shader invocation does a series of writes, followed by a
memoryBarrier call, followed by another write, then another invocation that sees
the results of the ?nal write will also see the previous writes. Without the memory
barrier, the ?nal write may be visible before the previous writes.
The built-in atomic memory transaction and atomic counter functions may be
used to read and write a given memory address atomically. While built-in atomic
functions issued by multiple shader invocations are executed in unde?ned order
relative to each other, these functions perform both a read and a write of a memory
address and guarantee that no other memory transaction will write to the underlying
memory between the read and write. Atomics allow shaders to use shared global
addresses for mutual exclusion or as counters, among other uses.
7.13.2 Shader Memory Access Synchronization
Data written to textures or buffer objects by a shader invocation may eventually be
read by other shader invocations, sourced by other ?xed pipeline stages, or read
back by the application. When data is written using API commands such as Tex-
SubImage* or BufferSubData, the GL implementation knows when and where
writes occur and can perform implicit synchronization to ensure that operations re-
quested before the update see the original data and that subsequent operations see
the modi?ed data. Without logic to track the target address of each shader instruc-
tion performing a store, automatic synchronization of stores performed by a shader
invocation would require the GL implementation to make worst-case assumptions
at signi?cant performance cost. To permit cases where textures or buffers may
be read or written in different pipeline stages without the overhead of automatic
synchronization, buffer object and texture stores performed by shaders are not au-
tomatically synchronized with other GL operations using the same memory.
Explicit synchronization is required to ensure that the effects of buffer and tex-
ture data stores performed by shaders will be visible to subsequent operations using
the same objects and will not overwrite data still to be read by previously requested
operations. Without manual synchronization, shader stores for a “new” primitive
may complete before processing of an “old” primitive completes. Additionally,
stores for an “old” primitive might not be completed before processing of a “new”
primitive starts. The command
void MemoryBarrier(bitfield barriers );
de?nes a barrier ordering the memory transactions issued prior to the command
relative to those issued after the barrier. For the purposes of this ordering, memory
transactions performed by shaders are considered to be issued by the rendering
OpenGL 4.6 (Core Pro?le) - February 2, 20197.13. SHADERMEMORYACCESS 162
command that triggered the execution of the shader. barriers is a bit?eld indicating
the set of operations that are synchronized with shader stores; the bits used in
barriers are as follows:
 VERTEX_ATTRIB_ARRAY_BARRIER_BIT: If set, vertex data sourced from
buffer objects after the barrier will re?ect data written by shaders prior to the
barrier. The set of buffer objects affected by this bit is derived from the buffer
object bindings used for arrays of generic vertex attributes (VERTEX_-
ATTRIB_ARRAY_BUFFER bindings).
 ELEMENT_ARRAY_BARRIER_BIT: If set, vertex array indices sourced from
buffer objects after the barrier will re?ect data written by shaders prior to
the barrier. The buffer objects affected by this bit are derived from the
ELEMENT_ARRAY_BUFFER binding.
 UNIFORM_BARRIER_BIT: Shader uniforms sourced from buffer objects af-
ter the barrier will re?ect data written by shaders prior to the barrier.
 TEXTURE_FETCH_BARRIER_BIT: Texture fetches from shaders, including
fetches from buffer object memory via buffer textures, after the barrier will
re?ect data written by shaders prior to the barrier.
 SHADER_IMAGE_ACCESS_BARRIER_BIT: Memory accesses using shader
built-in image load, store, and atomic functions issued after the barrier will
re?ect data written by shaders prior to the barrier. Additionally, image stores
and atomics issued after the barrier will not execute until all memory ac-
cesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to
the barrier complete.
 COMMAND_BARRIER_BIT: Command data sourced from buffer objects by
Draw*Indirect, MultiDraw*IndirectCount and DispatchComputeIndi-
rect commands after the barrier will re?ect data written by shaders prior
to the barrier. The buffer objects affected by this bit are derived from
the DRAW_INDIRECT_BUFFER, PARAMETER_BUFFER and DISPATCH_-
INDIRECT_BUFFER bindings, respectively.
 PIXEL_BUFFER_BARRIER_BIT: Reads/writes of buffer objects via the
PIXEL_PACK_BUFFER and PIXEL_UNPACK_BUFFER bindings (ReadPix-
els, TexSubImage, etc.) after the barrier will re?ect data written by shaders
prior to the barrier. Additionally, buffer object writes issued after the barrier
will wait on the completion of all shader writes initiated prior to the barrier.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.13. SHADERMEMORYACCESS 163
 TEXTURE_UPDATE_BARRIER_BIT: Writes
to a texture via Tex(Sub)Image*, ClearTex*Image, CopyTex*, or Com-
pressedTex*, and reads via GetTexImage after the barrier will not execute
until all shader writes initiated prior to the barrier complete.
 BUFFER_UPDATE_BARRIER_BIT: Reads and writes to buffer object mem-
ory after the barrier using the commands in sections 6.2, 6.2.1, 6.3, 6.6,
and 6.5 will re?ect data written by shaders prior to the barrier. Additionally,
writes via these commands issued after the barrier will wait on the comple-
tion of any shader writes to the same memory initiated prior to the barrier.
 CLIENT_MAPPED_BUFFER_BARRIER_BIT: Access by the client to persis-
tent mapped regions of buffer objects will re?ect data written by shaders
prior to the barrier. Note that this may cause additional synchronization op-
erations.
 QUERY_BUFFER_BARRIER_BIT: Writes of buffer objects via the QUERY_-
BUFFER binding (see section 4.2.3) after the barrier will re?ect data written
by shaders prior to the barrier. Additionally, buffer object writes issued after
the barrier will wait on the completion of all shader writes initiated prior to
the barrier.
 FRAMEBUFFER_BARRIER_BIT: Reads and writes via framebuffer object at-
tachments after the barrier will re?ect data written by shaders prior to the
barrier. Additionally, framebuffer writes issued after the barrier will wait on
the completion of all shader writes issued prior to the barrier.
 TRANSFORM_FEEDBACK_BARRIER_BIT: Writes via transform feedback
bindings after the barrier will re?ect data written by shaders prior to the
barrier. Additionally, transform feedback writes issued after the barrier will
wait on the completion of all shader writes issued prior to the barrier.
 ATOMIC_COUNTER_BARRIER_BIT: Memory accesses using shader atomic
counter built-in functions issued after the barrier will re?ect data written by
shaders prior to the barrier. Additionally, atomic counter function invoca-
tions after the barrier will not execute until all memory accesses (e.g., loads,
stores, texture fetches, vertex fetches) initiated prior to the barrier complete.
 SHADER_STORAGE_BARRIER_BIT: Memory accesses using shader buffer
variables issued after the barrier will re?ect data written by shaders prior to
the barrier. Additionally, assignments to and atomic operations performed
on shader buffer variables after the barrier will not execute until all memory
accesses initiated prior to the barrier complete.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.13. SHADERMEMORYACCESS 164
If barriers isALL_BARRIER_BITS, shader memory accesses will be synchro-
nized relative to all the operations described above.
Errors
AnINVALID_VALUE error is generated if barriers is not the special value
ALL_BARRIER_BITS, and has any bits set other than those described above.
Implementations may cache buffer object and texture image memory that could
be written by shaders in multiple caches; for example, there may be separate caches
for texture, vertex fetching, and one or more caches for shader memory accesses.
Implementations are not required to keep these caches coherent with shader mem-
ory writes. Stores issued by one invocation may not be immediately observable
by other pipeline stages or other shader invocations because the value stored may
remain in a cache local to the processor executing the store, or because data over-
written by the store is still in a cache elsewhere in the system. When Memo-
ryBarrier is called, the GL ?ushes and/or invalidates any caches relevant to the
operations speci?ed by the barriers parameter to ensure consistent ordering of op-
erations across the barrier.
To allow for independent shader invocations to communicate by reads and
writes to a common memory address, image variables in the OpenGL Shading
Language may be declared ascoherent. Buffer object or texture image memory
accessed through such variables may be cached only if caches are automatically
updated due to stores issued by any other shader invocation. If the same address
is accessed using both coherent and non-coherent variables, the accesses using
variables declared as coherent will observe the results stored using coherent vari-
ables in other invocations. Using variables declared ascoherent guarantees only
that the results of stores will be immediately visible to shader invocations using
similarly-declared variables; calling MemoryBarrier is required to ensure that the
stores are visible to other operations.
The following guidelines may be helpful in choosing when to use coherent
memory accesses and when to use barriers.
 Data that are read-only or constant may be accessed without using coher-
ent variables or calling MemoryBarrier. Updates to the read-only data via
commands such as BufferSubData will invalidate shader caches implicitly
as required.
 Data that are shared between shader invocations at a ?ne granularity (e.g.,
written by one invocation, consumed by another invocation) should use co-
herent variables to read and write the shared data.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.13. SHADERMEMORYACCESS 165
 Data written by one shader invocation and consumed by other shader in-
vocations launched as a result of its execution (dependent invocations)
should use coherent variables in the producing shader invocation and call
memoryBarrier after the last write. The consuming shader invocation
should also use coherent variables.
 Data written to image variables in one rendering pass and read by the shader
in a later pass need not use coherent variables ormemoryBarrier. Calling
MemoryBarrier with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in
barriers between passes is necessary.
 Data written by the shader in one rendering pass and read by another mech-
anism (e.g., vertex or index buffer pulling) in a later pass need not use co-
herent variables ormemoryBarrier. Calling MemoryBarrier with the ap-
propriate bits set in barriers between passes is necessary.
The command
void MemoryBarrierByRegion(bitfield barriers );
behaves as described above for MemoryBarrier, with two differences:
First, it narrows the region under consideration so that only reads and writes of
prior fragment shaders that are invoked for a smaller region of the framebuffer will
be completed/re?ected prior to subsequent reads and writes of following fragment
shaders. The size of the region is implementation-dependent and may be as small
as one framebuffer pixel.
Second, it only applies to memory transactions that may be read by or written
by a fragment shader. Therefore, only the barrier bits
 ATOMIC_COUNTER_BARRIER_BIT
 FRAMEBUFFER_BARRIER_BIT
 SHADER_IMAGE_ACCESS_BARRIER_BIT
 SHADER_STORAGE_BARRIER_BIT
 TEXTURE_FETCH_BARRIER_BIT
 UNIFORM_BARRIER_BIT
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 166
are supported.
When barriers is ALL_BARRIER_BITS, shader memory accesses will be syn-
chronized relative to all these barrier bits, but not to other barrier bits speci?c to
MemoryBarrier. This implies that reads and writes for scatter/gather-like algo-
rithms may or may not be completed/re?ected after a MemoryBarrierByRegion
command. However, for uses such as deferred shading, where a linked list of vis-
ible surfaces with the head at a framebuffer address may be constructed, and the
entirety of the list is only dependent on previous executions at that framebuffer ad-
dress, MemoryBarrierByRegion may be signi?cantly more ef?cient than Mem-
oryBarrier.
Errors
AnINVALID_VALUE error is generated if barriers is not the special value
ALL_BARRIER_BITS, and has any bits set other than those described above.
7.14 Shader, Program, and Program Pipeline Queries
The command
void GetShaderiv(uint shader,enum pname,int *params );
returns properties of the shader object named shader in params. The parameter
value to return is speci?ed by pname.
If pname is SHADER_TYPE, one of the values from table 7.1 corresponding to
the type of shader is returned.
If pname isDELETE_STATUS,TRUE is returned if the shader has been ?agged
for deletion andFALSE is returned otherwise.
If pname is COMPILE_STATUS, TRUE is returned if the shader was last com-
piled or specialized successfully, andFALSE is returned otherwise.
If pname is INFO_LOG_LENGTH, the length of the info log, including a null
terminator, is returned. If there is an empty info log, zero is returned.
If pname isSHADER_SOURCE_LENGTH, the length of the concatenation of the
source strings making up the shader source, including a null terminator, is returned.
If no source has been de?ned, zero is returned.
If pname isSPIR_V_BINARY,TRUE is returned if the shader has been success-
fully associated with a SPIR-V binary module by the ShaderBinary command,
andFALSE is returned otherwise.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 167
Errors
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
An INVALID_ENUM error is generated if pname is not
SHADER_TYPE, DELETE_STATUS, COMPILE_STATUS, INFO_LOG_LENGTH,
SHADER_SOURCE_LENGTH, orSPIR_V_BINARY.
The command
void GetProgramiv(uint program,enum pname,
int *params );
returns properties of the program object named program in params. The parameter
value to return is speci?ed by pname.
Most properties set within program objects are speci?ed not to take effect until
the next call to LinkProgram or ProgramBinary. Some properties further require
a successful call to either of these commands before taking effect. GetProgramiv
returns the properties currently in effect for program, which may differ from the
properties set within program since the most recent call to LinkProgram or Pro-
gramBinary, which have not yet taken effect. If there has been no such call putting
changes to pname into effect, initial values are returned.
If pname isDELETE_STATUS,TRUE is returned if the program has been ?agged
for deletion, andFALSE is returned otherwise.
If pname is LINK_STATUS, TRUE is returned if the program was last linked
successfully, andFALSE is returned otherwise.
If pname is VALIDATE_STATUS, TRUE is returned if the last call to Vali-
dateProgram (see section 11.1.3.11) with program was successful, and FALSE
is returned otherwise.
If pname is INFO_LOG_LENGTH, the length of the info log, including a null
terminator, is returned. If there is an empty info log, zero is returned.
If pname isATTACHED_SHADERS, the number of objects attached is returned.
If pname is ACTIVE_ATTRIBUTES, the number of active attributes (see sec-
tion 7.3.1) in program is returned. If no active attributes exist, zero is returned.
If pname isACTIVE_ATTRIBUTE_MAX_LENGTH, the length of the longest ac-
tive attribute name, including a null terminator, is returned. If no active attributes
exist, zero is returned. If no name re?ection information is available, one is re-
turned.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 168
If pname isACTIVE_UNIFORMS, the number of active uniforms is returned. If
no active uniforms exist, zero is returned.
If pname isACTIVE_UNIFORM_MAX_LENGTH, the length of the longest active
uniform name, including a null terminator, is returned. If no active uniforms exist,
zero is returned. If no name re?ection information is available, one is returned.
If pname is TRANSFORM_FEEDBACK_BUFFER_MODE, the buffer mode used
when transform feedback (see section 11.1.2.1) is active is returned. It can be
one ofSEPARATE_ATTRIBS orINTERLEAVED_ATTRIBS.
If pname is TRANSFORM_FEEDBACK_VARYINGS, the number of output vari-
ables to capture in transform feedback mode for the program is returned.
If pname is TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, the length of
the longest output variable name speci?ed to be used for transform feedback, in-
cluding a null terminator, is returned. If no outputs are used for transform feedback,
zero is returned. If no name re?ection information is available, one is returned.
If pname is ACTIVE_UNIFORM_BLOCKS, the number of uniform blocks for
program containing active uniforms is returned.
If pname isACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, the length of the
longest active uniform block name, including the null terminator, is returned. If no
active uniform blocks exist, zero is returned. If no name re?ection information is
available, one is returned.
If pname isGEOMETRY_VERTICES_OUT, the maximum number of vertices the
geometry shader (see section 11.3) will output is returned.
If pname is GEOMETRY_INPUT_TYPE, the geometry shader input type,
which must be one of POINTS, LINES, LINES_ADJACENCY, TRIANGLES or
TRIANGLES_ADJACENCY, is returned.
If pname is GEOMETRY_OUTPUT_TYPE, the geometry shader output type,
which must be one ofPOINTS,LINE_STRIP orTRIANGLE_STRIP, is returned.
If pname is GEOMETRY_SHADER_INVOCATIONS, the number of geometry
shader invocations per primitive will be returned.
If pname is TESS_CONTROL_OUTPUT_VERTICES, the number of vertices in
the tessellation control shader (see section 11.2.1) output patch is returned.
If pname isTESS_GEN_MODE,QUADS,TRIANGLES, orISOLINES is returned,
depending on the primitive mode declaration in the tessellation evaluation shader
(see section 11.2.3).
If pname is
TESS_GEN_SPACING, EQUAL, FRACTIONAL_EVEN, or FRACTIONAL_ODD is re-
turned, depending on the spacing declaration in the tessellation evaluation shader.
If pname isTESS_GEN_VERTEX_ORDER,CCW orCW is returned, depending on
the vertex order declaration in the tessellation evaluation shader.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 169
If pname is TESS_GEN_POINT_MODE, TRUE is returned if point mode is en-
abled in a tessellation evaluation shader declaration;FALSE is returned otherwise.
If pname isCOMPUTE_WORK_GROUP_SIZE, an array of three integers contain-
ing the workgroup size of the compute program (see chapter 19), as speci?ed by
its inputlayout quali?er(s), is returned.
If pname is PROGRAM_SEPARABLE, TRUE is returned if the program has been
?agged for use as a separable program object that can be bound to individual shader
stages with UseProgramStages.
If pname is PROGRAM_BINARY_RETRIEVABLE_HINT, the value of whether
the binary retrieval hint is enabled for program is returned.
If pname is ACTIVE_ATOMIC_COUNTER_BUFFERS, the number of active
atomic counter buffers used by program is returned.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_ENUM error is generated if pname is not one of the values
listed above.
AnINVALID_OPERATION error is generated ifGEOMETRY_VERTICES_-
OUT,GEOMETRY_INPUT_TYPE,GEOMETRY_OUTPUT_TYPE, orGEOMETRY_-
SHADER_INVOCATIONS are queried for a program which has not been linked
successfully, or which does not contain objects to form a geometry shader.
An INVALID_OPERATION error is generated if TESS_CONTROL_-
OUTPUT_VERTICES is queried for a program which has not been linked suc-
cessfully, or which does not contain objects to form a tessellation control
shader.
An INVALID_OPERATION error is generated if TESS_GEN_MODE,
TESS_GEN_SPACING,TESS_GEN_VERTEX_ORDER, orTESS_GEN_POINT_-
MODE are queried for a program which has not been linked successfully, or
which does not contain objects to form a tessellation evaluation shader.
An INVALID_OPERATION error is generated if COMPUTE_WORK_-
GROUP_SIZE is queried for a program which has not been linked successfully,
or which does not contain objects to form a compute shader,
The command
void GetProgramPipelineiv(uint pipeline,enum pname,
int *params );
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 170
returns properties of the program pipeline object named pipeline in params. The
parameter value to return is speci?ed by pname.
If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL ?rst creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.
If pname is ACTIVE_PROGRAM, the name of the active program object (used
for uniform updates) of pipeline is returned.
If pname is one of the shader stage type arguments in table 7.1, the name of the
program object current for the corresponding shader stage of pipeline is returned.
If pname is VALIDATE_STATUS, the validation status of pipeline, as deter-
mined by ValidateProgramPipeline (see section 11.1.3.11) is returned.
If pname isINFO_LOG_LENGTH, the length of the info log for pipeline, includ-
ing a null terminator, is returned. If there is an empty info log, zero is returned.
Errors
AnINVALID_OPERATION error is generated if pipeline is not a name re-
turned from a previous call to GenProgramPipelines or if such a name has
since been deleted by DeleteProgramPipelines.
AnINVALID_ENUM error is generated if pname is notACTIVE_PROGRAM,
INFO_LOG_LENGTH, VALIDATE_STATUS, or one of the type arguments in
table 7.1.
The command
void GetAttachedShaders(uint program,sizei maxCount,
sizei *count,uint *shaders );
returns the names of shader objects attached to program in shaders. The actual
number of shader names written into shaders is returned in count. If no shaders
are attached, count is set to zero. If count is NULL then it is ignored. The max-
imum number of shader names that may be written into shaders is speci?ed by
maxCount. The number of objects attached to program may be queried by calling
GetProgramiv withATTACHED_SHADERS.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 171
shader object.
AnINVALID_VALUE error is generated if maxCount is negative.
A string that contains information about the last compilation attempt on a
shader object, last link or validation attempt on a program object, or last valida-
tion attempt on a program pipeline object, called the info log, can be obtained with
the commands
void GetShaderInfoLog(uint shader,sizei bufSize,
sizei *length,char *infoLog );
void GetProgramInfoLog(uint program,sizei bufSize,
sizei *length,char *infoLog );
void GetProgramPipelineInfoLog(uint pipeline,
sizei bufSize,sizei *length,char *infoLog );
These commands return an info log string for the corresponding type of object in
infoLog. This string will be null-terminated even if theINFO_LOG_LENGTH query
returns zero. The actual number of characters written into infoLog, excluding the
null terminator, is returned in length. If length isNULL, then no length is returned.
The maximum number of characters that may be written into infoLog, including
the null terminator, is speci?ed by bufSize. The number of characters in the info
log for a shader object, program object, or program pipeline object may be queried
respectively with GetShaderiv, GetProgramiv, or GetProgramPipelineiv with
pnameINFO_LOG_LENGTH.
If shader is a shader object, GetShaderInfoLog will return either an empty
string or information about the last compilation or specialization attempt for that
object.
If program is a program object, GetProgramInfoLog will return either an
empty string or information about the last link attempt or last validation attempt
(see section 11.1.3.11) for that object.
If pipeline is a program pipeline object, GetProgramPipelineInfoLog will
return either an empty string or information about the last validation attempt for
that object.
The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
info logs.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 172
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
An INVALID_VALUE error is generated if pipeline is not the name of an
existing program pipeline object.
AnINVALID_VALUE error is generated if bufSize is negative.
The command
void GetShaderSource(uint shader,sizei bufSize,
sizei *length,char *source );
returns in source the string making up the source code for the shader object shader.
The string source will be null-terminated. The actual number of characters written
into source, excluding the null terminator, is returned in length. If length isNULL,
no length is returned. The maximum number of characters that may be written into
source, including the null terminator, is speci?ed by bufSize. The string source is a
concatenation of the strings passed to the GL using ShaderSource. The length of
this concatenation is given by SHADER_SOURCE_LENGTH, which may be queried
with GetShaderiv.
Errors
AnINVALID_VALUE error is generated if shader is not the name of either
a program or shader object.
An INVALID_OPERATION error is generated if shader is the name of a
program object.
AnINVALID_VALUE error is generated if bufSize is negative.
The command
void GetShaderPrecisionFormat(enum shadertype,
enum precisiontype,int *range,int *precision );
returns the range and precision for different numeric formats supported by the
shader compiler. shadertype must be VERTEX_SHADER or FRAGMENT_SHADER.
precisiontype must be one ofLOW_FLOAT,MEDIUM_FLOAT,HIGH_FLOAT,LOW_-
INT,MEDIUM_INT orHIGH_INT. range points to an array of two integers in which
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 173
encodings of the format’s numeric range are returned. If min and max are the
smallest and largest values representable in the format, then the values returned are
de?ned to be
range[0] =blog (jminj)c
2
range[1] =blog (jmaxj)c
2
precision points to an integer in which the number of bits of precision of the for-
mat is returned. If the smallest representable value greater than 1 is 1 +, then
*precision will containb log ()c, and every value in the range
2
range[0] range[1]
[ 2 ; 2 ]
precision
can be represented to at least one part in 2 . For example, an IEEE single-
precision ?oating-point format would return range[0] = 127, range[1] = 127,
andprecision = 23, while a 32-bit two’s-complement integer format would re-
turnrange[0] = 31,range[1] = 30, andprecision = 0.
The minimum required precision and range for formats corresponding to the
different values of precisiontype are described in section 4.7(“Precision and Preci-
sion Quali?ers”) of the OpenGL Shading Language Specification.
Errors
An INVALID_ENUM error is generated if shadertype is not VERTEX_-
SHADER orFRAGMENT_SHADER.
The commands
void GetUniformfv(uint program,int location,
float *params );
void GetUniformdv(uint program,int location,
double *params );
void GetUniformiv(uint program,int location,
int *params );
void GetUniformuiv(uint program,int location,
uint *params );
void GetnUniformfv(uint program,int location,
sizei bufSize,float *params );
void GetnUniformdv(uint program,int location,
sizei bufSize,double *params );
OpenGL 4.6 (Core Pro?le) - February 2, 20197.14. SHADER,PROGRAM,ANDPROGRAMPIPELINEQUERIES 174
void GetnUniformiv(uint program,int location,
sizei bufSize,int *params );
void GetnUniformuiv(uint program,int location,
sizei bufSize,uint *params );
return the value or values of the uniform at location location of the default uniform
block for program object program in the array params. The type of the uniform at
location determines the number of values returned.
In order to query the values of an array of uniforms, a GetUniform* command
needs to be issued for each array element. If the uniform queried is a matrix, the
values of the matrix are returned in column major order.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_OPERATION error is generated if program has not been
linked successfully, or if location is not a valid location for program.
An INVALID_VALUE error is generated by GetnUniform* if bufSize is
negative.
An INVALID_OPERATION error is generated by GetnUniform* if the
buffer size required to store the requested data is greater than bufSize.
The command
void GetUniformSubroutineuiv(enum shadertype,
int location,uint *params );
returns the value of the subroutine uniform at location location for shader stage
shadertype of the current program. If location represents an unused location, the
valueINVALID_INDEX is returned and no error is generated.
Errors
AnINVALID_ENUM error is generated if shadertype is not one of the val-
ues in table 7.1.
AnINVALID_VALUE error is generated if location is greater than or equal
to the value ofACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader
currently in use at shader stage shadertype.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.15. REQUIREDSTATE 175
AnINVALID_OPERATION error is generated if no program is active.
The command
void GetProgramStageiv(uint program,enum shadertype,
enum pname,int *values );
returns properties of the program object program speci?c to the programmable
stage corresponding to shadertype in values. The parameter value to return is
speci?ed by pname. If pname is ACTIVE_SUBROUTINE_UNIFORMS, the number
of active subroutine variables in the stage is returned. If pname is ACTIVE_-
SUBROUTINE_UNIFORM_LOCATIONS, the number of active subroutine variable
locations in the stage is returned. If pname isACTIVE_SUBROUTINES, the number
of active subroutines in the stage is returned. If pname isACTIVE_SUBROUTINE_-
UNIFORM_MAX_LENGTH or ACTIVE_SUBROUTINE_MAX_LENGTH, the length of
the longest subroutine uniform or subroutine name, respectively, for the stage is
returned. The returned name length includes space for a null terminator. If there
is no shader of type shadertype in program, the values returned will be consistent
with a shader with no subroutines or subroutine uniforms.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_ENUM error is generated if shadertype is not one of the val-
ues in table 7.1.
7.15 Required State
The GL maintains state to indicate which shader and program object names are in
use. Initially, no shader or program objects exist, and no names are in use.
The state required per shader object consists of:
 An unsigned integer specifying the shader object name.
 An integer holding the value ofSHADER_TYPE.
 A boolean holding the delete status, initiallyFALSE.
 A boolean holding the status of the last compile, initiallyFALSE.
OpenGL 4.6 (Core Pro?le) - February 2, 20197.15. REQUIREDSTATE 176
 A boolean holding the SPIR-V binary status, initiallyFALSE.
 An array of typechar containing the information log, initially empty.
 An integer holding the length of the information log.
 An array of type char containing the concatenated shader string, initially
empty.
 An integer holding the length of the concatenated shader string.
The state required per program object consists of:
 An unsigned integer indicating the program object name.
 A boolean holding the delete status, initiallyFALSE.
 A boolean holding the status of the last link attempt, initiallyFALSE.
 A boolean holding the status of the last validation attempt, initiallyFALSE.
 An integer holding the number of attached shader objects.
 A list of unsigned integers to keep track of the names of the shader objects
attached.
 An array of typechar containing the information log, initially empty.
 An integer holding the length of the information log.
 An integer holding the number of active uniforms.
 For each active uniform, three integers, holding its location, size, and type,
and an array of typechar holding its name.
 An array holding the values of each active uniform.
 An integer holding the number of active attributes.
 For each active attribute, three integers holding its location, size, and type,
and an array of typechar holding its name.
 A boolean holding the hint to the retrievability of the program binary, ini-
tiallyFALSE.
Additional state required to support vertex shaders consists of:
OpenGL 4.6 (Core Pro?le) - February 2, 20197.15. REQUIREDSTATE 177
 A bit indicating whether or not program point size mode (section 14.4.1) is
enabled, initially disabled.
Additional state required to support transform feedback consists of:
 An integer holding the transform feedback mode, initiallyINTERLEAVED_-
ATTRIBS.
 An integer holding the number of outputs to be captured, initially zero.
 An integer holding the length of the longest output name being captured,
initially zero.
 For each output being captured, two integers holding its size and type, and
an array of typechar holding its name.
Additionally, one unsigned integer is required to hold the name of the current pro-
gram object, if any.
This list of program object state is not complete. Tables 23.32-23.42 describe
additional program object state speci?c to program binaries, geometry shaders,
tessellation control and evaluation shaders, shader subroutines, and uniform blocks.
Table 23.43 describes state related to vertex and geometry shaders that is not
program object state.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 8
Textures and Samplers
Texturing maps a portion of one or more speci?ed images onto a fragment or
vertex. This mapping is accomplished in shaders by sampling the color of an
image at the location indicated by speci?ed (s;t;r) texture coordinates. Texture
lookups are typically used to modify a fragment’s RGBA color but may be used
for any purpose in a shader.
This chapter ?rst describes how pixel rectangles, texture images, and texture
and sampler object parameters are speci?ed and queried, in sections 8.1-8.11. The
remainder of the chapter in sections 8.12-8.26 describe how texture sampling is
performed in shaders.
The internal data type of a texture may be signed or unsigned normalized ?xed-
point, signed or unsigned integer, or ?oating-point, depending on the internal for-
mat of the texture. The correspondence between the internal format and the internal
data type is given in tables 8.12-8.13. Fixed-point and ?oating-point textures return
a ?oating-point value and integer textures return signed or unsigned integer values.
The fragment shader is responsible for interpreting the result of a texture lookup as
the correct data type, otherwise the result is unde?ned.
Each of the supported types of texture is a collection of texture images built
from one-, two-, or three-dimensional arrays of texels (see section 2.6.6). One-,
two-, and three-dimensional textures consist respectively of one-, two-, or three-
dimensional texture images. One- and two-dimensional array textures are arrays
of one- or two-dimensional images. Each image consists of one or more layers.
Two-dimensional multisample and two-dimensional multisample array textures are
special two-dimensional and two-dimensional array textures, respectively, contain-
ing multiple samples in each texel. Cube maps are special two-dimensional array
textures with six layers that represent the faces of a cube. When accessing a cube
map, the texture coordinates are projected onto one of the six faces of the cube. A
1788.1. TEXTUREOBJECTS 179
cube map array is a collection of cube map layers stored as a two-dimensional array
texture. When accessing a cube map array, the texture coordinatess,t, andr are
applied similarly as cube maps while the last texture coordinateq is used as the in-
dex of one of the cube map slices. Rectangle textures are special two-dimensional
textures consisting of only a single image and accessed using unnormalized coor-
dinates. Buffer textures are special one-dimensional textures whose texture images
are stored in separate buffer objects.
Implementations must support texturing using multiple images.
The following subsections (up to and including section 8.14) specify the GL
operation with a single texture. Multiple texture images may be sampled and com-
bined by shaders as described in section 11.1.3.5.
The coordinates used for texturing in a fragment shader are de?ned by the
OpenGL Shading Language Specification.
The command
void ActiveTexture(enum texture );
speci?es the active texture unit selector. The selector may be queried by calling
GetIntegerv with pname set toACTIVE_TEXTURE.
Each texture image unit consists of all the texture state de?ned in chapter 8.
The active texture unit selector selects the texture image unit accessed by com-
mands involving texture image processing. Such commands include TexParam-
eter, TexImage, BindTexture, and queries of all such state.
Errors
An INVALID_ENUM error is generated if an invalid texture is speci?ed.
texture is a symbolic constant of the form TEXTUREi, indicating that texture
uniti is to be modi?ed. EachTEXTUREi adheres toTEXTUREi =TEXTURE0 +
i, wherei is in the range zero tok 1, andk is the value of MAX_COMBINED_-
TEXTURE_IMAGE_UNITS.
The state required for the active texture image unit selector is a single integer.
The initial value isTEXTURE0.
8.1 Texture Objects
Textures in GL are represented by named objects. The name space for tex-
ture objects is the unsigned integers, with zero reserved by the GL to represent
the default texture object. The default texture object is bound to each of the
OpenGL 4.6 (Core Pro?le) - February 2, 20198.1. TEXTUREOBJECTS 180
TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_-
2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_BUFFER, TEXTURE_CUBE_MAP,
TEXTURE_CUBE_MAP_ARRAY, TEXTURE_2D_MULTISAMPLE, and TEXTURE_-
2D_MULTISAMPLE_ARRAY targets during context initialization.
A new texture object is created by binding an unused name to one of these
texture targets. The command
void GenTextures(sizei n,uint *textures );
returns n previously unused texture names in textures. These names are marked as
used, for the purposes of GenTextures only, but they acquire texture state and a
dimensionality only when they are ?rst bound, just as if they were unused.
Errors
AnINVALID_VALUE error is generated if n is negative.
The binding is effected by calling
void BindTexture(enum target,uint texture );
with target set to the desired texture target and texture set to the unused name. The
resulting texture object is a new state vector, comprising all the state and with the
same initial values listed in section 8.22. The new texture object bound to target
is, and remains a texture of the dimensionality and type speci?ed by target until it
is deleted.
BindTexture may also be used to bind an existing texture object to any of these
targets. If the bind is successful no change is made to the state of the bound texture
object, and any previous binding to target is broken.
While a texture object is bound, GL operations on the target to which it is
bound affect the bound object, and queries of the target to which it is bound return
state from the bound object.
Errors
An INVALID_ENUM error is generated if target is not one of the texture
targets described in the introduction to section 8.1.
AnINVALID_OPERATION error is generated if an attempt is made to bind
a texture object of different dimensionality than the speci?ed target.
An INVALID_OPERATION error is generated if texture is not zero or a
OpenGL 4.6 (Core Pro?le) - February 2, 20198.1. TEXTUREOBJECTS 181
name returned from a previous call to GenTextures, or if such a name has
since been deleted.
The command
void BindTextures(uint ?rst,sizei count,const
uint *textures );
binds count existing texture objects to texture image units numbered ?rst through
first +count  1. If textures is not NULL, it speci?es an array of count values,
each of which must be zero or the name of an existing texture object. When an
entry in textures is the name of an existing texture object, that object is bound to
the target, in the corresponding texture unit, that was speci?ed when the object was
created. When an entry in textures is zero, each of the targets enumerated at the
beginning of this section is reset to its default texture for the corresponding texture
image unit. If textures isNULL, each target of each affected texture image unit from
?rst tofirst +count  1 is reset to its default texture.
BindTextures is equivalent (assuming no errors are generated to):
for (i = 0; i < count; i++) f
uint texture;
if (textures == NULL) f
texture = 0;
g else f
texture = textures[i];
g
ActiveTexture(TEXTURE0 + first + i);
if (texture != 0) f
enum target = / target of textures[i] /;
* *
BindTexture(target, textures[i]);
g else f
for (target in all supported targets) f
BindTexture(target, 0);
g
g
g
except that the active texture selector retains its original value upon completion of
the command, and that textures will not be created if they do not exist.
The values speci?ed in textures will be checked separately for each texture
image unit. When a value for a speci?c texture image unit is invalid, the state for
OpenGL 4.6 (Core Pro?le) - February 2, 20198.1. TEXTUREOBJECTS 182
that texture image unit will be unchanged and an error will be generated. However,
state for other texture image units will still be changed if their corresponding values
are valid.
Errors
An INVALID_OPERATION error is generated iffirst +count is greater
than the number of texture image units supported by the implementation.
AnINVALID_VALUE error is generated if count is negative.
AnINVALID_OPERATION error is generated if any value in textures is not
zero or the name of an existing texture object (per binding).
The command
void BindTextureUnit(uint unit,uint texture );
binds an existing texture object to the texture unit numbered unit. texture must
be zero or the name of an existing texture object. When texture is the name of
an existing texture object, that object is bound to the target, in the corresponding
texture unit, that was speci?ed when the object was created. When texture is zero,
each of the targets enumerated at the beginning of this section is reset to its default
texture for the corresponding texture image unit.
Errors
An INVALID_OPERATION error is generated by BindTextureUnit if tex-
ture is not zero or the name of an existing texture object.
Texture objects may also be created with the command
void CreateTextures(enum target,sizei n,uint *textures );
CreateTextures returns n previously unused texture names in textures, each
representing a new texture object that is a state vector comprising all the state and
with the same initial values listed in section 8.22. The new texture objects are and
remain textures of the dimensionality and type speci?ed by target until they are
deleted.
Errors
AnINVALID_VALUE error is generated if n is negative.
Texture objects are deleted by calling
OpenGL 4.6 (Core Pro?le) - February 2, 20198.2. SAMPLEROBJECTS 183
void DeleteTextures(sizei n,const uint *textures );
textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
a texture that is currently bound to any of the target bindings of BindTexture is
deleted, it is as though BindTexture had been executed with the same target and
texture zero. Additionally, special care must be taken when deleting a texture if any
of the images of the texture are attached to a framebuffer object. See section 9.2.8
for details.
Unused names in textures that have been marked as used for the purposes of
GenTextures are marked as unused again. Unused names in textures are silently
ignored, as is the name zero.
Errors
AnINVALID_VALUE error is generated if n is negative.
The command
boolean IsTexture(uint texture );
returnsTRUE if texture is the name of a texture object. If texture is zero, or is a non-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexture returnsFALSE.
The texture object name space, including the initial one-, two-, and three- di-
mensional, one- and two-dimensional array, rectangle, buffer, cube map, cube map
array, two-dimensional multisample, and two-dimensional multisample array tex-
ture objects, is shared among all texture units. A texture object may be bound to
more than one texture unit simultaneously. After a texture object is bound, any
GL operations on that target object affect any other texture units to which the same
texture object is bound.
Texture binding is affected by the setting of the state ACTIVE_TEXTURE. If a
texture object is deleted, it as if all texture units which are bound to that texture
object are rebound to texture object zero.
8.2 Sampler Objects
The state necessary for texturing can be divided into two categories as described
in section 8.22. A GL texture object includes both categories. The ?rst category
represents dimensionality and other image parameters, and the second category
OpenGL 4.6 (Core Pro?le) - February 2, 20198.2. SAMPLEROBJECTS 184
represents sampling state. Additionally, a sampler object may be created to encap-
sulate only the sampling state of a texture object.
A new sampler object is created by binding an unused name to a texture unit.
The command
void GenSamplers(sizei count,uint *samplers );
returns count previously unused sampler object names in samplers. The name zero
is reserved by the GL to represent no sampler being bound to a sampler unit. The
names are marked as used, for the purposes of GenSamplers only, but they acquire
state only when they are ?rst used as a parameter to BindSampler, SamplerPa-
rameter*, GetSamplerParameter*, or IsSampler. When a sampler object is ?rst
used in one of these functions, the resulting sampler object is initialized with a
new state vector, comprising all the state and with the same initial values listed in
table 23.18.
Errors
AnINVALID_VALUE error is generated if count is negative.
Sampler objects may also be created with the command
void CreateSamplers(sizei n,uint *samplers );
CreateSamplers returns n previously unused sampler names in samplers, each
representing a new sampler object which is a state vector comprising all the state
1
and with the same initial values listed in table 23.18 .
Errors
AnINVALID_VALUE error is generated if n is negative.
When a sampler object is bound to a texture unit, its state supersedes that of
the texture object bound to that texture unit. If the sampler name zero is bound to
a texture unit, the currently bound texture’s sampler state becomes active. A single
sampler object may be bound to multiple texture units simultaneously.
A sampler object binding is effected with the command
void BindSampler(uint unit,uint sampler );
1
Note that unlike texture objects, the initial sampler object state for TEXTURE_MIN_-
FILTER andTEXTURE_WRAP_ are ?xed, rather than dependent on the type of texture image.
*
OpenGL 4.6 (Core Pro?le) - February 2, 20198.2. SAMPLEROBJECTS 185
with unit set to the zero-based index of the texture unit to which to bind the sampler
and sampler set to the name of a sampler object returned from a previous call to
GenSamplers.
If the bind is successful no change is made to the state of the bound sampler
object, and any previous binding to unit is broken.
If state is present in a sampler object bound to a texture unit that would have
been rejected by a call to TexParameter* for the texture bound to that unit, the
behavior of the implementation is as if the texture were incomplete. For example, if
TEXTURE_WRAP_S or TEXTURE_WRAP_T is set to REPEAT, MIRRORED_REPEAT,
or MIRROR_CLAMP_TO_EDGE on the sampler object bound to a texture unit and
the texture bound to that unit is a rectangle texture, the texture will be considered
incomplete.
Sampler object state which does not affect sampling for the type of texture
bound to a texture unit, such as TEXTURE_WRAP_R for a rectangle texture, does
not affect completeness.
The currently bound sampler may be queried by calling GetIntegerv with
pname set to SAMPLER_BINDING. When a sampler object is unbound from the
texture unit (by binding the sampler object named zero to that unit), the modi?ed
state is again replaced with the sampler state associated with the texture object
bound to that texture unit.
Errors
An INVALID_VALUE error is generated if unit is greater than or equal to
the value ofMAX_COMBINED_TEXTURE_IMAGE_UNITS.
An INVALID_OPERATION error is generated if sampler is not zero or a
name returned from a previous call to GenSamplers, or if such a name has
since been deleted with DeleteSamplers.
The command
void BindSamplers(uint ?rst,sizei count,const
uint *samplers );
binds count existing sampler objects to texture image units numbered ?rst through
first +count  1. If samplers is not NULL, it speci?es an array of count values,
each of which must be zero or the name of an existing sampler object. If samplers
isNULL, each affected texture image unit from ?rst throughfirst +count  1 will
be reset to have no bound sampler object.
BindSamplers is equivalent (assuming no errors are generated to):
OpenGL 4.6 (Core Pro?le) - February 2, 20198.2. SAMPLEROBJECTS 186
for (i = 0; i < count; i++) f
if (samplers == NULL) f
BindSampler(first + i, 0);
g else f
BindSampler(first + i, samplers[i]);
g
g
The values speci?ed in samplers will be checked separately for each texture
image unit. When a value for a speci?c texture image unit is invalid, the state for
that texture image unit will be unchanged and an error will be generated. However,
state for other texture image units will still be changed if their corresponding values
are valid.
Errors
An INVALID_OPERATION error is generated iffirst +count is greater
than the number of texture image units supported by the implementation.
AnINVALID_VALUE error is generated if count is negative.
An INVALID_OPERATION error is generated if any value in samplers is
not zero or the name of an existing sampler object (per binding).
The parameters represented by a sampler object are a subset of those described
in section 8.10. Each parameter of a sampler object is set by calling
void SamplerParameterfifg(uint sampler,enum pname,
T param );
void SamplerParameterfifgv(uint sampler,enum pname,
const T *param );
void SamplerParameterIfi uigv(uint sampler,enum pname,
const T *params );
sampler is the name of a sampler object previously reserved by a call to GenSam-
plers. pname is the name of a parameter to modify and param is the new value of
that parameter. pname must be one of the sampler state names in table 23.18.
Texture state listed in tables 23.16- 23.17 but not listed here and in the sampler
state in table 23.18 is not part of the sampler state, and remains in the texture object.
Data conversions are performed as speci?ed in section 2.2.1, with these excep-
tions:
 If the values for TEXTURE_BORDER_COLOR are speci?ed with SamplerPa-
rameterIiv or SamplerParameterIuiv, they are unmodi?ed and stored with
OpenGL 4.6 (Core Pro?le) - February 2, 20198.2. SAMPLEROBJECTS 187
an internal data type of integer. If speci?ed with SamplerParameteriv, they
are converted to ?oating-point using equation 2.2. Otherwise, the values are
unmodi?ed and stored as ?oating-point.
Modifying a parameter of a sampler object affects all texture units to which
that sampler object is bound. Calling TexParameter has no effect on the sampler
object bound to the active texture unit. It will modify the parameters of the texture
object bound to that unit.
Errors
AnINVALID_OPERATION error is generated if sampler is not the name of
a sampler object previously returned from a call to GenSamplers.
An INVALID_ENUM error is generated if pname is not one of the sampler
state names in table 23.18.
AnINVALID_ENUM error is generated if SamplerParameterfifg is called
for a non-scalar parameter (pnameTEXTURE_BORDER_COLOR orTEXTURE_-
SWIZZLE_RGBA).
If the value of param is not an acceptable value for the parameter speci?ed
in pname, an error is generated as speci?ed in the description of TexParame-
ter*.
Sampler objects are deleted by calling
void DeleteSamplers(sizei count,const uint *samplers );
samplers contains count names of sampler objects to be deleted. After a sampler
object is deleted, its name is again unused. If a sampler object that is currently
bound to one or more texture units is deleted, it is as though BindSampler is called
once for each texture unit to which the sampler is bound, with unit set to the texture
unit and sampler set to zero. Unused names in samplers that have been marked as
used for the purposes of GenSamplers are marked as unused again. Unused names
in samplers are silently ignored, as is the reserved name zero.
Errors
AnINVALID_VALUE error is generated if count is negative.
The command
boolean IsSampler(uint sampler );
OpenGL 4.6 (Core Pro?le) - February 2, 20198.3. SAMPLEROBJECTQUERIES 188
may be called to determine whether sampler is the name of a sampler object. Is-
Sampler will return TRUE if sampler is the name of a sampler object previously
returned from a call to GenSamplers andFALSE otherwise. Zero is not the name
of a sampler object.
8.3 Sampler Object Queries
The current values of the parameters of a sampler object may be queried by calling
void GetSamplerParameterfifgv(uint sampler,
enum pname,T *params );
void GetSamplerParameterIfi uigv(uint sampler,
enum pname,T *params );
sampler is the name of the sampler object from which to retrieve parameters.
pname is the name of the parameter to be queried, and must be one of the sam-
pler state names in table 23.18. params is the address of an array into which the
current value of the parameter will be placed.
QueryingTEXTURE_BORDER_COLOR with GetSamplerParameterIiv or Get-
SamplerParameterIuiv returns the border color values as signed integers or un-
signed integers, respectively; otherwise the values are returned as described in sec-
tion 2.2.2. If the border color is queried with a type that does not match the original
type with which it was speci?ed, the result is unde?ned.
Errors
AnINVALID_OPERATION error is generated if sampler is not the name of
a sampler object previously returned from a call to GenSamplers.
An INVALID_ENUM error is generated if pname is not one of the sampler
state names in table 23.18.
8.4 Pixel Rectangles
Rectangles of color, depth, and certain other values may be speci?ed to the GL
using TexImage*D (see section 8.5). Some of the parameters and operations
governing the operation of these commands are shared by ReadPixels (used to
obtain pixel values from the framebuffer); the discussion of ReadPixels, how-
ever, is deferred until chapter 9 after the framebuffer has been discussed in detail.
Nevertheless, we note in this section when parameters and state pertaining to these
commands also pertain to ReadPixels.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 189
Parameter Name Type Initial Value Valid Range
UNPACK_SWAP_BYTES boolean FALSE TRUE/FALSE
UNPACK_LSB_FIRST boolean FALSE TRUE/FALSE
UNPACK_ROW_LENGTH integer 0 [0;1)
UNPACK_SKIP_ROWS integer 0 [0;1)
UNPACK_SKIP_PIXELS integer 0 [0;1)
UNPACK_ALIGNMENT integer 4 1,2,4,8
UNPACK_IMAGE_HEIGHT integer 0 [0;1)
UNPACK_SKIP_IMAGES integer 0 [0;1)
UNPACK_COMPRESSED_BLOCK_WIDTH integer 0 [0;1)
UNPACK_COMPRESSED_BLOCK_HEIGHT integer 0 [0;1)
UNPACK_COMPRESSED_BLOCK_DEPTH integer 0 [0;1)
UNPACK_COMPRESSED_BLOCK_SIZE integer 0 [0;1)
Table 8.1: PixelStore* parameters pertaining to one or more of TexImage*D,
TexSubImage*D, CompressedTexImage*D and CompressedTexSubImage*D.
A number of parameters control the encoding of pixels in buffer object or client
memory (for reading and writing) and how pixels are processed before being placed
in or after being read from the framebuffer (for reading, writing, and copying).
These parameters are set with PixelStore*.
8.4.1 Pixel Storage Modes and Pixel Buffer Objects
Pixel storage modes affect the operation of TexImage*D, TexSubImage*D, Com-
pressedTexImage*D, CompressedTexSubImage*D, and ReadPixels when one
of these commands is issued. Pixel storage modes are set with
void PixelStorefifg(enum pname,T param );
pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Tables 8.1 and 18.1 summarize the pixel storage parameters, their
types, their initial values, and their allowable ranges.
Errors
AnINVALID_ENUM error is generated if pname is not one of the paramater
names in table 8.1 or 18.1.
AnINVALID_VALUE error is generated if param is outside the given range
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 190
for the corresponding pname in table 8.1 or 18.1.
Data conversions are performed as speci?ed in section 2.2.1.
In addition to storing pixel data in client memory, pixel data may also be
stored in buffer objects (described in section 6). The current pixel unpack and
pack buffer objects are designated by thePIXEL_UNPACK_BUFFER andPIXEL_-
PACK_BUFFER targets respectively.
Initially, zero is bound for the PIXEL_UNPACK_BUFFER, indicating that im-
age speci?cation commands such as TexImage*D source their pixels from client
memory pointer parameters. However, if a non-zero buffer object is bound as the
current pixel unpack buffer, then the pointer parameter is treated as an offset into
the designated buffer object.
8.4.2
This subsection is only de?ned in the compatibility pro?le.
8.4.3
This subsection is only de?ned in the compatibility pro?le.
8.4.4 Transfer of Pixel Rectangles
The process of transferring pixels encoded in buffer object or client memory is
diagrammed in ?gure 8.1. We describe the stages of this process in the order in
which they occur.
Commands accepting or returning pixel rectangles take the following argu-
ments (as well as additional arguments speci?c to their function):
format is a symbolic constant indicating what the values in memory represent.
width and height are the width and height, respectively, of the pixel rectangle
to be transferred.
data refers to the data to be drawn. These data are represented with one of
several GL data types, speci?ed by type. The correspondence between the type
token values and the GL data types they indicate is given in table 8.2.
Not all combinations of format and type are valid.
Errors
An INVALID_OPERATION error is generated if format is one of the
INTEGER component formats de?ned in table 8.3 and type is one of the
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 191
byte, short, int, float, or packed
pixel component data stream
Unpack
Pixel Storage
Operations
Convert to Float
Expansion to
RGBA
RGBA pixel data out
Figure 8.1. Transfer of pixel rectangles to the GL. Output is RGBA pixels. Depth
and stencil pixel paths are not shown.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 192
?oating-point types de?ned in table 8.2.
Some additional constraints on the combinations of format and type values
that are accepted are discussed below. Additional restrictions may be imposed by
speci?c commands.
8.4.4.1 Unpacking
Data are taken from the currently bound pixel unpack buffer or client memory as a
sequence of signed or unsigned bytes (GL data typesbyte andubyte), signed or
unsigned short integers (GL data typesshort andushort), signed or unsigned
integers (GL data types int and uint), or ?oating-point values (GL data types
half and float). These elements are grouped into sets of one, two, three, or
four values, depending on the format, to form a group. Table 8.3 summarizes the
format of groups obtained from memory; it also indicates those formats that yield
indices and those that yield ?oating-point or integer components.
If a pixel unpack buffer is bound (as indicated by a non-zero value ofPIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and
the pixels are unpacked from the buffer relative to this offset; otherwise, data is a
pointer to client memory and the pixels are unpacked from client memory relative
to the pointer.
Errors
An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
ject is bound and unpacking the pixel data according to the process described
below would access memory beyond the size of the pixel unpack buffer’s
memory size.
An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
ject is bound and data is not evenly divisible by the number of basic machine
units needed to store in memory the corresponding GL data type from table 8.2
for the type parameter (or not evenly divisible by 4 for type FLOAT_32_-
UNSIGNED_INT_24_8_REV, which does not have a corresponding GL data
type).
By default the values of each GL data type are interpreted as they would be
speci?ed in the language of the client’s GL binding. If UNPACK_SWAP_BYTES is
enabled, however, then the values are interpreted with the bit orderings modi?ed
as per table 8.4. The modi?ed bit orderings are de?ned only if the GL data type
ubyte has eight bits, and then for each speci?c GL data type only if that type is
represented with 8, 16, or 32 bits.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 193
type Parameter Corresponding Special Floating-
Token Name GL Data Type Interpretation Point
UNSIGNED_BYTE ubyte No No
BYTE byte No No
UNSIGNED_SHORT ushort No No
SHORT short No No
UNSIGNED_INT uint No No
INT int No No
HALF_FLOAT half No Yes
FLOAT float No Yes
UNSIGNED_BYTE_3_3_2 ubyte Yes No
UNSIGNED_BYTE_2_3_3_REV ubyte Yes No
UNSIGNED_SHORT_5_6_5 ushort Yes No
UNSIGNED_SHORT_5_6_5_REV ushort Yes No
UNSIGNED_SHORT_4_4_4_4 ushort Yes No
UNSIGNED_SHORT_4_4_4_4_REV ushort Yes No
UNSIGNED_SHORT_5_5_5_1 ushort Yes No
UNSIGNED_SHORT_1_5_5_5_REV ushort Yes No
UNSIGNED_INT_8_8_8_8 uint Yes No
UNSIGNED_INT_8_8_8_8_REV uint Yes No
UNSIGNED_INT_10_10_10_2 uint Yes No
UNSIGNED_INT_2_10_10_10_REV uint Yes No
UNSIGNED_INT_24_8 uint Yes No
UNSIGNED_INT_10F_11F_11F_REV uint Yes Yes
UNSIGNED_INT_5_9_9_9_REV uint Yes Yes
FLOAT_32_UNSIGNED_INT_24_8_REV n/a Yes No
Table 8.2: Pixel data type parameter values and the corresponding GL data types.
Refer to table 2.2 for de?nitions of GL data types. Special interpretations are
described in section 8.4.4.2. Floating-point types are incompatible withINTEGER
formats as described above.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 194
Format Name Element Meaning and Order Target Buffer
STENCIL_INDEX Stencil Index Stencil
DEPTH_COMPONENT Depth Depth
DEPTH_STENCIL Depth and Stencil Index Depth and Stencil
RED R Color
GREEN G Color
BLUE B Color
RG R, G Color
RGB R, G, B Color
RGBA R, G, B, A Color
BGR B, G, R Color
BGRA B, G, R, A Color
RED_INTEGER iR Color
GREEN_INTEGER iG Color
BLUE_INTEGER iB Color
RG_INTEGER iR, iG Color
RGB_INTEGER iR, iG, iB Color
RGBA_INTEGER iR, iG, iB, iA Color
BGR_INTEGER iB, iG, iR Color
BGRA_INTEGER iB, iG, iR, iA Color
Table 8.3: Pixel data formats. The second column gives a description of and the
number and order of elements in a group. Unless speci?ed as an index, formats
yield components. Components are ?oating-point unless pre?xed with the letter
’i’, which indicates they are integer.
Element Size Default Bit Ordering Modi?ed Bit Ordering
8 bit [7::0] [7::0]
16 bit [15::0] [7::0][15::8]
32 bit [31::0] [7::0][15::8][23::16][31::24]
Table 8.4: Bit ordering modi?cation of elements when UNPACK_SWAP_BYTES is
enabled. These reorderings are de?ned only when GL data typeubyte has 8 bits,
and then only for GL data types with 8, 16, or 32 bits. Bit 0 is the least signi?cant.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 195
The groups in memory are treated as being arranged in a rectangle. This rect-
angle consists of a series of rows, with the ?rst element of the ?rst group of the
?rst row pointed to by data. If the value ofUNPACK_ROW_LENGTH is zero, then the
number of groups in a row is width; otherwise the number of groups is the value of
UNPACK_ROW_LENGTH. Ifp indicates the location in memory of the ?rst element
of the ?rst row, then the ?rst element of theNth row is indicated by
p +Nk (8.1)
whereN is the row number (counting from zero) andk is de?ned as

nl sa;
 
k = (8.2)
a snl
s<a
s a
wheren is the number of elements in a group,l is the number of groups in the row,
a is the value ofUNPACK_ALIGNMENT, ands is the size, in units of GLubytes, of
an element. If the number of bits per element is not 1, 2, 4, or 8 times the number
of bits in a GLubyte, thenk =nl for all values ofa.
There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK_ROW_LENGTH, UNPACK_SKIP_ROWS, and UNPACK_SKIP_PIXELS. Be-
fore obtaining the ?rst group from memory, the data pointer is advanced by
(UNPACK_SKIP_PIXELS)n + (UNPACK_SKIP_ROWS)k elements. Then width
groups are obtained from contiguous elements in memory (without advancing the
pointer), after which the pointer is advanced byk elements. height sets of width
groups of values are obtained this way. See ?gure 8.2.
8.4.4.2 Special Interpretations
A type matching one of the types in table 8.5 is a special case in which all the
components of each group are packed into a single unsigned byte, unsigned short,
or unsigned int, depending on the type. If type is FLOAT_32_UNSIGNED_INT_-
24_8_REV, the components of each group are contained within two 32-bit words;
the ?rst word contains the ?oat component, and the second word contains a packed
24-bit unused ?eld, followed by an 8-bit index. The number of components per
packed pixel is ?xed by the type, and must match the number of components per
group indicated by the format parameter, as listed in table 8.5.
Errors
AnINVALID_OPERATION error is generated by any command processing
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 196
ROW_LENGTH
                   
                   
                   
                   
      subimage             
                   
                   
SKIP_PIXELS
                   
SKIP_ROWS
Figure 8.2. Selecting a subimage from an image. The indicated parameter names
are pre?xed byUNPACK_ for TexImage* and byPACK_ for ReadPixels.
pixel rectangles if a mismatch occurs.
Bit?eld locations of the ?rst, second, third, and fourth components of each
packed pixel type are illustrated in tables 8.6- 8.9. Each bit?eld is interpreted as an
unsigned integer value.
Components are normally packed with the ?rst component in the most signif-
icant bits of the bit?eld, and successive components occupying progressively less
signi?cant locations. Types whose token names end with_REV reverse the compo-
nent packing order from least to most signi?cant locations. In all cases, the most
signi?cant bit of each component is packed in the most signi?cant bit location of
its location in the bit?eld.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 197
type Parameter GL Data Number of Matching
Token Name Type Components Pixel Formats
UNSIGNED_BYTE_3_3_2 ubyte 3 RGB,RGB_INTEGER
UNSIGNED_BYTE_2_3_3_REV ubyte 3 RGB,RGB_INTEGER
UNSIGNED_SHORT_5_6_5 ushort 3 RGB,RGB_INTEGER
UNSIGNED_SHORT_5_6_5_REV ushort 3 RGB,RGB_INTEGER
UNSIGNED_SHORT_4_4_4_4 ushort 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_SHORT_4_4_4_4_REV ushort 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_SHORT_5_5_5_1 ushort 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_SHORT_1_5_5_5_REV ushort 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_INT_8_8_8_8 uint 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_INT_8_8_8_8_REV uint 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_INT_10_10_10_2 uint 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_INT_2_10_10_10_REV uint 4 RGBA, BGRA, RGBA_-
INTEGER, BGRA_-
INTEGER
UNSIGNED_INT_24_8 uint 2 DEPTH_STENCIL
UNSIGNED_INT_10F_11F_11F_REV uint 3 RGB
UNSIGNED_INT_5_9_9_9_REV uint 4 RGB
FLOAT_32_UNSIGNED_INT_24_8_REV n/a 2 DEPTH_STENCIL
Table 8.5: Packed pixel formats.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 198
UNSIGNED_BYTE_3_3_2:
7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED_BYTE_2_3_3_REV:
7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
Table 8.6: UNSIGNED_BYTE formats. Bit numbers are indicated for each compo-
nent.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 199
UNSIGNED_SHORT_5_6_5:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED_SHORT_5_6_5_REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
UNSIGNED_SHORT_4_4_4_4:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_SHORT_4_4_4_4_REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED_SHORT_5_5_5_1:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_SHORT_1_5_5_5_REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table 8.7: UNSIGNED_SHORT formats
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 200
UNSIGNED_INT_8_8_8_8:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_INT_8_8_8_8_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED_INT_10_10_10_2:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_INT_2_10_10_10_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED_INT_24_8:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd
UNSIGNED_INT_10F_11F_11F_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
UNSIGNED_INT_5_9_9_9_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table 8.8: UNSIGNED_INT formats
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 201
FLOAT_32_UNSIGNED_INT_24_8_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
Unused 2nd
Table 8.9: FLOAT_UNSIGNED_INT formats
OpenGL 4.6 (Core Pro?le) - February 2, 20198.4. PIXELRECTANGLES 202
Format First Second Third Fourth
Component Component Component Component
RGB red green blue
RGBA red green blue alpha
BGRA blue green red alpha
DEPTH_STENCIL depth stencil
Table 8.10: Packed pixel ?eld assignments.
The assignment of components to ?elds in the packed pixel is as described in
table 8.10.
Byte swapping, if enabled, is performed before the components are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
of components per group is understood to be one.
A type ofUNSIGNED_INT_10F_11F_11F_REV and format ofRGB is a special
case in which the data are a series of GLuint values. Eachuint value speci?es
3 packed components as shown in table 8.8. The 1st, 2nd, and 3rd components are
calledf (11 bits),f (11 bits), andf (10 bits) respectively.
red green blue
f and f are treated as unsigned 11-bit ?oating-point values and con-
red green
verted to ?oating-point red and green components respectively as described in sec-
tion 2.3.4.3. f is treated as an unsigned 10-bit ?oating-point value and con-
blue
verted to a ?oating-point blue component as described in section 2.3.4.4.
A type ofUNSIGNED_INT_5_9_9_9_REV and format ofRGB is a special case
in which the data are a series of GL uint values. Each uint value speci?es 4
packed components as shown in table 8.8. The 1st, 2nd, 3rd, and 4th components
are called p , p , p , and p respectively and are treated as unsigned
red green blue exp
integers. These are then used to compute ?oating-pointRGB components (ignoring
the “Conversion to ?oating-point” section below in this case) as follows:
p  B N
exp
red =p 2
red
p  B N
exp
green =p 2
green
p  B N
exp
blue =p 2
blue
whereB = 15 (the exponent bias) andN = 9 (the number of mantissa bits).
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 203
8.4.4.3 Conversion to ?oating-point
This step applies only to groups of ?oating-point components. It is not performed
on indices or integer components. For groups containing both components and
indices, such asDEPTH_STENCIL, the indices are not converted.
Each element in a group is converted to a ?oating-point value. For unsigned
or signed normalized ?xed-point elements, equations 2.1 or 2.2, respectively, are
used.
8.4.4.4 Final Expansion to RGBA
This step is performed only for non-depth component groups. Each group is con-
verted to a group of 4 elements as follows: if a group does not contain an A element,
then A is added and set to one for integer components or 1.0 for ?oating-point com-
ponents. If any of R, G, or B is missing from the group, each missing element is
added and assigned a value of 0 for integer components or 0.0 for ?oating-point
components.
8.4.5
This subsection is only de?ned in the compatibility pro?le.
8.5 Texture Image Specification
The command
void TexImage3D(enum target,int level,int internalformat,
sizei width,sizei height,sizei depth,int border,
enum format,enum type,const void *data );
is used to specify a three-dimensional texture image. target must be one of
TEXTURE_3D for a three-dimensional texture, TEXTURE_2D_ARRAY for a two-
dimensional array texture, or TEXTURE_CUBE_MAP_ARRAY for a cube map ar-
ray texture. Additionally, target may be either PROXY_TEXTURE_3D for a three-
dimensional proxy texture, PROXY_TEXTURE_2D_ARRAY for a two-dimensional
proxy array texture, orPROXY_TEXTURE_CUBE_MAP_ARRAY for a cube map array
texture, as discussed in section 8.22. format, type, and data specify the format of
the image data, the type of those data, and a reference to the image data in the cur-
rently bound pixel unpack buffer or client memory, as described in section 8.4.4.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 204
The groups in memory are treated as being arranged in a sequence of adjacent
rectangles. Each rectangle is a two-dimensional image, whose size and organiza-
tion are speci?ed by the width and height parameters to TexImage3D. The val-
ues of UNPACK_ROW_LENGTH and UNPACK_ALIGNMENT control the row-to-row
spacing in these images as described in section 8.4.4. If the value of the integer
parameter UNPACK_IMAGE_HEIGHT is not positive, then the number of rows in
each two-dimensional image is height; otherwise the number of rows isUNPACK_-
IMAGE_HEIGHT. Each two-dimensional image comprises an integral number of
rows, and is exactly adjacent to its neighbor images.
The mechanism for selecting a sub-volume of a three-dimensional image relies
on the integer parameter UNPACK_SKIP_IMAGES. If UNPACK_SKIP_IMAGES is
positive, the pointer is advanced by UNPACK_SKIP_IMAGES times the number of
elements in one two-dimensional image before obtaining the ?rst group from mem-
ory. Then depth two-dimensional images are processed, each having a subimage
extracted as described in section 8.4.4.
The selected groups are transferred to the GL as described in section 8.4.4 and
then clamped to the representable range of the internal format as follows:
 If the internalformat of the texture is signed or unsigned integer, components
n 1 n 1 n
are clamped to [ 2 ; 2   1] or [0; 2   1], respectively, wheren is the
number of bits per component.
 For color component groups, if the internalformat of the texture is signed or
unsigned normalized ?xed-point:
– If the type of the data is a ?oating-point type (as de?ned in table 8.2),
it is clamped to [ 1; 1] or [0; 1], respectively.
n 1 n 1 n
– Otherwise, it is clamped to to [ 2 ; 2   1] or [0; 2   1], respec-
tively, wheren is the number of bits in the normalized representation.
 For depth component groups, the depth value is clamped to [0; 1].
n
 Stencil index values are masked by 2   1, wheren is the number of stencil
bits in the internal format resolution (see below).
 Otherwise, values are not modi?ed.
If the base internal format is DEPTH_STENCIL and format is not DEPTH_-
STENCIL, then the values of the stencil index texture components are unde?ned.
Components are then selected from the resulting R, G, B, A, depth, or stencil
values to obtain a texture with the base internal format speci?ed by (or derived
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 205
Base Internal Format RGBA, Depth, and Stencil Values Internal Components
DEPTH_COMPONENT Depth D
DEPTH_STENCIL Depth,Stencil D,S
RED R R
RG R,G R,G
RGB R,G,B R,G,B
RGBA R,G,B,A R,G,B,A
STENCIL_INDEX Stencil S
Table 8.11: Conversion from RGBA, depth, and stencil pixel components to inter-
nal texture components. Texture componentsR,G,B, andA are converted back
to RGBA colors during ?ltering as shown in table 15.1.
from) internalformat. Table 8.11 summarizes the mapping of R, G, B, A, depth,
or stencil values to texture components, as a function of the base internal format
of the texture image. internalformat may be speci?ed as one of the internal format
symbolic constants listed in table 8.11, as one of the sized internal format symbolic
constants listed in tables 8.12- 8.13, as one of the generic compressed internal
format symbolic constants listed in table 8.14, or as one of the speci?c compressed
internal format symbolic constants (if listed in table 8.14).
Textures with a base internal format of DEPTH_COMPONENT, DEPTH_-
STENCIL, or STENCIL_INDEX are supported by texture image speci?cation
commands only if target is TEXTURE_1D, TEXTURE_2D, TEXTURE_2D_-
MULTISAMPLE, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_-
2D_MULTISAMPLE_ARRAY, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP,
TEXTURE_CUBE_MAP_ARRAY, PROXY_TEXTURE_1D, PROXY_TEXTURE_-
2D, PROXY_TEXTURE_2D_MULTISAMPLE, PROXY_TEXTURE_1D_ARRAY,
PROXY_TEXTURE_2D_ARRAY, PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY,
PROXY_TEXTURE_RECTANGLE, PROXY_TEXTURE_CUBE_MAP, or PROXY_-
TEXTURE_CUBE_MAP_ARRAY.
AnINVALID_OPERATION error is generated if these formats are used in con-
junction with any other target.
Textures with a base internal format of DEPTH_COMPONENT or DEPTH_-
STENCIL require either depth component data or depth/stencil component data.
Textures with other base internal formats require RGBA component data.
Textures with integer internal formats (see table 8.12) require integer data.
In addition to the speci?c compressed internal formats listed in table 8.14, the
GL provides a mechanism to query token values for speci?c compressed internal
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 206
2
formats, suitable for general-purpose usage. Formats with restrictions that need to
be speci?cally understood prior to use will not be returned by this query. The num-
ber of speci?c compressed internal formats is obtained by querying the value of
NUM_COMPRESSED_TEXTURE_FORMATS. The set of speci?c compressed internal
formats is obtained by queryingCOMPRESSED_TEXTURE_FORMATS with GetInte-
gerv, returning an array containing that number of values.
Generic compressed internal formats are never used directly as the internal for-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a speci?c com-
pressed internal format of the GL’s choosing with the same base internal format.
If no speci?c compressed format is available, internalformat is instead replaced by
the corresponding base internal format. If internalformat is given as or mapped
to a speci?c compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
might not support 3D textures), internalformat is replaced by the corresponding
base internal format and the texture image will not be compressed by the GL.
The internal component resolution is the number of bits allocated to each value
in a texture image. If internalformat is speci?ed as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing, referred to as the effective internal format. The effective internal format chosen
may change depending only on the values of format and type, and affects format
compatibility for commands such as TextureView (see section 8.18) and Copy-
ImageSubData (see section 18.3.2). If a sized internal format is speci?ed, the
mapping of the R, G, B, A, depth, and stencil values to texture components is
equivalent to the mapping of the corresponding base internal format’s components,
as speci?ed in table 8.11; the type (unsigned int, ?oat, etc.) is assigned the same
type speci?ed by internalformat; and the memory allocation per texture component
is assigned by the GL to match the allocations listed in tables 8.12- 8.13 as closely
as possible. (The de?nition of closely is left up to the implementation. However,
a non-zero number of bits must be allocated for each component whose desired
allocation in tables 8.12- 8.13 is non-zero, and zero bits must be allocated for all
other components).
8.5.1 Required Texture Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, ?oat, etc.) for each base internal
format.
2
These queries have been deprecated in OpenGL 4.2, because the vagueness of the term “general-
purpose” makes it possible for implementations to choose to return no formats from the query.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 207
In addition, implementations are required to support the following sized and
compressed internal formats. Requesting one of these sized internal formats for
any texture type will allocate at least the internal component sizes, and exactly the
component types shown for that format in the corresponding table:
 Color formats which are checked in the “Req. tex.” column of table 8.12.
 All of the speci?c compressed texture formats in table 8.14.
 Depth, depth+stencil, and stencil formats which are checked in the “Req.
format” column of table 8.13.
8.5.2 Encoding of Special Internal Formats
If internalformat isR11F_G11F_B10F, the red, green, and blue bits are converted
to unsigned 11-bit, unsigned 11-bit, and unsigned 10-bit ?oating-point values as
described in sections 2.3.4.3 and 2.3.4.4.
If internalformat is RGB9_E5, the red, green, and blue bits are converted to a
shared exponent format according to the following procedure:
Componentsred,green, andblue are ?rst clamped (in the process, mapping
NaN to zero) as follows:
red = max(0;min(sharedexp ;red))
c max
green = max(0;min(sharedexp ;green))
c max
blue = max(0;min(sharedexp ;blue))
c max
where
N
(2   1)
E  B
max
sharedexp = 2 :
max
N
2
N is the number of mantissa bits per component (9),B is the exponent bias (15),
andE is the maximum allowed biased exponent value (31).
max
The largest clamped component,max , is determined:
c
max = max(red ;green ;blue )
c c c c
A preliminary shared exponentexp is computed:
p
exp = max( B  1;blog (max )c) + 1 +B
p c
2
A re?ned shared exponentexp is computed:
s
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 208
 
max 1
c
max = +
s
exp  B N
p
2 2
(
N
exp ; 0max < 2
p s
exp =
s
N
exp + 1; max = 2
p s
N
Finally, three integer values in the range 0 to 2   1 are computed:
 
red 1
c
red = +
s
exp B N
s
2 2
 
green 1
c
green = +
s
exps B N
2 2
 
blue 1
c
blue = +
s
exp B N
s
2 2
The resultingred ,green ,blue , andexp are stored in the red, green, blue,
s s s s
and shared bits respectively of the texture image.
An implementation accepting pixel data of typeUNSIGNED_INT_5_9_9_9_-
REV with formatRGB is allowed to store the components “as is”.
Sized Base Bits/component CR Req. Req.
Internal Internal S are shared bits rend. tex.
Format Format R G B A S
R8 RED 8   
R8_SNORM RED s8  
R16 RED 16   
R16_SNORM RED s16  
RG8 RG 8 8   
RG8_SNORM RG s8 s8  
RG16 RG 16 16   
RG16_SNORM RG s16 s16  
R3_G3_B2 RGB 3 3 2  
RGB4 RGB 4 4 4  
RGB5 RGB 5 5 5  
RGB565 RGB 5 6 5   
RGB8 RGB 8 8 8  
Sized internal color formats continued on next page
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 209
Sized internal color formats continued from previous page
Sized Base Bits/component CR Req. Req.
Internal Internal S are shared bits rend. tex.
Format Format R G B A S
RGB8_SNORM RGB s8 s8 s8  
RGB10 RGB 10 10 10  
RGB12 RGB 12 12 12  
RGB16 RGB 16 16 16  
RGB16_SNORM RGB s16 s16 s16  
RGBA2 RGBA 2 2 2 2  
RGBA4 RGBA 4 4 4 4   
RGB5_A1 RGBA 5 5 5 1   
RGBA8 RGBA 8 8 8 8   
RGBA8_SNORM RGBA s8 s8 s8 s8  
RGB10_A2 RGBA 10 10 10 2   
RGB10_A2UI RGBA ui10 ui10 ui10 ui2   
RGBA12 RGBA 12 12 12 12  
RGBA16 RGBA 16 16 16 16   
RGBA16_SNORM RGBA s16 s16 s16 s16  
SRGB8 RGB 8 8 8  
SRGB8_ALPHA8 RGBA 8 8 8 8   
R16F RED f16   
RG16F RG f16 f16   
RGB16F RGB f16 f16 f16  
RGBA16F RGBA f16 f16 f16 f16   
R32F RED f32   
RG32F RG f32 f32   
RGB32F RGB f32 f32 f32  
RGBA32F RGBA f32 f32 f32 f32   
R11F_G11F_B10F RGB f11 f11 f10   
RGB9_E5 RGB 9 9 9 5 
R8I RED i8   
R8UI RED ui8   
R16I RED i16   
R16UI RED ui16   
R32I RED i32   
R32UI RED ui32   
Sized internal color formats continued on next page
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 210
Sized internal color formats continued from previous page
Sized Base Bits/component CR Req. Req.
Internal Internal S are shared bits rend. tex.
Format Format R G B A S
RG8I RG i8 i8   
RG8UI RG ui8 ui8   
RG16I RG i16 i16   
RG16UI RG ui16 ui16   
RG32I RG i32 i32   
RG32UI RG ui32 ui32   
RGB8I RGB i8 i8 i8  
RGB8UI RGB ui8 ui8 ui8  
RGB16I RGB i16 i16 i16  
RGB16UI RGB ui16 ui16 ui16  
RGB32I RGB i32 i32 i32  
RGB32UI RGB ui32 ui32 ui32  
RGBA8I RGBA i8 i8 i8 i8   
RGBA8UI RGBA ui8 ui8 ui8 ui8   
RGBA16I RGBA i16 i16 i16 i16   
RGBA16UI RGBA ui16 ui16 ui16 ui16   
RGBA32I RGBA i32 i32 i32 i32   
RGBA32UI RGBA ui32 ui32 ui32 ui32   
Table 8.12: Correspondence of sized internal color formats to base
internal formats, internal data type, and desired component reso-
lutions for each sized internal format. The component resolution
pre?x indicates the internal data type: f is ?oating-point, i is signed
integer, ui is unsigned integer, s is signed normalized ?xed-point,
and no pre?x is unsigned normalized ?xed-point. The “CR”, “Req.
tex.”, and “Req. rend.” columns are described in sections 9.4,
8.5.1, and 9.2.5, respectively.
If a compressed internal format is speci?ed, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internal format’s components, as speci?ed in table 8.11. The speci?ed image
is compressed using a (possibly lossy) compression algorithm chosen by the GL.
A GL implementation may vary its allocation of internal component resolution
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 211
Sized Base Internal D S Req.
Internal Format Format bits bits format
DEPTH_COMPONENT16 DEPTH_COMPONENT 16 
DEPTH_COMPONENT24 DEPTH_COMPONENT 24 
DEPTH_COMPONENT32 DEPTH_COMPONENT 32
DEPTH_COMPONENT32F DEPTH_COMPONENT f32 
DEPTH24_STENCIL8 DEPTH_STENCIL 24 ui8 
DEPTH32F_STENCIL8 DEPTH_STENCIL f32 ui8 
STENCIL_INDEX1 STENCIL_INDEX ui1
STENCIL_INDEX4 STENCIL_INDEX ui4
STENCIL_INDEX8 STENCIL_INDEX ui8 
STENCIL_INDEX16 STENCIL_INDEX ui16
Table 8.13: Correspondence of sized internal depth and stencil formats to base
internal formats, internal data type, and desired component resolutions for each
sized internal format. The component resolution pre?x indicates the internal data
type: f is ?oating-point, i is signed integer, ui is unsigned integer, and no pre?x is
?xed-point. The “Req. format” column is described in section 8.5.1.
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low), or TexImage1D (see below) parameter (except target), but the allocation and
chosen compressed image format must not be a function of any other state and can-
not be changed once they are established. In addition, the choice of a compressed
image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each
time a texture image is speci?ed with the same parameter values. These allocation
rules also apply to proxy textures, which are described in section 8.22.
8.5.3 Texture Image Structure
The texture image itself (referred to by data) is a sequence of groups of values.
The ?rst group is the lower left back corner of the texture image. Subsequent
groups ?ll out rows of width width from left to right; height rows are stacked from
bottom to top forming a single two-dimensional image slice; and depth slices are
stacked from back to front. When the ?nal R, G, B, and A components have been
computed for a group, they are assigned to components of a texel as described by
table 8.11. Counting from zero, each resultingnth texel is assigned internal integer
coordinates (i;j;k), where
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 212
Compressed Internal Base Internal Type Border
Format Format Type
COMPRESSED_RED RED Generic unorm
COMPRESSED_RG RG Generic unorm
COMPRESSED_RGB RGB Generic unorm
COMPRESSED_RGBA RGBA Generic unorm
COMPRESSED_SRGB RGB Generic unorm
COMPRESSED_SRGB_ALPHA RGBA Generic unorm
COMPRESSED_RED_RGTC1 RED Speci?c unorm
COMPRESSED_SIGNED_RED_RGTC1 RED Speci?c snorm
COMPRESSED_RG_RGTC2 RG Speci?c unorm
COMPRESSED_SIGNED_RG_RGTC2 RG Speci?c snorm
COMPRESSED_RGBA_BPTC_UNORM RGBA Speci?c unorm
COMPRESSED_SRGB_ALPHA_BPTC_- RGBA Speci?c unorm
UNORM
COMPRESSED_RGB_BPTC_SIGNED_- RGB Speci?c ?oat
FLOAT
COMPRESSED_RGB_BPTC_UNSIGNED_- RGB Speci?c ?oat
FLOAT
COMPRESSED_RGB8_ETC2 RGB Speci?c unorm
COMPRESSED_SRGB8_ETC2 RGB Speci?c unorm
COMPRESSED_RGB8_PUNCHTHROUGH_- RGB Speci?c unorm
ALPHA1_ETC2
COMPRESSED_SRGB8_- RGB Speci?c unorm
PUNCHTHROUGH_ALPHA1_ETC2
COMPRESSED_RGBA8_ETC2_EAC RGBA Speci?c unorm
COMPRESSED_SRGB8_ALPHA8_ETC2_- RGBA Speci?c unorm
EAC
COMPRESSED_R11_EAC RED Speci?c unorm
COMPRESSED_SIGNED_R11_EAC RED Speci?c snorm
COMPRESSED_RG11_EAC RG Speci?c unorm
COMPRESSED_SIGNED_RG11_EAC RG Speci?c snorm
Table 8.14: Generic and speci?c compressed internal formats. Speci?c formats are
described in appendix D. The “Border Type” ?eld determines how border colors
are clamped, as described in section 8.14.2.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 213
i =n modwidth
j k 
n
j = modheight
width
  
n
k = moddepth
widthheight
Thus the last two-dimensional image slice of the three-dimensional image is in-
dexed with the highest value ofk.
When target isTEXTURE_CUBE_MAP_ARRAY, specifying a cube map array tex-
ture,k refers to a layer-face. The layer is given by
 
k
layer = ;
6
and the face is given by
face =k mod 6:
The face number corresponds to the cube map faces as shown in table 9.3.
If the internal data type of the texture image is signed or unsigned normalized
?xed-point, each color component is converted using equation 2.4 or 2.3, respec-
tively. If the internal type is ?oating-point or integer, components are clamped
to the representable range of the corresponding internal component, but are not
converted.
The level argument to TexImage3D is an integer level-of-detail number. Levels
of detail are discussed in section 8.14.3. The main texture image has a level-of-
detail number of zero. level must be zero or more.
w , h , and d are the speci?ed image width, height and depth respectively.
s s s
border must be zero.
The maximum allowable size, in any relevant dimension, of a texture image
is an implementation-dependent function of the texture target, the level-of-detail,
and the internal format of the image. For most texture types, it must satisfy the
relationship
k level
maxsize 2 (8.3)
for images of level-of-detail (level) 0 through k, where k is a texture target-
dependent maximum level-of-detail. The maximum size may be zero for any im-
ages wherelevel>k.
The maximum allowable width, height, or depth of a texture image for a three-
dimensional texture is determined by equation 8.3, wherek islog of the value of
2
MAX_3D_TEXTURE_SIZE.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 214
In a similar fashion, the maximum allowable width, or height for two-
dimensional texture types, of a texture image for a one- or two-dimensional, one-
or two-dimensional array, two-dimensional multisample, or two-dimensional mul-
tisample array texture is determined by equation 8.3, wherek islog of the value
2
ofMAX_TEXTURE_SIZE.
The maximum allowable width or height of a cube map or cube map array
texture image must be the same, and is determined by equation 8.3, wherek islog
2
of the value ofMAX_CUBE_MAP_TEXTURE_SIZE.
The maximum number of layers for one- and two-dimensional array textures
(height or depth, respectively), or the maximum number of layer-faces for cube
map array textures (depth), must be at least the value ofMAX_ARRAY_TEXTURE_-
LAYERS for all levels.
The maximum allowable width or height of a rectangle texture image must
each be at least the value of the implementation-dependent constant MAX_-
RECTANGLE_TEXTURE_SIZE.
As described in section 8.17, these implementation-dependent limits may be
con?gured to reject textures at level one or greater unless a mipmap complete set
of texture images consistent with the speci?ed sizes can be supported.
Regardless of the values of these implementation-dependent constants, an im-
plementation may not succeed in creating a texture of the maximum sizes due to
resource limits, resulting in memory exhaustion.
Errors
AnINVALID_ENUM error is generated if target is not one of the valid tar-
gets listed for each TexImage*D command.
AnINVALID_VALUE error is generated if level is negative.
AnINVALID_VALUE error is generated if width, height, or depth (if each
argument is present) is negative.
AnINVALID_VALUE error is generated if width, height, or depth (if each
argument is present) exceed the corresponding target-dependent maximum
size, as described above.
AnINVALID_VALUE error is generated ifw ,h , ord are negative.
s s s
An INVALID_VALUE error is generated by TexImage3D if target is
TEXTURE_CUBE_MAP_ARRAY or PROXY_TEXTURE_CUBE_MAP_ARRAY, and
width and height are not equal, or if depth is not a multiple of six, indicating
6N layer-faces in the cube map array.
AnINVALID_VALUE error is generated by TexImage2D if target is one of
the cube map face targets from table 8.19, and width and height are not equal.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 215
An INVALID_VALUE error is generated by TexImage2D if target is
TEXTURE_RECTANGLE and level is non-zero.
AnINVALID_VALUE error is generated if border is not zero.
AnINVALID_VALUE error is generated if internalformat is not one of the
valid values described above.
An INVALID_OPERATION error is generated if the internal format is in-
teger and format is not one of the integer formats listed in table 8.3, or if the
internal format is not integer and format is an integer format.
AnINVALID_OPERATION error is generated by TexImage3D if internal-
format is one of the EAC, ETC2, or RGTC compressed formats and either
border is non-zero, or target is notTEXTURE_2D_ARRAY.
AnINVALID_OPERATION error is generated by TexImage2D if internal-
format is one of the EAC, ETC2, or RGTC compressed formats and either
border is non-zero, or target is notTEXTURE_2D or one of the cube map face
targets from table 8.19.
AnINVALID_ENUM error is generated by CompressedTexImage1D if in-
ternalformat is one of the speci?c compressed formats. OpenGL de?nes no
speci?c one-dimensional compressed formats, but such formats may be pro-
vided by extensions.
An INVALID_OPERATION error is generated if one of the base internal
format and format isDEPTH_COMPONENT orDEPTH_STENCIL, and the other
is neither of these values.
An INVALID_OPERATION error is generated if format is STENCIL_-
INDEX and the base internal format is notSTENCIL_INDEX.
An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
ject is bound and storing texture data would access memory beyond the end of
the pixel unpack buffer.
The command
void TexImage2D(enum target,int level,int internalformat,
sizei width,sizei height,int border,enum format,
enum type,const void *data );
is used to specify a two-dimensional texture image. target must be one of
TEXTURE_2D for a two-dimensional texture, TEXTURE_1D_ARRAY for a one-
dimensional array texture, TEXTURE_RECTANGLE for a rectangle texture, or one
of the cube map face targets from table 8.19 for a cube map texture. Addi-
tionally, target may be either PROXY_TEXTURE_2D for a two-dimensional proxy
texture, PROXY_TEXTURE_1D_ARRAY for a one-dimensional proxy array tex-
ture, PROXY_TEXTURE_RECTANGLE for a rectangle proxy texture, or PROXY_-
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 216
TEXTURE_CUBE_MAP for a cube map proxy texture in the special case discussed
in section 8.22. The other parameters match the corresponding parameters of Tex-
Image3D.
For the purposes of decoding the texture image, TexImage2D is equivalent to
calling TexImage3D with corresponding arguments and depth of 1, except that
UNPACK_SKIP_IMAGES is ignored.
A two-dimensional or rectangle texture consists of a single two-dimensional
texture image. A cube map texture is a set of six two-dimensional texture images.
The six cube map texture face targets from table 8.19 form a single cube map tex-
ture. These targets each update the corresponding cube map face two-dimensional
texture image. Note that the cube map face targets are used when specifying, up-
dating, or querying one of a cube map’s six two-dimensional images, but when
binding to a cube map texture object (that is when the cube map is accessed as a
whole as opposed to a particular two-dimensional image), the TEXTURE_CUBE_-
MAP target is speci?ed.
Finally, the command
void TexImage1D(enum target,int level,
int internalformat,sizei width,int border,
enum format,enum type,const void *data );
is used to specify a one-dimensional texture image. target must be either
TEXTURE_1D, or PROXY_TEXTURE_1D in the special case discussed in sec-
tion 8.22.
For the purposes of decoding the texture image, TexImage1D is equivalent to
calling TexImage2D with corresponding arguments and height of 1.
The image indicated to the GL by the image pointer is decoded and copied into
the GL’s internal memory.
We shall refer to the decoded image as the texture image. A three-dimensional
texture image has width, height, and depth w , h , and d as de?ned in sec-
s s s
tion 8.5.3. A two-dimensional or rectangle texture image has depthd = 1, with
s
height h and width w as above. A one-dimensional texture image has depth
s s
d = 1, heighth = 1, and widthw as above.
s s s
An element (i;j;k) of the texture image is called a texel (for a two-dimensional
texture or one-dimensional array texture, k is irrelevant; for a one-dimensional
texture,j andk are both irrelevant). The texture value used in texturing a fragment
is determined by sampling the texture in a shader, but may not correspond to any
actual texel. See ?gure 8.3. If target is TEXTURE_CUBE_MAP_ARRAY, the texture
value is determined by (s;t;r;q) coordinates wheres,t, andr are de?ned to be the
same as for TEXTURE_CUBE_MAP andq is de?ned as the index of a speci?c cube
map in the cube map array.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.5. TEXTUREIMAGESPECIFICATION 217
5.0
4
1.0
3
?
2
t v j
?
1
0
0.0
?1
?1.0
?1 0 1 2 3 4 5 6 7 8
i
?1.0 u 9.0
0.0 s 1.0
Figure 8.3. A texture image and the coordinates used to access it. This is a two-
dimensional texture with width 8 and height 4. A one-dimensional texture would
consist of a single horizontal strip. and, values used in blending adjacent texels
to obtain a texture value are also shown.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 218
If the data argument of TexImage1D, TexImage2D, or TexImage3D isNULL,
and the pixel unpack buffer object is zero, a one-, two-, or three-dimensional tex-
ture image is created with the speci?ed target, level, internalformat, border, width,
height, and depth, but with unspeci?ed image contents. In this case no pixel values
are accessed in client memory, and no pixel processing is performed. Errors are
generated, however, exactly as though the data pointer were valid. Otherwise if
the pixel unpack buffer object is non-zero, the data argument is treated normally
to refer to the beginning of the pixel unpack buffer object’s data.
8.6 Alternate Texture Image Specification Commands
Two-dimensional and one-dimensional texture images may also be speci?ed us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existing texture images may be respeci?ed.
The command
void CopyTexImage2D(enum target,int level,
enum internalformat,int x,int y,sizei width,
sizei height,int border );
de?nes a two-dimensional texture image in exactly the manner of TexImage2D,
except that the image data are taken from the framebuffer rather than from client
memory. target must be one ofTEXTURE_2D,TEXTURE_1D_ARRAY,TEXTURE_-
RECTANGLE, or one of the cube map face targets from table 8.19. x, y, width,
and height correspond precisely to the corresponding arguments to ReadPixels
(refer to section 18.2); they specify the image’s width and height, and the lower
left (x;y) coordinates of the framebuffer region to be copied. The image is taken
from the framebuffer exactly as if these arguments were passed to CopyPixels
(see section 18.3) with argument type set to COLOR, DEPTH, DEPTH_STENCIL,
or STENCIL_INDEX, depending on internalformat, stopping after conversion of
depth values. RGBA data is taken from the current color buffer, while depth
component and stencil index data are taken from the depth and stencil buffers,
respectively.
Subsequent processing is identical to that described for TexImage2D, begin-
ning with clamping of the R, G, B, A, or depth values, and masking of the stencil
index values from the resulting pixel groups. Parameters level, internalformat, and
border are speci?ed using the same values, with the same meanings, as the corre-
sponding arguments of TexImage2D.
The constraints on width, height, and border are exactly those for the corre-
sponding arguments of TexImage2D.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 219
Errors
An INVALID_ENUM error is generated if target is not TEXTURE_2D,
TEXTURE_1D_ARRAY, TEXTURE_RECTANGLE, or one of the cube map face
targets from table 8.19.
An INVALID_ENUM error is generated if an invalid value is speci?ed for
internalformat.
An INVALID_VALUE error is generated if the target parameter to Copy-
TexImage2D is one of the six cube map two-dimensional image targets, and
width and height are not equal.
An INVALID_OPERATION error is generated under any of the following
conditions:
 if depth component data is required and no depth buffer is present
 if stencil index data is required and no stencil buffer is present
 if integer RGBA data is required and the format of the current color
buffer is not integer
 if ?oating- or ?xed-point RGBA data is required and the format of the
current color buffer is integer
 if the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for
the framebuffer attachment corresponding to the read buffer (see sec-
tion 18.2.1) is LINEAR (see section 9.2.3) and internalformat is one of
the sRGB formats in table 8.24
 if the value of FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for
the framebuffer attachment corresponding to the read buffer is SRGB
and internalformat is not one of the sRGB formats in table 8.24.
AnINVALID_VALUE error is generated if width or height is negative.
AnINVALID_FRAMEBUFFER_OPERATION error is generated if the object
bound to READ_FRAMEBUFFER_BINDING (see section 9) is not framebuffer
complete (as de?ned in section 9.4.2).
An INVALID_OPERATION error is generated if the object bound to
READ_FRAMEBUFFER_BINDING is framebuffer complete and its effective
value ofSAMPLE_BUFFERS (see section 9.2.3.1) is one.
The command
void CopyTexImage1D(enum target,int level,
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 220
enum internalformat,int x,int y,sizei width,
int border );
de?nes a one-dimensional texture image in exactly the manner of TexImage1D,
except that the image data are taken from the framebuffer, rather than from client
memory. Currently, target must be TEXTURE_1D. For the purposes of decoding
the texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D
with corresponding arguments and height of 1, except that the height of the image
is always 1, regardless of the value of border. level, internalformat and border
are speci?ed using the same values, with the same meanings, as the corresponding
arguments of TexImage1D. The constraints on width and border are exactly those
of the corresponding arguments of TexImage1D.
To respecify only a rectangular subregion of the texture image of a texture
object, use the commands
void TexSubImage3D(enum target,int level,int xoffset,
int yoffset,int zoffset,sizei width,sizei height,
sizei depth,enum format,enum type,const
void *data );
void TexSubImage2D(enum target,int level,int xoffset,
int yoffset,sizei width,sizei height,enum format,
enum type,const void *data );
void TexSubImage1D(enum target,int level,int xoffset,
sizei width,enum format,enum type,const
void *data );
void CopyTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,int x,int y,
sizei width,sizei height );
void CopyTexSubImage2D(enum target,int level,
int xoffset,int yoffset,int x,int y,sizei width,
sizei height );
void CopyTexSubImage1D(enum target,int level,
int xoffset,int x,int y,sizei width );
void TextureSubImage3D(uint texture,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth,enum format,enum type,
const void *pixels );
void TextureSubImage2D(uint texture,int level,
int xoffset,int yoffset,sizei width,sizei height,
enum format,enum type,const void *pixels );
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 221
void TextureSubImage1D(uint texture,int level,
int xoffset,sizei width,enum format,enum type,const
void *pixels );
void CopyTextureSubImage3D(uint texture,int level,
int xoffset,int yoffset,int zoffset,int x,int y,
sizei width,sizei height );
void CopyTextureSubImage2D(uint texture,int level,
int xoffset,int yoffset,int x,int y,sizei width,
sizei height );
void CopyTextureSubImage1D(uint texture,int level,
int xoffset,int x,int y,sizei width );
For *TexSubImage*, the texture object is that bound to target, For *Texture-
SubImage*, texture is the name of the texture object. target or the effective target
of texture (the value of TEXTURE_TARGET; see section 8.11.2) must match each
command as shown in table 8.15.
No change is made to the internalformat, width, height, depth, or border pa-
rameters of the speci?ed texture image, nor is any change made to texel values
outside the speci?ed subregion.
The level parameter of each command speci?es the level of the texture image
that is modi?ed.
TexSubImage*D and TextureSubImage*D arguments width, height, depth,
3
format, type, and data match the corresponding arguments to the corresponding
TexImage*D command (where those arguments exist), meaning that they accept
the same values, and have the same meanings. The exception is that a NULL data
pointer does not represent unspeci?ed image contents.
CopyTex*SubImage3D and CopyTex*SubImage2D arguments x, y, width,
and height match the corresponding arguments to CopyTexImage2D. Copy-
Tex*SubImage1D arguments x, y, and width match the corresponding arguments
to CopyTexImage1D.
Each of these commands interprets and processes pixel groups in exactly the
manner of its TexImage counterpart, except that the assignment of R, G, B, A,
depth, and stencil index pixel group values to the texture components is controlled
by the internalformat of the texture image, not by an argument to the command.
The same constraints and errors apply to the format argument of these commands
and the internalformat of the texture image being respeci?ed as apply to the format
and internalformat arguments of their TexImage counterparts.
3
For example, both TexSubImage2D and TextureSubImage2D correspond to TexImage2D for
purposes of this paragraph.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 222
Command Names Valid targets or effective texture targets
TexSubImage1D, TEXTURE_1D
CopyTexSubImage1D,
TextureSubImage1D,
CopyTextureSubImage1D
TexSubImage2D, TEXTURE_2D,
CopyTexSubImage2D, TEXTURE_1D_ARRAY,
TEXTURE_RECTANGLE or one of the
cube map face targets from table 8.19
TextureSubImage2D, TEXTURE_2D,
CopyTextureSubImage2D TEXTURE_1D_ARRAY or
TEXTURE_RECTANGLE
TexSubImage3D, TEXTURE_3D,
CopyTexSubImage3D, TEXTURE_2D_ARRAY or
TEXTURE_CUBE_MAP_ARRAY
TextureSubImage3D, TEXTURE_3D,
CopyTextureSubImage3D TEXTURE_2D_ARRAY,
TEXTURE_CUBE_MAP_ARRAY or
TEXTURE_CUBE_MAP
Table 8.15: Valid texture target parameters or effective texture targets for texture
subimage commands.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 223
Arguments xoffset, yoffset, and zoffset of Tex*SubImage3D and Copy-
Tex*SubImage3D specify the lower left back texel coordinates of a width-wide
by height-high by depth-deep rectangular subregion of the texture image. For cube
map array textures, zoffset is the ?rst layer-face to update, and depth is the num-
ber of layer-faces to update. For TextureSubImage3D and CopyTextureSubIm-
age3D only, texture may be a cube map texture. In this case, zoffset is interpreted
as specifying the cube map face for the corresponding layer in table 9.3 and depth
is the number of successive faces to update.
The depth argument associated with CopyTex*SubImage3D is always 1, be-
cause framebuffer memory is two-dimensional - only a portion of a single (s;t)
slice of a three-dimensional texture is replaced by these commands.
The subregion must lie within the bounds of the texture image. Ifw ,h , and
s s
d are the speci?ed width, height, and depth of the texture image (as described in
s
section 8.5.3);x,y, andz are the speci?ed xoffset, yoffset, and zoffset values; and
w,h, andd are the speci?ed width, height, and depth values; then it is an error if
any of the relationships in equations 8.4-8.6 are satis?ed.
x< 0; x +w>w (8.4)
s
y< 0; y +h>h (8.5)
s
z< 0; z +d>d (8.6)
s
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i;j;k], where
i =x + (n modw)
j k 
n
j =y + modh
w
  
n
k =z + modd
wh
Arguments xoffset and yoffset of Tex*SubImage2D and Copy-
Tex*SubImage2D specify the lower left texel coordinates of a width-wide
by height-high rectangular subregion of the texture image.
The subregion must lie within the bounds of the texture image, as described
above for TexSubImage3D. It is an error if any of the relationships in equa-
tions 8.4-8.5 are satis?ed.
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i;j], where
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 224
i =x + (n modw)
j k
n
j =y + ( modh)
w
The xoffset argument of Tex*SubImage1D and CopyTex*SubImage1D spec-
i?es the left texel coordinate of a width-wide subregion of the texture image.
The subregion must lie within the bounds of the texture image, as described
above for TexSubImage3D. It is an error if any of the relationships in equation 8.4
are satis?ed.
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i], where
i =x + (n modw)
Texture images with compressed internal formats may be stored in such a way
that it is not possible to modify an image with subimage commands without having
to decompress and recompress the texture image. Even if the image were modi?ed
in this manner, it may not be possible to preserve the contents of some of the tex-
els outside the region being modi?ed. To avoid these complications, the GL does
not support arbitrary modi?cations to texture images with compressed internal for-
mats. Calling any of the Tex*SubImage* or CopyTex*SubImage* commands
will generate an INVALID_OPERATION error if xoffset, yoffset, or zoffset is not
equal to zero. In addition, the contents of any texel outside the region modi?ed
by such a call are unde?ned. These restrictions may be relaxed for speci?c com-
pressed internal formats whose images are easily modi?ed.
If the internal format of the texture image being modi?ed is one of the spe-
ci?c compressed formats described in table 8.14, the texture is stored using the
corresponding compressed texture image encoding (see appendix D). Since such
images are easily edited along 4 4 texel boundaries, the limitations on subimage
location and size are relaxed for Tex*SubImage2D, Tex*SubImage3D, Copy-
Tex*SubImage2D, and CopyTex*SubImage3D. These commands will generate
anINVALID_OPERATION error if one of the following conditions occurs:
 width is not a multiple of four, width + xoset is not equal to the value of
TEXTURE_WIDTH, and either xoffset or yoffset is non-zero.
 height is not a multiple of four, height + yoset is not equal to the value of
TEXTURE_HEIGHT, and either xoffset or yoffset is non-zero.
 xoffset or yoffset is not a multiple of four.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.6. ALTERNATETEXTUREIMAGESPECIFICATIONCOMMANDS 225
The contents of any 4 4 block of texels of such a compressed texture im-
age that does not intersect the area being modi?ed are preserved during valid
Tex*SubImage* and Copy*TexSubImage* calls.
Errors
An INVALID_ENUM error is generated by *TexSubImage* if target does
not match the command, as shown in table 8.15.
An INVALID_OPERATION error is generated by *TextureSubImage* if
texture is not the name of an existing texture object.
An INVALID_OPERATION error is generated by *TextureSubImage* if
the effective target of texture does not match the command, as shown in ta-
ble 8.15.
AnINVALID_OPERATION error is generated by:
 *TextureSubImage3D if the effective target is TEXTURE_CUBE_MAP
orTEXTURE_CUBE_MAP_ARRAY
and the texture object is not cube complete (forTEXTURE_CUBE_MAP or cube
array complete (forTEXTURE_CUBE_MAP_ARRAY).
AnINVALID_VALUE error is generated if width, height, or depth (if each
argument is present) is negative.
AnINVALID_VALUE error is generated if level is negative or greater than
thelog of the maximum texture width, height, or depth.
2
An INVALID_VALUE error is generated if the effective target is
TEXTURE_RECTANGLE and level is not zero.
AnINVALID_VALUE error is generated if the speci?ed subregion does not
lie within the bounds of the texture image, as described above.
An INVALID_FRAMEBUFFER_OPERATION error is generated by Copy-
TexImage*D, CopyTexSubImage*D and CopyTextureSubImage*D if the
object bound toREAD_FRAMEBUFFER_BINDING is not framebuffer complete
(see section 9.4.2)
An INVALID_OPERATION error is generated by CopyTexImage*D,
CopyTexSubImage*D and CopyTextureSubImage*D if
 the read buffer isNONE, or
 the value ofREAD_FRAMEBUFFER_BINDING is non-zero, and
– the read buffer selects an attachment that has no image attached,
or
OpenGL 4.6 (Core Pro?le) - February 2, 20198.7. COMPRESSEDTEXTUREIMAGES 226
– the effective value of SAMPLE_BUFFERS for the read framebuffer
(see section 9.2.3.1) is one.
An INVALID_OPERATION error is generated by *TexSubImage2D and
*TextureSubImage2D if internalformat is one of the EAC, ETC2, or RGTC
formats and the effective target isTEXTURE_RECTANGLE.
8.6.1 Texture Copying Feedback Loops
Calling any of the CopyTex*SubImage* or CopyTexImage* commands will re-
sult in unde?ned behavior if the destination texture image level is also bound to to
the selected read buffer (see section 18.2.1) of the read framebuffer. This situation
is discussed in more detail in the description of feedback loops in section 9.3.2.
8.7 Compressed Texture Images
Texture images may also be speci?ed or modi?ed using image data already stored
in a known compressed image format, including the formats de?ned in appendix D
as well as any additional formats de?ned by extensions.
The commands
void CompressedTexImage1D(enum target,int level,
enum internalformat,sizei width,int border,
sizei imageSize,const void *data );
void CompressedTexImage2D(enum target,int level,
enum internalformat,sizei width,sizei height,
int border,sizei imageSize,const void *data );
void CompressedTexImage3D(enum target,int level,
enum internalformat,sizei width,sizei height,
sizei depth,int border,sizei imageSize,const
void *data );
de?ne one-, two-, and three-dimensional texture images, respectively, with incom-
ing data stored in a speci?c compressed image format. The target, level, inter-
nalformat, width, height, depth, and border parameters have the same meaning
as in TexImage1D, TexImage2D, and TexImage3D, except that compressed rect-
angle texture formats are not supported. data refers to compressed image data
stored in the speci?c compressed image format corresponding to internalformat.
If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and the
OpenGL 4.6 (Core Pro?le) - February 2, 20198.7. COMPRESSEDTEXTUREIMAGES 227
compressed data is read from the buffer relative to this offset; otherwise, data is
a pointer to client memory and the compressed data is read from client memory
relative to the pointer.
The compressed image will be decoded according to the speci?cation de?ning
the internalformat token. Compressed texture images are treated as an array of
imageSizeubytes relative to data.
If the compressed image is not encoded according to the de?ned image format,
the results of the call are unde?ned.
If the compressed data are arranged into ?xed-size blocks of texels, the pixel
storage modes can be used to select a sub-rectangle from a larger containing rect-
angle. These pixel storage modes operate in the same way as they do for Tex-
Image*D and as described in section 8.4.4. In the remainder of this section, de-
note by blocksize, b , b , and b the values of pixel storage modes UNPACK_-
w
h d
COMPRESSED_BLOCK_SIZE, UNPACK_COMPRESSED_BLOCK_WIDTH, UNPACK_-
COMPRESSED_BLOCK_HEIGHT, and UNPACK_COMPRESSED_BLOCK_DEPTH re-
spectively. blocksize is the compressed block size in bytes; b , b , and b are
w h d
the compressed block width, height, and depth in pixels.
By default the pixel storage modes UNPACK_ROW_LENGTH, UNPACK_SKIP_-
ROWS, UNPACK_SKIP_PIXELS, UNPACK_IMAGE_HEIGHT and UNPACK_SKIP_-
IMAGES are ignored for compressed images. To enable UNPACK_SKIP_PIXELS
and UNPACK_ROW_LENGTH, blocksize and b must both be non-zero. To also
w
enableUNPACK_SKIP_ROWS andUNPACK_IMAGE_HEIGHT,b must be non-zero.
h
And to also enableUNPACK_SKIP_IMAGES,b must be non-zero. All parameters
d
must be consistent with the compressed format to produce the desired results.
Errors
AnINVALID_ENUM error is generated if the target parameter to any of the
CompressedTexImagenD commands isTEXTURE_RECTANGLE orPROXY_-
TEXTURE_RECTANGLE.
AnINVALID_ENUM error is generated if internalformat is not a supported
speci?c compressed internal format from table 8.14. In particular, this error
will be generated for any of the generic compressed internal formats.
An INVALID_VALUE error is generated if width, height, depth, or image-
Size is negative.
An INVALID_OPERATION error is generated if a pixel unpack buffer ob-
ject is bound anddata+imageSize is greater than the size of the pixel buffer.
An INVALID_VALUE error is generated if the imageSize parameter is not
consistent with the format, dimensions, and contents of the compressed image.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.7. COMPRESSEDTEXTUREIMAGES 228
AnINVALID_OPERATION error is generated if any of the following con-
ditions is violated when selecting a sub-rectangle from a compressed image:
 the value ofUNPACK_SKIP_PIXELS must be a multiple ofb ;
w
 the value of UNPACK_SKIP_ROWS must be a multiple of b for Com-
h
pressedTexImage2D and CompressedTexImage3D;
 the value ofUNPACK_SKIP_IMAGES must be a multiple ofb for Com-
d
pressedTexImage3D.
An INVALID_VALUE error is generated if imageSize does not match the
following requirements when pixel storage modes are active:
 For CompressedTexImage1D the imageSize parameter must be equal
to
 
width
blocksize
b
w
 For CompressedTexImage2D the imageSize parameter must be equal
to
   
width height
blocksize 
b b
w h
 For CompressedTexImage3D the imageSize parameter must be equal
to
     
width height depth
blocksize  
b b b
w h d
Based on the de?nition of unpacking from section 8.4.4 for uncompressed im-
ages, unpacking compressed images can be de?ned where:
 n, the number of elements in a group, is 1.
 s, the size of an element, isblocksize.
 l, the number of groups in a row, is
8l m
row length
<
; row length> 0
b
w
l m
l =
width
:
; otherwise
b
w
OpenGL 4.6 (Core Pro?le) - February 2, 20198.7. COMPRESSEDTEXTUREIMAGES 229
whererow length is the value ofUNPACK_ROW_LENGTH.
 a, the value ofUNPACK_ALIGNMENT, is ignored.
 k =nl as is de?ned for uncompressed images.
Before obtaining the ?rst compressed image block from memory, the data
pointer is advanced by
UNPACK SKIP PIXELS UNPACK SKIP ROWS
n + k
b b
w h
l m
width
elements. Then blocks are obtained from contiguous blocks in memory
b
w
(without advancing the pointer), after which the pointer is advanced byk elements.
l m l m
height
width
sets of blocks are obtained this way. For three-dimensional com-
b b
h w
UNPACK SKIP IMAGES
pressed images the pointer is advanced by times the number
b
d
of elements in one two-dimensional image before obtaining the ?rst group from
memory. Then after height rows are obtained the pointer skips over the remaining
l m
UNPACK IMAGE HEIGHT
rows, ifUNPACK_IMAGE_HEIGHT is positive, before starting
b
h
the next two-dimensional image.
Speci?c compressed internal formats may impose additional format-speci?c
restrictions. For example, a format might be supported only for two-dimensional
textures, or might not allow non-zero border values. Any such restrictions will be
documented in the extension speci?cation de?ning the compressed internal format.
Any restrictions imposed by speci?c compressed internal formats will be in-
variant, meaning that if the GL accepts and stores a texture image in compressed
form, providing the same image to CompressedTexImage1D, CompressedTex-
Image2D, or CompressedTexImage3D will not generate an error if the following
restrictions are satis?ed:
 data points to a compressed texture image returned by GetCompressedTex-
Image (section 8.11).
 target, level, and internalformat match the target, level and format parame-
ters provided to the GetCompressedTexImage call returning data.
 width, height, depth, internalformat, and imageSize match the values
of TEXTURE_WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_-
INTERNAL_FORMAT, andTEXTURE_COMPRESSED_IMAGE_SIZE for image
level level in effect at the time of the GetCompressedTexImage call return-
ing data.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.7. COMPRESSEDTEXTUREIMAGES 230
This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
and format.
If internalformat is one of the speci?c compressed formats described in ta-
ble 8.14, the compressed image data is stored using the corresponding texture im-
age encoding (see appendix D). The corresponding compression algorithms sup-
port only two-dimensional images without borders, though three-dimensional im-
ages can be compressed as multiple slices of compressed two-dimensional BPTC
images.
Errors
An INVALID_OPERATION error is generated if any format-speci?c re-
strictions imposed by speci?c compressed internal formats are violated by the
compressed image speci?cation calls or parameters.
AnINVALID_ENUM error is generated by CompressedTexImage1D if in-
ternalformat is one of the speci?c compressed formats. OpenGL de?nes no
speci?c one-dimensional compressed formats, but such formats may be pro-
vided by extensions.
An INVALID_OPERATION error is generated by CompressedTexIm-
age2D if internalformat is one of the EAC, ETC2, or RGTC formats and
border is non-zero.
An INVALID_OPERATION error is generated by CompressedTexIm-
age3D if internalformat is one of the EAC, ETC2, or RGTC formats and either
border is non-zero, or target is notTEXTURE_2D_ARRAY, TEXTURE_CUBE_-
MAP orTEXTURE_CUBE_MAP_ARRAY.
An INVALID_OPERATION error is generated by CompressedTexIm-
age2D and CompressedTexImage3D if internalformat is one of the BPTC
formats and border is non-zero.
If the data argument of CompressedTexImage1D, CompressedTexImage2D,
or CompressedTexImage3D is NULL, and the pixel unpack buffer object is zero,
a texture image with unspeci?ed image contents is created, just as when a NULL
pointer is passed to TexImage1D, TexImage2D, or TexImage3D.
To respecify only a rectangular subregion of the texture image of a texture
object, with incoming data stored in a speci?c compressed image format, use the
commands
void CompressedTexSubImage1D(enum target,int level,
int xoffset,sizei width,enum format,sizei imageSize,
const void *data );
OpenGL 4.6 (Core Pro?le) - February 2, 20198.7. COMPRESSEDTEXTUREIMAGES 231
void CompressedTexSubImage2D(enum target,int level,
int xoffset,int yoffset,sizei width,sizei height,
enum format,sizei imageSize,const void *data );
void CompressedTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth,enum format,
sizei imageSize,const void *data );
void CompressedTextureSubImage1D(uint texture,
int level,int xoffset,sizei width,enum format,
sizei imageSize,const void *data );
void CompressedTextureSubImage2D(uint texture,
int level,int xoffset,int yoffset,sizei width,
sizei height,enum format,sizei imageSize,const
void *data );
void CompressedTextureSubImage3D(uint texture,
int level,int xoffset,int yoffset,int zoffset,
sizei width,sizei height,sizei depth,enum format,
sizei imageSize,const void *data );
The target, texture, level, xoffset, yoffset, zoffset, width, height, and depth pa-
rameters have the same meaning as in the corresponding commands from sec-
tion 8.6 without the Compressed pre?x (where those parameters are present). data
points to compressed image data stored in the compressed image format corre-
sponding to format.
The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D.
Any restrictions imposed by speci?c compressed internal formats will be in-
variant, meaning that if the GL accepts and stores a texture image in compressed
form, providing the same image to CompressedTex*Image* will not generate an
error if the following restrictions are satis?ed:
 data points to a compressed texture image returned by GetCompressedTex-
Image (section 8.11).
 target, level, and format match the target, level and format parameters pro-
vided to the GetCompressedTexImage call returning data.
 width, height, depth, format, and imageSize match the values ofTEXTURE_-
WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_INTERNAL_-
FORMAT, and TEXTURE_COMPRESSED_IMAGE_SIZE for image level level
in effect at the time of the GetCompressedTexImage call returning data.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.7. COMPRESSEDTEXTUREIMAGES 232
 width, height, depth, and format match the values of TEXTURE_WIDTH,
TEXTURE_HEIGHT, TEXTURE_DEPTH, and TEXTURE_INTERNAL_FORMAT
currently in effect for image level level.
 xoffset, yoffset, and zoffset are all zero.
This guarantee applies not just to images returned by GetCompressedTexIm-
age, but also to any other properly encoded compressed texture image of the same
size.
If the internal format of the image being modi?ed is one of the speci?c com-
pressed formats described in table 8.14, the texture is stored using the correspond-
ing texture image encoding (see appendix D).
Since these speci?c compressed formats are easily edited along 4 4 texel
boundaries, the limitations on subimage location and size are relaxed for Com-
pressedTex*SubImage2D and CompressedTex*SubImage3D.
The contents of any 4 4 block of texels of a compressed texture image in
these speci?c compressed formats that do not intersect the area being modi?ed are
preserved during CompressedTex*SubImage* calls.
Errors
An INVALID_ENUM error is generated by CompressedTexSubImage*D
if target isTEXTURE_RECTANGLE orPROXY_TEXTURE_RECTANGLE.
An INVALID_OPERATION error is generated by CompressedTexture-
SubImage*D if texture is not the name of an existing texture object.
An INVALID_OPERATION error is generated by CompressedTexture-
SubImage*D if the effective target isTEXTURE_RECTANGLE.
AnINVALID_ENUM error is generated if format is one of the generic com-
pressed internal formats.
AnINVALID_OPERATION error is generated if format does not match the
internal format of the texture image being modi?ed, since these commands do
not provide for image format conversion.
An INVALID_VALUE error is generated if width, height, depth, or image-
Size is negative.
AnINVALID_VALUE error is generated if imageSize is not consistent with
the format, dimensions, and contents of the compressed image (too little or
too much data).
An INVALID_OPERATION error is generated if any format-speci?c re-
strictions are violated, as with CompressedTex*Image commands. Any such
restrictions will be documented in the speci?cation de?ning the compressed
OpenGL 4.6 (Core Pro?le) - February 2, 20198.8. MULTISAMPLETEXTURES 233
internal format.
An INVALID_OPERATION error is generated if xoffset, yoffset, or zoffset
are not equal to zero, or if width, height, and depth do not match the corre-
sponding dimensions of the texture level. The contents of any texel outside the
region modi?ed by the call are unde?ned. These restrictions may be relaxed
for speci?c compressed internal formats whose images are easily modi?ed.
AnINVALID_ENUM error is generated by CompressedTex*SubImage1D
if the internal format of the texture is one of the speci?c compressed formats.
An INVALID_OPERATION error
is generated by CompressedTex*SubImage2D if the internal format of the
texture is one of the EAC, ETC2, or RGTC formats and border is non-zero.
An INVALID_OPERATION er-
ror is generated by CompressedTex*SubImage3D if the internal format of
the texture is one of the EAC, ETC2, or RGTC formats and either border is
non-zero, or the effective target for the texture is not TEXTURE_2D_ARRAY,
TEXTURE_CUBE_MAP orTEXTURE_CUBE_MAP_ARRAY.
An INVALID_OPERATION error is generated if the internal format of the
texture is one of the BPTC formats and border is non-zero.
AnINVALID_OPERATION error is generated if any of the following con-
ditions occurs:
 width is not a multiple of four, and width + xoset is not equal to the
value ofTEXTURE_WIDTH.
 height is not a multiple of four, and height + yoset is not equal to the
value ofTEXTURE_HEIGHT.
 xoffset or yoffset is not a multiple of four.
8.8 Multisample Textures
In addition to the texture types described in previous sections, two additional types
of textures are supported. A multisample texture is similar to a two-dimensional
or two-dimensional array texture, except it contains multiple samples per texel.
Multisample textures do not have multiple image levels.
The commands
void TexImage2DMultisample(enum target,sizei samples,
enum internalformat,sizei width,sizei height,
boolean ?xedsamplelocations );
OpenGL 4.6 (Core Pro?le) - February 2, 20198.8. MULTISAMPLETEXTURES 234
void TexImage3DMultisample(enum target,sizei samples,
enum internalformat,sizei width,sizei height,
sizei depth,boolean ?xedsamplelocations );
establish the data storage, format, dimensions, and number of samples of a
multisample texture’s image. For TexImage2DMultisample, target must be
TEXTURE_2D_MULTISAMPLE or PROXY_TEXTURE_2D_MULTISAMPLE and for
TexImage3DMultisample target must be TEXTURE_2D_MULTISAMPLE_ARRAY
orPROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. width and height are the dimen-
sions in texels of the texture.
samples represents a request for a desired minimum number of samples.
Since different implementations may support different sample counts for multi-
sampled textures, the actual number of samples allocated for the texture image is
implementation-dependent. However, the resulting value for TEXTURE_SAMPLES
is guaranteed to be greater than or equal to samples and no more than the next
larger sample count supported by the implementation.
If ?xedsamplelocations isTRUE, the image will use identical sample locations
and the same number of samples for all texels in the image, and the sample loca-
tions will not depend on the internal format or size of the image.
Upon success, TexImage*Multisample deletes any existing image for tar-
get and the contents of texels are unde?ned. TEXTURE_WIDTH, TEXTURE_-
HEIGHT, TEXTURE_SAMPLES, TEXTURE_INTERNAL_FORMAT and TEXTURE_-
FIXED_SAMPLE_LOCATIONS are set to width, height, the actual number of sam-
ples allocated, internalformat, and ?xedsamplelocations respectively.
When a multisample texture is accessed in a shader, the access takes one vec-
tor of integers describing which texel to fetch and an integer corresponding to the
sample numbers described in section 14.3.1 determining which sample within the
texel to fetch. No standard sampling instructions are allowed on the multisample
texture targets, and no ?ltering is performed by the fetch. Fetching a sample num-
ber less than zero, or greater than or equal to the number of samples in the texture,
produces unde?ned results.
Errors
An INVALID_ENUM error is generated if target is not an accepted multi-
sample target as described above.
AnINVALID_VALUE error is generated if width, height, or depth is nega-
tive.
AnINVALID_VALUE error is generated if samples is zero.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.9. BUFFERTEXTURES 235
An INVALID_VALUE error is generated if width or height is greater than
the value ofMAX_TEXTURE_SIZE.
An INVALID_VALUE error is generated by TexImage3DMultisample if
depth is greater than the value ofMAX_ARRAY_TEXTURE_LAYERS.
An INVALID_ENUM error is generated if internalformat is not color-
renderable, depth-renderable, or stencil-renderable (as de?ned in section 9.4).
AnINVALID_OPERATION error is generated if samples is greater than the
maximum number of samples supported for this target and internalformat.
The maximum number of samples supported can be determined by calling
GetInternalformativ with a pname ofSAMPLES (see section 22.3).
An INVALID_OPERATION error is generated if the value of TEXTURE_-
IMMUTABLE_FORMAT for the texture currently bound to target on the active
texture unit isTRUE.
8.9 Buffer Textures
In addition to one-, two-, and three-dimensional, one- and two-dimensional array,
and cube map textures described in previous sections, one additional type of texture
is supported. A buffer texture is similar to a one-dimensional texture. However,
unlike other texture types, the texture image is not stored as part of the texture.
Instead, a buffer object is attached to a buffer texture and the texture image is taken
from that buffer object’s data store. When the contents of a buffer object’s data
store are modi?ed, those changes are re?ected in the contents of any buffer texture
to which the buffer object is attached. Buffer textures do not have multiple image
levels; only a single data store is available.
The commands
void TexBufferRange(enum target,enum internalformat,
uint buffer,intptr offset,sizeiptr size );
void TextureBufferRange(uint texture,enum internalformat,
uint buffer,intptr offset,sizeiptr size );
attach the range of the storage for the buffer object named buffer for size basic
machine units, starting at offset (also in basic machine units) to a buffer texture.
For TexBufferRange, the buffer texture is that currently bound to target. For
TextureBufferRange, texture is the name of the buffer texture. target or the effec-
tive target of texture must beTEXTURE_BUFFER.
If buffer is zero, then any buffer object attached to the buffer texture is detached,
the values offset and size are ignored and the state for offset and size for the buffer
texture are reset to zero. internalformat speci?es the storage format for the texture
OpenGL 4.6 (Core Pro?le) - February 2, 20198.9. BUFFERTEXTURES 236
image found in the range of the attached buffer object, and must be one of the sized
internal formats found in table 8.16.
Errors
An INVALID_OPERATION error is generated by TextureBufferRange if
texture is not the name of an existing texture object.
AnINVALID_ENUM error is generated by TexBufferRange if target is not
TEXTURE_BUFFER.
An INVALID_OPERATION error is generated by TextureBufferRange if
the effective target is notTEXTURE_BUFFER.
An INVALID_ENUM error is generated if internalformat is not one of the
sized internal formats in table 8.16.
An INVALID_OPERATION error is generated if buffer is non-zero and is
not the name of a buffer object.
An INVALID_VALUE error is generated if offset is negative, if size is less
than or equal to zero, or if oset + size is greater than the value ofBUFFER_-
SIZE for the buffer bound to target.
AnINVALID_VALUE error is generated if offset is not an integer multiple
of the value ofTEXTURE_BUFFER_OFFSET_ALIGNMENT.
The commands
void TexBuffer(enum target,enum internalformat,
uint buffer );
void TextureBuffer(uint texture,enum internalformat,
uint buffer );
are respectively equivalent to
TexBufferRange(target, internalformat, buffer, 0, size);
and
TextureBufferRange(texture, internalformat, buffer, 0, size);
wheresize is the value ofBUFFER_SIZE for buffer.
When a range of the storage of a buffer object is attached to a buffer texture, the
range of the buffer’s data store is taken as the texture’s texture image. The number
of texels in the buffer texture’s texture image is given by
 
size
:
components sizeof (base type)
OpenGL 4.6 (Core Pro?le) - February 2, 20198.9. BUFFERTEXTURES 237
where components and base type are the element count and base type for
elements, as speci?ed in table 8.16.
The number of texels in the texture image is then clamped to an
implementation-dependent limit, the value of MAX_TEXTURE_BUFFER_SIZE.
When a buffer texture is accessed in a shader, the results of a texel fetch are un-
de?ned if the speci?ed texel coordinate is negative, or greater than or equal to the
clamped number of texels in the texture image.
When a buffer texture is accessed in a shader, an integer is provided to indicate
the texel coordinate being accessed. If no buffer object is bound to the buffer tex-
ture, the results of the texel access are unde?ned. Otherwise, the attached buffer
object’s data store is interpreted as an array of elements of the GL data type cor-
responding to internalformat. Each texel consists of one to four elements that are
mapped to texture components (R, G, B, and A). Elementm of the texel numbered
n is taken from elementncomponents +m of the attached buffer object’s data
store. Elements and texels are both numbered starting with zero. For texture for-
mats with signed or unsigned normalized ?xed-point components, the extracted
values are converted to ?oating-point using equations 2.2 or 2.1, respectively. The
components of the texture are then converted to a (R;G;B;A) vector according
to table 8.16, and returned to the shader as a four-component result vector with
components of the appropriate data type for the texture’s internal format. The base
data type, component count, normalized component information, and mapping of
data store elements to texture components is speci?ed in table 8.16.
Sized Internal Format Base Type Components Norm Component
0 1 2 3
R8 ubyte 1 Yes R 0 0 1
R16 ushort 1 Yes R 0 0 1
R16F half 1 No R 0 0 1
R32F float 1 No R 0 0 1
R8I byte 1 No R 0 0 1
R16I short 1 No R 0 0 1
R32I int 1 No R 0 0 1
R8UI ubyte 1 No R 0 0 1
R16UI ushort 1 No R 0 0 1
R32UI uint 1 No R 0 0 1
RG8 ubyte 2 Yes R G 0 1
RG16 ushort 2 Yes R G 0 1
(Continued on next page)
OpenGL 4.6 (Core Pro?le) - February 2, 20198.9. BUFFERTEXTURES 238
Internal formats for buffer textures (continued)
Sized Internal Format Base Type Components Norm Component
0 1 2 3
RG16F half 2 No R G 0 1
RG32F float 2 No R G 0 1
RG8I byte 2 No R G 0 1
RG16I short 2 No R G 0 1
RG32I int 2 No R G 0 1
RG8UI ubyte 2 No R G 0 1
RG16UI ushort 2 No R G 0 1
RG32UI uint 2 No R G 0 1
RGB32F float 3 No R G B 1
RGB32I int 3 No R G B 1
RGB32UI uint 3 No R G B 1
RGBA8 ubyte 4 Yes R G B A
RGBA16 ushort 4 Yes R G B A
RGBA16F half 4 No R G B A
RGBA32F float 4 No R G B A
RGBA8I byte 4 No R G B A
RGBA16I short 4 No R G B A
RGBA32I int 4 No R G B A
RGBA8UI ubyte 4 No R G B A
RGBA16UI ushort 4 No R G B A
RGBA32UI uint 4 No R G B A
Table 8.16: Internal formats for buffer textures. For each format,
the data type of each element is indicated in the “Base Type” col-
umn and the element count is in the “Components” column. The
“Norm” column indicates whether components should be treated
as normalized ?oating-point values. The “Component 0, 1, 2, and
3” columns indicate the mapping of each element of a texel to tex-
ture components.
In addition to attaching buffer objects to textures, buffer objects can be bound
to the buffer object target namedTEXTURE_BUFFER, in order to specify, modify, or
read the buffer object’s data store. The buffer object bound to TEXTURE_BUFFER
has no effect on rendering. A buffer object is bound to TEXTURE_BUFFER by
OpenGL 4.6 (Core Pro?le) - February 2, 20198.10. TEXTUREPARAMETERS 239
calling BindBuffer with target set toTEXTURE_BUFFER, as described in section 6.
8.10 Texture Parameters
Texture parameters control how the texture image of a texture object is treated
when speci?ed or changed, and when applied to a fragment. Each parameter is set
with the commands
void TexParameterfifg(enum target,enum pname,T param );
void TexParameterfifgv(enum target,enum pname,const
T *params );
void TexParameterIfi uigv(enum target,enum pname,const
T *params );
void TextureParameterfifg(uint texture,enum pname,
T param );
void TextureParameterfifgv(uint texture,enum pname,
const T *params );
void TextureParameterIfi uigv(uint texture,enum pname,
const T *params );
For TexParameter*, the texture object is that bound to target. For TexturePa-
rameter*, texture is the name of the texture object. target or the effective target
of texture must be one ofTEXTURE_1D,TEXTURE_2D,TEXTURE_3D,TEXTURE_-
1D_ARRAY,TEXTURE_2D_ARRAY.TEXTURE_RECTANGLE,TEXTURE_CUBE_MAP,
TEXTURE_CUBE_MAP_ARRAY, TEXTURE_2D_MULTISAMPLE, or TEXTURE_2D_-
MULTISAMPLE_ARRAY.
pname is a symbolic constant indicating the parameter to be set; the possible
constants and corresponding parameters are summarized in table 8.17. In the scalar
forms of the command, param is a value to which to set a single-valued parameter;
in the vector forms, params is an array of parameters whose type depends on the
parameter being set.
Data conversions are performed as speci?ed in section 2.2.1, with these excep-
tions:
 If the values forTEXTURE_BORDER_COLOR are speci?ed with TexParame-
terIiv or TexParameterIuiv, they are unmodi?ed and stored with an internal
data type of integer. If speci?ed with TexParameteriv, they are converted to
?oating-point using equation 2.2. Otherwise, the values are unmodi?ed and
stored as ?oating-point.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.10. TEXTUREPARAMETERS 240
If pname is TEXTURE_SWIZZLE_RGBA, params is an array of four
enums which respectively set theTEXTURE_SWIZZLE_R,TEXTURE_SWIZZLE_G,
TEXTURE_SWIZZLE_B, andTEXTURE_SWIZZLE_A parameters simultaneously.
Name Type Legal Values
DEPTH_STENCIL_TEXTURE_MODE enum DEPTH_COMPONENT, STENCIL_-
INDEX
TEXTURE_BASE_LEVEL int any non-negative integer
TEXTURE_BORDER_COLOR 4floats, any 4 values
ints, oruints
TEXTURE_COMPARE_MODE enum NONE, COMPARE_REF_TO_-
TEXTURE
TEXTURE_COMPARE_FUNC enum LEQUAL, GEQUAL, LESS,
GREATER, EQUAL, NOTEQUAL,
ALWAYS,NEVER
TEXTURE_LOD_BIAS float any value
TEXTURE_MAG_FILTER enum NEAREST,LINEAR
TEXTURE_MAX_ANISOTROPY float greater or equal to 1:0
TEXTURE_MAX_LEVEL int any non-negative integer
TEXTURE_MAX_LOD float any value
TEXTURE_MIN_FILTER enum NEAREST,LINEAR,
NEAREST_MIPMAP_NEAREST,
NEAREST_MIPMAP_LINEAR,
LINEAR_MIPMAP_NEAREST,
LINEAR_MIPMAP_LINEAR,
TEXTURE_MIN_LOD float any value
TEXTURE_SWIZZLE_R enum RED, GREEN, BLUE, ALPHA, ZERO,
ONE
TEXTURE_SWIZZLE_G enum RED, GREEN, BLUE, ALPHA, ZERO,
ONE
TEXTURE_SWIZZLE_B enum RED, GREEN, BLUE, ALPHA, ZERO,
ONE
TEXTURE_SWIZZLE_A enum RED, GREEN, BLUE, ALPHA, ZERO,
ONE
TEXTURE_SWIZZLE_RGBA 4enums RED, GREEN, BLUE, ALPHA, ZERO,
ONE
TEXTURE_WRAP_S enum CLAMP_TO_EDGE,REPEAT,
Texture parameters continued on next page
OpenGL 4.6 (Core Pro?le) - February 2, 20198.10. TEXTUREPARAMETERS 241
Texture parameters continued from previous page
Name Type Legal Values
CLAMP_TO_BORDER,
MIRRORED_REPEAT,
MIRROR_CLAMP_TO_EDGE
TEXTURE_WRAP_T enum CLAMP_TO_EDGE,REPEAT,
CLAMP_TO_BORDER,
MIRRORED_REPEAT,
MIRROR_CLAMP_TO_EDGE
TEXTURE_WRAP_R enum CLAMP_TO_EDGE,REPEAT,
CLAMP_TO_BORDER,
MIRRORED_REPEAT,
MIRROR_CLAMP_TO_EDGE
Table 8.17: Texture parameters and their values.
In the remainder of chapter 8, denote by lod , lod , level , and
min max base
level the values of the texture parameters TEXTURE_MIN_LOD, TEXTURE_-
max
MAX_LOD, TEXTURE_BASE_LEVEL, and TEXTURE_MAX_LEVEL respectively. If
the texture was created with TextureView, then the TEXTURE_BASE_LEVEL and
TEXTURE_MAX_LEVEL parameters are interpreted relative to the view and not rel-
ative to the original data store.
Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cube map itself.
Errors
An INVALID_ENUM error is generated by TexParameter* if target is not
one of the valid targets listed above.
An INVALID_OPERATION error is generated by TextureParameter* if
the effective target is not one of the valid targets listed above.
AnINVALID_ENUM error is generated if pname is not one of the parameter
names in table 8.17.
An INVALID_OPERATION error is generated by TextureParameter* if
texture is not the name of an existing texture object.
An INVALID_ENUM error is generated if the type of the parameter spec-
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 242
i?ed by pname is enum, and any value speci?ed by param or params is not
among the legal values shown in table 8.17.
An INVALID_VALUE error is generated if pname is TEXTURE_BASE_-
LEVEL orTEXTURE_MAX_LEVEL, and any value speci?ed by param or params
is negative.
An INVALID_VALUE error is generated if pname is TEXTURE_MAX_-
ANISOTROPY, and any value speci?ed by param or params is less than 1:0.
An INVALID_ENUM error is generated if Tex*Parameterfifg is called
for a non-scalar parameter (pnameTEXTURE_BORDER_COLOR orTEXTURE_-
SWIZZLE_RGBA).
An INVALID_ENUM error is generated if the effective target is either
TEXTURE_2D_MULTISAMPLE or TEXTURE_2D_MULTISAMPLE_ARRAY, and
pname is any sampler state from table 23.18.
An INVALID_ENUM error is generated by TexParameter* if target is ei-
ther TEXTURE_2D_MULTISAMPLE or TEXTURE_2D_MULTISAMPLE_ARRAY,
and pname is any sampler state from table 23.18.
An INVALID_OPERATION error is generated by TextureParameter* if
the effective target is eitherTEXTURE_2D_MULTISAMPLE orTEXTURE_2D_-
MULTISAMPLE_ARRAY, and pname is any sampler state
An INVALID_OPERATION error is generated if the effective target
is TEXTURE_2D_MULTISAMPLE, TEXTURE_2D_MULTISAMPLE_ARRAY or
TEXTURE_RECTANGLE, and pname TEXTURE_BASE_LEVEL is set to a value
other than zero.
AnINVALID_ENUM error is generated if the effective target isTEXTURE_-
RECTANGLE and either of pnamesTEXTURE_WRAP_S orTEXTURE_WRAP_T is
set to eitherMIRROR_CLAMP_TO_EDGE,MIRRORED_REPEAT orREPEAT.
AnINVALID_ENUM error is generated if the effective target isTEXTURE_-
RECTANGLE and pname TEXTURE_MIN_FILTER is set to a value other than
NEAREST orLINEAR (no mipmap ?ltering is permitted).
8.11 Texture Queries
8.11.1 Active Texture
Queries of most texture state variables are quali?ed by the value of ACTIVE_-
TEXTURE to determine which server texture state vector is queried.
Table 23.12 indicates those state variables which are quali?ed by ACTIVE_-
TEXTURE during state queries.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 243
8.11.2 Texture Parameter Queries
Parameters of a texture object may be queried with the commands
void GetTexParameterfifgv(enum target,enum pname,
T *params );
void GetTexParameterIfi uigv(enum target,enum pname,
T *params );
void GetTextureParameterfifgv(uint texture,enum pname,
T *data );
void GetTextureParameterIfi uigv(uint texture,
enum pname,T *data );
For GetTexParameter*, the texture object is that bound to target. For Get-
TextureParameter*, texture is the name of the texture object.
The value of texture parameter pname for the texture is returned in params.
target or the effective target of texture must be one of TEXTURE_1D,
TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY,
TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP, TEXTURE_CUBE_MAP_ARRAY,
TEXTURE_2D_MULTISAMPLE, or TEXTURE_2D_MULTISAMPLE_ARRAY, indicat-
ing the currently bound one-, two-, or three-dimensional, one- or two-dimensional
array, rectangle, cube map, cube map array, two-dimensional multisample, or
two-dimensional multisample array texture object.
pname must be one ofIMAGE_FORMAT_COMPATIBILITY_TYPE,TEXTURE_-
IMMUTABLE_FORMAT, TEXTURE_IMMUTABLE_-
LEVELS, TEXTURE_TARGET, TEXTURE_VIEW_MIN_LEVEL, TEXTURE_VIEW_-
NUM_LEVELS, TEXTURE_VIEW_MIN_LAYER, TEXTURE_VIEW_NUM_LAYERS, or
one of the symbolic values in table 8.17.
Querying pname TEXTURE_BORDER_COLOR with GetTex*ParameterIiv or
GetTex*ParameterIuiv returns the border color values as signed integers or un-
signed integers, respectively; otherwise the values are returned as described in sec-
tion 2.2.2. If the border color is queried with a type that does not match the original
type with which it was speci?ed, the result is unde?ned.
Querying pname TEXTURE_TARGET returns the effective target of the texture
object. For GetTexParameter*, this is the target parameter. For GetTexturePa-
rameter*, it is the target to which the texture was initially bound when it was
created, or the value of the target parameter to the call to CreateTextures which
created the texture.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 244
Errors
AnINVALID_OPERATION error is generated by GetTextureParameter*
if texture is not the name of an existing texture object.
An INVALID_ENUM error is generated by GetTexParameter* if target is
not one of the texture targets described above.
An INVALID_OPERATION error is generated by GetTexParameter* if
the effective target is not one of the texture targets described above.
An INVALID_ENUM error is generated if pname is not one of the texture
parameters described above.
8.11.3 Texture Level Parameter Queries
Parameters of a speci?ed level-of-detail of a texture object may be queried with the
commands
void GetTexLevelParameterfifgv(enum target,int level,
enum pname,T *params );
void GetTextureLevelParameterfifgv(uint texture,
int level,enum pname,T *params );
For GetTexLevelParameter*, the texture object is that bound to target. For
GetTextureLevelParameter*, texture is the name of the texture object.
The value of texture parameter pname for level-of-detail level of the texture is
returned in params. pname must be one of the symbolic values in tables 23.16-
23.17.
The effective target of the texture object must be one of TEXTURE_1D,
TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY,
TEXTURE_CUBE_MAP_ARRAY, TEXTURE_RECTANGLE, TEXTURE_BUFFER,
TEXTURE_2D_MULTISAMPLE, TEXTURE_2D_MULTISAMPLE_ARRAY, PROXY_-
TEXTURE_1D, PROXY_TEXTURE_2D, PROXY_TEXTURE_3D, PROXY_TEXTURE_-
1D_ARRAY, PROXY_TEXTURE_2D_ARRAY, PROXY_TEXTURE_CUBE_MAP_-
ARRAY, PROXY_TEXTURE_RECTANGLE, PROXY_TEXTURE_CUBE_MAP, PROXY_-
TEXTURE_2D_MULTISAMPLE, or PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY,
indicating the one-, two-, or three-dimensional texture, one- or two-dimensional
array texture, cube map array texture, rectangle texture, buffer texture, two-
dimensional multisample texture, two-dimensional multisample array texture;
or the one-, two-, three-dimensional, one- or two-dimensional array, cube map
array, rectangle, cube map, two-dimensional multisample, or two-dimensional
multisample array proxy state vector.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 245
For GetTexLevelParameter* only, target may also be one of the cube map
face targets from table 8.19, indicating one of the six distinct two-dimensional
images making up the cube map texture object. Note thatTEXTURE_CUBE_MAP is
not a valid target parameter for GetTexLevelParameter*.
For GetTextureLevelParameter* only, texture may also be a cube map texture
object. In this case the query is always performed for face zero (the TEXTURE_-
CUBE_MAP_POSITIVE_X face), since there is no way to specify another face.
level determines which level-of-detail’s state is returned. The maximum value
of level depends on the texture target:
 For targets TEXTURE_CUBE_MAP and TEXTURE_CUBE_MAP_ARRAY, the
maximum value is log of the value ofMAX_CUBE_MAP_TEXTURE_SIZE.
2
 For target TEXTURE_3D, the maximum value is log of the value of MAX_-
2
3D_TEXTURE_SIZE.
 For targets TEXTURE_BUFFER, TEXTURE_RECTANGLE, TEXTURE_2D_-
MULTISAMPLE, and TEXTURE_2D_MULTISAMPLE_ARRAY, which do not
support mipmaps, the maximum value is zero.
 For all other texture targets supported by GetTex*LevelParameter*, the
maximum value is log of the value ofMAX_TEXTURE_SIZE.
2
For texture images with uncompressed internal formats, queries of
pname TEXTURE_RED_TYPE, TEXTURE_GREEN_TYPE, TEXTURE_BLUE_TYPE,
TEXTURE_ALPHA_TYPE, and TEXTURE_DEPTH_TYPE return the data type used
to store the component. Types NONE, SIGNED_NORMALIZED, UNSIGNED_-
NORMALIZED, FLOAT, INT, and UNSIGNED_INT respectively indicate missing,
signed normalized ?xed-point, unsigned normalized ?xed-point, ?oating-point,
signed unnormalized integer, and unsigned unnormalized integer components.
Queries of pname TEXTURE_RED_SIZE, TEXTURE_GREEN_SIZE, TEXTURE_-
BLUE_SIZE, TEXTURE_ALPHA_SIZE, TEXTURE_DEPTH_SIZE, TEXTURE_-
STENCIL_SIZE, andTEXTURE_SHARED_SIZE return the actual resolutions of the
stored texture image components, not the resolutions speci?ed when the image was
de?ned.
For texture images with compressed internal formats, the types returned spec-
ify how components are interpreted after decompression, while the resolutions re-
turned specify the component resolution of an uncompressed internal format that
produces an image of roughly the same quality as the compressed image in ques-
tion. Since the quality of the implementation’s compression algorithm is likely
data-dependent, the returned component sizes should be treated only as rough ap-
proximations.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 246
Querying pname TEXTURE_COMPRESSED_IMAGE_SIZE returns the size (in
ubytes) of the compressed texture image that would be returned by GetCom-
pressedTexImage (section 8.11). target must be a compressed texture target.
Queries of pname TEXTURE_SAMPLES and TEXTURE_FIXED_SAMPLE_-
LOCATIONS on multisample textures return the number of samples and whether
texture sample ?xed locations are enabled respectively. For non-multisample tex-
tures, the default values in tables 23.16- 23.17 are returned.
Queries of pname TEXTURE_INTERNAL_FORMAT, TEXTURE_WIDTH,
TEXTURE_HEIGHT, and TEXTURE_DEPTH return the internal format, width,
height, and depth, respectively, as speci?ed when the texture image was created.
Errors
An INVALID_OPERATION error is generated by GetTextureLevelPa-
rameter* if texture is not the name of an existing texture object.
AnINVALID_ENUM error is generated by GetTexLevelParameter* if tar-
get is not one of the targets described above as valid for the corresponding
command.
An INVALID_OPERATION error is generated by GetTextureLevelPa-
rameter* if the effective target is not one of the targets described above as
valid for the corresponding command.
AnINVALID_ENUM error is generated if pname is not one of the symbolic
values in tables 23.16- 23.17.
An INVALID_VALUE error is generated if level is negative or larger than
the maximum allowable level-of-detail for the effective texture target as de-
scribed above.
An INVALID_OPERATION error is generated if pname is TEXTURE_-
COMPRESSED_IMAGE_SIZE and the effective texture target is a proxy target,
or has an uncompressed internal format.
8.11.4 Texture Image Queries
Texture images may be obtained from a texture object with the commands
void GetTexImage(enum target,int level,enum format,
enum type,void *pixels );
void GetTextureImage(uint texture,int level,enum format,
enum type,sizei bufSize,void *pixels );
void GetnTexImage(enum target,int level,enum format,
enum type,sizei bufSize,void *pixels );
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 247
For Get*TexImage, target speci?es the target to which the texture object is bound.
target must be one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_ARRAY or TEXTURE_-
RECTANGLE, indicating a one-, two- or three-dimensional, one- or two-dimensional
array, cube map array or rectangle texture, respectively, or one of the targets from
table 8.19, indicates the corresponding face of a cube map texture.
For GetTextureImage, texture is the name of the texture object. In addition to
the types of textures accepted by the Get*TexImage commands, GetTextureIm-
age also accepts cube map texture objects (with effective targetTEXTURE_CUBE_-
MAP).
level is a level-of-detail number, format is a pixel format from table 8.3, and
type is a pixel type from table 8.2.
If present, bufSize is the size of the buffer to receive the retrieved pixel data.
GetnTexImage and GetTextureImage do not write more than bufSize bytes
into pixels.
These commands obtain component groups from a texture image with the in-
dicated level-of-detail. If format is a color format then the components are as-
signed among R, G, B, and A according to table 8.18, starting with the ?rst group
in the ?rst row, and continuing by obtaining groups in order from each row and
proceeding from the ?rst row to the last, and from the ?rst image to the last for
three-dimensional textures. One- and two-dimensional array and cube map array
textures are treated as two-, three-, and three-dimensional images, respectively,
where the layers are treated as rows or images. Cube map textures are treated as
three-dimensional images with a depth of 6, where the cube map faces are ordered
as image layers as shown in table 9.3.
If format isDEPTH_COMPONENT,DEPTH_STENCIL, orSTENCIL_INDEX, then
each depth component and/or stencil index is assigned with the same ordering of
rows and images.
These groups are then packed and placed in client or pixel buffer object mem-
ory. If a pixel pack buffer is bound (as indicated by a non-zero value ofPIXEL_-
PACK_BUFFER_BINDING), pixels is an offset into the pixel pack buffer; otherwise,
pixels is a pointer to client memory. Pixel storage modes that are applicable to
ReadPixels are applied, as described in table 18.1 and section 18.2.9.
For three-dimensional, two-dimensional array, cube map array, and cube map
textures pixel storage operations are applied as if the image were two-dimensional,
except that the additional pixel storage state values PACK_IMAGE_HEIGHT and
PACK_SKIP_IMAGES are applied. The correspondence of texels to memory loca-
tions is as de?ned for TexImage3D in section 8.5.
The row length, number of rows, image depth, and number of images are de-
termined by the size of the texture image (including any borders).
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 248
Errors
AnINVALID_OPERATION error is generated by GetTextureImage if tex-
ture is not the name of an existing texture object.
An INVALID_ENUM error is generated by GetTexImage and GetnTex-
Image if target is not one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D,
TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_ARRAY,
TEXTURE_RECTANGLE, or one of the targets from table 8.19.
An INVALID_OPERATION error is generated by GetTextureImage if
the effective target is not one of TEXTURE_1D, TEXTURE_2D, TEXTURE_-
3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_-
ARRAY,TEXTURE_RECTANGLE, orTEXTURE_CUBE_MAP (for GetTextureIm-
age only).
AnINVALID_OPERATION error is generated by GetTextureImage if the
effective target isTEXTURE_CUBE_MAP orTEXTURE_CUBE_MAP_ARRAY, and
the texture object is not cube complete or cube array complete, respectively.
An INVALID_VALUE error is generated if level is negative or larger than
the maximum allowable level.
AnINVALID_VALUE error is generated if level is non-zero and the effec-
tive target isTEXTURE_RECTANGLE.
AnINVALID_OPERATION error is generated if any of the following mis-
matches between format and the internal format of the texture image exist:
 format is a color format (one of the formats in table 8.3 whose target is
the color buffer) and the base internal format of the texture image is not
a color format.
 format is DEPTH_COMPONENT and the base internal format is not
DEPTH_COMPONENT orDEPTH_STENCIL.
 format isDEPTH_STENCIL and the base internal format is notDEPTH_-
STENCIL.
 format is STENCIL_INDEX and the base internal format is not
STENCIL_INDEX orDEPTH_STENCIL.
 format is one of the integer formats in table 8.3 and the internal format
of the texture image is not integer, or format is not one of the integer
formats in table 8.3 and the internal format is integer.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 249
Base Internal Format R G B A
RED R 0 0 1
i
RG R G 0 1
i i
RGB R G B 1
i i i
RGBA R G B A
i i i i
Table 8.18: Texture return values. R , G , B , and A are components of the
i i i i
internal format that are assigned to pixel values R, G, B, and A. If a requested pixel
value is not present in the internal format, the speci?ed constant value is used.
AnINVALID_OPERATION error is generated if a pixel pack buffer object
is bound and packing the texture image into the buffer’s memory would exceed
the size of the buffer.
AnINVALID_OPERATION error is generated if a pixel pack buffer object
is bound and pixels is not evenly divisible by the number of basic machine
units needed to store in memory the GL data type corresponding to type (see
table 8.2).
AnINVALID_VALUE error is generated if bufSize is negative.
An INVALID_OPERATION error is generated by GetTextureImage and
GetnTexImage if the buffer size required to store the requested data is greater
than bufSize.
Sub-regions of a texture image may be obtained from a texture object with the
command
void GetTextureSubImage(uint texture,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth,enum format,enum type,
sizei bufSize,void *pixels );
texture is the name of the texture object, and must not be a buffer or multi-
sample texture. The effective target is the value ofTEXTURE_TARGET for texture.
level, format, type and pixels have the same meaning as for GetTexImage. bufSize
is the size of the buffer to receive the retrieved pixel data.
For cube map textures, the behavior is as though GetTextureImage were
called, but only texels from the requested cube map faces (selected by zoffset and
depth, as described below) were returned.
xoffset, yoffset and zoffset indicate the position of the subregion to return. width,
height and depth indicate the size of the region to return. These parameters have
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 250
the same meaning as for TexSubImage3D, though for one- and two-dimensional
textures there are extra restrictions, described in the errors section below.
For one-dimensional array textures, yoffset is interpreted as the ?rst layer to
access and height is the number of layers to access. For two-dimensional array
textures, zoffset is interpreted as the ?rst layer to access and depth is the number
of layers to access. Cube map textures are treated as an array of six slices in the z-
dimension, where the value of zoffset is interpreted as specifying the cube map face
for the corresponding layer in table 9.3 and depth is the number of faces to access.
For cube map array textures, zoffset is the ?rst layer-face to access, and depth is the
number of layer-faces to access. Each layer-face is translated into an array layer
and a cube map face as described for layer-face numbers in section 8.5.3.
Component groups from the speci?ed sub-region are packed and placed
into memory as described for GetTextureImage, starting with the texel at
(xoffset; yoffset; zoffset):
Errors
AnINVALID_OPERATION error is generated if texture is not the name of
an existing texture object.
An INVALID_OPERATION error is generated if texture is the name of a
buffer or multisample texture.
An INVALID_OPERATION error is generated if the effective target is
TEXTURE_CUBE_MAP orTEXTURE_CUBE_MAP_ARRAY, and the texture object
is not cube complete or cube array complete, respectively.
An INVALID_VALUE error is generated if xoffset, yoffset or zoffset are
negative.
AnINVALID_VALUE error is generated if width, height, or depth is nega-
tive.
An INVALID_VALUE error is generated if xoffset + width is greater than
the texture’s width, yoffset + height is greater than the texture’s height, or
zoffset + depth is greater than the texture’s depth.
An INVALID_VALUE error is generated if the effective target is
TEXTURE_1D and either yoffset is not zero, or height is not one.
An INVALID_VALUE error is generated if
the effective target is TEXTURE_1D, TEXTURE_1D_ARRAY, TEXTURE_2D or
TEXTURE_RECTANGLE, and either zoffset is not zero, or depth is not one.
AnINVALID_VALUE error is generated if bufSize is negative.
AnINVALID_OPERATION error is generated if the buffer size required to
store the requested data is greater than bufSize.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 251
Texture images stored in compressed form may be obtained with the commands
void GetCompressedTexImage(enum target,int level,
void *pixels );
void GetCompressedTextureImage(uint texture,int level,
sizei bufSize,void *pixels );
void GetnCompressedTexImage(enum target,int level,
sizei bufSize,void *pixels );
For Get*CompressedTexImage, the texture object is that which is bound to
target. For GetCompressedTextureImage, texture is the name of the texture ob-
ject, and the effective target is the value ofTEXTURE_TARGET for texture.
target, level, bufSize, and pixels are interpreted in the same manner as the cor-
responding parameters of GetTexImage, GetTextureImage, and GetnTexImage.
When called, GetCompressedTexImage writes n ubytes of compressed
image data to the pixel pack buffer or client memory pointed to by pix-
els, while GetCompressedTextureImage and GetnCompressedTexImage write
min(n;bufSize) ubytes. n is the value of TEXTURE_COMPRESSED_IMAGE_-
SIZE for the texture image The compressed image data is formatted according to
the de?nition of the texture’s internal format.
By default the pixel storage modes PACK_ROW_LENGTH, PACK_SKIP_ROWS,
PACK_SKIP_PIXELS, PACK_IMAGE_HEIGHT and PACK_SKIP_IMAGES are ig-
nored for compressed images. To enable PACK_SKIP_PIXELS and PACK_-
ROW_LENGTH, the values of PACK_COMPRESSED_BLOCK_SIZE and PACK_-
COMPRESSED_BLOCK_WIDTH must both be non-zero. To also enable PACK_-
SKIP_ROWS and PACK_IMAGE_HEIGHT, the value of PACK_COMPRESSED_-
BLOCK_HEIGHT must be non-zero. And to also enable PACK_SKIP_IMAGES,
the value of PACK_COMPRESSED_BLOCK_DEPTH must be non-zero. All param-
eters must be consistent with the compressed format to produce the desired results.
When the pixel storage modes are active, the correspondence of texels to memory
locations is as de?ned for CompressedTexImage3D in section 8.7.
Errors
An INVALID_OPERATION error is generated by GetCompressedTex-
tureImage if texture is not the name of an existing texture object.
An INVALID_OPERATION error is generated by GetCompressedTex-
tureImage if the effective target is TEXTURE_CUBE_MAP or TEXTURE_-
CUBE_MAP_ARRAY, and the texture object is not cube complete or cube array
complete, respectively.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.11. TEXTUREQUERIES 252
AnINVALID_VALUE error is generated if level is negative, or greater than
the maximum allowable level.
AnINVALID_OPERATION error is generated if the texture image is stored
with an uncompressed internal format.
AnINVALID_OPERATION error is generated if a pixel pack buffer object
is bound and packing the texture image into the buffer’s memory would exceed
the size of the buffer.
AnINVALID_VALUE error is generated if bufSize is negative.
An INVALID_OPERATION error is generated by GetCompressedTex-
tureImage and GetnCompressedTexImage if the buffer size required to store
the requested data is greater than bufSize.
If the compressed data are arranged into ?xed-size blocks of texels, the com-
mand
void GetCompressedTextureSubImage(uint texture,
int level,int xoffset,int yoffset,int zoffset,
sizei width,sizei height,sizei depth,sizei bufSize,
void *pixels );
can be used to obtain a sub-region of a compressed texture image instead of the
whole image. texture is the name of the texture object, and must not be a buffer
or multisample texture. The effective target is the value ofTEXTURE_TARGET for
texture. level and pixels have the same meaning as the corresponding arguments of
CompressedTexSubImage3D. bufSize indicates the size of the buffer to receive
the retrieved pixel data.
For cube map textures, the behavior is as though GetCompressedTexImage
were called once for each requested face (selected by zoffset and depth, as de-
scribed below) with target corresponding to the requested texture cube map face as
indicated by table 9.3. pixels is offset appropriately for each successive image.
xoffset, yoffset and zoffset indicate the position of the subregion to return. width,
height and depth indicate the size of the region to return. These arguments have
the same meaning as for CompressedTexSubImage3D, though there are extra
restrictions, described in the errors section below.
The mapping between the xoffset, yoffset, zoffset, width, height, and depth pa-
rameters and the faces, layers, and layer-faces for cube map, array, and cube map
array textures is the same as for GetTextureSubImage.
The xoffset, yoffset, zoffset offsets and width, height and depth sizes must
be multiples of the values of PACK_COMPRESSED_BLOCK_WIDTH, PACK_-
COMPRESSED_BLOCK_HEIGHT, and PACK_COMPRESSED_BLOCK_DEPTH respec-
OpenGL 4.6 (Core Pro?le) - February 2, 20198.12. DEPTHCOMPONENTTEXTURES 253
tively, unless an offset is zero and the corresponding size is the same as the texture
size in that dimension.
Pixel storage modes are treated as for GetCompressedTexSubImage. The
texel at (xoffset; yoffset; zoffset) will be stored at the location indicated by pixels
and the current pixel packing parameters.
Errors
In addition to the same errors generated by GetTextureSubImage with
corresponding parameters:
AnINVALID_VALUE error is generated if xoffset, yoffset or zoffset is not a
multiple of the compressed block width, height or depth respectively.
An INVALID_VALUE error is generated if width, height or depth is not a
multiple of the compressed block width, height or depth respectively, unless
the offset is zero and the size equals the texture image size.
An INVALID_OPERATION error is generated if the texture compression
format is not based on ?xed-size blocks.
8.12 Depth Component Textures
Depth textures and the depth components of depth/stencil textures can be treated as
RED textures during texture ?ltering and application (see section 8.23). The initial
state for depth and depth/stencil textures treats them asRED textures.
8.13 Cube Map Texture Selection
  
When a cube map texture is sampled, the s t r texture coordinates are treated
  
as a direction vector r r r emanating from the center of a cube. The q
x y z
coordinate is ignored. At texture application time, the interpolated per-fragment
direction vector selects one of the cube map face’s two-dimensional images based
on the largest magnitude coordinate direction (the major axis direction). If two
or more coordinates have the identical magnitude, the implementation may de?ne
the rule to disambiguate this situation. The rule must be deterministic and depend
  
only on r r r . The target column in table 8.19 explains how the major axis
x y z
direction maps to the two-dimensional image of a particular cube map target.
Using thes ,t , andm determined by the major axis direction as speci?ed in
c c a
  
table 8.19, an updated s t is calculated as follows:
OpenGL 4.6 (Core Pro?le) - February 2, 20198.13. CUBEMAPTEXTURESELECTION 254
Major Axis Direction Target s t m
c c a
+r TEXTURE_CUBE_MAP_POSITIVE_X  r  r r
x z y x
 r TEXTURE_CUBE_MAP_NEGATIVE_X r  r r
x z y x
+r TEXTURE_CUBE_MAP_POSITIVE_Y r r r
y x z y
 r TEXTURE_CUBE_MAP_NEGATIVE_Y r  r r
y x z y
+r TEXTURE_CUBE_MAP_POSITIVE_Z r  r r
z x y z
 r TEXTURE_CUBE_MAP_NEGATIVE_Z  r  r r
z x y z
Table 8.19: Selection of cube map images based on major axis direction of texture
coordinates.
 
1 s
c
s = + 1
2 jmj
a
 
1 t
c
t = + 1
2 jmj
a
8.13.1 Seamless Cube Map Filtering
Seamless cube map ?ltering is enabled or disabled by calling Enable or Disable
with targetTEXTURE_CUBE_MAP_SEAMLESS.
  
When seamless cube map ?ltering is disabled, the new s t is used to ?nd a
texture value in the determined face’s two-dimensional image using the rules given
in sections 8.14 through 8.15.
When seamless cube map ?ltering is enabled, the rules for texel selection in
sections 8.14 through 8.15 are modi?ed so that texture wrap modes are ignored.
Instead,
 If NEAREST ?ltering is done within a miplevel, always apply wrap mode
CLAMP_TO_EDGE.
 If LINEAR ?ltering is done within a miplevel, always apply wrap mode
CLAMP_TO_BORDER. Then,
– If a texture sample location would lie in the texture border in eitheru
orv, instead select the corresponding texel from the appropriate neigh-
boring face.
– If a texture sample location would lie in the texture border in both u
andv (in one of the corners of the cube), there is no unique neighbor-
ing face from which to extract one texel. The recommended method to
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 255
generate this texel is to average the values of the three available sam-
ples. However, implementations are free to construct this fourth texel
in another way, so long as, when the three available samples have the
same value, this texel also has that value.
The required state is one bit indicating whether seamless cube map ?ltering is
enabled or disabled. Initially, it is disabled.
8.14 Texture Minification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the
mapping to framebuffer space, then a ?ltering, followed ?nally by a resampling
of the ?ltered, warped, reconstructed image before applying it to a fragment. In
the GL this mapping is approximated by one of two simple ?ltering schemes. One
of these schemes is selected based on whether the mapping from texture space to
framebuffer space is deemed to magnify or minify the texture image.
When the texture’s value of TEXTURE_MAX_ANISOTROPY is equal to 1:0, the
GL uses an isotropic texture ?ltering approach as described in this section and sec-
tion 8.15. However, when the texture’s value of TEXTURE_MAX_ANISOTROPY is
greater than 1:0, the GL should use a texture ?ltering scheme that accounts for
a degree of anisotropy up to the smaller of the texture’s value of TEXTURE_-
MAX_ANISOTROPY or the implementation-de?ned value ofMAX_TEXTURE_MAX_-
ANISOTROPY.
The particular scheme for anisotropic texture ?ltering is implementation de-
pendent. Additionally, implementations are free to consider the current texture
mini?cation and magni?cation modes to control the speci?cs of the anisotropic
?ltering scheme used.
The anisotropic texture ?ltering scheme may only access mipmap levels if the
mini?cation ?lter is one that requires mipmaps. Additionally, when a mini?cation
?lter is speci?ed, the anisotropic texture ?ltering scheme may only access tex-
ture mipmap levels between the texture’s values for TEXTURE_BASE_LEVEL and
TEXTURE_MAX_LEVEL, inclusive. Implementations should also respect the val-
ues of TEXTURE_MAX_LOD and TEXTURE_MIN_LOD to the extent the anisotropic
texture ?ltering scheme permits this.
The following describes one particular approach to implementing anisotropic
texture ?ltering for the two-dimensional texturing case:
Anisotropic texture ?ltering substantially changes section 8.14. Previously a
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 256
single scale factor P was determined based on the pixel’s projection into texture
space. Now two scale factors,  and , are computed:
x y
q
2 2
@u @v
 = +
x
@x @x
q
2 2
@u @v
 = +
y
@y @y
 = max( ; )
max x y
 = min( ; )
min x y
l m

max
N = min( ;maxAniso)

min

0 max
 =log ( )
2
N
where maxAniso is the smaller of the texture’s value of TEXTURE_MAX_-
ANISOTROPY or the implementation-de?ned value of MAX_TEXTURE_MAX_-
ANISOTROPY.
It is acceptable for an implementation to round the sampling rate, N, up to
the nearest supported sampling rate. For example, an implementation may only
support power-of-two sampling rates.
It is also acceptable for an implementation to approximate the ideal functions
 and with functionsf andf subject to the following constraints:
x y x y
   
@u @v
   
1. f is continuous and monotonically increasing in and .
x
@x @x
   
   
@u @v
2. f is continuous and monotonically increasing in and .
   
y
@y @y
    p    
  
@u @v @u @v
       
3. max( ; )f  2 + .
x
@x @x @x @x
       
 
p
       
@u @v @u @v
4. max( ; )f  2   +  .
y
@y @y @y @y
Instead of a single sample,, at (u;v;),N locations in the mipmap at level-
of-detail are sampled within the texture footprint of the pixel.
This sum is de?ned using the single sample. When the texture’s value
aniso
of TEXTURE_MAX_ANISOTROPHY is greater than 1:0, use  instead of  to
aniso
determine the fragment’s texture value.
(
P
N
1 1 i 1 i
(u(x  + ;y);v(x  + ;y)); P >P
x y
i=1
N 2 N+1 2 N+1
 = P
aniso
N
1 1 i 1 i
(u(x;y  + );v(x;y  + )); P P
y x
N i=1 2 N+1 2 N+1
It is acceptable to approximate theu andv functions with equally spaced sam-
ples in texture space at level-of-details:
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 257
(
P
1 N @u i 1 @v i 1
(u(x;y) + (   );v(x;y) + (   )); P >P
x y
N i=1 @x N+1 2 @x N+1 2
 =
P
aniso
N
1 @u i 1 @v i 1
(u(x;y) + (   );v(x;y) + (   )); P P
y x
i=1
N @y N+1 2 @y N+1 2
8.14.1 Scale Factor and Level-of-Detail
The choice is governed by a scale factor(x;y) and the level-of-detail parameter
(x;y), de?ned as
 (x;y) = log [(x;y)] (8.7)
base
2
0
 (x;y) = (x;y) +clamp(bias +bias ) (8.8)
base texobj shader
8
0
lod ;  >lod
> max max
>
<
0 0
; lod  lod
min max
 = (8.9)
0
> lod ;  <lod
min min
>
:
undefined; lod >lod
min max
bias is the value of TEXTURE_LOD_BIAS for the bound texture object (as
texobj
described in section 8.10). bias is the value of the optional bias parameter
shader
in the texture lookup functions available to fragment shaders. If the texture access
is performed in a fragment shader without a provided bias, or outside a fragment
shader, thenbias is zero. The sum of these values is clamped to the range
shader
[ bias ;bias ] where bias is the value of the implementation de?ned
max max max
constantMAX_TEXTURE_LOD_BIAS.
Different implementations have chosen to perform clamping on intermediate
0
and ?nal terms in computing differently. Care should be taken that intermediate
terms do not exceed the implementation-dependent range as different results may
otherwise occur.
If(x;y) is less than or equal to zero, the texture is said to be magni?ed; if
it is greater, the texture is mini?ed. Sampling of mini?ed textures is described in
the remainder of this section, while sampling of magni?ed textures is described in
section 8.15.
The initial values of lod and lod are chosen so as to never clamp the
min max
normal range of.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 258
Lets(x;y) be the function that associates ans texture coordinate with each set
of window coordinates (x;y) that lie within a primitive; de?net(x;y) andr(x;y)
analogously. Let
(
s(x;y) + ; rectangle texture
u
u(x;y) =
w s(x;y) + ; otherwise
s u
(
(8.10)
t(x;y) + ; rectangle texture
v
v(x;y) =
h t(x;y) + ; otherwise
s v
w(x;y) =d r(x;y) +
s w
wherew , h , andd are as de?ned in section 8.5.3 for the texture image whose
s s s
level islevel . For a one-dimensional or one-dimensional array texture, de?ne
base
v(x;y) = 0 andw(x;y) = 0; for a two-dimensional, two-dimensional array, rect-
angle, cube map, or cube map array texture, de?new(x;y) = 0.
( ; ; ) are the texel offsets speci?ed in the OpenGL Shading Language
u v w
texture lookup functions that support offsets. If the texture function used does not
support offsets, all three shader offsets are taken to be zero.
If the value of any non-ignored component of the offset vector operand is
outside implementation-dependent limits, the results of the texture lookup are
unde?ned. For all instructions except textureGather, the limits are the val-
ues ofMIN_PROGRAM_TEXEL_OFFSET andMAX_PROGRAM_TEXEL_OFFSET. For
the textureGather instruction, the limits are the values of MIN_PROGRAM_-
TEXTURE_GATHER_OFFSET andMAX_PROGRAM_TEXTURE_GATHER_OFFSET.
A point sampled in screen space has an elliptical footprint in texture space. The
ideal scale factor should be the major axis of this ellipse.
@u @u @v @v @w @w
The derivatives , , , , , and are used to calculate the value of
@x @y @x @y @x @y
 for a fragment with window coordinates (x;y).
Computing the ellipse major axis using the derivatives inx andy can be im-
practical to implement. Therefore, an implementation may approximate the ideal
 with a functionf(x;y) subject to these conditions:
 
 
 
@u @u
 
1. f(x;y) is continuous and monotonically increasing in each of , ,
 
@x @y
   
   
   
@v @v @w @w
   
, , , and 
@x @y @x @y
     
      p  
     
@u @u @v @v @w @w @u
       
2. max( ; ; ; ; ; )  f(x;y)  2 max( +
     
@x @y @x @y @x @y @x
     
   
     
@v @w @u @v @w
   
+ ;  +  + )
@x @x @y @y @y
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 259
For a polygon or point,  is given at a fragment with window coordinates (x;y)
by
8 9
s s
           
< 2 2 2 2 2 2=
@u @v @w @u @v @w
 = max + + ; + +
: @x @x @x @y @y @y ;
(8.11)
where@u=@x indicates the derivative ofu with respect to windowx, and similarly
for the other derivatives.
For a line, the formula is
s
      
2 2 2
@u @u @v @v @w @w
 = x + y + x + y + x + y l;
@x @y @x @y @x @y
(8.12)
where x = x  x and y = y  y with (x ;y ) and (x ;y ) being the
2 1 2 1 1 1 2 2
p
2 2
segment’s window coordinate endpoints andl = x + y .
While it is generally agreed that equations 8.11 and 8.12 give the best results
when texturing, they are often impractical to implement. Therefore, an imple-
mentation may approximate the ideal  with a function f(x;y) subject to these
conditions:
1. f(x;y) is continuous and monotonically increasing in each ofj@u=@xj,
j@u=@yj,j@v=@xj,j@v=@yj,j@w=@xj, andj@w=@yj
2. Let
   
 
   
@u @u
   
m = max ;
u
   
@x @y
   
 
   
@v @v
   
m = max ;
v
   
@x @y
   
   
@w @w
   
m = max ; :
w
   
@x @y
Then maxfm ;m ;m gf(x;y)m +m +m .
u v w u v w
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 260
8.14.2 Coordinate Wrapping and Texel Selection
After generatingu(x;y),v(x;y), andw(x;y), they may be clamped and wrapped
before sampling the texture, depending on the corresponding texture wrap modes.
0 0 0
Letu (x;y) =u(x;y),v (x;y) =v(x;y), andw (x;y) =w(x;y).
The value assigned to TEXTURE_MIN_FILTER is used to determine how the
texture value for a fragment is selected.
When the value ofTEXTURE_MIN_FILTER isNEAREST, the texel in the texture
0 0 0
image of level level that is nearest (in Manhattan distance) to (u;v;w ) is
base
obtained. Let (i;j;k) be integers such that
0
i =wrap(bu (x;y)c)
0
j =wrap(bv (x;y)c)
0
k =wrap(bw (x;y)c)
and the value returned bywrap() is de?ned in table 8.20. For a three-dimensional
texture, the texel at location (i;j;k) becomes the texture value. For two-
dimensional, two-dimensional array, rectangle, or cube map textures, k is irrele-
vant, and the texel at location (i;j) becomes the texture value. For one-dimensional
texture or one-dimensional array textures, j andk are irrelevant, and the texel at
locationi becomes the texture value.
For one- and two-dimensional array textures, the texel is obtained from image
layerl, where
(
clamp(RNE(t); 0;h   1); for one-dimensional array textures
s
4
l =
clamp(RNE(r); 0;d   1); for two-dimensional array textures
s
andRNE() is the round-to-nearest-even operation de?ned by IEEE arithmetic.
If the selected (i;j;k), (i;j), ori location refers to a border texel that satis?es
any of the conditions
i< 0 iw
s
j < 0 jh
s
k< 0 kd
s
4
Implementations may instead round the texture layer using the nearly equivalent computation
1
bvalue+ c.
2
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 261
Wrap mode Result ofwrap(coord)
CLAMP_TO_EDGE clamp(coord; 0;size  1)
CLAMP_TO_BORDER clamp(coord; 1;size)
REPEAT coord modsize
MIRRORED_REPEAT (size  1) mirror(coord mod (2size)) size)
MIRROR_CLAMP_TO_EDGE clamp(mirror(coord); 0;size  1)
Table 8.20: Texel location wrap mode application. mirror(a) returnsa ifa 0,
and (1 +a) otherwise. The values ofmode andsize areTEXTURE_WRAP_S and
w , TEXTURE_WRAP_T andh , and TEXTURE_WRAP_R andd when wrappingi,
s s s
j, ork coordinates, respectively.
then the border values de?ned by TEXTURE_BORDER_COLOR are used in place
of the non-existent texel. If the texture contains color components, the values of
TEXTURE_BORDER_COLOR are interpreted as an RGBA color to match the tex-
ture’s internal format in a manner consistent with table 8.11. The internal data type
of the border values must be consistent with the type returned by the texture as
described in chapter 8, or the result is unde?ned. If border values are out-of-range
with respect to the texture’s internal format, the result is unde?ned. If the texture
contains depth components, the ?rst component of TEXTURE_BORDER_COLOR is
interpreted as a depth value.
When the value of TEXTURE_MIN_FILTER is LINEAR, a 2 2 2 cube of
texels in the texture image of levellevel is selected. Let
base
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 262
1
0
i =wrap(bu  c)
0
2
1
0
j =wrap(bv   c)
0
2
1
0
k =wrap(bw   c)
0
2
1
0
i =wrap(bu  c + 1)
1
2
1
0
j =wrap(bv   c + 1)
1
2
1
0
k =wrap(bw   c + 1)
1
2
1
0
 =frac(u  )
2
1
0
 =frac(v   )
2
1
0
 =frac(w   )
2
wherefrac(x) denotes the fractional part ofx.
For a three-dimensional texture, the texture value is found as
 = (1 )(1 )(1 ) +(1 )(1 )
i j k i j k
0 0 0 1 0 0
+ (1 )(1 ) +(1 )
i j k i j k
0 1 0 1 1 0
(8.13)
+ (1 )(1 ) +(1 )
i j k i j k
0 0 1 1 0 1
+ (1 ) +
i j k i j k
0 1 1 1 1 1
where is the texel at location (i;j;k) in the three-dimensional texture image.
ijk
For a two-dimensional, two-dimensional array, rectangle, or cube map texture,
 =(1 )(1 ) +(1 )
i j i j
0 0 1 0
+ (1 ) +
i j i j
0 1 1 1
where is the texel at location (i;j) in the two-dimensional texture image. For
ij
two-dimensional array textures, all texels are obtained from layerl, where
 
1
l =clamp( r + ; 0;d   1):
s
2
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 263
Figure 8.4. An example of an 8 8 texture image and the components returned for
textureGather. The vector (X;Y;Z;W ) is returned, where each component is
taken from the post-swizzleR component of the corresponding texel.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 264
ThetextureGather andtextureGatherOffset built-in shader functions
return a vector derived from sampling a 2 2 block of texels in the texture im-
age of levellevel . The rules for the LINEAR mini?cation ?lter are applied to
base
identify the four selected texels. Each texel is then converted to a texture source
color (R ;G ;B ;A ) according to table 15.1 and then swizzled as described in
s s s s
section 15.2.1. A four-component vector is then assembled by taking a single com-
ponent from the swizzled texture source colors of the four texels, in the order ,
i j
0 1
 , , and (see ?gure 8.4). The selected component is identi?ed by the
i j i j i j
1 1 1 0 0 0
optional comp argument, where the values zero, one, two, and three identify the
R , G , B , or A component, respectively. If comp is omitted, it is treated as
s s s s
identifying theR component. Incomplete textures (see section 8.17) are consid-
s
ered to return a texture source color of (0:0; 0:0; 0:0; 1:0) in ?oating-point format
for all four source texels.
The textureGatherOffsets functions operate identically to
textureGather, except that the array of two-component integer vectors offsets is
used to determine the location of the four texels to sample. Each of the four texels is
obtained by applying the corresponding offset in the four-element array offsets as a
(u;v) coordinate offset to the coordinates coord, identifying the four-texelLINEAR
footprint, and then selecting the texel of that footprint. The speci?ed values
i j
0 0
in offsets must be constant. A limited range of offset values are supported; the
minimum and maximum offset values are implementation-dependent and given by
the values of MIN_PROGRAM_TEXTURE_GATHER_OFFSET and MAX_PROGRAM_-
TEXTURE_GATHER_OFFSET, respectively. Note that offset does not apply to the
layer coordinate for array textures.
And for a one-dimensional or one-dimensional array texture,
 = (1 ) +
i i
0 1
where  is the texel at location i in the one-dimensional texture. For one-
i
dimensional array textures, both texels are obtained from layerl, where
 
1
l =clamp( t + ; 0;h   1):
s
2
For any texel in the equation above that refers to a border texel outside the
de?ned range of the image, the texel value is taken from the texture border color as
withNEAREST ?ltering.
8.14.2.1 Rendering Feedback Loops
If all of the following conditions are satis?ed, then the value of the selected ,
ijk
 , or in the above equations is unde?ned instead of referring to the value of the
ij i
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 265
texel at location (i;j;k), (i;j), or (i) respectively. This situation is discussed in
more detail in the description of feedback loops in section 9.3.1.
 The currentDRAW_FRAMEBUFFER_BINDING names a framebuffer object F.
 The texture is attached to one of the attachment points, A, of framebuffer
object F.
 The value ofTEXTURE_MIN_FILTER isNEAREST orLINEAR, and the value
of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for attachment point A
is equal tolevel
base
-or-
The value of TEXTURE_MIN_FILTER is NEAREST_MIPMAP_NEAREST,
NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, or LINEAR_-
MIPMAP_LINEAR, and the value of FRAMEBUFFER_ATTACHMENT_-
TEXTURE_LEVEL for attachment point A is within the inclusive range from
level toq.
base
8.14.3 Mipmapping
TEXTURE_MIN_FILTER values NEAREST_MIPMAP_NEAREST, NEAREST_-
MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, and LINEAR_MIPMAP_LINEAR
each require the use of a mipmap. Rectangle textures do not support mipmapping
(it is an error to specify a mini?cation ?lter that requires mipmapping). A mipmap
is an ordered set of arrays representing the same image; each array has a resolution
lower than the previous one. If the texture image of levellevel has dimensions
base
w h d , then there areblog (maxsize)c + 1 levels in the mipmap, where
s s s
2
8
>w ; for 1D and 1D array textures
s
<
maxsize =
max(w ;h ); for 2D, 2D array, cube map, and cube map array textures
s s
>
:
max(w ;h ;d ); for 3D textures
s s s
Numbering the levels such that levellevel is the 0th level, theith array has
base
dimensions
     
w h d
s s s
max(1; ) max(1; ) max(1; )
w h d
d d d
where
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 266
i
w = 2
d
(
1; for 1D and 1D array textures
h =
d
i
2; otherwise
(
i
2; for 3D textures
d =
d
1; otherwise
until the last array is reached with dimension 1 1 1.
Each array in a mipmap is de?ned using TexImage3D, TexImage2D, Copy-
TexImage2D, TexImage1D, or CopyTexImage1D or by functions that are de?ned
in terms of these functions. The array being set is indicated with the level-of-detail
argument level. Level-of-detail numbers proceed from level for the original
base
texture image through the maximum level p, with each unit increase indicating
an array of half the dimensions of the previous one (rounded down to the next
integer if fractional) as already described. For immutable-format textures (see sec-
tion 8.19),level is clamped to the range [0;level   1],level is then
base immut max
clamped to the range [level ;level  1], andp is one less thanlevel ,
immut immut
base
where level is the levels parameter passed to TexStorage* for the texture
immut
object (the value of TEXTURE_IMMUTABLE_LEVELS; see section 8.19). Other-
wise p = blog (maxsize)c + level , and all arrays from level through
base base
2
q = min(p;level ) must be de?ned, as discussed in section 8.17.
max
The mipmap is used in conjunction with the level-of-detail to approximate the
application of an appropriately ?ltered texture to a fragment. Since this discussion
pertains to mini?cation, we are concerned only with values of where> 0.
For mipmap ?lters NEAREST_MIPMAP_NEAREST and LINEAR_MIPMAP_-
NEAREST, thedth mipmap array is selected, where
8
>level ;  0
base
<
1
d = (8.14)
nearest(); > 0;level +q +
base
2
>
:
1
q; > 0;level +>q +
base
2
where
(
 
1
level + +   1; preferred
base
2
nearest() =  
1
level + + ; alternative
base
2
The rules for NEAREST or LINEAR ?ltering are then applied to the selected
array. Speci?cally, the coordinate (u;v;w) is computed as in equation 8.10, with
OpenGL 4.6 (Core Pro?le) - February 2, 20198.14. TEXTUREMINIFICATION 267
w , h , and d equal to the width, height, and depth of the texture image whose
s s s
level isd.
For mipmap ?lters NEAREST_MIPMAP_LINEAR and LINEAR_MIPMAP_-
LINEAR, the leveld andd mipmap arrays are selected, where
1 2
(
q; level +q
base
d = (8.15)
1
blevel +c; otherwise
base
(
q; level +q
base
d = (8.16)
2
d + 1; otherwise
1
The rules for NEAREST or LINEAR ?ltering are then applied to each of the
selected arrays, yielding two corresponding texture values and . Speci?cally,
1 2
for leveld , the coordinate (u;v;w) is computed as in equation 8.10, withw ,h ,
1 s s
andd equal to the width, height, and depth of the texture image whose level isd .
s 1
0 0 0
For leveld the coordinate (u;v;w ) is computed as in equation 8.10, withw ,
2 s
h , andd equal to the width, height, and depth of the texture image whose level is
s s
d .
2
The ?nal texture value is then found as
 = [1  frac()] + frac() :
1 2
8.14.4 Manual Mipmap Generation
Mipmaps can be generated manually for a texture object with the commands
void GenerateMipmap(enum target );
void GenerateTextureMipmap(uint texture );
For GenerateMipmap, the texture object is that bound to target. For Gener-
ateTextureMipmap, texture is the name of the texture object.
target or the effective target of texture must be one of TEXTURE_-
1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY,
TEXTURE_CUBE_MAP, orTEXTURE_CUBE_MAP_ARRAY.
If target or the effective target of texture is TEXTURE_CUBE_MAP or
TEXTURE_CUBE_MAP_ARRAY, then the texture object must be cube complete or
cube array complete respectively, as de?ned in section 8.17. Otherwise, if
level is not de?ned, or if any dimension is zero, all mipmap levels are left
base
unchanged. This is not an error.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.15. TEXTUREMAGNIFICATION 268
Mipmap generation replaces texture image levelslevel + 1 throughq with
base
images derived from thelevel image, regardless of their previous contents. All
base
other mipmap levels, includinglevel , are left unchanged by this computation.
base
The internal formats and border widths of the derived mipmap texture images
all match those of thelevel image, and the dimensions of the derived images,
base
follow the requirements described in section 8.17.
The contents of the derived images are computed by repeated, ?ltered reduc-
tion of the level image. For one- and two-dimensional array and cube map
base
array textures, each layer is ?ltered independently. No particular ?lter algorithm is
required, though a box ?lter is recommended as the default ?lter.
Any synchronization required before performing this reduction will be done
5
within the Generate*Mipmap commands themselves .
Errors
An INVALID_ENUM error is generated by GenerateMipmap if target is
not one of the valid targets listed above.
An INVALID_OPERATION error is gener-
ated by GenerateTextureMipmap if texture is not the name of an existing
texture object.
An INVALID_OPERATION error is
generated by GenerateTextureMipmap if the effective target is not one of
the valid targets listed above.
An INVALID_OPERATION error is generated by
GenerateTextureMipmap if the effective target is TEXTURE_CUBE_MAP or
TEXTURE_CUBE_MAP_ARRAY, and the texture object is not cube complete or
cube array complete, respectively.
8.14.5
This subsection is only de?ned in the compatibility pro?le.
8.15 Texture Magnification
When  indicates magni?cation, the value assigned to TEXTURE_MAG_FILTER
determines how the texture value is obtained. There are two possible values
5
For example, if mipmaps were generated by texture fetches, a fetch barrier would be issued
prior to reduction; or if mipmaps were generated on the CPU, a texture update barrier would be
issued prior to reduction.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.16. COMBINEDDEPTH/STENCILTEXTURES 269
forTEXTURE_MAG_FILTER:NEAREST andLINEAR.NEAREST behaves exactly as
NEAREST forTEXTURE_MIN_FILTER andLINEAR behaves exactly asLINEAR for
TEXTURE_MIN_FILTER as described in section 8.14, including the texture coordi-
nate wrap modes speci?ed in table 8.20. The level-of-detaillevel texture image
base
is always used for magni?cation.
8.16 Combined Depth/Stencil Textures
If the texture image has a base internal format ofDEPTH_STENCIL, then the stencil
index texture component is ignored by default. The texture value does not include
a stencil index component, but includes only the depth component.
In order to access the stencil index texture component theDEPTH_STENCIL_-
TEXTURE_MODE texture parameter should be set to STENCIL_INDEX. When this
mode is set the depth component is ignored and the texture value includes only the
stencil index component. The stencil index value is treated as an unsigned inte-
ger texture and returns an unsigned integer value when sampled. When sampling
the stencil index only NEAREST ?ltering is supported. The DEPTH_STENCIL_-
TEXTURE_MODE is ignored for non depth/stencil textures.
8.17 Texture Completeness
A texture is said to be complete if all the texture images and texture parameters
required to utilize the texture for texture application are consistently de?ned. The
de?nition of completeness varies depending on texture dimensionality and type.
For one-, two-, and three-dimensional and one- and two-dimensional array tex-
tures, a texture is mipmap complete if all of the following conditions hold true:
 The set of mipmap images level through q (where q is de?ned in sec-
base
tion 8.14.3) were each speci?ed with the same internal format.
 The dimensions of the images follow the sequence described in sec-
tion 8.14.3.
 level level
base max
Image levelsk wherek < level ork > q are insigni?cant to the de?nition of
base
completeness.
A cube map texture is mipmap complete if each of the six texture images,
considered individually, is mipmap complete. Additionally, a cube map texture is
cube complete if the following conditions all hold true:
OpenGL 4.6 (Core Pro?le) - February 2, 20198.17. TEXTURECOMPLETENESS 270
 Thelevel texture images of each of the six cube map faces have identical,
base
positive, and square dimensions.
 Thelevel images were each speci?ed with the same internal format.
base
A cube map array texture is cube array complete if it is complete when treated
as a two-dimensional array and cube complete for every cube map slice within the
array texture.
Using the preceding de?nitions, a texture is complete unless any of the follow-
ing conditions hold true:
 Any dimension of the level image is not positive. For a rectangle or
base
multisample texture,level is always zero.
base
 The texture is a cube map texture, and is not cube complete.
 The texture is a cube map array texture, and is not cube array complete.
 The mini?cation ?lter requires a mipmap (is neitherNEAREST norLINEAR),
and the texture is not mipmap complete.
 Any of
– The internal format of the texture is integer (see table 8.12).
– The internal format isSTENCIL_INDEX.
– The internal format is DEPTH_STENCIL, and the value of DEPTH_-
STENCIL_TEXTURE_MODE for the texture isSTENCIL_INDEX.
and either the magni?cation ?lter is not NEAREST, or the mini?cation ?lter
is neitherNEAREST norNEAREST_MIPMAP_NEAREST.
8.17.1 Effects of Sampler Objects on Texture Completeness
If a sampler object and a texture object are simultaneously bound to the same tex-
ture unit, then the sampling state for that unit is taken from the sampler object (see
section 8.2). This can have an effect on the effective completeness of the texture. In
particular, if the texture is not mipmap complete and the sampler object speci?es a
TEXTURE_MIN_FILTER requiring mipmaps, the texture will be considered incom-
plete for the purposes of that texture unit. However, if the sampler object does not
require mipmaps, the texture object will be considered complete. This means that
a texture can be considered both complete and incomplete simultaneously if it is
bound to two or more texture units along with sampler objects with different states.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.18. TEXTUREVIEWS 271
8.17.2 Effects of Completeness on Texture Application
Texture lookup and texture fetch operations performed in shaders are affected
by completeness of the texture being sampled as described in sections 11.1.3.5
and 15.2.1.
8.17.3 Effects of Completeness on Texture Image Specification
The implementation-dependent maximum sizes for texture images depend on the
texture level. In particular, an implementation may allow a texture image of level
one or greater to be created only if a mipmap complete set of images consistent with
the requested image can be supported with default values of TEXTURE_BASE_-
LEVEL andTEXTURE_MAX_LEVEL (see table 23.14). As a result, implementations
may permit a texture image at level zero that will never be mipmap complete and
can only be used with non-mipmapped mini?cation ?lters.
8.18 Texture Views
A texture can be created which references the data store of another texture and
interprets the data with a different format, and/or selects a subset of the levels
and/or layers of the other texture. The data store for such a texture is shared with
the data store of the original texture. Updating the shared data store using the
original texture affects texture values read using the new texture, and vice versa. A
texture data store remains in existence until all textures that reference it are deleted.
The command
void TextureView(uint texture,enum target,
uint origtexture,enum internalformat,uint minlevel,
uint numlevels,uint minlayer,uint numlayers );
initializes the texture named texture to the target speci?ed by target. texture’s data
store is inherited from the texture named origtexture, but elements of the data store
are interpreted according to the internal format speci?ed by internalformat. Ad-
ditionally, if origtexture is an array or has multiple mipmap levels, the parameters
minlayer, numlayers, minlevel, and numlevels control which of those slices and
levels are considered part of the texture.
The minlevel and minlayer parameters are relative to the view of origtexture. If
numlayers or numlevels extend beyond origtexture, they are clamped to the maxi-
mum extent of the original texture.
If the command is successful, the texture parameters in texture are updated as
follows:
OpenGL 4.6 (Core Pro?le) - February 2, 20198.18. TEXTUREVIEWS 272
 TEXTURE_IMMUTABLE_FORMAT is set toTRUE.
 TEXTURE_IMMUTABLE_LEVELS is set to the value of TEXTURE_-
IMMUTABLE_LEVELS for origtexture.
 TEXTURE_VIEW_MIN_LEVEL is set to minlevel plus the value of
TEXTURE_VIEW_MIN_LEVEL for origtexture.
 TEXTURE_VIEW_MIN_LAYER is set to minlayer plus the value of
TEXTURE_VIEW_MIN_LAYER for origtexture.
 TEXTURE_VIEW_NUM_LEVELS is set to the lesser of numlevels and the value
ofTEXTURE_VIEW_NUM_LEVELS for origtexture minus minlevel.
 TEXTURE_VIEW_NUM_LAYERS is set to the lesser of numlayers and the value
ofTEXTURE_VIEW_NUM_LAYERS for origtexture minus minlayer.
The new texture’s target must be compatible with the target of origtexture, as
de?ned by table 8.21.
Numerous constraints on numlayers and the texture dimensions depend on tar-
get and the target of origtexture. These constraints are summarized below in the
errors section.
When origtexture’s target is TEXTURE_CUBE_MAP, the layer parameters are
interpreted in the same order as if it were a TEXTURE_CUBE_MAP_ARRAY with 6
layer-faces.
The two textures’ internal formats must be compatible according to table 8.22
if the internal format exists in that table. The internal formats must be identical if
not in that table. If the internal formats are the same but are a base internal format,
the implementation’s effective internal format (see the end of section 8.5) for each
texture must be the same.
If the internal format does not exactly match the internal format of the original
texture, the contents of the memory are reinterpreted in the same manner as for
image bindings described in section 8.26.
Texture commands that take a level or layer parameter, such as TexSubIm-
age2D, interpret that parameter to be relative to the view of the texture. i.e. the
mipmap level of the data store that would be updated via TexSubImage2D would
be the sum of level and the value ofTEXTURE_VIEW_MIN_LEVEL.
Errors
AnINVALID_VALUE error is generated if texture is zero.
AnINVALID_OPERATION error is generated if texture is not a valid name
OpenGL 4.6 (Core Pro?le) - February 2, 20198.18. TEXTUREVIEWS 273
Original target Valid new targets
TEXTURE_1D TEXTURE_1D,TEXTURE_1D_ARRAY
TEXTURE_2D TEXTURE_2D,TEXTURE_2D_ARRAY
TEXTURE_3D TEXTURE_3D
TEXTURE_CUBE_MAP TEXTURE_CUBE_MAP, TEXTURE_2D,
TEXTURE_2D_ARRAY, TEXTURE_CUBE_-
MAP_ARRAY
TEXTURE_RECTANGLE TEXTURE_RECTANGLE
TEXTURE_BUFFER none
TEXTURE_1D_ARRAY TEXTURE_1D_ARRAY,TEXTURE_1D
TEXTURE_2D_ARRAY TEXTURE_2D_ARRAY, TEXTURE_2D,
TEXTURE_CUBE_MAP, TEXTURE_CUBE_-
MAP_ARRAY
TEXTURE_CUBE_MAP_ARRAY TEXTURE_CUBE_MAP_ARRAY, TEXTURE_2D_-
ARRAY,TEXTURE_2D,TEXTURE_CUBE_MAP
TEXTURE_2D_MULTISAMPLE TEXTURE_2D_MULTISAMPLE, TEXTURE_2D_-
MULTISAMPLE_ARRAY
TEXTURE_2D_MULTISAMPLE_ARRAY TEXTURE_2D_MULTISAMPLE, TEXTURE_2D_-
MULTISAMPLE_ARRAY
Table 8.21: Legal texture targets for TextureView.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.18. TEXTUREVIEWS 274
Class Internal formats
VIEW_CLASS_128_BITS RGBA32F,RGBA32UI,RGBA32I
VIEW_CLASS_96_BITS RGB32F,RGB32UI,RGB32I
VIEW_CLASS_64_BITS RGBA16F, RG32F, RGBA16UI, RG32UI, RGBA16I, RG32I,
RGBA16,RGBA16_SNORM
VIEW_CLASS_48_BITS RGB16,RGB16_SNORM,RGB16F,RGB16UI,RGB16I
VIEW_CLASS_32_BITS RG16F, R11F_G11F_B10F, R32F, RGB10_A2UI, RGBA8UI,
RG16UI, R32UI, RGBA8I, RG16I, R32I, RGB10_A2, RGBA8,
RG16,RGBA8_SNORM,RG16_SNORM,SRGB8_ALPHA8,RGB9_E5
VIEW_CLASS_24_BITS RGB8,RGB8_SNORM,SRGB8,RGB8UI,RGB8I
VIEW_CLASS_16_BITS R16F, RG8UI, R16UI, RG8I, R16I, RG8, R16, RG8_SNORM,
R16_SNORM
VIEW_CLASS_8_BITS R8UI,R8I,R8,R8_SNORM
VIEW_CLASS_RGTC1_RED COMPRESSED_RED_RGTC1,COMPRESSED_SIGNED_RED_RGTC1
VIEW_CLASS_RGTC2_RG COMPRESSED_RG_RGTC2,COMPRESSED_SIGNED_RG_RGTC2
VIEW_CLASS_BPTC_UNORM COMPRESSED_RGBA_BPTC_UNORM, COMPRESSED_SRGB_-
ALPHA_BPTC_UNORM
VIEW_CLASS_BPTC_FLOAT COMPRESSED_RGB_BPTC_SIGNED_FLOAT, COMPRESSED_-
RGB_BPTC_UNSIGNED_FLOAT
Table 8.22: Compatible internal formats for TextureView. Formats in the same
row may be cast to each other.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.19. IMMUTABLE-FORMATTEXTUREIMAGES 275
returned by GenTextures, or if texture has already been bound and given a
target.
AnINVALID_VALUE error is generated if origtexture is not the name of a
texture.
An INVALID_OPERATION error is generated if the value of TEXTURE_-
IMMUTABLE_FORMAT for origtexture is notTRUE.
An INVALID_OPERATION error is generated if target is not compatible
with the target of origtexture, as de?ned by table 8.21.
AnINVALID_OPERATION error is generated if the internal format of orig-
texture exists in table 8.22 and is not compatible with internalformat, as de-
scribed in that table.
AnINVALID_OPERATION error is generated if the internal format of orig-
texture does not exist in table 8.22, and is not identical to internalformat.
An INVALID_VALUE error is generated if minlevel or minlayer are larger
than the greatest level or layer, respectively, of origtexture.
An INVALID_VALUE error is generated if target is TEXTURE_CUBE_MAP
and the clamped numlayers is not 6.
An INVALID_VALUE error is generated if target is TEXTURE_CUBE_-
MAP_ARRAY and the clamped numlayers is not a multiple of 6.
An INVALID_VALUE error is generated if target is TEXTURE_1D,
TEXTURE_2D, TEXTURE_3D, TEXTURE_RECTANGLE, or TEXTURE_2D_-
MULTISAMPLE and numlayers does not equal 1.
An INVALID_OPERATION error is generated if target is TEXTURE_-
CUBE_MAP orTEXTURE_CUBE_MAP_ARRAY, and the width and height of orig-
texture’s levels are not equal.
AnINVALID_OPERATION error is generated if any dimension of origtex-
ture is larger than the maximum supported corresponding dimension of the
new target. For example, if origtexture has aTEXTURE_2D_ARRAY target and
target isTEXTURE_CUBE_MAP, its width must be no greater than the value of
MAX_CUBE_MAP_TEXTURE_SIZE.
An INVALID_OPERATION error is generated if the computed values of
TEXTURE_VIEW_NUM_LEVELS orTEXTURE_VIEW_NUM_LAYERS for texture,
as described above, are less than or equal to zero.
8.19 Immutable-Format Texture Images
An alternative set of commands is provided for specifying the properties of all
levels of a texture at once. Once a texture is speci?ed with such a command, the
format and dimensions of all levels becomes immutable, unless it is a proxy texture
OpenGL 4.6 (Core Pro?le) - February 2, 20198.19. IMMUTABLE-FORMATTEXTUREIMAGES 276
(since otherwise it would no longer be possible to use the proxy). The contents of
the images and the parameters can still be modi?ed. Such a texture is referred
to as an immutable-format texture. The immutability status of a texture can be
determined by calling GetTexParameter with pname TEXTURE_IMMUTABLE_-
FORMAT.
Each of the commands below is described by pseudocode which indicates the
effect on the dimensions and format of the texture. For each command the follow-
ing apply in addition to the pseudocode:
 If executing the pseudocode would result in any other error, the error is gen-
erated and the command will have no effect.
 Any existing levels that are not replaced are reset to their initial state.
 The pixel unpack buffer should be considered to be zero; i.e., the image
contents are unspeci?ed.
 Since no pixel data are provided, the format and type values used in the
pseudocode are irrelevant; they can be considered to be any values that are
legal to use with internalformat.
 If the command is successful, TEXTURE_IMMUTABLE_FORMAT becomes
TRUE.TEXTURE_IMMUTABLE_LEVELS andTEXTURE_VIEW_NUM_LEVELS
become levels. If the texture target is TEXTURE_1D_ARRAY then
TEXTURE_VIEW_NUM_LAYERS becomes height. If the texture target is
TEXTURE_2D_ARRAY, TEXTURE_CUBE_MAP_ARRAY, or TEXTURE_2D_-
MULTISAMPLE_ARRAY thenTEXTURE_VIEW_NUM_LAYERS becomes depth.
If the texture target is TEXTURE_CUBE_MAP, then TEXTURE_VIEW_NUM_-
LAYERS becomes 6. For any other texture target, TEXTURE_VIEW_NUM_-
LAYERS becomes 1.
The TexStorage* commands specify properties of the texture object bound to
the target parameter of each command.
The TextureStorage* commands behave similarly to the equivalent TexStor-
age* commands, but specify properties of the texture object named by the texture
parameter of each command. The effective target of texture must be compatible
with the target parameter of the equivalent TexStorage* command.
For each command, the following errors are generated in addition to the errors
described speci?c to that command:
OpenGL 4.6 (Core Pro?le) - February 2, 20198.19. IMMUTABLE-FORMATTEXTUREIMAGES 277
Errors
An INVALID_OPERATION error is generated by TexStorage* if zero is
bound to target.
An INVALID_OPERATION error is generated by TextureStorage* if tex-
ture is not the name of an existing texture object.
An INVALID_VALUE error is generated if width, height, depth or levels
are less than 1, for commands with the corresponding parameters.
An INVALID_ENUM error is generated if internalformat is one of the un-
sized base internal formats listed in table 8.11.
The commands
void TexStorage1D(enum target,sizei levels,
enum internalformat,sizei width );
void TextureStorage1D(uint texture,sizei levels,
enum internalformat,sizei width );
specify all the levels of a one-dimensional texture (or for TexStorage1D, proxy) at
the same time. TexStorage1D is described by the pseudocode below:
for (i = 0; i < levels; i++) f
TexImage1D(target, i, internalformat, width, 0,
format, type, NULL);
 
width
width = max(1; );
2
g
Errors
In addition to the generic errors described at the start of this section,
An INVALID_ENUM error is generated by TexStorage1D if target is not
TEXTURE_1D orPROXY_TEXTURE_1D.
AnINVALID_OPERATION error is generated by TextureStorage1D if the
effective target is notTEXTURE_1D.
An INVALID_OPERATION error is generated if levels is greater than
blog (width)c + 1.
2
The commands
void TexStorage2D(enum target,sizei levels,
enum internalformat,sizei width,sizei height );
OpenGL 4.6 (Core Pro?le) - February 2, 20198.19. IMMUTABLE-FORMATTEXTUREIMAGES 278
void TextureStorage2D(uint texture,sizei levels,
enum internalformat,sizei width,sizei height );
specify all the levels of a two-dimensional, cube map, one-dimensional array or
rectangle texture (or for TexStorage2D, proxy) at the same time. TexStorage2D
is described by the target-dependent pseudocode below:
targets TEXTURE_2D, PROXY_TEXTURE_2D, TEXTURE_RECTANGLE, PROXY_-
TEXTURE_RECTANGLE, orPROXY_TEXTURE_CUBE_MAP:
for (i = 0; i < levels; i++) f
TexImage2D(target, i, internalformat, width, height, 0,
format, type, NULL);
 
width
width = max(1; );
2
j k
height
height = max(1; );
2
g
targetTEXTURE_CUBE_MAP:
for (i = 0; i < levels; i++) f
for face in (each target in table 8.19) f
TexImage2D(face, i, internalformat, width, height, 0,
format, type, NULL);
g
 
width
width = max(1; );
j 2 k
height
height = max(1; );
2
g
targetsTEXTURE_1D_ARRAY orPROXY_TEXTURE_1D_ARRAY:
for (i = 0; i < levels; i++) f
TexImage2D(target, i, internalformat, width, height, 0,
format, type, NULL);
 
width
width = max(1; );
2
g
Errors
In addition to the generic errors described at the start of this section,
An INVALID_ENUM error is generated by TexStorage2D if target is not
OpenGL 4.6 (Core Pro?le) - February 2, 20198.19. IMMUTABLE-FORMATTEXTUREIMAGES 279
one of those listed above.
AnINVALID_OPERATION error is generated by TextureStorage2D if the
effective target is not one of those listed above.
AnINVALID_OPERATION error is generated if any of the following con-
ditions hold:
 The effective target is TEXTURE_1D_ARRAY or PROXY_TEXTURE_-
1D_ARRAY, and levels is greater thanblog (width)c + 1
2
 The effective target is notTEXTURE_1D_ARRAY orPROXY_TEXTURE_-
1D_ARRAY, and levels is greater thanblog (max(width;height))c + 1
2
AnINVALID_OPERATION error is generated by TexStorage2D and Tex-
tureStorage2D if internalformat is one of the EAC, ETC2, or RGTC formats
and the effective target isTEXTURE_RECTANGLE.
The commands
void TexStorage3D(enum target,sizei levels,
enum internalformat,sizei width,sizei height,
sizei depth );
void TextureStorage3D(uint texture,sizei levels,
enum internalformat,sizei width,sizei height,
sizei depth );
specify all the levels of a three-dimensional, two-dimensional array texture, or cube
map array texture (or for TexStorage3D, proxy). TexStorage3D is described by
the target-dependent pseudocode below:
targetsTEXTURE_3D orPROXY_TEXTURE_3D:
for (i = 0; i < levels; i++) f
TexImage3D(target, i, internalformat, width, height, depth, 0,
format, type, NULL);
 
width
width = max(1; );
j 2 k
height
height = max(1; );
2
j k
depth
depth = max(1; );
2
g
targets TEXTURE_2D_ARRAY, PROXY_TEXTURE_2D_ARRAY, TEXTURE_CUBE_-
MAP_ARRAY orPROXY_TEXTURE_CUBE_MAP_ARRAY:
OpenGL 4.6 (Core Pro?le) - February 2, 20198.19. IMMUTABLE-FORMATTEXTUREIMAGES 280
for (i = 0; i < levels; i++) f
TexImage3D(target, i, internalformat, width, height, depth, 0,
format, type, NULL);
 
width
width = max(1; );
2
j k
height
height = max(1; );
2
g
Errors
In addition to the generic errors described at the start of this section,
An INVALID_ENUM error is generated by TexStorage3D if target is not
one of those listed above.
AnINVALID_OPERATION error is generated by TextureStorage3D if the
effective target is not one of those listed above.
AnINVALID_OPERATION error is generated if any of the following con-
ditions hold:
 The effective target isTEXTURE_3D orPROXY_TEXTURE_3D and levels
is greater thanblog (max(width;height;depth)))c + 1
2
 The effective target is TEXTURE_2D_ARRAY, PROXY_TEXTURE_2D_-
ARRAY, TEXTURE_CUBE_MAP_ARRAY or PROXY_TEXTURE_CUBE_-
MAP_ARRAY and levels is greater thanblog (max(width;height))c+1
2
 The effective target isTEXTURE_CUBE_MAP_ARRAY and depth is not a
multiple of 6.
The commands
void TexStorage2DMultisample(enum target,sizei samples,
enum internalformat,sizei width,sizei height,
boolean ?xedsamplelocations );
void TextureStorage2DMultisample(uint texture,
sizei samples,enum internalformat,sizei width,
sizei height,boolean ?xedsamplelocations );
specify a
two-dimensional multisample texture (or for TexStorage2DMultisample, proxy).
For TexStorage2DMultisample, target must be TEXTURE_2D_MULTISAMPLE or
PROXY_TEXTURE_2D_MULTISAMPLE.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.19. IMMUTABLE-FORMATTEXTUREIMAGES 281
Calling TexStorage2DMultisample is
equivalent to calling TexImage2DMultisample with the equivalently named pa-
rameters set to the same values, except that the resulting texture has immutable
format.
Errors
In addition to the generic errors described at the start of this section,
An INVALID_ENUM error is generated by TexStorage2DMultisample
if target is not TEXTURE_2D_MULTISAMPLE or PROXY_TEXTURE_2D_-
MULTISAMPLE.
An INVALID_OPERATION
error is generated by TextureStorage2DMultisample if the effective target
is notTEXTURE_2D_MULTISAMPLE.
The commands
void TexStorage3DMultisample(enum target,sizei samples,
enum internalformat,sizei width,sizei height,
sizei depth,boolean ?xedsamplelocations );
void TextureStorage3DMultisample(uint texture,
sizei samples,enum internalformat,sizei width,
sizei height,sizei depth,
boolean ?xedsamplelocations );
specify a two-dimensional
multisample array texture (or, for TexStorage3DMultisample, proxy). For TexS-
torage3DMultisample, target must be TEXTURE_2D_MULTISAMPLE_ARRAY or
PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
Calling TexStorage3DMultisample is equivalent to calling TexIm-
age3DMultisample with the equivalently named parameters set to the same
values, except that the resulting texture has immutable format.
Errors
In addition to the generic errors described at the start of this section,
An INVALID_ENUM error is generated by TexStorage3DMultisample
if target is not TEXTURE_2D_MULTISAMPLE_ARRAY or PROXY_TEXTURE_-
2D_MULTISAMPLE_ARRAY.
An INVALID_-
OPERATION error is generated by TextureStorage3DMultisample if target
OpenGL 4.6 (Core Pro?le) - February 2, 20198.20. INVALIDATINGTEXTUREIMAGEDATA 282
is notTEXTURE_2D_MULTISAMPLE_ARRAY.
8.19.1 Behavior of Immutable-Format Texture Images
After a successful call to any Tex*Storage* command with a non-proxy target, no
further changes to the dimensions or format of the texture object may be made.
Other commands may only alter the texel values and texture parameters.
Errors
An INVALID_OPERATION error is generated by any of the commands
CompressedTexImage*, CopyTexImage*, TexImage*, and TexStorage*
with the same texture, even if it does not affect the dimensions or format:
8.20 Invalidating Texture Image Data
All or part of a texture image may be invalidated, effectively leaving those texels
unde?ned, by calling
void InvalidateTexSubImage(uint texture,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth );
with texture and level indicating which texture image is being invalidated. After
this command, data in that subregion have unde?ned values.
Arguments xoffset, yoffset, and zoffset specify the lower left back texel coordi-
nates of a width-wide by height-high by depth-deep rectangular subregion of the
texture image to invalidate, and are interpreted as described for TexSubImage3D
in section 8.6. The subregion must lie within the bounds of the texture image, as
described in that section.
Cube map textures are treated as an array of six slices in the z-dimension,
where a value of zoffset is interpreted as specifying the cube map face for the
corresponding layer in table 9.3.
For texture types that do not have certain dimensions, InvalidateTexSubImage
treats those dimensions as having a size of 1. For example, to invalidate a portion
of a two-dimensional texture, use zoffset equal to zero and depth equal to one.
Errors
AnINVALID_VALUE error is generated if level is negative or greater than
OpenGL 4.6 (Core Pro?le) - February 2, 20198.21. CLEARINGTEXTUREIMAGEDATA 283
log of the maximum texture width, height, or depth.
2
An INVALID_OPERATION error is generated if the speci?ed subregion
does not lie within the bounds of the texture image, as described for Tex-
SubImage3D in section 8.6.
AnINVALID_OPERATION error is generated if texture is zero or is not the
name of a texture. It is not possible to invalidate a portion of a default texture.
An INVALID_VALUE error is generated if the effective target of texture
isTEXTURE_RECTANGLE,TEXTURE_BUFFER,TEXTURE_2D_MULTISAMPLE,
orTEXTURE_2D_MULTISAMPLE_ARRAY, and level is not zero.
AnINVALID_VALUE error is generated if width, height, or depth is nega-
tive.
The command
void InvalidateTexImage(uint texture,int level );
is equivalent to calling InvalidateTexSubImage with xoffset, yoffset, and zoffset
equal to 0 and width, height, and depth equal to the dimensions of the texture
image (or zero and one for dimensions the texture doesn’t have).
8.21 Clearing Texture Image Data
All or part of a texture image may be ?lled with a constant value with the command
void ClearTexSubImage(uint texture,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth,enum format,enum type,
const void *data );
with texture and level indicating which texture image is being cleared. It is an error
if texture is zero or not the name of a texture object, if texture is a buffer texture, or
if the texture image has a compressed internal format.
Arguments xoffset, yoffset, and zoffset specify the lower left back texel coordi-
nates of a width-wide by height-high by depth-deep rectangular subregion of the
texture image, and are interpreted as described for TexSubImage3D in section 8.6.
The subregion must lie within the bounds of the texture image, as described in that
section.
For one-dimensional array textures, yoffset is interpreted as the ?rst layer to
be cleared and height is the number of layers to clear. For two-dimensional array
textures, zoffset is interpreted as the ?rst layer to be cleared and depth is the number
OpenGL 4.6 (Core Pro?le) - February 2, 20198.21. CLEARINGTEXTUREIMAGEDATA 284
of layers to clear. Cube map textures are treated as an array of six slices in the z-
dimension, where the value of zoffset is interpreted as specifying the cube map face
for the corresponding layer in table 9.3 and depth is the number of faces to clear.
For cube map array textures, zoffset is the ?rst layer-face to clear, and depth is the
number of layer-faces to clear. Each layer-face is translated into an array layer and
a cube map face as described for layer-face numbers in section 8.5.3.
For texture types that do not have certain dimensions, ClearTexSubImage
treats those dimensions as having a size of 1. For example, to clear a portion
of a two-dimensional texture, use zoffset equal to zero and depth equal to one.
format and type specify the format and type of the source data and are inter-
preted as they are for TexImage3D, as described in section 8.4.4. Textures with a
base internal format ofDEPTH_COMPONENT,STENCIL_INDEX,DEPTH_STENCIL
require depth component, stencil, or depth/stencil component data respectively.
Textures with other base internal formats requireRGBA formats. Textures with in-
teger internal formats (see table 8.12) require integer data.
data is a pointer to an array of between one and four components of texel
data that will be used as the source for the constant ?ll value. The elements of
data are converted by the GL into the internalformat of the texture image (that
was speci?ed when the level was de?ned by any of the TexImage, TexStorage
or CopyTexImage commands) in the manner described in section 8.4.4, and then
used to ?ll the speci?ed range of the destination texture level. If data isNULL, then
the pointer is ignored and the sub-range of the texture image is ?lled with zeros. If
texture is a multisample texture, all the samples in a texel are cleared to the value
speci?ed by data.
Errors
An INVALID_OPERATION error is generated if texture is zero or not the
name of a texture object.
AnINVALID_OPERATION error is generated if texture is a buffer texture.
An INVALID_OPERATION error is generated if texture has a compressed
internal format.
AnINVALID_VALUE error is generated if width, height, or depth is nega-
tive.
AnINVALID_OPERATION error is generated if the base internal format is
DEPTH_COMPONENT and format is notDEPTH_COMPONENT.
AnINVALID_OPERATION error is generated if the base internal format is
DEPTH_STENCIL and format is notDEPTH_STENCIL.
AnINVALID_OPERATION error is generated if the base internal format is
OpenGL 4.6 (Core Pro?le) - February 2, 20198.22. TEXTURESTATEANDPROXYSTATE 285
STENCIL_INDEX and format is notSTENCIL_INDEX.
AnINVALID_OPERATION error is generated if the base internal format is
RGBA and the format is DEPTH_COMPONENT, STENCIL_INDEX, or DEPTH_-
STENCIL.
AnINVALID_OPERATION error is generated if the internal format is inte-
ger and format does not specify integer data.
An INVALID_OPERATION error is generated if the internal format is not
integer and format does specify integer data.
An INVALID_OPERATION error is generated if the speci?ed subregion
does not lie within the bounds of the texture image, as described for Tex-
SubImage3D in section 8.6.
The command
void ClearTexImage(uint texture,int level,enum format,
enum type,const void * data );
is equivalent to calling ClearTexSubImage with xoffset, yoffset, and zoffset equal
to 0, and width, height, and depth equal to the dimensions of the texture image (or
zero and one for dimensions the texture doesn’t have).
Errors
In addition to the errors generated by ClearTexSubImage:
An INVALID_OPERATION error is generated if the texture image identi-
?ed by level has not previously been de?ned by a TexImage* or TexStorage*
command.
8.22 Texture State and Proxy State
The state necessary for texture can be divided into two categories. First, there
are the multiple sets of texture images (a single image for the rectangle texture
target; one set of mipmap images each for the one-, two-, and three-dimensional
and one- and two-dimensional array texture targets; and six sets of mipmap im-
ages each for the cube map and cube map array texture targets) and their num-
ber. Each array has associated with it a width, height (two- and three-dimensional,
rectangle, one-dimensional array, cube map, and cube map array only), and depth
(three-dimensional, two-dimensional array, and cube map array only), an integer
describing the internal format of the image, integer values describing the resolu-
tions of each of the red, green, blue, alpha, depth, and stencil components of the
OpenGL 4.6 (Core Pro?le) - February 2, 20198.22. TEXTURESTATEANDPROXYSTATE 286
image, integer values describing the type (unsigned normalized, integer, ?oating-
point, etc.) of each of the components, a boolean describing whether the image is
compressed or not, an integer size of a compressed image, and an integer contain-
ing the name of a buffer object bound as the data store of the image.
Each initial texture image is null. It has zero width, height, and depth, internal
formatRGBA, orR8 for buffer textures, component sizes set to zero and component
types set to NONE, the compressed ?ag set to FALSE, a zero compressed size, and
the bound buffer object name is zero.
Multisample textures also contain an integer identifying the number of samples
in each texel, and a boolean indicating whether identical sample locations and the
same number of samples will be used for all texels in the image.
Buffer textures also contain two pointer sized integers containing the offset and
range of the buffer object’s data store.
Next, there are the ?ve sets of texture properties, corresponding to the one-,
two-, three-dimensional, cube map and cube map array texture targets. Each set
consists of the selected mini?cation and magni?cation ?lters, the wrap modes for
s, t (two- and three-dimensional and cube map only), and r (three-dimensional
only), the TEXTURE_BORDER_COLOR, two ?oating-point numbers describing the
minimum and maximum level-of-detail, two integers describing the base and max-
imum mipmap image levels, a boolean ?ag indicating whether the format and
dimensions of the texture are immutable, three integers describing the depth tex-
ture mode, compare mode, and compare function, an integer describing the depth
stencil texture mode, and four integers describing the red, green, blue, and alpha
swizzle modes (see section 15.2.1).
In the initial state, the value assigned to TEXTURE_MIN_FILTER is
NEAREST_MIPMAP_LINEAR (except for rectangle textures, where the initial value
isLINEAR), and the value forTEXTURE_MAG_FILTER isLINEAR.s,t, andr wrap
modes are all set to REPEAT (except for rectangle textures, where the initial value
is CLAMP_TO_EDGE). The values of TEXTURE_MIN_LOD and TEXTURE_MAX_-
LOD are -1000 and 1000 respectively. The values of TEXTURE_BASE_LEVEL and
TEXTURE_MAX_LEVEL are 0 and 1000 respectively. The value of TEXTURE_-
BORDER_COLOR is (0,0,0,0). The value of TEXTURE_IMMUTABLE_FORMAT is
FALSE. The values of TEXTURE_COMPARE_MODE, and TEXTURE_COMPARE_-
FUNC are NONE, and LEQUAL respectively. The value of DEPTH_STENCIL_-
TEXTURE_MODE is DEPTH_COMPONENT. The values of TEXTURE_SWIZZLE_-
R, TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_-
A are RED, GREEN, BLUE, and ALPHA, respectively. The values of TEXTURE_-
IMMUTABLE_LEVELS, TEXTURE_VIEW_MIN_LEVEL, TEXTURE_VIEW_NUM_-
LEVELS, TEXTURE_VIEW_MIN_LAYER, TEXTURE_VIEW_NUM_LAYERS are each
zero.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.22. TEXTURESTATEANDPROXYSTATE 287
In addition to texture images for the non-proxy texture targets described above,
partially instantiated texture images are maintained for one-, two-, and three-
dimensional, rectangle, one- and two-dimensional array, and cube map array tex-
tures. Additionally, a single proxy image is maintained for the cube map texture.
Each proxy image includes width, height, depth, number of samples, and inter-
nal format state values, as well as state for the red, green, blue, alpha, depth,
and stencil component resolutions and types. Proxy images do not include image
data or texture parameters. When TexImage3D is executed with target speci?ed
asPROXY_TEXTURE_3D, the three-dimensional proxy state values of the speci?ed
level-of-detail are recomputed and updated. If the image would not be supported
by TexImage3D called with target set to TEXTURE_3D, no error is generated, but
the proxy width, height, depth, number of samples, and component resolutions
are set to zero, and the component types are set to NONE. If the image would be
supported by such a call to TexImage3D, the proxy state values are set exactly
as though the actual image were being speci?ed. No pixel data are transferred or
processed in either case.
Proxy images for one- and two-dimensional textures, one- and two-
dimensional array textures, and cube map array textures are operated on in the
same way when TexImage1D is executed with target speci?ed as PROXY_-
TEXTURE_1D, TexImage2D is executed with target speci?ed as PROXY_-
TEXTURE_2D, PROXY_TEXTURE_1D_ARRAY, or PROXY_TEXTURE_RECTANGLE,
or TexImage3D is executed with target speci?ed asPROXY_TEXTURE_2D_ARRAY
orPROXY_TEXTURE_CUBE_MAP_ARRAY.
Proxy images for two-dimensional multisample and two-dimensional mul-
tisample array textures are operated on in the same way when TexIm-
age2DMultisample is called with target speci?ed as PROXY_TEXTURE_2D_-
MULTISAMPLE, or TexImage3DMultisample is called with target speci?ed as
PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY. However, if samples is not sup-
ported, then no error is generated.
The cube map proxy images are operated on in the same manner when Tex-
Image2D is executed with the target ?eld speci?ed asPROXY_TEXTURE_CUBE_-
MAP, with the addition that determining that a given cube map texture is supported
with PROXY_TEXTURE_CUBE_MAP indicates that all six of the cube map two-
dimensional images are supported. Likewise, if the speci?edPROXY_TEXTURE_-
CUBE_MAP is not supported, none of the six cube map two-dimensional images are
supported.
Errors
OpenGL 4.6 (Core Pro?le) - February 2, 20198.23. TEXTURECOMPARISONMODES 288
An INVALID_ENUM error is generated by BindTexture, GetTexImage,
GetTexParameteriv, and GetTexParameterfv when called with a proxy tex-
ture target. There is no image or non-level-related state associated with proxy
textures, therefore they may not be used as textures.
8.23 Texture Comparison Modes
Texture values can also be computed according to a speci?ed comparison function.
Texture parameter TEXTURE_COMPARE_MODE speci?es the comparison operands,
and parameterTEXTURE_COMPARE_FUNC speci?es the comparison function.
8.23.1 Depth Texture Comparison Mode
If the currently bound texture’s base internal format is DEPTH_COMPONENT or
DEPTH_STENCIL, then TEXTURE_COMPARE_MODE and TEXTURE_COMPARE_-
FUNC control the output of the texture unit as described below. Otherwise, the
texture unit operates in the normal manner and texture comparison is bypassed.
Let D be the depth texture value and S be the stencil index component. If
t t
there is no stencil component, the value ofS is unde?ned. LetD be the ref-
t ref
erence value, provided by the shader’s texture lookup function. If the texture’s
internal format indicates a ?xed-point depth texture, thenD andD are clamped
t ref
to the range [0; 1]; otherwise no clamping is performed.
Then the effective texture value is computed as follows:
 If the base internal format isSTENCIL_INDEX, thenr =S .
t
 If the base internal format is DEPTH_STENCIL and the value of DEPTH_-
STENCIL_TEXTURE_MODE isSTENCIL_INDEX, thenr =S .
t
 Otherwise, if the value ofTEXTURE_COMPARE_MODE isNONE, thenr =D .
t
 Otherwise, if the value of TEXTURE_COMPARE_MODE is COMPARE_REF_-
TO_TEXTURE, thenr depends on the texture comparison function as shown
in table 8.23.
The resultingr is assigned to R .
t
If the value of TEXTURE_MAG_FILTER is not NEAREST, or the value of
TEXTURE_MIN_FILTER is notNEAREST orNEAREST_MIPMAP_NEAREST, thenr
may be computed by comparing more than one depth texture value to the texture
reference value. The details of this are implementation-dependent, but r should
be a value in the range [0; 1] which is proportional to the number of comparison
passes or failures.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.24. SRGBTEXTURECOLORCONVERSION 289
Texture Comparison Function Computed resultr
(
1:0; D D
ref t
LEQUAL r =
0:0; D >D
t
ref
(
1:0; D D
ref t
GEQUAL r =
0:0; D <D
ref t
(
1:0; D <D
t
ref
LESS r =
0:0; D D
ref t
(
1:0; D >D
ref t
GREATER r =
0:0; D D
ref t
(
1:0; D =D
ref t
EQUAL r =
0:0; D 6=D
ref t
(
1:0; D 6=D
ref t
NOTEQUAL r =
0:0; D =D
ref t
ALWAYS r = 1:0
NEVER r = 0:0
Table 8.23: Depth texture comparison functions.
8.24 sRGB Texture Color Conversion
If the currently bound texture’s internal format is one of the sRGB formats in ta-
ble 8.24, the red, green, and blue components are converted from an sRGB color
space to a linear color space as part of ?ltering described in sections 8.14 and 8.15.
Any alpha component is left unchanged. Ideally, implementations should perform
this color conversion on each sample prior to ?ltering but implementations are al-
lowed to perform this conversion after ?ltering (though this post-?ltering approach
is inferior to converting from sRGB prior to ?ltering).
The conversion from an sRGB encoded componentc to a linear componentc
s l
is as follows.
(
c
s
; c  0:04045
s
12:92
c =    (8.17)
l 2:4
c +0:055
s
; c > 0:04045
s
1:055
Assumec is the sRGB component in the range [0; 1].
s
OpenGL 4.6 (Core Pro?le) - February 2, 20198.25. SHAREDEXPONENTTEXTURECOLORCONVERSION 290
Internal Format
SRGB
SRGB8
SRGB_ALPHA
SRGB8_ALPHA8
COMPRESSED_SRGB
COMPRESSED_SRGB8_ETC2
COMPRESSED_SRGB_ALPHA
COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
COMPRESSED_SRGB_ALPHA_BPTC_UNORM
Table 8.24: sRGB texture internal formats.
8.25 Shared Exponent Texture Color Conversion
If the currently bound texture’s internal format is RGB9_E5, the red, green, blue,
and shared bits are converted to color components (prior to ?ltering) using shared
exponent decoding. The component red , green , blue , and exp values (see
s s s s
section 8.5.2) are treated as unsigned integers and are converted to ?oating-point
red,green, andblue as follows:
exp B N
s
red =red 2
s
exp B N
s
green =green 2
s
exp B N
s
blue =blue 2
s
8.26 Texture Image Loads and Stores
The contents of a texture may be made available for shaders to read and write by
binding the texture to one of a collection of image units. The GL implementation
provides an array of image units numbered beginning with zero, with the total num-
ber of image units provided determined by the implementation-dependent value of
MAX_IMAGE_UNITS. Unlike texture image units, image units do not have a sep-
arate binding point for each texture target; each image unit may have only one
texture bound at a time.
A texture may be bound to an image unit for use by image loads and stores
with the command
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 291
void BindImageTexture(uint unit,uint texture,int level,
boolean layered,int layer,enum access,enum format );
where unit identi?es the image unit, texture is the name of the texture, and level
selects a single level of the texture. If texture is zero, any texture currently bound
to image unit unit is unbound.
If the texture identi?ed by texture is a one-dimensional array, two-dimensional
array, three-dimensional, cube map, cube map array, or two-dimensional multi-
sample array texture, it is possible to bind either the entire texture level or a single
layer or face of the texture level. If layered is TRUE, the entire level is bound. If
layered is FALSE, only the single layer identi?ed by layer will be bound. When
layered is FALSE, the single bound layer is treated as a different texture target for
image accesses:
 one-dimensional array texture layers are treated as one-dimensional textures;
 two-dimensional array, three-dimensional, cube map, and cube map array
texture layers are treated as two-dimensional textures; and
 two-dimensional multisample array textures are treated as two-dimensional
multisample textures.
For cube map textures where layered is FALSE, the face is taken by mapping
the layer number to a face according to table 9.3. For cube map array textures
where layered is FALSE, the selected layer number is mapped to a texture layer
and cube face using the following equations and mapping face to a face according
to table 9.3.
 
layer
orig
layer =
6
face =layer   (layer 6)
orig
If the texture identi?ed by texture does not have multiple layers or faces, the
entire texture level is bound, regardless of the values speci?ed for layered and
layer.
format speci?es the format that the elements of the image will be treated as
when doing formatted stores, as described later in this section. This is referred to
as the image unit format.
access speci?es whether the texture bound to the image will be treated as
READ_ONLY,WRITE_ONLY, orREAD_WRITE. If a shader reads from an image unit
with a texture bound as WRITE_ONLY, or writes to an image unit with a texture
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 292
bound as READ_ONLY, the results of that shader operation are unde?ned and may
lead to application termination.
If a texture object bound to one or more image units is deleted by DeleteTex-
tures, it is detached from each such image unit, as though BindImageTexture
were called with unit identifying the image unit and texture set to zero.
Errors
An INVALID_VALUE error is generated if unit is greater than or equal to
the value of MAX_IMAGE_UNITS, if level or layer is negative, or if texture is
not the name of an existing texture object.
AnINVALID_VALUE error is generated if format is not one of the formats
listed in table 8.26.
The command
void BindImageTextures(uint ?rst,sizei count,const
uint *textures );
binds count existing texture objects to image units numbered ?rst throughfirst +
count  1. If textures is not NULL, it speci?es an array of count values, each of
which must be zero or the name of an existing texture object. If textures is NULL,
each affected image unit from ?rst throughfirst +count  1 will be reset to have
no bound texture object.
When binding a non-zero texture object to an image unit, the image unit level,
layered, layer, and access parameters are set to zero, TRUE, zero, and READ_-
WRITE, respectively. The image unit format parameter is taken from the internal
format of the texture image at level zero of the texture object identi?ed by tex-
tures. For cube map textures, the internal format of the TEXTURE_CUBE_MAP_-
POSITIVE_X image of level zero is used. For multisample, multisample array,
buffer, and rectangle textures, the internal format of the single texture level is used.
When unbinding a texture object from an image unit, the image unit parameters
level, layered, layer, and format will be reset to their default values of zero,FALSE,
0, andR8, respectively.
BindImageTextures is equivalent (assuming no errors are generated) to:
for (i = 0; i < count; i++) f
if (textures == NULL || textures[i] = 0) f
BindImageTexture(first + i, 0, 0, FALSE, 0,
READ_ONLY, R8);
g else f
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 293
BindImageTexture(first + i, textures[i], 0, TRUE, 0,
READ_WRITE, lookupInternalFormat(textures[i]));
g
g
where lookupInternalFormat returns the internal format of the speci?ed
texture object.
The values speci?ed in textures will be checked separately for each image unit.
When a value for a speci?c image unit is invalid, the state for that image unit will
be unchanged and an error will be generated. However, state for other image units
will still be changed if their corresponding values are valid.
Errors
An INVALID_OPERATION error is generated iffirst +count is greater
than the number of image units supported by the implementation.
AnINVALID_VALUE error is generated if count is negative.
AnINVALID_OPERATION error is generated if any value in textures is not
zero or the name of an existing texture object (per binding).
An INVALID_OPERATION error is generated if the internal format of the
level zero texture image of any texture in textures is not found in table 8.26
(per binding).
AnINVALID_OPERATION error is generated if the width, height, or depth
of the level zero texture image of any texture in textures is zero (per binding).
When a shader accesses the texture bound to an image unit using a built-in
image load, store, or atomic function, it identi?es a single texel by providing a
one-, two-, or three-dimensional coordinate. Multisample texture accesses also
specify a sample number. A coordinate vector is mapped to an individual texel
 , , or according to the target of the texture bound to the image unit using
i ij ijk
table 8.25. As noted above, single-layer bindings of array or cube map textures are
considered to use a texture target corresponding to the bound layer, rather than that
of the full texture.
If the texture target has layers or cube map faces, the layer or face number is
taken from the layer argument of BindImageTexture if the texture is bound with
layered set toFALSE, or from the coordinate identi?ed by table 8.25 otherwise. For
cube map and cube map array textures with layered set toTRUE, the coordinate is
mapped to a layer and face in the same manner as described for the layer argument
of BindImageTexture.
If the individual texel identi?ed for an image load, store, or atomic operation
doesn’t exist, the access is treated as invalid. Invalid image loads will return zero.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 294
Texture target i j k Face / layer
TEXTURE_1D x - - -
TEXTURE_2D x y - -
TEXTURE_3D x y z -
TEXTURE_RECTANGLE x y - -
TEXTURE_CUBE_MAP x y - z
TEXTURE_BUFFER x - - -
TEXTURE_1D_ARRAY x - - y
TEXTURE_2D_ARRAY x y - z
TEXTURE_CUBE_MAP_ARRAY x y - z
TEXTURE_2D_MULTISAMPLE x y - -
TEXTURE_2D_MULTISAMPLE_ARRAY x y - z
Table 8.25: Mapping of image load, store, and atomic texel coordinate components
to texel numbers.
Invalid image stores will have no effect. Invalid image atomics will not update
any texture bound to the image unit and will return zero. An access is considered
invalid if:
 no texture is bound to the selected image unit;
 the texture bound to the selected image unit is incomplete;
 the texture level bound to the image unit is less than the base level or greater
than the maximum level of the texture;
 the internal format of the texture bound to the image unit is not found in
table 8.26;
 the internal format of the texture bound to the image unit is incompatible
with the speci?ed format, as described below;
 the texture bound to the image unit has layers, and the selected layer or cube
map face doesn’t exist;
 the selected texel , , or doesn’t exist;
i ij ijk
 the image has more samples than the implementation-dependent value of
MAX_IMAGE_SAMPLES.
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 295
Additionally, there are a number of cases where image load, store, or atomic
operations are considered to involve a format mismatch. In such cases, unde?ned
values will be returned by image loads and atomic operations and unde?ned values
will be written by stores and atomic operations. A format mismatch will occur if:
 the type of image variable used to access the image unit does not match the
target of a texture bound to the image unit with layered set toTRUE;
 the type of image variable used to access the image unit does not match the
target corresponding to a single layer of a multi-layer texture target bound to
the image unit with layered set toFALSE;
 the type of image variable used to access the image unit has a component data
type (?oating-point, signed integer, unsigned integer) incompatible with the
format of the image unit;
 the formatlayout quali?er for an image variable used for an image load or
atomic operation does not match the format of the image unit, according to
table 8.26; or
 the image variable used for an image store has a format layout quali?er,
and that quali?er does not match the format of the image unit, according to
table 8.26.
For textures with multiple samples per texel, the sample selected for an image
load, store, or atomic is unde?ned if the sample coordinate is negative or greater
than or equal to the number of samples in the texture.
If a shader performs an image load, store, or atomic operation using an image
variable declared as an array, and if the index used to select an individual element is
negative or greater than or equal to the size of the array, the results of the operation
are unde?ned but may not lead to termination.
Accesses to textures bound to image units do format conversions based on
the format argument speci?ed when the image is bound. Loads always return a
value as a vec4, ivec4, or uvec4, and stores always take the source data as a
vec4, ivec4, or uvec4. Data are converted to/from the speci?ed format accord-
ing to the process described for a TexImage2D or GetTexImage command with
format and type asRGBA andFLOAT forvec4 data, asRGBA_INTEGER andINT for
ivec4 data, or as RGBA_INTEGER and UNSIGNED_INT for uvec4 data, respec-
tively. Unused components are ?lled in with (0; 0; 0; 1) (where 0 and 1 are either
?oating-point or integer values, depending on the format).
Any image variable used for shader loads or atomic memory operations must
be declared with a format layout quali?er matching the format of its associated
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 296
image unit, as enumerated in table 8.26. Otherwise, the access is considered to
involve a format mismatch, as described above. Image variables used exclusively
for image stores need not include a format layout quali?er, but any declared
quali?er must match the image unit format to avoid a format mismatch.
Image Unit Format Format Qualifer
RGBA32F rgba32f
RGBA16F rgba16f
RG32F rg32f
RG16F rg16f
R11F_G11F_B10F r11f_g11f_b10f
R32F r32f
R16F r16f
RGBA32UI rgba32ui
RGBA16UI rgba16ui
RGB10_A2UI rgb10_a2ui
RGBA8UI rgba8ui
RG32UI rg32ui
RG16UI rg16ui
RG8UI rg8ui
R32UI r32ui
R16UI r16ui
R8UI r8ui
RGBA32I rgba32i
RGBA16I rgba16i
RGBA8I rgba8i
RG32I rg32i
RG16I rg16i
RG8I rg8i
R32I r32i
R16I r16i
R8I r8i
RGBA16 rgba16
RGB10_A2 rgb10_a2
RGBA8 rgba8
RG16 rg16
RG8 rg8
(Continued on next page)
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 297
Supported image unit formats (continued)
Image Unit Format Format Qualifer
R16 r16
R8 r8
RGBA16_SNORM rgba16_snorm
RGBA8_SNORM rgba8_snorm
RG16_SNORM rg16_snorm
RG8_SNORM rg8_snorm
R16_SNORM r16_snorm
R8_SNORM r8_snorm
Table 8.26: Supported image unit formats, with equivalent format
layout quali?ers.
When a texture is bound to an image unit, the format parameter for the image
unit need not exactly match the texture internal format as long as the formats are
considered compatible. A pair of formats is considered to match in size if the cor-
responding entries in the Size column of table 8.27 are identical. A pair of formats
is considered to match by class if the corresponding entries in the Class column
of table 8.27 are identical. For textures allocated by the GL, an image unit format
is compatible with a texture internal format if they match by size. For textures
allocated outside the GL, format compatibility is determined by matching by size
or by class, in an implementation-dependent manner. The matching criterion used
for a given texture may be determined by calling GetTexParameter with pname
set to IMAGE_FORMAT_COMPATIBILITY_TYPE, with return values of IMAGE_-
FORMAT_COMPATIBILITY_BY_SIZE and IMAGE_FORMAT_COMPATIBILITY_-
BY_CLASS, specifying matches by size and class, respectively.
When the format associated with an image unit does not exactly match the in-
ternal format of a compatible texture bound to the image unit, image loads, stores,
and atomic operations re-interpret the memory holding the components of an ac-
cessed texel according to the format of the image unit. The re-interpretation for
image loads and the read portion of image atomics is performed as though data
were copied from the texel of the bound texture to a similar texel represented in
the format of the image unit. Similarly, the re-interpretation for image stores and
the write portion of image atomics is performed as though data were copied from
a texel represented in the format of the image unit to the texel in the bound texture.
In both cases, this copy operation would be performed by:
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 298
 reading the texel from the source format to scratch memory according to the
process described for GetTexImage (see section 8.11), using default pixel
storage modes and format and type parameters corresponding to the source
format in table 8.27; and
 writing the texel from scratch memory to the destination format according to
the process described for TexSubImage3D (see section 8.6), using default
pixel storage modes and format and type parameters corresponding to the
destination format in table 8.27.
Image Format Size Class Pixel format Pixel type
RGBA32F 128 4x32 RGBA FLOAT
RGBA16F 64 4x16 RGBA HALF_FLOAT
RG32F 64 2x32 RG FLOAT
RG16F 32 2x16 RG HALF_FLOAT
R11F_G11F_B10F 32 (a) RGB UNSIGNED_INT_10F_11F_11F_REV
R32F 32 1x32 RED FLOAT
R16F 16 1x16 RED HALF_FLOAT
RGBA32UI 128 4x32 RGBA_INTEGER UNSIGNED_INT
RGBA16UI 64 4x16 RGBA_INTEGER UNSIGNED_SHORT
RGB10_A2UI 32 (b) RGBA_INTEGER UNSIGNED_INT_2_10_10_10_REV
RGBA8UI 32 4x8 RGBA_INTEGER UNSIGNED_BYTE
RG32UI 64 2x32 RG_INTEGER UNSIGNED_INT
RG16UI 32 2x16 RG_INTEGER UNSIGNED_SHORT
RG8UI 16 2x8 RG_INTEGER UNSIGNED_BYTE
R32UI 32 1x32 RED_INTEGER UNSIGNED_INT
R16UI 16 1x16 RED_INTEGER UNSIGNED_SHORT
R8UI 8 1x8 RED_INTEGER UNSIGNED_BYTE
RGBA32I 128 4x32 RGBA_INTEGER INT
RGBA16I 64 4x16 RGBA_INTEGER SHORT
RGBA8I 32 4x8 RGBA_INTEGER BYTE
RG32I 64 2x32 RG_INTEGER INT
RG16I 32 2x16 RG_INTEGER SHORT
RG8I 16 2x8 RG_INTEGER BYTE
R32I 32 1x32 RED_INTEGER INT
R16I 16 1x16 RED_INTEGER SHORT
R8I 8 1x8 RED_INTEGER BYTE
(Continued on next page)
OpenGL 4.6 (Core Pro?le) - February 2, 20198.26. TEXTUREIMAGELOADSANDSTORES 299
Texel sizes, compatibility classes ... (continued)
Image Format Size Class Pixel format Pixel type
RGBA16 64 4x16 RGBA UNSIGNED_SHORT
RGB10_A2 32 (b) RGBA UNSIGNED_INT_2_10_10_10_REV
RGBA8 32 4x8 RGBA UNSIGNED_BYTE
RG16 32 2x16 RG UNSIGNED_SHORT
RG8 16 2x8 RG UNSIGNED_BYTE
R16 16 1x16 RED UNSIGNED_SHORT
R8 8 1x8 RED UNSIGNED_BYTE
RGBA16_SNORM 64 4x16 RGBA SHORT
RGBA8_SNORM 32 4x8 RGBA BYTE
RG16_SNORM 32 2x16 RG SHORT
RG8_SNORM 16 2x8 RG BYTE
R16_SNORM 16 1x16 RED SHORT
R8_SNORM 8 1x8 RED BYTE
Table 8.27: Texel sizes, compatibility classes, and pixel for-
mat/type combinations for each image format. Class (a) is for
11/11/10 packed ?oating-point formats; class (b) is for 10/10/10/2
packed formats.
Implementations may support a limited combined number of image units,
shader storage blocks (see section 7.8), and active fragment shader outputs (see
section 17.4.1). A link error is generated if the sum of the number of active image
uniforms used in all shaders, the number of active shader storage blocks, and the
number of active fragment shader outputs exceeds the implementation-dependent
value ofMAX_COMBINED_SHADER_OUTPUT_RESOURCES.
8.26.1 Image Unit Queries
The state required for each image unit is summarized in table 23.45 and may be
queried using the indexed query commands in that table. The initial values of
image unit state are described above for BindImageTexture.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 9
Framebuffers and Framebuffer
Objects
As described in chapter 1 and section 2.1, the GL renders into (and reads values
from) a framebuffer.
Initially, the GL uses the window system-provided default framebuffer. The
storage, dimensions, allocation, and format of the images attached to this frame-
buffer are managed entirely by the window system. Consequently, the state of the
default framebuffer, including its images, can not be changed by the GL, nor can
the default framebuffer be deleted by the GL.
This chapter begins with an overview of the structure and contents of the frame-
buffer in section 9.1, followed by describing the commands used to create, destroy,
and modify the state and attachments of application-created framebuffer objects
which may be used instead of the default framebuffer.
9.1 Framebuffer Overview
The framebuffer consists of a set of pixels arranged as a two-dimensional array.
For purposes of this discussion, each pixel in the framebuffer is simply a set of
some number of bits. The number of bits per pixel may vary depending on the GL
implementation, the type of framebuffer selected, and parameters speci?ed when
the framebuffer was created. Creation and management of the default framebuffer
is outside the scope of this speci?cation, while creation and management of frame-
buffer objects is described in detail in section 9.2.
Corresponding bits from each pixel in the framebuffer are grouped together
into a bitplane; each bitplane contains a single bit from each pixel. These bitplanes
are grouped into several logical buffers. These are the color, depth, and stencil
3009.1. FRAMEBUFFEROVERVIEW 301
buffers. The color buffer actually consists of a number of buffers, and these color
buffers serve related but slightly different purposes depending on whether the GL
is bound to the default framebuffer or a framebuffer object.
For the default framebuffer, the color buffers are the front left buffer, the front
right buffer, the back left buffer, and the back right buffer. Typically the contents
of the front buffers are displayed on a color monitor while the contents of the
back buffers are invisible. (Monoscopic contexts display only the front left buffer;
stereoscopic contexts display both the front left and the front right buffers.) All
color buffers must have the same number of bitplanes, although an implementation
or context may choose not to provide right buffers, or back buffers at all. Further,
an implementation or context may choose not to provide depth or stencil buffers.
If no default framebuffer is associated with the GL context, the framebuffer is
incomplete except when a framebuffer object is bound (see sections 9.2 and 9.4).
Framebuffer objects are not visible, and do not have any of the color buffers
present in the default framebuffer. Instead, the buffers of an framebuffer object are
speci?ed by attaching individual textures or renderbuffers (see section 9) to a set
of attachment points. A framebuffer object has an array of color buffer attachment
points, numbered zero through n, a depth buffer attachment point, and a stencil
buffer attachment point. In order to be used for rendering, a framebuffer object
must be complete, as described in section 9.4. Not all attachments of a framebuffer
object need to be populated.
Each pixel in a color buffer consists of up to four color components. The four
color components are named R, G, B, and A, in that order; color buffers are not
required to have all four color components. R, G, B, and A components may be
represented as signed or unsigned normalized ?xed-point, ?oating-point, or signed
or unsigned integer values; all components must have the same representation.
Each pixel in a depth buffer consists of a single unsigned integer value in the format
described in section 13.8.1 or a ?oating-point value. Each pixel in a stencil buffer
consists of a single unsigned integer value.
The number of bitplanes in the color, depth, and stencil buffers is dependent
on the currently bound framebuffer. For the default framebuffer, the number of
bitplanes is ?xed. For framebuffer objects, the number of bitplanes in a given
logical buffer may change if the image attached to the corresponding attachment
point changes.
The GL has two active framebuffers; the draw framebuffer is the destination
for rendering operations, and the read framebuffer is the source for readback op-
erations. The same framebuffer may be used for both drawing and reading. Sec-
tion 9.2 describes the mechanism for controlling framebuffer usage.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 302
1
The default framebuffer is initially used as the draw and read framebuffer ,
and the initial state of all provided bitplanes is unde?ned. The format and encod-
ing of buffers in the draw and read framebuffers may be queried as described in
section 9.2.3.
9.2 Binding and Managing Framebuffer Objects
Framebuffer objects encapsulate the state of a framebuffer in a similar manner to
the way texture objects encapsulate the state of a texture. In particular, a frame-
buffer object encapsulates state necessary to describe a collection of color, depth,
and stencil logical buffers (other types of buffers are not allowed). For each logical
buffer, a framebuffer-attachable image can be attached to the framebuffer to store
the rendered output for that logical buffer. Examples of framebuffer-attachable im-
ages include texture images and renderbuffer images. Renderbuffers are described
further in section 9.2.4
By allowing the images of a renderbuffer to be attached to a framebuffer, the
GL provides a mechanism to support off-screen rendering. Further, by allowing the
images of a texture to be attached to a framebuffer, the GL provides a mechanism
to support render to texture.
The default framebuffer for rendering and readback operations is provided by
the window system. In addition, named framebuffer objects can be created and
operated upon. The name space for framebuffer objects is the unsigned integers,
with zero reserved by the GL for the default framebuffer.
A framebuffer object is created by binding a name returned by GenFrame-
buffers (see below) to DRAW_FRAMEBUFFER or READ_FRAMEBUFFER. The bind-
ing is effected by calling
void BindFramebuffer(enum target,uint framebuffer );
with target set to the desired framebuffer target and framebuffer set to the frame-
buffer object name. The resulting framebuffer object is a new state vector, com-
prising all the state and with the same initial values listed in table 23.24, as well
as one set of the state values listed in table 23.25 for each attachment point of the
framebuffer, with the same initial values. There are the value of MAX_COLOR_-
ATTACHMENTS color attachment points, plus one each for the depth and stencil
attachment points.
1
The window system binding API may allow associating a GL context with two separate “default
framebuffers” provided by the window system as the draw and read framebuffers, but if so, both
default framebuffers are referred to by the name zero at their respective binding points.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 303
BindFramebuffer may also be used to bind an existing framebuffer object
toDRAW_FRAMEBUFFER and/orREAD_FRAMEBUFFER. If the bind is successful no
change is made to the state of the newly bound framebuffer object, and any previous
binding to target is broken.
If a framebuffer object is bound to DRAW_FRAMEBUFFER or READ_-
FRAMEBUFFER, it becomes the target for rendering or readback operations, respec-
tively, until it is deleted or another framebuffer object is bound to the correspond-
ing bind point. Calling BindFramebuffer with target set toFRAMEBUFFER binds
framebuffer to both the draw and read targets.
Errors
An INVALID_ENUM error is generated if target is not DRAW_-
FRAMEBUFFER,READ_FRAMEBUFFER, orFRAMEBUFFER.
AnINVALID_OPERATION error is generated if framebuffer is not zero or
a name returned from a previous call to GenFramebuffers, or if such a name
has since been deleted with DeleteFramebuffers.
While a framebuffer object is bound, GL operations on the target to which it is
bound affect the images attached to the bound framebuffer object, and queries of
the target to which it is bound return state from the bound object. Queries of the
values speci?ed in tables 23.73 and 23.24 are derived from the framebuffer object
bound to DRAW_FRAMEBUFFER, with the exception of those marked as properties
of the read framebuffer, which are derived from the framebuffer object bound to
READ_FRAMEBUFFER.
Framebuffer objects may also be created with the command
void CreateFramebuffers(sizei n,uint *framebuffers );
CreateFramebuffers returns n previously unused framebuffer names in frame-
buffers, each representing a new framebuffer object which is a state vector, com-
prising all the state and with the same initial values listed in table 23.24, as well
as one set of the state values listed in table 23.25 for each attachment point of the
framebuffer, with the same initial values.
Errors
AnINVALID_VALUE error is generated if n is negative.
The initial state of DRAW_FRAMEBUFFER and READ_FRAMEBUFFER refers to
the default framebuffer. In order that access to the default framebuffer is not lost,
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 304
it is treated as a framebuffer object with the name of zero. The default framebuffer
is therefore rendered to and read from while zero is bound to the corresponding
targets. On some implementations, the properties of the default framebuffer can
change over time (e.g., in response to window system events such as attaching the
context to a new window system drawable.)
Framebuffer objects (those with a non-zero name) differ from the default
framebuffer in a few important ways. First and foremost, unlike the default frame-
buffer, framebuffer objects have modi?able attachment points for each logical
buffer in the framebuffer. Framebuffer-attachable images can be attached to and de-
tached from these attachment points, which are described further in section 9.2.2.
Also, the size and format of the images attached to framebuffer objects are con-
trolled entirely within the GL interface, and are not affected by window system
events, such as pixel format selection, window resizes, and display mode changes.
Additionally, when rendering to or reading from an application created-
framebuffer object,
 The pixel ownership test always succeeds. In other words, framebuffer ob-
jects own all of their pixels.
 There are no visible color buffer bitplanes. This means there is no color
buffer corresponding to the back, front, left, or right color bitplanes.
 The only color buffer bitplanes are the ones de?ned by the frame-
buffer attachment points named COLOR_ATTACHMENT0 through COLOR_-
ATTACHMENTn. Each COLOR_ATTACHMENTi adheres to COLOR_-
2
ATTACHMENTi =COLOR_ATTACHMENT0 +i .
 The only depth buffer bitplanes are the ones de?ned by the framebuffer at-
tachment pointDEPTH_ATTACHMENT.
 The only stencil buffer bitplanes are the ones de?ned by the framebuffer
attachment pointSTENCIL_ATTACHMENT.
 If the attachment sizes are not all identical, the results of rendering are de-
?ned only within the largest area that can ?t in all of the attachments. This
area is de?ned as the intersection of rectangles having a lower left of (0; 0)
and an upper right of (width;height) for each attachment. Contents of at-
tachments outside this area are unde?ned after execution of a rendering com-
mand (as de?ned in section 2.4).
2
The header ?les de?ne tokensCOLOR_ATTACHMENTi fori in the range[0;31]. Most imple-
mentations support fewer than 32 color attachments, and it is anINVALID_OPERATION error
to pass an unsupported attachment name to a command accepting color attachment names.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 305
If there are no attachments, rendering will be limited to a rectangle having a
lower left of (0; 0) and an upper right of (width;height), wherewidth and
height are the framebuffer object’s default width and height.
 If the number of layers of each attachment are not all identical, rendering
will be limited to the smallest number of layers of any attachment. If there
are no attachments, the number of layers will be taken from the framebuffer
object’s default layer count.
The command
void GenFramebuffers(sizei n,uint *framebuffers );
returns n previously unused framebuffer object names in framebuffers. These
names are marked as used, for the purposes of GenFramebuffers only, but they
acquire state and type only when they are ?rst bound.
Errors
AnINVALID_VALUE error is generated if n is negative.
Framebuffer objects are deleted by calling
void DeleteFramebuffers(sizei n,const
uint *framebuffers );
framebuffers contains n names of framebuffer objects to be deleted. After a frame-
buffer object is deleted, it has no attachments, and its name is again unused.
If a framebuffer that is currently bound to one or more of the targets DRAW_-
FRAMEBUFFER or READ_FRAMEBUFFER is deleted, it is as though BindFrame-
buffer had been executed with the corresponding target and framebuffer zero. Un-
used names in framebuffers that have been marked as used for the purposes of
GenFramebuffers are marked as unused again. Unused names in framebuffers are
silently ignored, as is the value zero.
Errors
AnINVALID_VALUE error is generated if n is negative.
The command
boolean IsFramebuffer(uint framebuffer );
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 306
returns TRUE if framebuffer is the name of an framebuffer object. If framebuffer
is zero, or if framebuffer is a non-zero value that is not the name of a framebuffer
object, IsFramebuffer returnsFALSE.
The names bound to the draw and read framebuffer bindings may be queried by
calling GetIntegerv with pnames DRAW_FRAMEBUFFER_BINDING and READ_-
FRAMEBUFFER_BINDING, respectively. FRAMEBUFFER_BINDING is equivalent to
DRAW_FRAMEBUFFER_BINDING.
9.2.1 Framebuffer Object Parameters
Parameters of a framebuffer object are set using the commands
void FramebufferParameteri(enum target,enum pname,
int param );
void NamedFramebufferParameteri(uint framebuffer,
enum pname,int param );
For FramebufferParameteri, the framebuffer object is that bound to target,
which must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. For NamedFramebuffer-
Parameteri, framebuffer is the name of the framebuffer object.
pname speci?es the parameter of the framebuffer object to set.
When a framebuffer has one or more attachments, the width, height, layer count
(see section 9.8), sample count, and sample location pattern of the framebuffer are
derived from the properties of the framebuffer attachments. When the framebuffer
has no attachments, these properties are taken from framebuffer parameters. When
pname is FRAMEBUFFER_DEFAULT_WIDTH, FRAMEBUFFER_DEFAULT_HEIGHT,
FRAMEBUFFER_DEFAULT_LAYERS, FRAMEBUFFER_DEFAULT_SAMPLES,
or FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS, param speci?es the
width, height, layer count, sample count, or sample location pattern, respectively,
used when the framebuffer has no attachments.
When a framebuffer has no attachments, it is considered layered (see sec-
tion 9.8) if and only if the value ofFRAMEBUFFER_DEFAULT_LAYERS is non-zero.
It is considered to have sample buffers if and only if the value ofFRAMEBUFFER_-
DEFAULT_SAMPLES is non-zero. The number of samples in the framebuffer is de-
rived from the value ofFRAMEBUFFER_DEFAULT_SAMPLES in an implementation-
dependent manner similar to that described for the command RenderbufferStor-
ageMultisample (see section 9.2.4). If the framebuffer has sample buffers and
the value ofFRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS is non-zero,
it is considered to have a ?xed sample location pattern as described for TexIm-
age2DMultisample (see section 8.8).
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 307
Errors
AnINVALID_ENUM error is generated by FramebufferParameteri if tar-
get is notDRAW_FRAMEBUFFER,READ_FRAMEBUFFER, orFRAMEBUFFER.
An INVALID_OPERATION error is generated if the default framebuffer is
bound to target.
AnINVALID_OPERATION error is generated by NamedFramebufferPa-
rameteri if framebuffer is not the name of an existing framebuffer object.
An INVALID_ENUM error is generated if pname is not FRAMEBUFFER_-
DEFAULT_WIDTH, FRAMEBUFFER_DEFAULT_HEIGHT,
FRAMEBUFFER_DEFAULT_LAYERS, FRAMEBUFFER_DEFAULT_SAMPLES, or
FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS.
An INVALID_VALUE error is generated if pname is FRAMEBUFFER_-
DEFAULT_WIDTH, FRAMEBUFFER_DEFAULT_HEIGHT, FRAMEBUFFER_-
DEFAULT_LAYERS, orFRAMEBUFFER_DEFAULT_SAMPLES, and param is ei-
ther negative or greater than the value of the corresponding implementation-
dependent limit MAX_FRAMEBUFFER_WIDTH, MAX_FRAMEBUFFER_HEIGHT,
MAX_FRAMEBUFFER_LAYERS, or MAX_FRAMEBUFFER_SAMPLES, respec-
tively.
9.2.2 Attaching Images to Framebuffer Objects
Framebuffer-attachable images may be attached to, and detached from, framebuffer
objects. In contrast, the image attachments of the default framebuffer may not be
changed by the GL.
A single framebuffer-attachable image may be attached to multiple framebuffer
objects, potentially avoiding some data copies, and possibly decreasing memory
consumption.
For each logical buffer, a framebuffer object stores a set of state which de?nes
the logical buffer’s attachment point. The attachment point state contains enough
information to identify the single image attached to the attachment point, or to
indicate that no image is attached. The per-logical buffer attachment point state is
listed in table 23.25.
There are several types of framebuffer-attachable images:
 The image of a renderbuffer object, which is always two-dimensional.
 A single level of a one-dimensional texture, which is treated as a two-
dimensional image with a height of one.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 308
 A single level of a two-dimensional, two-dimensional multisample, or rect-
angle texture.
 A single face of a cube map texture level, which is treated as a two-
dimensional image.
 A single layer of a one- or two-dimensional array texture, two-dimensional
multisample array texture, or three-dimensional texture, which is treated as
a two-dimensional image.
 A single layer-face of a cube map array texture, which is treated as a two-
dimensional image.
Additionally, an entire level of a three-dimensional, cube map, cube map array,
or one- or two-dimensional array texture can be attached to an attachment point.
Such attachments are treated as an array of two-dimensional images, arranged in
layers, and the corresponding attachment point is considered to be layered (also
see section 9.8).
9.2.3 Framebuffer Object Queries
Parameters of a framebuffer object may be queried with the commands
void GetFramebufferParameteriv(enum target,enum pname,
int *params );
void GetNamedFramebufferParameteriv(uint framebuffer,
enum pname,int *params );
For GetFramebufferParameteriv, the framebuffer object is that bound to
target, which must be must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. For Get-
NamedFramebufferParameteriv, framebuffer may be zero, indicating the default
draw framebuffer, or the name of the framebuffer object.
pname may be one of FRAMEBUFFER_DEFAULT_WIDTH, FRAMEBUFFER_-
DEFAULT_HEIGHT, FRAMEBUFFER_DEFAULT_LAYERS, FRAMEBUFFER_-
DEFAULT_SAMPLES, or FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_-
LOCATIONS, indicating one of the corresponding parameters set with Frame-
bufferParameteri (see section 9.2.1). These values may only be queried from a
framebuffer object, not from a default framebuffer.
pname may also be one of DOUBLEBUFFER, IMPLEMENTATION_COLOR_-
READ_FORMAT, IMPLEMENTATION_COLOR_READ_TYPE, SAMPLES, SAMPLE_-
BUFFERS, or STEREO, indicating the corresponding framebuffer-dependent state
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 309
from table 23.73. Values of framebuffer-dependent state are identical to those that
would be obtained were the framebuffer object bound and queried using the simple
state queries in that table. These values may be queried from either a framebuffer
object or a default framebuffer. The values of SAMPLES and SAMPLE_BUFFERS
are determined as described in section 9.2.3.1.
The value of parameter pname for the framebuffer object is returned in params.
Errors
An INVALID_ENUM error is generated by GetNamedFramebufferPa-
rameteriv if target is not DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER.
An INVALID_OPERATION error is generated by GetNamedFrame-
bufferParameteriv if framebuffer is not zero or the name of an existing frame-
buffer object.
An INVALID_ENUM error is generated if pname is not one of the valid
values listed above.
AnINVALID_OPERATION error is generated by GetFramebufferParam-
eteriv if the default framebuffer is bound to target and pname is not one of the
accepted values from table 23.73, other thanSAMPLE_POSITION.
An INVALID_OPERATION error is generated by GetNamedFrame-
bufferParameteriv if framebuffer is zero, and pname is not one of the valid
values from table 23.73, other thanSAMPLE_POSITION.
Attachments of a framebuffer object or buffers of a default framebuffer may be
queried with the commands
void GetFramebufferAttachmentParameteriv(enum target,
enum attachment,enum pname,int *params );
void GetNamedFramebufferAttachmentParameteriv(
uint framebuffer,enum attachment,enum pname,
int *params );
For GetFramebufferAttachmentParameteriv, the framebuffer object is that
bound to target, which must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. For Get-
NamedFramebufferAttachmentParameteriv, framebuffer is zero or the name of
a framebuffer object. If framebuffer is zero, then the default draw framebuffer is
queried.
If a default framebuffer is queried, then attachment must be one of the values
listed in table 9.1, selecting a single color, depth or stencil buffer as shown in that
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 310
attachment Buffer Queried
FRONT Front Left Color
FRONT_LEFT Front Left Color
FRONT_RIGHT Front Right Color
BACK Back Left Color
BACK_LEFT Back Left Color
BACK_RIGHT Back Right Color
DEPTH Depth buffer
STENCIL Stencil buffer
Table 9.1: Valid attachment parameters when a default framebuffer is queried with
Get*FramebufferAttachmentParameteriv, and the buffers they select.
table.
Otherwise, attachment must be one of the framebuffer object attachment points
listed in table 9.2. If attachment isDEPTH_STENCIL_ATTACHMENT, the same ob-
ject must be bound to both the depth and stencil attachment points of the frame-
buffer object, and information about that object is returned.
Upon successful return from Get*FramebufferAttachmentParameteriv, if
pname isFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, then params will contain
one ofNONE,FRAMEBUFFER_DEFAULT,TEXTURE, orRENDERBUFFER, identifying
the type of object which contains the attached image. Other values accepted for
pname depend on the type of object, as described below.
If the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE isNONE, then one
of the following conditions is true:
 no framebuffer is bound to target, or
 the default framebuffer is bound, and
– attachment is DEPTH or STENCIL, and the number of depth or stencil
bits, respectively, is zero; or,
– attachment does not indicate one of the color buffers allocated to the
default framebuffer.
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is NONE, query-
ing pnameFRAMEBUFFER_ATTACHMENT_OBJECT_NAME will return zero, and the
only other valid query isFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE.
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is not NONE,
these queries apply to all other framebuffer types:
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 311
 If pname is FRAMEBUFFER_ATTACHMENT_RED_SIZE, FRAMEBUFFER_-
ATTACHMENT_GREEN_SIZE, FRAMEBUFFER_ATTACHMENT_BLUE_-
SIZE, FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, FRAMEBUFFER_-
ATTACHMENT_DEPTH_SIZE, or FRAMEBUFFER_ATTACHMENT_-
STENCIL_SIZE, then params will contain the number of bits in the
corresponding red, green, blue, alpha, depth, or stencil component of
the speci?ed attachment. If the requested component is not present in
attachment, or if no data storage or texture image has been speci?ed for the
attachment, then params will contain zero.
 If pname isFRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, then params
will contain the format of components of the speci?ed attachment, one of
FLOAT, INT, UNSIGNED_INT, SIGNED_NORMALIZED, or UNSIGNED_-
NORMALIZED for ?oating-point, signed integer, unsigned integer, signed
normalized ?xed-point, or unsigned normalized ?xed-point components re-
spectively. If no data storage or texture image has been speci?ed for the
attachment, then params will containNONE. This query cannot be performed
for a combined depth+stencil attachment, since it does not have a single for-
mat.
 If pname isFRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, then params
will contain the encoding of components of the speci?ed attachment, one
of LINEAR or SRGB for linear or sRGB-encoded components, respectively.
Only color buffer components may be sRGB-encoded; such components are
treated as described in sections 17.3.6 and 17.3.7. For the default frame-
buffer, color encoding is determined by the implementation. For frame-
buffer objects, components are sRGB-encoded if the internal format of a
color attachment is one of the color-renderable SRGB formats described in
section 8.24. If attachment is not a color attachment, or no data storage or
texture image has been speci?ed for the attachment, then params will contain
the valueLINEAR.
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is
RENDERBUFFER, then
 If pname isFRAMEBUFFER_ATTACHMENT_OBJECT_NAME, params will con-
tain the name of the renderbuffer object which contains the attached image.
If the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE isTEXTURE, then
 If pname isFRAMEBUFFER_ATTACHMENT_OBJECT_NAME, then params will
contain the name of the texture object which contains the attached image.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 312
 If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, then params
will contain the mipmap level of the texture object which contains the at-
tached image.
 If pname isFRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE and
the value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is the name of a
cube map texture object, then params will contain the cube map face of
the cubemap texture object which contains the attached image. Otherwise
params will contain zero.
 If pname isFRAMEBUFFER_ATTACHMENT_LAYERED, then params will con-
tainTRUE if an entire level of a three-dimensional texture, cube map texture,
or one- or two-dimensional array texture is attached. Otherwise, params will
containFALSE.
 If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER; the value
of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is the name of a three-
dimensional texture, or a one- or two-dimensional array texture object; and
the value ofFRAMEBUFFER_ATTACHMENT_LAYERED isFALSE, then params
will contain the texture layer which contains the attached image. Otherwise
params will contain zero.
Errors
An INVALID_ENUM error is generated by GetFramebufferAttachment-
Parameteriv if target is not DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER.
An INVALID_OPERATION error is generated by GetNamedFrame-
bufferAttachmentParameteriv if framebuffer is not zero or the name of an
existing framebuffer object.
AnINVALID_ENUM error is generated by any combinations of framebuffer
type and pname not described above.
An INVALID_OPERATION er-
ror is generated if the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
is NONE and pname is not FRAMEBUFFER_ATTACHMENT_OBJECT_NAME or
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE.
AnINVALID_ENUM error is generated if the default framebuffer is queried
and attachment is not one the values speci?ed in table 9.1.
An INVALID_OPERATION error is generated if a framebuffer object is
bound to target and attachment isCOLOR_ATTACHMENTm wherem is greater
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 313
than or equal to the value ofMAX_COLOR_ATTACHMENTS.
An INVALID_ENUM error is generated if a framebuffer object is queried,
attachment is not one of the attachments in table 9.2, and attachment is not
COLOR_ATTACHMENTm wherem is greater than or equal to the value ofMAX_-
COLOR_ATTACHMENTS.
An INVALID_OPERATION error is generated if attachment is DEPTH_-
STENCIL_ATTACHMENT and different objects are bound to the depth and sten-
cil attachment points of the framebuffer object.
9.2.3.1 Multisample Queries
The values of SAMPLE_BUFFERS and SAMPLES control whether and how multi-
sampling is performed (see section 14.3.1). They are framebuffer-dependent con-
stants derived from the attachments of a framebuffer object or the buffers of a
default framebuffer, and may be determined either by calling GetFramebuffer-
Parameteriv and GetNamedFramebufferParameteriv for a speci?c framebuffer
(see section 9.2.3), or by calling GetIntegerv with pname set toSAMPLE_BUFFERS
orSAMPLES.
If a framebuffer object is not framebuffer complete, as de?ned in section 9.4.2,
then the values ofSAMPLE_BUFFERS andSAMPLES are unde?ned.
Otherwise, the value of SAMPLES is equal to the value of RENDERBUFFER_-
SAMPLES or TEXTURE_SAMPLES (depending on the type of the attached images),
which must all have the same value. The value of SAMPLE_BUFFERS is one if
SAMPLES is non-zero, and zero otherwise.
9.2.4 Renderbuffer Objects
A renderbuffer is a data storage object containing a single image of a renderable in-
ternal format. The commands described below allocate and delete a renderbuffer’s
image, and attach a renderbuffer’s image to a framebuffer object.
The name space for renderbuffer objects is the unsigned integers, with zero
reserved by the GL. A renderbuffer object is created by binding a name returned
by GenRenderbuffers (see below) toRENDERBUFFER. The binding is effected by
calling
void BindRenderbuffer(enum target,uint renderbuffer );
with target set to RENDERBUFFER and renderbuffer set to the renderbuffer object
name. If renderbuffer is not zero, then the resulting renderbuffer object is a new
state vector, initialized with a zero-sized memory buffer, and comprising all the
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 314
state and with the same initial values listed in table 23.27. Any previous binding to
target is broken.
BindRenderbuffer may also be used to bind an existing renderbuffer object.
If the bind is successful, no change is made to the state of the newly bound render-
buffer object, and any previous binding to target is broken.
While a renderbuffer object is bound, GL operations on the target to which it
is bound affect the bound renderbuffer object, and queries of the target to which a
renderbuffer object is bound return state from the bound object.
The name zero is reserved. A renderbuffer object cannot be created with the
name zero. If renderbuffer is zero, then any previous binding to target is broken
and the target binding is restored to the initial state.
In the initial state, the reserved name zero is bound toRENDERBUFFER. There is
no renderbuffer object corresponding to the name zero, so client attempts to modify
or query renderbuffer state for the targetRENDERBUFFER while zero is bound will
generate GL errors, as described in section 9.2.3.
The current RENDERBUFFER binding can be determined by calling GetInte-
gerv with pnameRENDERBUFFER_BINDING.
Errors
AnINVALID_ENUM error is generated if target is notRENDERBUFFER.
AnINVALID_OPERATION error is generated if renderbuffer is not zero or
a name returned from a previous call to GenRenderbuffers, or if such a name
has since been deleted with DeleteRenderbuffers.
New renderbuffers may also be created with the command
void CreateRenderbuffers(sizei n,uint *renderbuffers );
CreateRenderbuffers returns n previously unused renderbuffer names in ren-
derbuffers, each representing a new renderbuffer object which is a state vector
comprising all the state and with the initial values listed in table 23.27. The
state of each renderbuffer object is as if a name returned from GenRenderbuffers
had been bound to the RENDERBUFFER target, except that any existing binding to
RENDERBUFFER is not affected.
Errors
AnINVALID_VALUE error is generated if n is negative.
The command
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 315
void GenRenderbuffers(sizei n,uint *renderbuffers );
returns n previously unused renderbuffer object names in renderbuffers. These
names are marked as used, for the purposes of GenRenderbuffers only, but they
acquire renderbuffer state only when they are ?rst bound.
Errors
AnINVALID_VALUE error is generated if n is negative.
Renderbuffer objects are deleted by calling
void DeleteRenderbuffers(sizei n,const
uint *renderbuffers );
where renderbuffers contains n names of renderbuffer objects to be deleted. After
a renderbuffer object is deleted, it has no contents, and its name is again unused. If
a renderbuffer that is currently bound toRENDERBUFFER is deleted, it is as though
BindRenderbuffer had been executed with the target RENDERBUFFER and name
of zero. Additionally, special care must be taken when deleting a renderbuffer if
the image of the renderbuffer is attached to a framebuffer object (see section 9.2.7).
Unused names in renderbuffers that have been marked as used for the purposes of
GenRenderbuffers are marked as unused again. Unused names in renderbuffers
are silently ignored, as is the value zero.
Errors
AnINVALID_VALUE error is generated if n is negative.
The command
boolean IsRenderbuffer(uint renderbuffer );
returns TRUE if renderbuffer is the name of a renderbuffer object. If renderbuffer
is zero, or if renderbuffer is a non-zero value that is not the name of a renderbuffer
object, IsRenderbuffer returnsFALSE.
The data storage, format, dimensions, and number of samples of a renderbuffer
object’s image are established with the commands
void RenderbufferStorageMultisample(enum target,
sizei samples,enum internalformat,sizei width,
sizei height );
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 316
void NamedRenderbufferStorageMultisample(
uint renderbuffer,sizei samples,enum internalformat,
sizei width,sizei height );
For RenderbufferStorageMultisample, the renderbuffer object is that bound
to target, which must beRENDERBUFFER. For NamedRenderbufferStorageMul-
tisample, renderbuffer is the name of the renderbuffer object.
internalformat must be color-renderable, depth-renderable, or stencil-
renderable (as de?ned in section 9.4). width and height are the dimensions in
pixels of the renderbuffer.
Upon success, *RenderbufferStorageMultisample deletes any existing data
store for the renderbuffer image, and the contents of the data store are unde?ned.
RENDERBUFFER_WIDTH is set to width,RENDERBUFFER_HEIGHT is set to height,
andRENDERBUFFER_INTERNAL_FORMAT is set to internalformat.
If samples is zero, then RENDERBUFFER_SAMPLES is set to zero. Otherwise
samples represents a request for a desired minimum number of samples. Since
different implementations may support different sample counts for multisampled
rendering, the actual number of samples allocated for the renderbuffer image is
implementation-dependent. However, the resulting value for RENDERBUFFER_-
SAMPLES is guaranteed to be greater than or equal to samples and no more than the
next larger sample count supported by the implementation.
A GL implementation may vary its allocation of internal component resolution
based on any *RenderbufferStorageMultisample parameter (except target and
renderbuffer), but the allocation and chosen internal format must not be a function
of any other state and cannot be changed once they are established.
Errors
An INVALID_ENUM error is generated by RenderbufferStorageMulti-
sample if target is notRENDERBUFFER.
An INVALID_OPERATION error is generated by NamedRenderbuffer-
StorageMultisample if renderbuffer is not the name of an existing render-
buffer object.
AnINVALID_VALUE error is generated if samples, width, or height is neg-
ative.
AnINVALID_OPERATION error is generated if samples is greater than the
maximum number of samples supported for internalformat (see GetInternal-
formativ in section 22.3).
An INVALID_ENUM error is generated if internalformat is not one of the
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 317
color-renderable, depth-renderable, or stencil-renderable formats de?ned in
section 9.4.
AnINVALID_VALUE error is generated if either width or height is greater
than the value ofMAX_RENDERBUFFER_SIZE.
The commands
void RenderbufferStorage(enum target,enum internalformat,
sizei width,sizei height );
void NamedRenderbufferStorage(uint renderbuffer,
enum internalformat,sizei width,sizei height );
are equivalent to
RenderbufferStorageMultisample(target,0,internalformat,width,height);
and
NamedRenderbufferStorageMultisample(renderbuffer,0,internalformat,width,height);
respectively.
9.2.5 Required Renderbuffer Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, ?oat, etc.) for each base internal
format.
In addition, implementations are required to support the following sized and
compressed internal formats. Requesting one of these sized internal formats for
a renderbuffer will allocate at least the internal component sizes, and exactly the
component types shown for that format in the corresponding table:
 Color formats which are checked in the “Req. rend.” column of table 8.12.
 Depth, depth+stencil, and stencil formats which are checked in the “Req.
format” column of table 8.13.
The required color formats for renderbuffers are a subset of the required for-
mats for textures (see section 8.5.1).
Implementations must support creation of renderbuffers in these required for-
mats with up to the value of MAX_SAMPLES multisamples, with the exception
that the signed and unsigned integer formats are required only to support creation
of renderbuffers with up to the value of MAX_INTEGER_SAMPLES multisamples,
which must be at least one.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 318
9.2.6 Renderbuffer Object Queries
Parameters of a renderbuffer object may be queried with the commands
void GetRenderbufferParameteriv(enum target,enum pname,
int *params );
void GetNamedRenderbufferParameteriv(uint renderbuffer,
enum pname,int *params );
For GetRenderbufferParameteriv, the renderbuffer object is that bound to
target, which must be RENDERBUFFER. For GetNamedRenderbufferParame-
teriv, renderbuffer is the name of the renderbuffer object.
The value of renderbuffer parameter pname for the renderbuffer object is re-
turned in params. pname must be one of the symbolic values in table 23.27.
If pname is RENDERBUFFER_WIDTH, RENDERBUFFER_HEIGHT,
RENDERBUFFER_INTERNAL_FORMAT, or RENDERBUFFER_SAMPLES, then
params will contain the width in pixels, height in pixels, internal format, or
number of samples, respectively, of the image of the renderbuffer object.
If pname is RENDERBUFFER_RED_SIZE, RENDERBUFFER_GREEN_-
SIZE, RENDERBUFFER_BLUE_SIZE, RENDERBUFFER_ALPHA_SIZE,
RENDERBUFFER_DEPTH_SIZE, or RENDERBUFFER_STENCIL_SIZE, then
params will contain the actual resolutions (not the resolutions speci?ed when the
image was de?ned) for the red, green, blue, alpha, depth, or stencil components,
respectively, of the image of the renderbuffer object.
Errors
AnINVALID_ENUM error is generated by GetRenderbufferParameteriv
if target is notRENDERBUFFER.
An INVALID_OPERATION error is generated by GetRenderbufferPa-
rameteriv if the renderbuffer currently bound to target is zero.
An INVALID_OPERATION error is generated by GetNamedRender-
bufferParameteriv if renderbuffer is not the name of an existing renderbuffer
object.
An INVALID_ENUM error is generated if pname is not one of the render-
buffer state names in table 23.27.
9.2.7 Attaching Renderbuffer Images to a Framebuffer
A renderbuffer object can be attached as one of the logical buffers of a framebuffer
object with the commmands
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 319
void FramebufferRenderbuffer(enum target,
enum attachment,enum renderbuffertarget,
uint renderbuffer );
void NamedFramebufferRenderbuffer(uint framebuffer,
enum attachment,enum renderbuffertarget,
uint renderbuffer );
For FramebufferRenderbuffer the framebuffer object is that bound to target,
which must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER or FRAMEBUFFER.
FRAMEBUFFER is equivalent toDRAW_FRAMEBUFFER.
For NamedFramebufferRenderbuffer, framebuffer is the name of the frame-
buffer object.
attachment must be set to one of the attachment points of the framebuffer listed
in table 9.2.
renderbuffertarget must be RENDERBUFFER and renderbuffer is zero or the
name of a renderbuffer object of type renderbuffertarget to be attached to the
framebuffer. If renderbuffer is zero, then the value of renderbuffertarget is ignored.
If renderbuffer is not zero and if *FramebufferRenderbuffer is suc-
cessful, then the renderbuffer named renderbuffer will be used as the logi-
cal buffer identi?ed by attachment of the framebuffer object. The value of
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the speci?ed attachment point is
set toRENDERBUFFER and the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_-
NAME is set to renderbuffer. All other state values of the attachment point speci?ed
by attachment are set to their default values listed in table 23.25. No change is
made to the state of the renderbuffer object and any previous attachment to the at-
tachment logical buffer of the framebuffer object is broken. If the attachment is not
successful, then no change is made to the state of either the renderbuffer object or
the framebuffer object.
Calling *FramebufferRenderbuffer with the renderbuffer name zero will de-
tach the image, if any, identi?ed by attachment, in the framebuffer object currently
bound to target. All state values of the attachment point speci?ed by attachment in
the framebuffer object are set to their default values listed in table 23.25.
Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to be
set to renderbuffer, which should have base internal formatDEPTH_STENCIL.
If a renderbuffer object is deleted while its image is attached to one or more at-
tachment points in a currently bound framebuffer object, then it is as if Framebuf-
ferRenderbuffer had been called, with a renderbuffer of zero, for each attachment
point to which this image was attached in that framebuffer object. In other words,
the renderbuffer image is ?rst detached from all attachment points in that frame-
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 320
buffer object. Note that the renderbuffer image is speci?cally not detached from
any non-bound framebuffer objects. Detaching the image from any non-bound
framebuffer objects is the responsibility of the application.
Name of attachment
COLOR_ATTACHMENTi (see caption)
DEPTH_ATTACHMENT
STENCIL_ATTACHMENT
DEPTH_STENCIL_ATTACHMENT
Table 9.2: Framebuffer attachment points. i in COLOR_ATTACHMENTi may range
from zero to the value ofMAX_COLOR_ATTACHMENTS minus one.
Errors
An INVALID_ENUM error is generated by FramebufferRenderbuffer if
target is notDRAW_FRAMEBUFFER,READ_FRAMEBUFFER, orFRAMEBUFFER.
An INVALID_OPERATION error is generated by FramebufferRender-
buffer if zero is bound to target.
An INVALID_OPERATION error is generated by NamedFramebuffer-
Renderbuffer if framebuffer is not the name of an existing framebuffer object.
An INVALID_OPERATION error is generated if attachment is COLOR_-
ATTACHMENTm wherem is greater than or equal to the value ofMAX_COLOR_-
ATTACHMENTS.
An INVALID_ENUM error is generated if attachment is not one of the at-
tachments in table 9.2, and attachment is not COLOR_ATTACHMENTm where
m is greater than or equal to the value ofMAX_COLOR_ATTACHMENTS.
An INVALID_ENUM error is generated if renderbuffertarget is not
RENDERBUFFER.
AnINVALID_OPERATION error is generated if renderbuffer is not zero or
the name of an existing renderbuffer object of type renderbuffertarget.
9.2.8 Attaching Texture Images to a Framebuffer
The GL supports copying the rendered contents of the framebuffer into the images
of a texture object through the use of the routines CopyTexImage* and CopyTex-
SubImage*. Additionally, the GL supports rendering directly into the images of a
texture object.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 321
To render directly into a texture image, a speci?ed level of a texture object can
be attached as one of the logical buffers of a framebuffer object with the commands
void FramebufferTexture(enum target,enum attachment,
uint texture,int level );
void NamedFramebufferTexture(uint framebuffer,
enum attachment,uint texture,int level );
For FramebufferTexture, the framebuffer object is that bound to target,
which must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. For NamedFramebuffer-
Texture, framebuffer is the name of the framebuffer object.
attachment must be one of the attachment points of the framebuffer listed in
table 9.2.
If texture is non-zero, the speci?ed mipmap level of the texture object named
texture is attached to the framebuffer attachment point named by attachment.
If texture is the name of a three-dimensional texture, cube map array texture,
cube map texture, one- or two-dimensional array texture, or two-dimensional mul-
tisample array texture, the texture level attached to the framebuffer attachment
point is an array of images, and the framebuffer attachment is considered layered.
Errors
An INVALID_ENUM error is generated by FramebufferTexture if target
is notDRAW_FRAMEBUFFER,READ_FRAMEBUFFER, orFRAMEBUFFER.
An INVALID_OPERATION error is generated by FramebufferTexture if
zero is bound to target.
An INVALID_OPERATION error is generated by NamedFramebuffer-
Texture if framebuffer is not the name of an existing framebuffer object.
An INVALID_OPERATION error is generated if attachment is COLOR_-
ATTACHMENTm wherem is greater than or equal to the value ofMAX_COLOR_-
ATTACHMENTS.
An INVALID_ENUM error is generated if attachment is not one of the at-
tachments in table 9.2, and attachment is not COLOR_ATTACHMENTm where
m is greater than or equal to the value ofMAX_COLOR_ATTACHMENTS.
AnINVALID_VALUE error is generated if texture is not zero and is not the
name of a texture object, or if level is not a supported texture level for texture.
An INVALID_OPERATION error is generated if texture is the name of a
buffer texture.
Additionally, a speci?ed image from a texture object can be attached as one of
the logical buffers of a framebuffer object with the commands
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 322
void FramebufferTexture1D(enum target,enum attachment,
enum textarget,uint texture,int level );
void FramebufferTexture2D(enum target,enum attachment,
enum textarget,uint texture,int level );
void FramebufferTexture3D(enum target,enum attachment,
enum textarget,uint texture,int level,int layer );
target speci?es the target to which the framebuffer object is bound, and must be
DRAW_FRAMEBUFFER,READ_FRAMEBUFFER, orFRAMEBUFFER.FRAMEBUFFER is
equivalent toDRAW_FRAMEBUFFER.
attachment must be one of the attachment points of the framebuffer listed in
table 9.2.
If texture is not zero, then texture must either name an existing texture object
with a target of textarget, or texture must name an existing cube map texture and
textarget must be one of the cube map face targets from table 8.19.
level speci?es the mipmap level of the texture image to be attached to the
framebuffer, and must satisfy the following conditions:
 If texture refers to an immutable-format texture, level must be greater than or
equal to zero and smaller than the value of TEXTURE_VIEW_NUM_LEVELS
for texture.
 If textarget isTEXTURE_RECTANGLE orTEXTURE_2D_MULTISAMPLE, then
level must be zero.
 If textarget isTEXTURE_3D, then level must be greater than or equal to zero
and less than or equal tolog of the value ofMAX_3D_TEXTURE_SIZE.
2
 If textarget is one of the cube map face targets from table 8.19, then level
must be greater than or equal to zero and less than or equal to log of the
2
value ofMAX_CUBE_MAP_TEXTURE_SIZE.
 For all other values of textarget, level must be greater than or equal to zero
and no larger thanlog of the value ofMAX_TEXTURE_SIZE.
2
layer speci?es the layer of a two-dimensional image within a three-dimensional
texture.
Errors
An INVALID_ENUM error is generated if target is not DRAW_-
FRAMEBUFFER,READ_FRAMEBUFFER, orFRAMEBUFFER.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 323
An INVALID_OPERATION error is generated if attachment is COLOR_-
ATTACHMENTm wherem is greater than or equal to the value ofMAX_COLOR_-
ATTACHMENTS.
An INVALID_ENUM error is generated if attachment is not one of the at-
tachments in table 9.2, and attachment is not COLOR_ATTACHMENTm where
m is greater than or equal to the value ofMAX_COLOR_ATTACHMENTS.
AnINVALID_OPERATION error is generated if zero is bound to target.
An INVALID_VALUE error is generated if texture is not zero and level is
not a supported texture level for textarget, as described above.
An INVALID_VALUE error is generated if texture is not zero and layer is
larger than the value ofMAX_3D_TEXTURE_SIZE minus one.
AnINVALID_OPERATION error is generated for FramebufferTexture1D
if texture is not zero and textarget is notTEXTURE_1D.
AnINVALID_OPERATION error is generated for FramebufferTexture2D
if texture is not zero and textarget is not one ofTEXTURE_2D,TEXTURE_2D_-
MULTISAMPLE, TEXTURE_RECTANGLE, or one of the cube map face targets
from table 8.19.
AnINVALID_OPERATION error is generated for FramebufferTexture3D
if texture is not zero and textarget is notTEXTURE_3D.
An INVALID_OPERATION error is generated if texture is not zero, and
does not name an existing texture object of type matching textarget, as de-
scribed above.
An INVALID_OPERATION error is generated if texture is the name of a
buffer texture.
A single layer of a three-dimensional or array texture object can be attached as
one of the logical buffers of a framebuffer object with the commands
void FramebufferTextureLayer(enum target,
enum attachment,uint texture,int level,int layer );
void NamedFramebufferTextureLayer(uint framebuffer,
enum attachment,uint texture,int level,int layer );
These commands operate identically to the equivalent FramebufferTexture
and NamedFramebufferTexture commands, respectively, except for the addi-
tional layer argument which selects a layer of the texture object to attach.
layer speci?es the layer of a one- or two-dimensional image within texture,
except for cube map and cube map array textures. For cube map textures, layer
is translated into a cube map face as described in table 9.3. For cube map array
textures, layer is translated into an array layer and a cube map face as described for
layer-face numbers in section 8.5.3.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 324
level speci?es the mipmap level of the texture image to be attached to the
framebuffer, and must satisfy the following conditions:
 If texture refers to an immutable-format texture, level must be greater than or
equal to zero and smaller than the value of TEXTURE_VIEW_NUM_LEVELS
for texture.
 If texture is a three-dimensional texture, then level must be greater than
or equal to zero and less than or equal to log of the value of MAX_3D_-
2
TEXTURE_SIZE.
 If texture is a two-dimensional array texture, then level must be greater
than or equal to zero and less than or equal to log of the value of MAX_-
2
TEXTURE_SIZE.
 If texture is a two-dimensional multisample array texture, then level must be
zero.
Errors
In addition to the corresponding errors for FramebufferTexture and
NamedFramebufferTexture when called with the same parameters (other
than layer):
An INVALID_VALUE error is generated if texture is a three-dimensional
texture, and layer is larger than the value of MAX_3D_TEXTURE_SIZE minus
one.
An INVALID_VALUE error is generated if texture is an array texture, and
layer is larger than the value ofMAX_ARRAY_TEXTURE_LAYERS minus one.
AnINVALID_VALUE error is generated if texture is a cube map array tex-
ture, and
layer
6
is larger than the value of MAX_CUBE_MAP_TEXTURE_SIZE minus one (see
section 9.8).
AnINVALID_VALUE error is generated if texture is non-zero and layer is
negative.
An INVALID_OPERATION error is generated if texture is non-zero and is
not the name of a three-dimensional, two-dimensional multisample array, one-
or two-dimensional array, or cube map array texture.
An INVALID_VALUE error is generated if texture is not zero and level is
OpenGL 4.6 (Core Pro?le) - February 2, 20199.2. BINDINGANDMANAGINGFRAMEBUFFEROBJECTS 325
not a supported texture level for texture, as described above.
If texture is non-zero and the command does not result in an error, the frame-
buffer attachment state corresponding to attachment is updated as in the other
FramebufferTexture* commands, except that the value of FRAMEBUFFER_-
ATTACHMENT_TEXTURE_LAYER is set to layer.
9.2.8.1 Effects of Attaching a Texture Image
The remaining comments in this section apply to all forms of *FramebufferTex-
ture*.
If texture is zero, any image or array of images attached to the attachment point
named by attachment is detached. Any additional parameters (level, textarget,
and/or layer) are ignored when texture is zero. All state values of the attachment
point speci?ed by attachment are set to their default values listed in table 23.25.
If texture is not zero, and if *FramebufferTexture* is successful, then the
speci?ed texture image will be used as the logical buffer identi?ed by attachment
of the framebuffer object currently bound to target. State values of the speci?ed
attachment point are set as follows:
 The value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is set to
TEXTURE.
 The value ofFRAMEBUFFER_ATTACHMENT_OBJECT_NAME is set to texture.
 The value ofFRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL is set to level.
 If *FramebufferTexture2D is called and texture is a cube map texture, then
the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE is
set to textarget; otherwise it is set to the default value (NONE).
 If *FramebufferTextureLayer or *FramebufferTexture3D is called, then
the value ofFRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER is set to layer;
otherwise it is set to zero.
 If *FramebufferTexture* is called and texture is the name of a three-
dimensional, cube map, two-dimensional multisample array, or one- or
two-dimensional array texture, the value ofFRAMEBUFFER_ATTACHMENT_-
LAYERED is set toTRUE; otherwise it is set toFALSE.
All other state values of the attachment point speci?ed by attachment are set
to their default values listed in table 23.25. No change is made to the state of the
OpenGL 4.6 (Core Pro?le) - February 2, 20199.3. FEEDBACKLOOPSBETWEENTEXTURESANDTHEFRAMEBUFFER326
texture object, and any previous attachment to the attachment logical buffer of the
framebuffer object bound to framebuffer target is broken. If the attachment is not
successful, then no change is made to the state of either the texture object or the
framebuffer object.
Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to texture. texture must have base internal format DEPTH_STENCIL, or the
depth and stencil framebuffer attachments will be incomplete (see section 9.4.1).
If a texture object is deleted while its image is attached to one or more at-
tachment points in a currently bound framebuffer object, then it is as if *Frame-
bufferTexture* had been called, with a texture of zero, for each attachment point
to which this image was attached in that framebuffer object. In other words, the
texture image is ?rst detached from all attachment points in that framebuffer ob-
ject. Note that the texture image is speci?cally not detached from any non-bound
framebuffer objects. Detaching the texture image from any non-bound framebuffer
objects is the responsibility of the application.
9.3 Feedback Loops Between Textures and the Framebuffer
A feedback loop may exist when the data store of a texture object is used as both
the source and destination of a GL operation. When a feedback loop exists, un-
de?ned behavior results. This section describes rendering feedback loops (see
section 8.14.2.1) and texture copying feedback loops (see section 8.6.1) in more
detail.
9.3.1 Rendering Feedback Loops
The mechanisms for attaching textures to a framebuffer object do not prevent a
one- or two-dimensional texture level, a face of a cube map texture level, or a layer
of a two-dimensional array, three-dimensional texture, or texture view from being
attached to the draw framebuffer while the same texture is bound to a texture unit.
While this condition holds, texturing operations accessing that image will produce
unde?ned results, as described at the end of section 8.14. Conditions resulting in
such unde?ned behavior are de?ned in more detail below. Such unde?ned texturing
operations are likely to leave the ?nal results of fragment processing operations
unde?ned, and should be avoided.
Special precautions need to be taken to avoid attaching a texture image to
the currently bound draw framebuffer object while the texture object is currently
OpenGL 4.6 (Core Pro?le) - February 2, 20199.3. FEEDBACKLOOPSBETWEENTEXTURESANDTHEFRAMEBUFFER327
bound. Doing so could lead to the creation of a rendering feedback loop between
the writing of pixels by GL rendering operations and the simultaneous reading of
those same pixels when used as texels in the currently bound texture. In this sce-
nario, the framebuffer will be considered framebuffer complete (see section 9.4),
but the values of fragments rendered while in this state will be unde?ned. The val-
ues of texture samples may be unde?ned as well, as described under “Rendering
Feedback Loops” in section 8.14.2.1
Speci?cally, the values of rendered fragments are unde?ned if any shader stage
fetches texels and the same texels are written via fragment shader outputs, even
if the reads and writes are not in the same draw call, unless any of the following
exceptions apply:
 The reads and writes are from/to disjoint sets of texels (after accounting for
texture ?ltering rules).
 There is only a single read and write of each texel, and the read is in
the fragment shader invocation that writes the same texel (e.g. using
texelFetch2D(sampler, ivec2(gl_FragCoord.xy), 0);).
 If a texel has been written, then in order to safely read the result a texel fetch
must be in a subsequent draw call separated by the command
void TextureBarrier(void );
TextureBarrier will guarantee that writes have completed and caches have
been invalidated before subsequent draw calls are executed.
9.3.2 Texture Copying Feedback Loops
Similarly to rendering feedback loops, it is possible for a texture image to be at-
tached to the currently bound read framebuffer object while the same texture im-
age is the destination of a CopyTexImage* operation, as described under “Texture
Copying Feedback Loops” in section 8.6.1. While this condition holds, a texture
copying feedback loop between the writing of texels by the copying operation and
the reading of those same texels when used as pixels in the read framebuffer may
exist. In this scenario, the values of texels written by the copying operation will be
unde?ned (in the same fashion that overlapping copies via BlitFramebuffer are
unde?ned).
Speci?cally, the values of copied texels are unde?ned if all of the following
conditions are true:
OpenGL 4.6 (Core Pro?le) - February 2, 20199.4. FRAMEBUFFERCOMPLETENESS 328
 an image from texture object T is attached to the currently bound read frame-
buffer object at attachment point A
 the selected read buffer (see section 18.2.1) is attachment point A
 T is bound to the texture target of a CopyTexImage* operation
 the level argument of the copying operation selects the same image that is
attached to A
9.4 Framebuffer Completeness
A framebuffer must be framebuffer complete to effectively be used as the draw or
read framebuffer of the GL.
The default framebuffer is always complete if it exists; however, if no default
framebuffer exists (no window system-provided drawable is associated with the
GL context), it is deemed to be incomplete.
A framebuffer object is said to be framebuffer complete if all of its attached
images, and all framebuffer parameters required to utilize the framebuffer for ren-
dering and reading, are consistently de?ned and meet the requirements de?ned
below. The rules of framebuffer completeness are dependent on the properties of
the attached images, and on certain implementation-dependent restrictions.
The internal formats of the attached images can affect the completeness of
the framebuffer, so it is useful to ?rst de?ne the relationship between the internal
format of an image and the attachment points to which it can be attached.
 An internal format is color-renderable if it is RED, RG, RGB, RGBA, or one
of the sized internal formats from table 8.12 whose “CR” (color-renderable)
column is checked in that table No other formats, including compressed in-
ternal formats, are color-renderable.
 An internal format is depth-renderable if it is DEPTH_COMPONENT or one
of the formats from table 8.13 whose base internal format is DEPTH_-
COMPONENT orDEPTH_STENCIL. No other formats are depth-renderable.
 An internal format is stencil-renderable if it isSTENCIL_INDEX,DEPTH_-
STENCIL, or one of the formats from table 8.13 whose base internal for-
mat isSTENCIL_INDEX orDEPTH_STENCIL. No other formats are stencil-
renderable.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.4. FRAMEBUFFERCOMPLETENESS 329
9.4.1 Framebuffer Attachment Completeness
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the framebuffer
attachment point attachment is not NONE, then it is said that a framebuffer-
attachable image, named image, is attached to the framebuffer at the attachment
point. image is identi?ed by the state in attachment as described in section 9.2.2.
The framebuffer attachment point attachment is said to be framebuffer attach-
ment complete if the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for
attachment isNONE (i.e., no image is attached), or if all of the following conditions
are true:
 image is a component of an existing object with the name speci?ed by
the value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, and of the type
speci?ed by the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE.
 The width and height of image are greater than zero and less than or equal
to the values of the implementation-dependent limitsMAX_FRAMEBUFFER_-
WIDTH andMAX_FRAMEBUFFER_HEIGHT, respectively.
 If image is a three-dimensional, one- or two-dimensional array, or cube map
array texture and the attachment is not layered, the selected layer is less than
the depth or layer count of the texture.
 If image is a three-dimensional, one- or two-dimensional array, or cube map
array texture and the attachment is layered, the depth or layer count of the
texture is less than or equal to the value of the implementation-dependent
limitMAX_FRAMEBUFFER_LAYERS.
 If image has multiple samples, its sample count is less than or equal to
the value of the implementation-dependent limit MAX_FRAMEBUFFER_-
SAMPLES.
 If image is not an immutable-format texture, the selected level number is in
the range [level ;q], wherelevel andq are as de?ned in section 8.14.3.
base base
 If image is not an immutable-format texture and the selected level is not
level , the texture must be mipmap complete; if image is part of a cube-
base
map texture, the texture must also be mipmap cube complete.
 If attachment is COLOR_ATTACHMENTi, then image must have a color-
renderable internal format.
 If attachment is DEPTH_ATTACHMENT, then image must have a depth-
renderable internal format.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.4. FRAMEBUFFERCOMPLETENESS 330
 If attachment is STENCIL_ATTACHMENT, then image must have a stencil-
renderable internal format.
9.4.2 Whole Framebuffer Completeness
Each rule below is followed by an error token enclosed inf bracketsg. The mean-
ing of these errors is explained below and under “Effects of Framebuffer Com-
pleteness on Framebuffer Operations” in section 9.4.4.
The framebuffer object bound to target is said to be framebuffer complete if all
the following conditions are true:
 if the default framebuffer is bound to target, the default framebuffer exists.
fFRAMEBUFFER_UNDEFINEDg
 All framebuffer attachment points are framebuffer attachment complete.
fFRAMEBUFFER_INCOMPLETE_ATTACHMENTg
 There is at least one image attached to the framebuffer, or the value of
the framebuffer’s FRAMEBUFFER_DEFAULT_WIDTH and FRAMEBUFFER_-
DEFAULT_HEIGHT parameters are both non-zero.
fFRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENTg
 The combination of internal formats of the attached images does not violate
an implementation-dependent set of restrictions.
fFRAMEBUFFER_UNSUPPORTEDg
 The value ofRENDERBUFFER_SAMPLES is the same for all attached render-
buffers; the value of TEXTURE_SAMPLES is the same for all attached tex-
tures; and, if the attached images are a mix of renderbuffers and textures,
the value of RENDERBUFFER_SAMPLES matches the value of TEXTURE_-
SAMPLES.
fFRAMEBUFFER_INCOMPLETE_MULTISAMPLEg
 The value of TEXTURE_FIXED_SAMPLE_LOCATIONS is the same for all
attached textures; and, if the attached images are a mix of renderbuffers
and textures, the value of TEXTURE_FIXED_SAMPLE_LOCATIONS must be
TRUE for all attached textures.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.4. FRAMEBUFFERCOMPLETENESS 331
fFRAMEBUFFER_INCOMPLETE_MULTISAMPLEg
 If any framebuffer attachment is layered, all populated attachments must be
layered. Additionally, all populated color attachments must be from textures
of the same target (three-dimensional, one- or two-dimensional array, cube
map, or cube map array textures).
fFRAMEBUFFER_INCOMPLETE_LAYER_TARGETSg
The token in brackets after each clause of the framebuffer completeness rules
speci?es the return value of CheckFramebufferStatus (see below) that is gen-
erated when that clause is violated. If more than one clause is violated, it is
implementation-dependent which value will be returned by CheckFramebuffer-
Status.
Performing any of the following actions may change whether the framebuffer
is considered complete or incomplete:
 Binding to a different framebuffer with BindFramebuffer.
 Attaching an image to the framebuffer with FramebufferTexture* or
FramebufferRenderbuffer.
 Detaching an image from the framebuffer with FramebufferTexture* or
FramebufferRenderbuffer.
 Changing the internal format of a texture image that is attached to the frame-
buffer by calling TexImage*, TexStorage*, CopyTexImage*, or Com-
pressedTexImage*.
 Changing the internal format of a renderbuffer that is attached to the frame-
buffer by calling RenderbufferStorage*.
 Deleting, with DeleteTextures or DeleteRenderbuffers, an object contain-
ing an image that is attached to a currently bound framebuffer object.
 Associating a different window system-provided drawable, or no drawable,
with the default framebuffer using a window system binding API such as
those described in section 1.3.6.
Although the GL de?nes a wide variety of internal formats for framebuffer-
attachable images, such as texture images and renderbuffer images, some imple-
mentations may not support rendering to particular combinations of internal for-
mats. If the combination of formats of the images attached to a framebuffer object
OpenGL 4.6 (Core Pro?le) - February 2, 20199.4. FRAMEBUFFERCOMPLETENESS 332
are not supported by the implementation, then the framebuffer is not complete un-
der the clause labeledFRAMEBUFFER_UNSUPPORTED.
Implementations are required to support certain combinations of framebuffer
internal formats as described under “Required Framebuffer Formats” in sec-
tion 9.4.3.
Because of the implementation-dependent clause of the framebuffer complete-
ness test in particular, and because framebuffer completeness can change when the
set of attached images is modi?ed, it is strongly advised, though not required, that
an application check to see if the framebuffer is complete prior to rendering.
The status of a framebuffer object or default framebuffer may be queried with
the commands
enum CheckFramebufferStatus(enum target );
enum CheckNamedFramebufferStatus(uint framebuffer,
enum target );
For CheckFramebufferStatus, the framebuffer object is that bound to target.
For CheckNamedFramebufferStatus, framebuffer is the name of the framebuffer
object.
target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER.FRAMEBUFFER is equivalent toDRAW_FRAMEBUFFER.
If framebuffer is zero, then the status of the default read or draw framebuffer
(as determined by target) is returned.
A value is returned that identi?es whether or not the framebuffer object or
default framebuffer is complete when treated as a read or draw framebuffer (as de-
termined by target). If the framebuffer object is complete, then FRAMEBUFFER_-
COMPLETE is returned. Otherwise, the value returned is one of the error codes
de?ned at the start of section 9.4.2 identifying one of the rules of framebuffer com-
pleteness that is violated.
If CheckFramebufferStatus generates an error, zero is returned.
Errors
An INVALID_ENUM error is generated if target is not DRAW_-
FRAMEBUFFER,READ_FRAMEBUFFER, orFRAMEBUFFER.
An INVALID_OPERATION error is generated by CheckNamedFrame-
bufferStatus if framebuffer is not the name of an existing framebuffer object.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.4. FRAMEBUFFERCOMPLETENESS 333
9.4.3 Required Framebuffer Formats
Implementations must support framebuffer objects with up to the value of MAX_-
COLOR_ATTACHMENTS color attachments, a depth attachment, and a stencil at-
tachment. Each color attachment may be in any of the color-renderable formats
described in section 9.4 (although implementations are not required to support cre-
ation of attachments in all color-renderable formats). The depth attachment may
be in any of the required depth or combined depth+stencil formats described in
sections 8.5.1 and 9.2.5, and the stencil attachment may be in any of the required
stencil or combined depth+stencil formats. However, when both depth and stencil
attachments are present, implementations are only required to support framebuffer
objects where both attachments refer to the same image.
Any internal format that returnsFULL_SUPPORT from the GetInternalforma-
tiv query for pnameFRAMEBUFFER_RENDERABLE (see section 22.3.1) can be used
in non-layered attachments in any combination with other required formats or for-
mats that offerFULL_SUPPORT.
Any internal format that returns FULL_SUPPORT from the query for pname
FRAMEBUFFER_RENDERABLE_LAYERED can be used in any combination with
other required formats or formats that offerFULL_SUPPORT.
There must be at least one default framebuffer format allowing creation of a
default framebuffer supporting front-buffered rendering.
9.4.4 Effects of Framebuffer Completeness on Framebuffer Opera-
tions
Errors
AnINVALID_FRAMEBUFFER_OPERATION error is generated by attempts
to render to or read from a framebuffer which is not framebuffer complete.
This error is generated regardless of whether fragments are actually read from
or written to the framebuffer. For example, it is generated when a rendering
command is called and the framebuffer is incomplete, even ifRASTERIZER_-
DISCARD is enabled.
An INVALID_FRAMEBUFFER_OPERATION error is generated by render-
ing commands (see section 2.4), and commands that read from the frame-
buffer such as ReadPixels, CopyTexImage*, and CopyTexSubImage* if
called while the framebuffer is not framebuffer complete.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.5. MAPPINGBETWEENPIXELANDELEMENTINATTACHEDIMAGE334
9.4.5 Effects of Framebuffer State on Framebuffer Dependent Values
The values of the state variables listed in table 23.73 may change when a
change is made to the current read or draw framebuffer binding, to the state
of a currently bound framebuffer object, or to an image attached to that frame-
buffer object. Most such state is dependent on the draw framebuffer (the
value DRAW_FRAMEBUFFER_BINDING), but IMPLEMENTATION_COLOR_READ_-
TYPE and IMPLEMENTATION_COLOR_READ_FORMAT are dependent on the read
framebuffer (the value ofREAD_FRAMEBUFFER_BINDING).
The values of the state variables listed in table 23.73 may change when a
change is made to DRAW_FRAMEBUFFER_BINDING, to the state of the currently
bound draw framebuffer object, or to an image attached to that framebuffer object.
WhenDRAW_FRAMEBUFFER_BINDING is zero, the values of the state variables
listed in table 23.73 are implementation-de?ned.
When DRAW_FRAMEBUFFER_BINDING is non-zero, if the currently bound
draw framebuffer object is not framebuffer complete, then the values of the state
variables listed in table 23.73 are unde?ned.
When DRAW_FRAMEBUFFER_BINDING is non-zero and the currently bound
draw framebuffer object is framebuffer complete, then the values of the state vari-
ables listed in table 23.73 are completely determined by DRAW_FRAMEBUFFER_-
BINDING, the state of the currently bound draw framebuffer object, and the state
of the images attached to that framebuffer object.
The actual sizes of the color, depth, or stencil bit planes can be obtained by
querying an attachment point using Get*FramebufferAttachmentParameteriv,
or querying the object attached to that point. If the value of FRAMEBUFFER_-
ATTACHMENT_OBJECT_TYPE at a particular attachment point isRENDERBUFFER,
the sizes may be determined by calling GetRenderbufferParameteriv as de-
scribed in section 9.2.6. If the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_-
TYPE at a particular attachment point isTEXTURE, the sizes may be determined by
calling GetTexParameter, as described in section 8.11.
9.5 Mapping between Pixel and Element in Attached Image
WhenDRAW_FRAMEBUFFER_BINDING is non-zero, an operation that writes to the
framebuffer modi?es the image attached to the selected logical buffer, and an oper-
ation that reads from the framebuffer reads from the image attached to the selected
logical buffer.
If the attached image is a renderbuffer image, then the window coordinates
OpenGL 4.6 (Core Pro?le) - February 2, 20199.6. CONVERSIONTOFRAMEBUFFER-ATTACHABLEIMAGECOMPONENTS335
(x ;y ) correspond to the value in the renderbuffer image at the same coordinates.
w w
If the attached image is a texture image, then the window coordinates (x ;y )
w w
correspond to the texel (i;j;k) from ?gure 8.3 as follows:
i =x
w
j =y
w
k =layer
layer is the value ofFRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER for the se-
lected logical buffer. For a two-dimensional texture,k andlayer are irrelevant; for
a one-dimensional texture,j,k, andlayer are irrelevant.
(x ;y ) corresponds to a border texel ifx ,y , orlayer is less than zero, or if
w w w w
x ,y , orlayer is greater than or equal to the width, height, or depth, respectively,
w w
of the texture image.
9.6 Conversion to Framebuffer-Attachable Image Components
When an enabled color value is written to the framebuffer while the draw frame-
buffer binding is non-zero, for each draw buffer the R, G, B, and A values are
converted to internal components as described in table 8.11, according to the ta-
ble row corresponding to the internal format of the framebuffer-attachable image
attached to the selected logical buffer, and the resulting internal components are
written to the image attached to logical buffer. The masking operations described
in section 17.4.2 are also effective.
9.7 Conversion to RGBA Values
When a color value is read while the read framebuffer binding is non-zero, or is
used as the source of a logical operation or for blending while the draw frame-
buffer binding is non-zero, components of that color taken from the framebuffer-
attachable image attached to the selected logical buffer are ?rst converted to R,
G, B, and A values according to table 15.1 and the internal format of the attached
image.
OpenGL 4.6 (Core Pro?le) - February 2, 20199.8. LAYEREDFRAMEBUFFERS 336
9.8 Layered Framebuffers
A framebuffer is considered to be layered if it is complete and all of its populated
attachments are layered. When rendering to a layered framebuffer, each fragment
generated by the GL is assigned a layer number. The layer number for a fragment
is zero if
 geometry shaders are disabled, or
 the current geometry shader does not statically assign a value to the built-in
output variablegl_Layer.
Otherwise, the layer for each point, line, or triangle emitted by the geometry
shader is taken from the gl_Layer output of one of the vertices of the primitive.
The vertex used is implementation-dependent. To get de?ned results, all vertices
of each primitive emitted should set the same value for gl_Layer. Since the
EndPrimitive built-in function starts a new output primitive, de?ned results can
be achieved ifEndPrimitive is called between two vertices emitted with differ-
ent layer numbers. A layer number written by a geometry shader has no effect if
the framebuffer is not layered.
When fragments are written to a layered framebuffer, the fragment’s layer num-
ber selects an image from the array of images at each attachment point to use for
the stencil test (see section 17.3.3), depth buffer test (see section 17.3.4), and for
blending and color buffer writes (see section 17.3.6). If the fragment’s layer num-
ber is negative, or greater than or equal to the minimum number of layers of any
attachment, the effects of the fragment on the framebuffer contents are unde?ned.
When the Clear or ClearBuffer* commands described in section 17.4.3 are
used to clear a layered framebuffer attachment, all layers of the attachment are
cleared.
When commands such as ReadPixels read from a layered framebuffer, the
image at layer zero of the selected attachment is always used to obtain pixel values.
When cube map texture levels are attached to a layered framebuffer, there are
six layers, numbered zero through ?ve. Each layer number corresponds to a cube
map face, as shown in table 9.3.
When cube map array texture levels are attached to a layered framebuffer, the
layer number corresponds to a layer-face. The layer-face can be translated into an
array layer and a cube map face by
 
layer
array layer =
6
face =layer mod 6
OpenGL 4.6 (Core Pro?le) - February 2, 20199.8. LAYEREDFRAMEBUFFERS 337
Layer Number Cube Map Face
0 TEXTURE_CUBE_MAP_POSITIVE_X
1 TEXTURE_CUBE_MAP_NEGATIVE_X
2 TEXTURE_CUBE_MAP_POSITIVE_Y
3 TEXTURE_CUBE_MAP_NEGATIVE_Y
4 TEXTURE_CUBE_MAP_POSITIVE_Z
5 TEXTURE_CUBE_MAP_NEGATIVE_Z
Table 9.3: Layer numbers for cube map texture faces. The layers are numbered in
the same sequence as the cube map face token values.
.
The face number corresponds to the cube map faces as shown in table 9.3.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 10
Vertex Specification and Drawing
Commands
Most geometric primitives are drawn by specifying a series of generic attribute
sets corresponding to vertices of a primitive using DrawArrays or one of the other
drawing commands de?ned in section 10.4. Points, lines, polygons, and a variety
of related geometric primitives (see section 10.1) can be drawn in this way.
The process of specifying attributes of a vertex and passing them to a shader
is referred to as transferring a vertex to the GL.
Vertex Shader Processing and Vertex State
Each vertex is speci?ed with one or more generic vertex attributes. Each at-
tribute is speci?ed with one, two, three, or four scalar values.
Generic vertex attributes can be accessed from within vertex shaders (see sec-
tion 11.1) and used to compute values for consumption by later processing stages.
Before vertex shader execution, the state required by a vertex is its generic
vertex attributes. Vertex shader execution processes vertices producing a homoge-
neous vertex position and any outputs explicitly written by the vertex shader.
Figure 10.1 shows the sequence of operations that builds a primitive (point, line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it is
clipped to a clip volume. This may modify the primitive by altering vertex coordi-
nates and vertex shader outputs. In the case of line and polygon primitives, clipping
may insert new vertices into the primitive. The vertices de?ning a primitive to be
rasterized have output variables associated with them.
338339
Coordinates
Point,
Point culling,
Vertex Line Segment, or
Shaded
Line Segment
Shader Triangle Rasterization
Vertices
or Triangle
Execution (Primitive)
clipping
Assembly
Varying
Outputs
Generic Primitive type
Vertex (from DrawArrays or
Attributes DrawElements mode)
Figure 10.1. Vertex processing and primitive assembly.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.1. PRIMITIVETYPES 340
10.1 Primitive Types
A sequence of vertices is passed to the GL using DrawArrays or one of the other
drawing commands de?ned in section 10.4. There is no limit to the number of
vertices that may be speci?ed, other than the size of the vertex arrays. The mode
parameter of these commands determines the type of primitives to be drawn using
the vertices. Primitive types and the corresponding mode parameters are summa-
rized below, together with any additional state required when assembling primitives
from multiple vertices.
10.1.1 Points
A series of individual points are speci?ed with modePOINTS. Each vertex de?nes
a separate point. No state is required for points, since each point is independent of
any previous and following points.
10.1.2 Line Strips
A series of one or more connected line segments are speci?ed with modeLINE_-
STRIP. In this case, the ?rst vertex speci?es the ?rst segment’s start point while
the second vertex speci?es the ?rst segment’s endpoint and the second segment’s
start point. In general, theith vertex (fori > 1) speci?es the beginning of theith
segment and the end of the i  1st. The last vertex speci?es the end of the last
segment. If only one vertex is speci?ed, then no primitive is generated.
The required state consists of the processed vertex produced from the last ver-
tex that was sent (so that a line segment can be generated from it to the current
vertex), and a boolean ?ag indicating if the current vertex is the ?rst vertex.
10.1.3 Line Loops
A line loop is speci?ed with mode LINE_LOOP. Loops are the same as line strips
except that a ?nal segment is added from the ?nal speci?ed vertex to the ?rst vertex.
The required state consists of the processed ?rst vertex, in addition to the state
required for line strips.
10.1.4 Separate Lines
Individual line segments, each de?ned by a pair of vertices, are speci?ed with mode
LINES. The ?rst two vertices passed de?ne the ?rst segment, with subsequent pairs
of vertices each de?ning one more segment. If the number of vertices passed is
odd, then the last vertex is ignored. The state required is the same as for line strips
OpenGL 4.6 (Core Pro?le) - February 2, 201910.1. PRIMITIVETYPES 341
4
2 2 2
3 6
4
4
5
5
1
1 3 5 1 3
(a) (b) (c)
Figure 10.2. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
numbers give the sequencing of the vertices in order within the vertex arrays. Note
that in (a) and (b) triangle edge ordering is determined by the ?rst triangle, while in
(c) the order of each triangle’s edges is independent of the other triangles.
but it is used differently: a processed vertex holding the ?rst vertex of the current
segment, and a boolean ?ag indicating whether the current vertex is odd or even (a
segment start or end).
10.1.5
This subsection is only de?ned in the compatibility pro?le.
10.1.6 Triangle Strips
A triangle strip is a series of triangles connected along shared edges, and is spec-
i?ed with mode TRIANGLE_STRIP. In this case, the ?rst three vertices de?ne the
?rst triangle (and their order is signi?cant). Each subsequent vertex de?nes a new
triangle using that point along with two vertices from the previous triangle. If fewer
than three vertices are speci?ed, no primitive is produced. See ?gure 10.2.
The required state consists of a ?ag indicating if the ?rst triangle has been
completed, two stored processed vertices (called vertex A and vertex B), and a
one bit pointer indicating which stored vertex will be replaced with the next vertex.
When a series of vertices are transferred to the GL, the pointer is initialized to point
to vertex A. Each successive vertex toggles the pointer. Therefore, the ?rst vertex
is stored as vertex A, the second stored as vertex B, the third stored as vertex A,
OpenGL 4.6 (Core Pro?le) - February 2, 201910.1. PRIMITIVETYPES 342
and so on. Any vertex after the second one sent forms a triangle from vertex A,
vertex B, and the current vertex (in that order).
10.1.7 Triangle Fans
A triangle fan is speci?ed with modeTRIANGLE_FAN, and is the same as a triangle
strip with one exception: each vertex after the ?rst always replaces vertex B of the
two stored vertices.
10.1.8 Separate Triangles
Separate triangles are speci?ed with mode TRIANGLES. In this case, the 3i + 1st,
3i + 2nd, and 3i + 3rd vertices (in that order) determine a triangle for eachi =
0; 1;:::;n  1, where there are 3n +k vertices drawn. k is either 0, 1, or 2; ifk
is not zero, the ?nalk vertices are ignored. For each triangle, vertex A is vertex
3i and vertex B is vertex 3i + 1. Otherwise, separate triangles are the same as a
triangle strip.
10.1.9
This subsection is only de?ned in the compatibility pro?le.
10.1.10
This subsection is only de?ned in the compatibility pro?le.
10.1.11 Lines with Adjacency
Lines with adjacency are speci?ed with mode LINES_ADJACENCY, and are inde-
pendent line segments where each endpoint has a corresponding adjacent vertex
that can be accessed by a geometry shader (section 11.3). If a geometry shader is
not active, the adjacent vertices are ignored.
A line segment is drawn from the 4i+2nd vertex to the 4i+3rd vertex for each
i = 0; 1;:::;n  1, where there are 4n +k vertices passed. k is either 0, 1, 2, or
3; ifk is not zero, the ?nalk vertices are ignored. For line segmenti, the 4i + 1st
and 4i + 4th vertices are considered adjacent to the 4i + 2nd and 4i + 3rd vertices,
respectively (see ?gure 10.3).
OpenGL 4.6 (Core Pro?le) - February 2, 201910.1. PRIMITIVETYPES 343
Figure 10.3. Lines with adjacency (a) and line strips with adjacency (b). The ver-
tices connected with solid lines belong to the main primitives; the vertices connected
by dashed lines are the adjacent vertices that may be used in a geometry shader.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.1. PRIMITIVETYPES 344
Figure 10.4. Triangles with adjacency. The vertices connected with solid lines
belong to the main primitive; the vertices connected by dashed lines are the adjacent
vertices that may be used in a geometry shader.
10.1.12 Line Strips with Adjacency
Line strips with adjacency are speci?ed with modeLINE_STRIP_ADJACENCY and
are similar to line strips, except that each line segment has a pair of adjacent ver-
tices that can be accessed by a geometry shader. If a geometry shader is not active,
the adjacent vertices are ignored.
A line segment is drawn from thei + 2nd vertex to thei + 3rd vertex for each
i = 0; 1;:::;n  1, where there aren + 3 vertices passed. If there are fewer than
four vertices, all vertices are ignored. For line segmenti, thei + 1st andi + 4th
vertex are considered adjacent to thei + 2nd andi + 3rd vertices, respectively (see
?gure 10.3).
10.1.13 Triangles with Adjacency
Triangles with adjacency are speci?ed with mode TRIANGLES_ADJACENCY, and
are similar to separate triangles except that each triangle edge has an adjacent ver-
tex that can be accessed by a geometry shader. If a geometry shader is not active,
the adjacent vertices are ignored.
The 6i + 1st, 6i + 3rd, and 6i + 5th vertices (in that order) determine a triangle
for eachi = 0; 1;:::;n  1, where there are 6n +k vertices passed. k is either
0, 1, 2, 3, 4, or 5; ifk is non-zero, the ?nalk vertices are ignored. For trianglei,
OpenGL 4.6 (Core Pro?le) - February 2, 201910.1. PRIMITIVETYPES 345
Figure 10.5. Triangle strips with adjacency. The vertices connected with solid lines
belong to the main primitives; the vertices connected by dashed lines are the adja-
cent vertices that may be used in a geometry shader.
thei + 2nd,i + 4th, andi + 6th vertices are considered adjacent to edges from the
i + 1st to thei + 3rd, from thei + 3rd to thei + 5th, and from thei + 5th to the
i + 1st vertices, respectively (see ?gure 10.4).
10.1.14 Triangle Strips with Adjacency
Triangle strips with adjacency are speci?ed with mode TRIANGLE_STRIP_-
ADJACENCY, and are similar to triangle strips except that each triangle edge has
an adjacent vertex that can be accessed by a geometry shader. If a geometry shader
is not active, the adjacent vertices are ignored.
In triangle strips with adjacency,n triangles are drawn where there are 2(n +
2) +k vertices passed. k is either 0 or 1; ifk is 1, the ?nal vertex is ignored. If
OpenGL 4.6 (Core Pro?le) - February 2, 201910.1. PRIMITIVETYPES 346
Primitive Vertices Adjacent Vertices
Primitive 1st 2nd 3rd 1/2 2/3 3/1
only (i = 0,n = 1) 1 3 5 2 6 4
?rst (i = 0) 1 3 5 2 7 4
middle (i odd) 2i + 3 2i + 1 2i + 5 2i  1 2i + 4 2i + 7
middle (i even) 2i + 1 2i + 3 2i + 5 2i  1 2i + 7 2i + 4
last (i =n  1,i odd) 2i + 3 2i + 1 2i + 5 2i  1 2i + 4 2i + 6
last (i =n  1,i even) 2i + 1 2i + 3 2i + 5 2i  1 2i + 6 2i + 4
Table 10.1: Triangles generated by triangle strips with adjacency. Each triangle
is drawn using the vertices whose numbers are in the 1st, 2nd, and 3rd columns
under primitive vertices, in that order. The vertices in the 1/2, 2/3, and 3/1 columns
under adjacent vertices are considered adjacent to the edges from the ?rst to the
second, from the second to the third, and from the third to the ?rst vertex of the
triangle, respectively. The six rows correspond to six cases: the ?rst and only
triangle (i = 0;n = 1), the ?rst triangle of several (i = 0;n > 0), “odd” middle
triangles (i = 1; 3; 5:::), “even” middle triangles (i = 2; 4; 6;:::), and special
cases for the last triangle, wheni is either even or odd. For the purposes of this
table, the ?rst vertex passed is numbered 1 and the ?rst triangle is numbered 0.
there are fewer than 6 vertices, the entire primitive is ignored. Table 10.1 describes
the vertices and order used to draw each triangle, and which vertices are considered
adjacent to each edge of the triangle (see ?gure 10.5).
10.1.15 Separate Patches
Separate patches are speci?ed with mode PATCHES. A patch is an ordered collec-
tion of vertices used for primitive tessellation (section 11.2). The vertices compris-
ing a patch have no implied geometric ordering. The vertices of a patch are used by
tessellation shaders and the ?xed-function tessellator to generate new point, line,
or triangle primitives.
Each patch in the series has a ?xed number of vertices, which is speci?ed by
calling
void PatchParameteri(enum pname,int value );
with pname set toPATCH_VERTICES.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.2. CURRENTVERTEXATTRIBUTEVALUES 347
Errors
AnINVALID_ENUM error is generated if pname is notPATCH_VERTICES.
An INVALID_VALUE error is generated if value is less than or equal to
zero, or greater than the implementation-dependent maximum patch size (the
value ofMAX_PATCH_VERTICES). The patch size is initially three vertices.
If the number of vertices in a patch is given byv, thevi + 1st throughvi +vth
vertices (in that order) determine a patch for eachi = 0; 1;:::n  1, where there
arevn +k vertices.k is in the range [0;v  1]; ifk is not zero, the ?nalk vertices
are ignored.
10.1.16 General Considerations For Polygon Primitives
Depending on the current state of the GL, a polygon primitive generated from a
drawing command with mode TRIANGLE_FAN,TRIANGLE_STRIP,TRIANGLES,
TRIANGLES_ADJACENCY, orTRIANGLE_STRIP_ADJACENCY may be rendered in
one of several ways, such as outlining its border or ?lling its interior. The or-
der of vertices in such a primitive is signi?cant in polygon rasterization (see sec-
tion 14.6.1) and fragment shading (see section 15.2.2).
10.1.17
This subsection is only de?ned in the compatibility pro?le.
10.2 Current Vertex Attribute Values
The commands in this section are used to specify current attribute values. These
values are used by drawing commands to de?ne the attributes transferred for a
vertex when a vertex array de?ning a required attribute is not enabled, as described
in section 10.3.
10.2.1 Current Generic Attributes
Vertex shaders (see section 11.1) access an array of 4-component generic vertex
attributes. The ?rst slot of this array is numbered zero, and the size of the array is
speci?ed by the value of the implementation-dependent constant MAX_VERTEX_-
ATTRIBS.
The current values of a generic shader attribute declared as a ?oating-point
scalar, vector, or matrix may be changed at any time by issuing one of the com-
mands
OpenGL 4.6 (Core Pro?le) - February 2, 201910.2. CURRENTVERTEXATTRIBUTEVALUES 348
void VertexAttribf1234gfsfdg(uint index,T values );
void VertexAttribf123gfsfdgv(uint index,const
T *values );
void VertexAttrib4fbsifd ub us uigv(uint index,const
T *values );
void VertexAttrib4Nub(uint index,ubyte x,ubyte y,
ubyte z,ubyte w );
void VertexAttrib4Nfbsi ub us uigv(uint index,const
T *values );
void VertexAttribIf1234gfi uig(uint index,T values );
void VertexAttribIf1234gfi uigv(uint index,const
T *values );
void VertexAttribI4fb s ub usgv(uint index,const
T *values );
void VertexAttribLf1234gd(uint index,const T values );
void VertexAttribLf1234gdv(uint index,const T *values );
void VertexAttribPf1234gui(uint index,enum
type,boolean normalized,uint value);
void VertexAttribPf1234guiv(uint index,enum
type,boolean normalized,const uint *value);
The VertexAttrib4N* commands specify ?xed-point values that are converted
to a normalized [0; 1] or [ 1; 1] range as described in equations 2.1 and 2.2, re-
spectively.
The VertexAttribI* commands specify signed or unsigned ?xed-point values
that are stored as signed or unsigned integers, respectively. Such values are referred
to as pure integers.
The VertexAttribL* commands specify double-precision values that will be
stored as double-precision values.
The VertexAttribP* commands specify up to four attribute component values
packed into a single natural type type as described in section 10.3.8. type must be
INT_2_10_10_10_REV, UNSIGNED_INT_2_10_10_10_REV, or UNSIGNED_-
INT_10F_11F_11F_REV, specifying signed, unsigned, or unsigned ?oating-point
data, respectively. The ?rst one (x), two (x;y), three (x;y;z), or four (x;y;z;w)
components of the packed data are consumed by VertexAttribP1ui, VertexAt-
tribP2ui, VertexAttribP3ui, and VertexAttribP4ui, respectively. If normalized
isTRUE, signed or unsigned components are converted to ?oating-point by normal-
izing to [ 1; 1] or [0; 1] respectively. If normalized isFALSE, signed and unsigned
components are directly cast to ?oating-point. For ?oating-point formats, normal-
ized is ignored. The number of components speci?ed must be no greater than the
OpenGL 4.6 (Core Pro?le) - February 2, 201910.2. CURRENTVERTEXATTRIBUTEVALUES 349
number of components in the packed type. For VertexAttribP*uiv, value contains
the address of a single uint containing the packed attribute components.
All other VertexAttrib* commands specify values that are converted directly
to the internal ?oating-point representation.
The resulting value(s) are loaded into the generic attribute at slot index, whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
sets the x coordinate to the provided single argument while setting y and z to 0 and
w to 1. Similarly, VertexAttrib2* commands set x and y to the speci?ed values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4* commands set all four coordinates.
The VertexAttrib* entry points may also be used to load shader attributes de-
clared as a ?oating-point matrix. Each column of a matrix takes up one generic
4-component attribute slot out of theMAX_VERTEX_ATTRIBS available slots. Ma-
trices are loaded into these slots in column major order. Matrix columns are loaded
in increasing slot numbers.
When values for a vertex shader attribute variable are sourced from a current
generic attribute value, the attribute must be speci?ed by a command compatible
with the data type of the variable. The values loaded into a shader attribute variable
bound to generic attribute index are unde?ned if the current value for attribute index
was not speci?ed by
 VertexAttrib[1234]* or VertexAttribP*, for single-precision ?oating-point
scalar, vector, and matrix types
 VertexAttribI[1234]i or VertexAttribI[1234]iv, for signed integer scalar
and vector types
 VertexAttribI[1234]ui or VertexAttribI[1234]uiv, for unsigned integer
scalar and vector types
 VertexAttribL*, for double-precision ?oating-point scalar and vector types.
Errors
An INVALID_VALUE error is generated for all VertexAttrib* commands
if index is greater than or equal to the value ofMAX_VERTEX_ATTRIBS.
An INVALID_ENUM error is generated by VertexAttribP4ui and Vertex-
AttribP4uiv if type isUNSIGNED_INT_10F_11F_11F_REV.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 350
10.2.2
This subsection is only de?ned in the compatibility pro?le.
10.2.3 Vertex Attribute Queries
Current generic vertex attribute values may be queried using the GetVertexAttrib*
commands as described in section 10.5.
10.2.4 Required State
The state required to support vertex speci?cation consists of the value of MAX_-
VERTEX_ATTRIBS four-component vectors to store generic vertex attributes.
The initial values for all generic vertex attributes are (0:0; 0:0; 0:0; 1:0).
10.3 Vertex Arrays
Vertex data are placed into arrays that are stored in the server’s address space
(described in section 10.3.9). Blocks of data in these arrays may then be used to
specify multiple geometric primitives through the execution of a single GL com-
mand.
All of the state required to represent the vertex arrays is stored in a vertex array
object.
10.3.1 Vertex Array Objects
The buffer objects that are to be used by the vertex stage of the GL are collected
together to form a vertex array object. All state related to the de?nition of data
used by the vertex processor is encapsulated in a vertex array object.
The name space for vertex array objects is the unsigned integers, with zero
reserved by the GL.
The command
void GenVertexArrays(sizei n,uint *arrays );
returns n previous unused vertex array object names in arrays. These names are
marked as used, for the purposes of GenVertexArrays only, but they acquire array
state only when they are ?rst bound.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 351
Errors
AnINVALID_VALUE error is generated if n is negative.
Vertex array objects are deleted by calling
void DeleteVertexArrays(sizei n,const uint *arrays );
arrays contains n names of vertex array objects to be deleted. Once a vertex array
object is deleted it has no contents and its name is again unused. If a vertex array
object that is currently bound is deleted, the binding for that object reverts to zero
and no vertex array object is bound. Unused names in arrays that have been
marked as used for the purposes of GenVertexArrays are marked as unused again.
Unused names in arrays are silently ignored, as is the value zero.
Errors
AnINVALID_VALUE error is generated if n is negative.
A vertex array object is created by binding a name returned by GenVertexAr-
rays with the command
void BindVertexArray(uint array );
array is the vertex array object name. The resulting vertex array object is a new
state vector, comprising all the state and with the same initial values listed in ta-
bles 23.3 and 23.4.
BindVertexArray may also be used to bind an existing vertex array object.
If the bind is successful no change is made to the state of the bound vertex array
object, and any previous binding is broken.
The currently bound vertex array object is used for all commands which modify
vertex array state, such as VertexAttribPointer and EnableVertexAttribArray;
all commands which draw from vertex arrays, such as DrawArrays and DrawEle-
ments; and all queries of vertex array state (see chapter 22).
Errors
AnINVALID_OPERATION error is generated if array is not zero or a name
returned from a previous call to GenVertexArrays, or if such a name has since
been deleted with DeleteVertexArrays.
An INVALID_OPERATION error is generated by any commands which
modify, draw from, or query vertex array state when no vertex array is bound.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 352
This occurs in the initial GL state, and may occur as a result of BindVertexAr-
ray or a side effect of DeleteVertexArrays.
Vertex array objects may also be created with the command
void CreateVertexArrays(sizei n,uint *arrays );
CreateVertexArrays returns n previously unused vertex array object names in
arrays, each representing a state vector comprising all the state and with the same
initial values listed in tables 23.3 and 23.4.
Errors
AnINVALID_VALUE error is generated if n is negative.
The command
boolean IsVertexArray(uint array );
returns TRUE if array is the name of a vertex array object. If array is zero, or a
non-zero value that is not the name of a vertex array object, IsVertexArray returns
FALSE. No error is generated if array is not a valid vertex array object name.
To bind a buffer object to the element array buffer bind point of a vertex array
object, use the command
void VertexArrayElementBuffer(uint vaobj,uint buffer );
vaobj is the name of the vertex array object, and buffer is zero or the name
of the buffer object. If buffer is zero, any existing element array buffer binding to
vaobj is removed.
Errors
An INVALID_OPERATION error is generated if vaobj is not the name of
an existing vertex array object.
An INVALID_OPERATION error is generated if buffer is not zero or the
name of an existing buffer object.
10.3.2 Specifying Arrays for Generic Vertex Attributes
To specify the organization of arrays storing generic vertex attributes of a vertex
array object, use the commands
The commands
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 353
void VertexAttribFormat(uint attribindex,int size,
enum type,boolean normalized,uint relativeoffset );
void VertexAttribIFormat(uint attribindex,int size,
enum type,uint relativeoffset );
void VertexAttribLFormat(uint attribindex,int size,
enum type,uint relativeoffset );
void VertexArrayAttribFormat(uint vaobj,
uint attribindex,int size,enum type,
boolean normalized,uint relativeoffset );
void VertexArrayAttribIFormat(uint vaobj,
uint attribindex,int size,enum type,uint relativeoffset );
void VertexArrayAttribLFormat(uint vaobj,
uint attribindex,int size,enum type,uint relativeoffset );
For VertexAttrib*Format, the vertex array object is that bound toVERTEX_-
ARRAY_BINDING. For VertexArrayAttrib*Format, vaobj is the name of the ver-
tex array object.
attribindex identi?es the generic vertex attribute array. size indicates the num-
ber of values per vertex that are stored in the array, as well as their component
ordering. type speci?es the data type of the values stored in the array.
Table 10.2 indicates the allowable values for size and type. A type of BYTE,
UNSIGNED_BYTE, SHORT, UNSIGNED_SHORT, INT, UNSIGNED_INT, FLOAT,
HALF_FLOAT, or DOUBLE indicates the corresponding GL data type shown in
table 8.2. A type of FIXED indicates the data type fixed. A type of
INT_2_10_10_10_REV orUNSIGNED_INT_2_10_10_10_REV indicates respec-
tively, four signed or unsigned elements packed into a single uint. A type
of UNSIGNED_INT_10F_11F_11F_REV indicates two unsigned 11-bit ?oating-
point elements and one unsigned 10-bit ?oating-point element packed into a sin-
gle uint. Encoding of the unsigned 11- and 10-bit ?oating-point values is de-
scribed in sections 2.3.4.3 and 2.3.4.4, respectively. The types INT_2_10_10_-
10_REV, UNSIGNED_INT_2_10_10_10_REV and UNSIGNED_INT_10F_11F_-
11F_REV all correspond to the term packed in table 10.2. The components are
packed as shown in table 8.8. packed is not a GL type, but indicates commands
accepting multiple components packed into a singleuint.
The “Integer Handling” column in table 10.2 indicates how integer and ?xed-
point data types are handled. “cast” means that they are converted to ?oating-point
directly. “normalize” means that they are converted to ?oating-point by normaliz-
ing to [0; 1] (for unsigned types) or [ 1; 1] (for signed types), as described in equa-
tions 2.1 and 2.2, respectively. “integer” means that they remain as integer values.
“?ag” means that either “cast” or “normalized” applies, depending on whether the
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 354
sizes and
Component Integer
Command Ordering Handling types
VertexAttribFormat 1, 2, 3, 4,BGRA ?ag byte, ubyte, short,
ushort, int, uint,
fixed, float, half,
double, packed
VertexAttribIFormat 1, 2, 3, 4 integer byte, ubyte, short,
ushort,int,uint
VertexAttribLFormat 1, 2, 3, 4 n/a double
Table 10.2: Vertex array sizes (values per vertex) and data types for generic vertex
attributes. See the body text for a full description of each column.
normalized ?ag to the command isTRUE orFALSE, respectively.
The normalized ?ag is ignored for ?oating-point data types, includingfixed,
float, half, double, and any packed types that have ?oating-point compo-
nents.
If size is BGRA, vertex array values are always normalized, irrespective of the
“normalize” table entry.
If type is UNSIGNED_INT_10F_11F_11F_REV, vertex array values are never
normalized, irrespective of the “normalize” table entry.
relativeoffset is a byte offset of the ?rst element relative to the start of the vertex
buffer binding this attribute fetches from.
Errors
AnINVALID_OPERATION error is generated by VertexAttrib*Format if
no vertex array object is currently bound (see section 10.3.1);
An INVALID_OPERATION error is generated by VertexArrayAt-
trib*Format if vaobj is not the name of an existing vertex array object.
An INVALID_VALUE error is generated if attribindex is greater than or
equal to the value ofMAX_VERTEX_ATTRIBS.
An INVALID_VALUE error is generated if size is not one of the values
shown in table 10.2 for the corresponding command.
An INVALID_ENUM error is generated if type is not one of the parameter
token names from table 8.2 corresponding to one of the allowed GL data types
for that command as shown in table 10.2.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 355
AnINVALID_ENUM error is generated by VertexAttribIFormat and Ver-
texAttribLFormat if type isUNSIGNED_INT_10F_11F_11F_REV.
An INVALID_OPERATION error is generated under any of the following
conditions:
 size isBGRA and type is notUNSIGNED_BYTE,INT_2_10_10_10_REV
orUNSIGNED_INT_2_10_10_10_REV;
 type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_-
REV, and size is neither 4 norBGRA;
 type isUNSIGNED_INT_10F_11F_11F_REV and size is not 3;
 size isBGRA and normalized isFALSE.
An INVALID_VALUE error is generated if relativeoffset is larger than the
value ofMAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
The source of data for a generic vertex attribute may be determined by attaching
a buffer object to a vertex array object with the commands
void BindVertexBuffer(uint bindingindex,uint buffer,
intptr offset,sizei stride );
void VertexArrayVertexBuffer(uint vaobj,
uint bindingindex,uint buffer,intptr offset,
sizei stride );
For BindVertexBuffer, the vertex array object is the currently bound vertex
array object. For VertexArrayVertexBuffer, vaobj is the name of the vertex
array object.
buffer is either zero or a name returned by GenBuffers or CreateBuffers.
If buffer is zero, any buffer object bound to bindingindex is detached.
If buffer is not the name of an existing buffer object, the GL ?rst creates a new
state vector, initialized with a zero-sized memory buffer and comprising all the
state and with the same initial values listed in table 6.2, just as for BindBuffer.
buffer is then attached to the speci?ed bindingindex of the vertex array object.
When sourcing vertex data from the buffer object, offset speci?es the offset in
basic machine units of the ?rst element in the vertex buffer. Pointers to theith and
(i + 1)st elements of the array differ by stride basic machine units, the pointer to
the (i + 1)st element being greater.
If the operation is successful no change is made to the state of the newly bound
buffer object, and any previous binding to bindingindex is broken.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 356
Errors
An INVALID_OPERATION error is generated by BindVertexBuffer if no
vertex array object is bound.
An INVALID_OPERATION error is generated by VertexArrayVer-
texBuffer if vaobj is not the name of an existing vertex array object.
AnINVALID_OPERATION error is generated if buffer is not zero or a name
returned from a previous call to GenBuffers or CreateBuffers, or if such a
name has since been deleted with DeleteBuffers.
An INVALID_VALUE error is generated if bindingindex is greater than or
equal to the value ofMAX_VERTEX_ATTRIB_BINDINGS.
AnINVALID_VALUE error is generated if stride or offset is negative, or if
stride is greater than the value ofMAX_VERTEX_ATTRIB_STRIDE.
The source of data for multiple vertex attributes may be determined by attach-
ing multiple existing buffer objects to a vertex array object with the commands
void BindVertexBuffers(uint ?rst,sizei count,const
uint *buffers,const intptr *offsets,const
sizei *strides );
void VertexArrayVertexBuffers(uint vaobj,uint ?rst,
sizei count,const uint *buffers,const
intptr *offsets,const sizei *strides );
For BindVertexBuffers, the vertex array object is the currently bound vertex
array object. For VertexArrayVertexBuffers, vaobj is the name of the vertex
array object.
count existing buffer objects are bound to vertex buffer binding points num-
bered ?rst throughfirst +count  1. If buffers is notNULL, it speci?es an array
of count values, each of which must be zero or the name of an existing buffer ob-
ject. offsets and strides specify arrays of count values indicating the offset of the
?rst element and stride between elements in each buffer, respectively. If buffers is
NULL, each affected vertex buffer binding point from ?rst throughfirst+count 1
will be reset to have no bound buffer object. In this case, the offsets and strides
associated with the binding points are set to default values, ignoring offsets and
strides.
BindVertexBuffers is equivalent (assuming no errors are generated) to:
for (i = 0; i < count; i++) f
if (buffers == NULL) f
BindVertexBuffer(first + i, 0, 0, 16);
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 357
g else f
BindVertexBuffer(first + i, buffers[i], offsets[i],
strides[i]);
g
g
except that buffers will not be created if they do not exist.
VertexArrayVertexBuffers is equivalent to the pseudocode above, but replac-
ing BindVertexBuffer(args) with VertexArrayVertexBuffers(vaobj, args).
The values speci?ed in buffers, offsets, and strides will be checked separately
for each vertex buffer binding point. When a value for a speci?c vertex buffer
binding point is invalid, the state for that binding point will be unchanged and an
error will be generated. However, state for other vertex buffer binding points will
still be changed if their corresponding values are valid.
Errors
AnINVALID_OPERATION error is generated by BindVertexBuffers if no
vertex array object is bound.
An INVALID_OPERATION error is generated by VertexArrayVer-
texBuffers if vaobj is not the name of an existing vertex array object.
An INVALID_OPERATION error is generated iffirst +count is greater
than the value ofMAX_VERTEX_ATTRIB_BINDINGS.
AnINVALID_VALUE error is generated if count is negative.
AnINVALID_OPERATION error is generated if any value in buffers is not
zero or the name of an existing buffer object (per binding).
AnINVALID_VALUE error is generated if any value in offsets or strides is
negative, or if any value in strides is greater than the value ofMAX_VERTEX_-
ATTRIB_STRIDE (per binding).
The association between a vertex attribute and the vertex buffer binding used
by that attribute is set by the command
void VertexAttribBinding(uint attribindex,
uint bindingindex );
void VertexArrayAttribBinding(uint vaobj, uint attribindex,
uint bindingindex );
For VertexAttribBinding, the vertex array object is the currently bound vertex
array object. For VertexArrayAttribBinding, vaobj is the name of the vertex
array object.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 358
Errors
An INVALID_OPERATION error is generated by VertexArrayAttrib-
Binding if vaobj is not the name of an existing vertex array object.
An INVALID_VALUE error is generated if attribindex is greater than or
equal to the value ofMAX_VERTEX_ATTRIBS.
An INVALID_VALUE error is generated if bindingindex is greater than or
equal to the value ofMAX_VERTEX_ATTRIB_BINDINGS.
An INVALID_OPERATION error is generated if no vertex array object is
bound.
The one, two, three, or four values in an array that correspond to a single vertex
comprise an array element. When size isBGRA, it indicates four values. The values
within each array element are stored sequentially in memory. However, if size is
BGRA, the ?rst, second, third, and fourth values of each array element are taken
from the third, second, ?rst, and fourth values in memory respectively.
The commands
void VertexAttribPointer(uint index,int size,enum type,
boolean normalized,sizei stride,const
void *pointer );
void VertexAttribIPointer(uint index,int size,enum type,
sizei stride,const void *pointer );
void VertexAttribLPointer(uint index,int size,enum type,
sizei stride,const void *pointer );
control vertex attribute state, a vertex buffer binding, and the mapping between
a vertex attribute and a vertex buffer binding. They are equivalent (assuming no
errors are generated) to:
VertexAttrib*Format(index, size, type, fnormalized, g, 0);
VertexAttribBinding(index, index);
if (stride != 0) f
effectiveStride = stride;
g else f
computeeffectiveStride based onsize andtype;
g
VERTEX_ATTRIB_ARRAY_STRIDE[index] = stride;
// This sets VERTEX_BINDING_STRIDE to effectiveStride
VERTEX_ATTRIB_ARRAY_POINTER[index] = pointer;
BindVertexBuffer(index, buffer bound toARRAY_BUFFER,
(char )pointer - (char )NULL, effectiveStride);
* *
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 359
If stride is speci?ed as zero, then array elements are stored sequentially.
Errors
AnINVALID_VALUE error is generated if stride is negative.
An INVALID_VALUE error is generated if stride is greater than the value
ofMAX_VERTEX_ATTRIB_STRIDE.
An INVALID_OPERATION error is generated if no buffer is bound to
ARRAY_BUFFER, and pointer is notNULL.
An INVALID_OPERATION error is generated if no vertex array object is
bound.
In addition, any of the errors de?ned by VertexAttrib*Format and Ver-
texAttribBinding may be generated if the parameters passed to those com-
mands in the equivalent code above would generate those errors.
An individual generic vertex attribute array in a vertex array object is enabled
with the commands
void EnableVertexAttribArray(uint index );
void EnableVertexArrayAttrib(uint vaobj,uint index );
and is disabled with the commands
void DisableVertexAttribArray(uint index );
void DisableVertexArrayAttrib(uint vaobj,uint index );
index identi?es the generic vertex attribute array to enable or disable. For En-
ableVertexAttribArray and DisableVertexAttribArray, the vertex array object
is the currently bound vertex array object. For EnableVertexArrayAttrib and
DisableVertexArrayAttrib, vaobj is the name of the vertex array object.
Errors
AnINVALID_OPERATION error is generated by EnableVertexAttribAr-
ray and DisableVertexAttribArray if no vertex array object is bound.
An INVALID_OPERATION error is generated by EnableVertexArrayAt-
trib and DisableVertexArrayAttrib if vaobj is not the name of an existing
vertex array object.
AnINVALID_VALUE error is generated if index is greater than or equal to
the value ofMAX_VERTEX_ATTRIBS.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 360
10.3.3
This subsection is only de?ned in the compatibility pro?le.
10.3.4 Vertex Attribute Divisors
Each generic vertex attribute has a corresponding divisor which modi?es the rate
at which attributes advance, which is useful when rendering multiple instances of
primitives in a single draw call. If the divisor is zero, the corresponding attributes
advance once per vertex. Otherwise, attributes advance once per divisor instances
of the set(s) of vertices being rendered. A generic attribute is referred to as in-
stanced if its corresponding divisor value is non-zero.
The divisor value for attributes taken from a vertex array object is set with the
commands
void VertexBindingDivisor(uint bindingindex,
uint divisor );
void VertexArrayBindingDivisor(uint vaobj,
uint bindingindex,uint divisor );
For VertexBindingDivisor, the vertex array object is the currently bound ver-
tex array object. For VertexArrayBindingDivisor, vaobj is the name of the vertex
array object. These commands set the divisor for the buffer bound to the speci?ed
bindingindex of the vertex array object to divisor.
Errors
AnINVALID_OPERATION error is generated by VertexBindingDivisor if
no vertex array object is bound.
AnINVALID_OPERATION error is generated by VertexArrayBindingDi-
visor if vaobj is not the name of an existing vertex array object.
An INVALID_VALUE error is generated if bindingindex is greater than or
equal to the value ofMAX_VERTEX_ATTRIB_BINDINGS.
The command
void VertexAttribDivisor(uint index,uint divisor );
is equivalent to (assuming no errors are generated):
VertexAttribBinding(index, index);
VertexBindingDivisor(index, divisor);
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 361
Errors
AnINVALID_VALUE error is generated if index is greater than or equal to
the value ofMAX_VERTEX_ATTRIBS.
An INVALID_OPERATION error is generated if no vertex array object is
bound.
10.3.5 Transferring Array Elements
When a vertex is transferred to the GL by DrawArrays, DrawElements, or the
other Draw* commands described below, each generic attribute is expanded to four
components. If size is one then thex component of the attribute is speci?ed by the
array; they,z, andw components are implicitly set to 0, 0, and 1, respectively. If
size is two then thex andy components of the attribute are speci?ed by the array;
thez andw components are implicitly set to 0 and 1, respectively. If size is three
thenx,y, andz are speci?ed, andw is implicitly set to 1. If size is four then all
components are speci?ed.
10.3.6 Primitive Restart
Primitive restart is enabled or disabled by calling one of the commands
void Enable(enum target );
and
void Disable(enum target );
with targetPRIMITIVE_RESTART. The command
void PrimitiveRestartIndex(uint index );
speci?es a vertex array element that is treated specially when primitive restart is
enabled. This value is called the primitive restart index.
When one of the *DrawElements* commands transfers a set of generic at-
tribute array elements to the GL, if the index within the vertex arrays correspond-
ing to that set is equal to the primitive restart index, then the GL does not process
those elements as a vertex. Instead, it is as if the drawing command ended with
the immediately preceding transfer, and another drawing command is immediately
started with the same parameters, but only transferring the immediately following
element through the end of the originally speci?ed elements.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 362
When one of the *BaseVertex drawing commands speci?ed in section 10.4 is
used, the primitive restart comparison occurs before the basevertex offset is added
to the array index.
Primitive restart can also be enabled or disabled with a target ofPRIMITIVE_-
RESTART_FIXED_INDEX. In this case, the primitive restart index is equal to
N
2   1, where N is 8, 16 or 32 if the type is UNSIGNED_BYTE, UNSIGNED_-
SHORT, or UNSIGNED_INT, respectively, and the index value speci?ed by Primi-
tiveRestartIndex is ignored.
If bothPRIMITIVE_RESTART andPRIMITIVE_RESTART_FIXED_INDEX are
enabled, the index value determined by PRIMITIVE_RESTART_FIXED_INDEX is
used.
Note that primitive restart is not performed for array elements transferred by
any drawing command not taking a type parameter, including all of the *Draw*
commands other than *DrawElements*.
Implementations are not required to support primitive restart for separate
patch primitives (primitive type PATCHES). Support can be queried by calling
GetBooleanv with pname PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED.
A value ofFALSE indicates that primitive restart is treated as disabled when draw-
ing patches, no matter the value of the enables. A value of TRUE indicates that
primitive restart behaves normally for patches.
10.3.7 Robust Buffer Access
Robust buffer access is enabled by creating a context with robust access enabled
through the window system binding APIs. When enabled, indices within the el-
ement array (see section 10.3.10) that reference vertex data that lies outside the
enabled attribute’s vertex buffer object result in reading zero. It is not possible to
read vertex data from outside the enabled vertex buffer objects or from another GL
context, and these accesses do not result in abnormal program termination.
10.3.8 Packed Vertex Data Formats
Vertex data formats UNSIGNED_INT_2_10_10_10_REV and INT_2_10_10_-
10_REV describe packed, 4 component formats stored in a single 32-bit word.
ForUNSIGNED_INT_2_10_10_10_REV, the ?rst (x), second (y), and third (z)
components are represented as 10-bit unsigned integer values and the fourth (w)
component is represented as a 2-bit unsigned integer value.
ForINT_2_10_10_10_REV, thex,y andz components are represented as 10-
bit signed two’s complement integer values and thew component is represented as
a 2-bit signed two’s complement integer value.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 363
The normalized value is used to indicate whether to normalize the data to [0; 1]
(for unsigned types) or [ 1; 1] (for signed types). During normalization, the con-
version rules speci?ed in equations 2.1 and 2.2 are followed.
Tables 10.3 and 10.4 describe how these components are laid out in a 32-bit
word.
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
w z y x
Table 10.3: Packed component layout for non-BGRA formats. Bit numbers are
indicated for each component.
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
w x y z
Table 10.4: Packed component layout forBGRA format. Bit numbers are indicated
for each component.
Vertex data format UNSIGNED_INT_10F_11F_11F_REV describes a packed,
3-component format that is stored in a single 32-bit word. The ?rst (x), and sec-
ond (y) components are represented as 11-bit unsigned ?oating-point values, and
the third (z) component is represented as a 10-bit unsigned ?oating-point value.
Table 10.5 describes how these components are laid out in a 32-bit word.
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
z y x
Table 10.5: Packed component layout for UNSIGNED_INT_10F_11F_11F_REV
format. Bit numbers are indicated for each component.
10.3.9 Vertex Arrays in Buffer Objects
Blocks of vertex array data are stored in buffer objects with the same format and
layout options described in section 10.3.
A buffer object binding point is added to the client state associated with each
vertex array index. The commands that specify the locations and organizations
OpenGL 4.6 (Core Pro?le) - February 2, 201910.3. VERTEXARRAYS 364
of vertex arrays copy the buffer object name that is bound to ARRAY_BUFFER to
the binding point corresponding to the vertex array index being speci?ed. For ex-
ample, the VertexAttribPointer command copies the value ofARRAY_BUFFER_-
BINDING (the queriable name of the buffer binding corresponding to the target
ARRAY_BUFFER) to the client state variableVERTEX_ATTRIB_ARRAY_BUFFER_-
BINDING for the speci?ed index.
The drawing commands using vertex arrays described in section 10.4 operate
as previously de?ned, where data for enabled generic attribute arrays are sourced
from buffer objects.
When an array is sourced from a buffer object for a vertex attribute, the
bindingindex set with VertexAttribBinding for that attribute indicates which ver-
tex buffer binding is used. The sum of the relativeoffset set for the attribute
with VertexAttrib*Format and the offset set for the vertex buffer with BindVer-
texBuffer is used as the offset in basic machine units of the ?rst element in that
buffer’s data store.
If any enabled array’s buffer binding is zero when DrawArrays or one of the
other drawing commands de?ned in section 10.4 is called, the result is unde?ned.
10.3.10 Array Indices in Buffer Objects
Blocks of array indices are stored in buffer objects in the formats described by the
type parameter of DrawElements (see section 10.4).
A buffer object is bound toELEMENT_ARRAY_BUFFER by calling BindBuffer
with target set to ELEMENT_ARRAY_BUFFER, and buffer set to the name of the
buffer object. If no corresponding buffer object exists, one is initialized as de?ned
in section 6.
DrawElements, DrawRangeElements, and DrawElementsInstanced source
their indices from the buffer object whose name is bound to ELEMENT_-
ARRAY_BUFFER, using their indices parameters as offsets into the buffer ob-
ject in the same fashion as described in section 10.3.9. DrawElementsBaseV-
ertex, DrawRangeElementsBaseVertex, and DrawElementsInstancedBaseVer-
tex also source their indices from that buffer object, adding the basevertex offset to
the appropriate vertex index as a ?nal step before indexing into the vertex buffer;
this does not affect the calculation of the base pointer for the index array. Finally,
MultiDrawElements and MultiDrawElementsBaseVertex also source their in-
dices from that buffer object, using its indices parameter as a pointer to an ar-
ray of pointers that represent offsets into the buffer object. If zero is bound to
ELEMENT_ARRAY_BUFFER, the result of these drawing commands is unde?ned.
In some cases performance will be optimized by storing indices and array data
in separate buffer objects, and by creating those buffer objects with the correspond-
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 365
Indirect Command Name Indirect Buffer target
DrawArraysIndirect DRAW_INDIRECT_BUFFER
DrawElementsIndirect DRAW_INDIRECT_BUFFER
MultiDrawArraysIndirect DRAW_INDIRECT_BUFFER
MultiDrawElementsIndirect DRAW_INDIRECT_BUFFER
DispatchComputeIndirect DISPATCH_INDIRECT_BUFFER
Table 10.6: Indirect commands and corresponding indirect buffer targets.
ing binding points.
10.3.11 Indirect Commands in Buffer Objects
Arguments to the indirect commands DrawArraysIndirect, DrawElementsIndi-
rect, MultiDrawArraysIndirect, and MultiDrawElementsIndirect (see sec-
tion 10.4), and to DispatchComputeIndirect (see section 19) are sourced from
the buffer object currently bound to the corresponding indirect buffer target (see
table 10.6), using the command’s indirect parameter as an offset into the buffer ob-
ject in the same fashion as described in section 10.3.9. Buffer objects are created
and/or bound to a target as described in section 6.1. Initially zero is bound to each
target.
Arguments are stored in buffer objects as structures (for *Draw*Indirect) or
arrays (for DispatchComputeIndirect) of tightly packed 32-bit integers.
10.4 Drawing Commands Using Vertex Arrays
The command
void DrawArraysOneInstance(enum mode,int ?rst,
sizei count,int instance,uint baseinstance );
does not exist in the GL, but is used to describe functionality in the rest of this sec-
tion. This command constructs a sequence of geometric primitives by successively
transferring elements for count vertices. Elements ?rst through rst + count  1
of each enabled non-instanced array are transferred to the GL. If count is zero, no
elements are transferred.
mode speci?es what kind of primitives are constructed, and must be one of the
primitive types de?ned in section 10.1.
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 366
If an enabled vertex attribute array is instanced (it has a non-zero divisor as
speci?ed by VertexAttribDivisor), the element index that is transferred to the GL,
for all vertices, is given by
 
instance
+baseinstance
divisor
If an array corresponding to an attribute required by a vertex shader is not
enabled, then the corresponding element is taken from the current attribute state
(see section 10.2).
If an array is enabled, the corresponding current vertex attribute value is unaf-
fected by the execution of DrawArraysOneInstance.
The index of any element transferred to the GL by DrawArraysOneInstance
is referred to as its vertex ID, and may be read by a vertex shader asgl_VertexID.
The vertex ID of theith element transferred is ?rst +i.
The value of instance may be read by a vertex shader asgl_InstanceID, as
described in section 11.1.3.9.
Errors
An INVALID_ENUM error is generated if mode is not one of the primitive
types de?ned in section 10.1.
Specifying first < 0 results in unde?ned behavior. Generating an
INVALID_VALUE error is recommended in this case.
AnINVALID_VALUE error is generated if count is negative.
An INVALID_OPERATION error is generated if no vertex array object is
bound (see section 10.3.1),
The command
void DrawArrays(enum mode,int ?rst,sizei count );
is equivalent to
DrawArraysOneInstance(mode, first, count, 0, 0);
The command
void DrawArraysInstancedBaseInstance(enum mode,
int ?rst,sizei count,sizei instancecount,
uint baseinstance );
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 367
behaves identically to DrawArrays except that instancecount instances of the
range of elements are executed and the value of instance advances for each it-
eration. Those attributes that have non-zero values for divisor, as speci?ed by
VertexAttribDivisor, advance once every divisor instances. Additionally, the ?rst
element within those instanced vertex attributes is speci?ed in baseinstance.
DrawArraysInstancedBaseInstance is equivalent (assuming no errors are
generated) to:
if (mode,count, orinstancecount is invalid)
generate appropriate error
else f
for (i = 0; i < instancecount; i++) f
DrawArraysOneInstance(mode, first, count, i,
baseinstance);
g
g
The command
void DrawArraysInstanced(enum mode,int ?rst,
sizei count,sizei instancecount );
is equivalent to
DrawArraysInstancedBaseInstance(mode, first, count, instancecount, 0);
The command
void DrawArraysIndirect(enum mode,const
void *indirect );
is equivalent to
typedef struct f
uint count;
uint instanceCount;
uint first;
uint baseInstance;
g DrawArraysIndirectCommand;
DrawArraysIndirectCommand cmd =
*
(DrawArraysIndirectCommand )indirect;
*
DrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count,
cmd->instanceCount, cmd->baseInstance);
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 368
Unlike DrawArraysInstanced, ?rst is unsigned and cannot cause an error.
Errors
An INVALID_OPERATION error is generated if zero is bound to DRAW_-
INDIRECT_BUFFER.
An INVALID_OPERATION error is generated if the command would
source data beyond the end of the buffer object.
AnINVALID_VALUE error is generated if indirect is not a multiple of the
size, in basic machine units, ofuint.
All elements of DrawArraysIndirectCommand are tightly packed 32-bit
values.
The command
void MultiDrawArrays(enum mode,const int *?rst,
const sizei *count,sizei drawcount );
behaves identically to DrawArrays except that drawcount separate ranges of el-
ements are speci?ed instead, all elements are treated as though they are not in-
stanced, and the value of instance remains zero. It is equivalent (assuming no
errors are generated) to:
if (mode ordrawcount is invalid)
generate appropriate error
else f
for (i = 0; i < drawcount; i++) f
if (count[i] > 0)
DrawArraysOneInstance(mode, first[i], count[i],
0, 0);
g
g
The index of the draw (i in the above pseudo-code) may be read by a vertex
shader asgl_DrawID, as described in section 11.1.3.9.
The command
void MultiDrawArraysIndirect(enum mode,const
void *indirect,sizei drawcount,sizei stride );
behaves identically to DrawArraysIndirect except that indirect is treated as an
array of drawcountDrawArraysIndirectCommand structures. indirect contains
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 369
the offset of the ?rst element of the array within the buffer currently bound to the
DRAW_INDIRECT buffer binding. stride speci?es the distance, in basic machine
units, between the elements of the array. If stride is zero, the array elements are
treated as tightly packed.
It is equivalent (assuming no errors are generated) to:
if (mode is invalid)
generate appropriate error
else f
const ubyte ptr = (const ubyte )indirect;
* *
for (i = 0; i < drawcount; i++) f
DrawArraysIndirect(mode, (DrawArraysIndirectCommand )ptr);
*
if (stride == 0) f
ptr += sizeof(DrawArraysIndirectCommand);
g else f
ptr += stride;
g
g
g
The index of the draw (i in the above pseudo-code) may be read by a vertex
shader asgl_DrawID, as described in section 11.1.3.9.
Errors
In addition to errors that would be generated by DrawArraysIndirect:
AnINVALID_VALUE error is generated if stride is negative.
AnINVALID_VALUE error is generated if stride is neither zero nor a mul-
tiple of four.
AnINVALID_VALUE error is generated if drawcount is not positive.
The command
void MultiDrawArraysIndirectCount(enum mode,const
void *indirect,intptr drawcount,intptr maxdrawcount,
sizei stride );
behaves similarly to MultiDrawArraysIndirect, except that drawcount de-
?nes an offset (in bytes) into the buffer object bound to the PARAMETER_BUFFER
binding point at which a single sizei typed value is stored, which contains the draw
count. maxdrawcount speci?es the maximum number of draws that are expected
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 370
to be stored in the buffer. If the value stored at drawcount into the buffer is greater
than maxdrawcount, the implementation stops processing draws after maxdraw-
count parameter sets. drawcount must be a multiple of four.
Errors
In addition to errors that would be generated by MultiDrawArraysIndi-
rect:
An INVALID_OPERATION error is generated if no buffer is bound to the
PARAMETER_BUFFER binding point.
An INVALID_VALUE error is generated if drawcount is not a multiple of
four.
AnINVALID_OPERATION error is generated if reading a sizei typed value
from the buffer bound to thePARAMETER_BUFFER target at the offset speci?ed
by drawcount would result in an out-of-bounds access.
The command
void DrawElementsOneInstance(enum mode,sizei count,
enum type,const void *indices,int instance,
int basevertex,uint baseinstance );
does not exist in the GL, but is used to describe functionality in the rest of this sec-
tion. This command constructs a sequence of geometric primitives by successively
transferring elements for count vertices to the GL.
The index of any element transferred to the GL by DrawElementsOneIn-
stance is referred to as its vertex ID, and may be read by a vertex shader as
gl_VertexID. The vertex ID of the ith element transferred is the sum of
basevertex and the value stored in the currently bound element array buffer at
offset indices + i. If the vertex ID is larger than the maximum value representable
by type, it should behave as if the calculation were upconverted to 32-bit unsigned
integers (with wrapping on over?ow conditions). Behavior of DrawElementsOne-
Instance is unde?ned if the vertex ID is negative for any element, and should be
handled as described in section 6.4.
type must be one of UNSIGNED_BYTE, UNSIGNED_SHORT, or UNSIGNED_-
INT, indicating that the index values are of GL type ubyte, ushort, or uint
respectively. mode speci?es what kind of primitives are constructed, and must be
one of the primitive types de?ned in section 10.1.
If an enabled vertex attribute array is instanced (it has a non-zero divisor as
speci?ed by VertexAttribDivisor), the element index that is transferred to the GL,
for all vertices, is given by
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 371
 
instance
+baseinstance
divisor
If an array corresponding to an attribute required by a vertex shader is not
enabled, then the corresponding element is taken from the current attribute state
(see section 10.2).
GL implementations do not restrict index values; any value representable in a
uint may be used. However, for compatibility with OpenGL ES implementations,
the maximum representable index vaue may be queried by calling GetInteger64v
32
with pnameMAX_ELEMENT_INDEX, and will return 2   1.
If an array is enabled, the corresponding current vertex attribute value is unaf-
fected by the execution of DrawElementsOneInstance.
The value of instance may be read by a vertex shader asgl_InstanceID, as
described in section 11.1.3.9.
Errors
An INVALID_ENUM error is generated if mode is not one of the primitive
types de?ned in section 10.1.
AnINVALID_VALUE error is generated if count is negative.
An INVALID_ENUM error is generated if type is not UNSIGNED_BYTE,
UNSIGNED_SHORT, orUNSIGNED_INT.
An INVALID_OPERATION error is generated if no vertex array object is
bound (see section 10.3.1),
The command
void DrawElements(enum mode,sizei count,enum type,
const void *indices );
behaves identically to DrawElementsOneInstance with instance, basevertex and
baseinstance set to zero; the effect of calling
DrawElements(mode, count, type, indices);
is equivalent to
if (mode,count ortype is invalid)
generate appropriate error
else
DrawElementsOneInstance(mode, count, type, indices,
0, 0, 0);
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 372
The command
void DrawElementsInstancedBaseInstance(enum mode,
sizei count,enum type,const void *indices,
sizei instancecount,uint baseinstance );
behaves identically to DrawElements except that instancecount instances of the
set of elements are executed and the value of instance advances between each set.
Instanced attributes are advanced as they do during execution of DrawArraysIn-
stancedBaseInstance, and baseinstance has the same effect. It is equivalent (as-
suming no errors are generated) to:
if (mode,count,type, orinstancecount is invalid)
generate appropriate error
else f
for (int i = 0; i < instancecount; i++) f
DrawElementsOneInstance(mode, count, type, indices,
i, 0, baseinstance);
g
g
The command
void DrawElementsInstanced(enum mode,sizei count,
enum type,const void *indices,sizei instancecount );
behaves identically to DrawElementsInstancedBaseInstance except that basein-
stance is zero. It is equivalent to
DrawElementsInstancedBaseInstance(mode, count, type, indices,
instancecount, 0, 0);
The command
void MultiDrawElements(enum mode,const
sizei *count,enum type,const void *const *indices,
sizei drawcount );
behaves identically to DrawElementsInstanced except that drawcount separate
sets of elements are speci?ed instead, all elements are treated as though they are
not instanced, and the value of instance remains zero. It is equivalent (assuming
no errors are generated) to:
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 373
if (mode,drawcount, ortype is invalid)
generate appropriate error
else f
for (int i = 0; i < drawcount; i++)
DrawElementsOneInstance(mode, count[i], type,
indices[i], 0, 0, 0);
g
The index of the draw (i in the above pseudo-code) may be read by a vertex
shader asgl_DrawID, as described in section 11.1.3.9.
The command
void DrawRangeElements(enum mode,uint start,
uint end,sizei count,enum type,const
void *indices );
is a restricted form of DrawElements. mode, count, type, and indices match the
corresponding arguments to DrawElements, with the additional constraint that all
index values identi?ed by indices must lie between start and end inclusive.
Implementations denote recommended maximum amounts of vertex and in-
dex data, which may be queried by calling GetIntegerv with pnames MAX_-
ELEMENTS_VERTICES and MAX_ELEMENTS_INDICES. If end  start + 1 is
greater than the value of MAX_ELEMENTS_VERTICES, or if count is greater than
the value ofMAX_ELEMENTS_INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start;end] be
referenced. However, the implementation may partially process unused vertices,
reducing performance from what could be achieved with an optimal index set.
Errors
AnINVALID_VALUE error is generated ifend<start.
AnINVALID_VALUE error is generated if count is negative.
Invalid mode, count, or type parameters generate the same errors as would
the corresponding call to DrawElements.
It is an error for index values (other than the primitive restart index,
when primitive restart is enabled) to lie outside the range [start;end], but
implementations are not required to check for this. Such indices will cause
implementation-dependent behavior.
The commands
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 374
void DrawElementsBaseVertex(enum mode,sizei count,
enum type,const void *indices,int basevertex );
void DrawRangeElementsBaseVertex(enum mode,
uint start,uint end,sizei count,enum type,const
void *indices,int basevertex );
void DrawElementsInstancedBaseVertex(enum mode,
sizei count,enum type,const void *indices,
sizei instancecount,int basevertex );
void DrawElementsInstancedBaseVertexBaseInstance(
enum mode,sizei count,enum type,const
void *indices,sizei instancecount,int basevertex,
uint baseinstance );
are equivalent to the commands with the same base name (without the BaseVertex
suf?x), except that the basevertex value passed to DrawElementsOneInstance is
the basevertex value of these commands, instead of zero.
For DrawRangeElementsBaseVertex, the values taken from indices for each
element transferred must be in the range [start;end], prior to adding the basev-
ertex offset. Index values lying outside this range are treated in the same way as
DrawRangeElements.
The command
void DrawElementsIndirect(enum mode,enum type,const
void *indirect );
is equivalent to
typedef struct f
uint count;
uint instanceCount;
uint firstIndex;
int baseVertex;
uint baseInstance;
g DrawElementsIndirectCommand;
if (no element array buffer is bound) f
generate appropriate error
g else f
DrawElementsIndirectCommand cmd =
*
(DrawElementsIndirectCommand )indirect;
*
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 375
DrawElementsInstancedBaseVertexBaseInstance(mode,
cmd->count, type,
cmd->firstIndex size-of-type,
*
cmd->instanceCount, cmd->baseVertex,
cmd->baseInstance);
g
Errors
AnINVALID_OPERATION error is generated if zero is bound toDRAW_-
INDIRECT_BUFFER, or if no element array buffer is bound.
An INVALID_OPERATION error is generated if the command would
source data beyond the end of the buffer object.
AnINVALID_VALUE error is generated if indirect is not a multiple of the
size, in basic machine units, ofuint.
All elements ofDrawElementsIndirectCommand are tightly packed.
The command
void MultiDrawElementsIndirect(enum mode,enum type,
const void *indirect,sizei drawcount,sizei stride );
behaves identically to DrawElementsIndirect except that indirect is treated as an
array of drawcount DrawElementsIndirectCommand structures. indirect con-
tains the offset of the ?rst element of the array within the buffer currently bound
to the DRAW_INDIRECT buffer binding. stride speci?es the distance, in basic ma-
chine units, between the elements of the array. If stride is zero, the array elements
are treated as tightly packed.
It is equivalent (assuming no errors are generated) to:
if (mode ortype is invalid)
generate appropriate error
else f
const ubyte ptr = (const ubyte )indirect;
* *
for (i = 0; i < drawcount; i++) f
DrawElementsIndirect(mode, type,
(DrawElementsIndirectCommand )ptr);
*
if (stride == 0) f
ptr += sizeof(DrawElementsIndirectCommand);
OpenGL 4.6 (Core Pro?le) - February 2, 201910.4. DRAWINGCOMMANDSUSINGVERTEXARRAYS 376
g else f
ptr += stride;
g
g
g
The index of the draw (i in the above pseudo-code) may be read by a vertex
shader asgl_DrawID, as described in section 11.1.3.9.
Errors
In addition to errors that would be generated by DrawElementsIndirect:
AnINVALID_VALUE error is generated if stride is negative.
AnINVALID_VALUE error is generated if stride is neither zero nor a mul-
tiple of four.
AnINVALID_VALUE error is generated if drawcount is not positive.
The command
void MultiDrawElementsIndirectCount(enum mode,
enum type,const void *indirect,intptr drawcount,
sizei maxdrawcount,sizei stride );
behaves similarly to MultiDrawElementsIndirect, except that drawcount de-
?nes an offset (in bytes) into the buffer object bound to the PARAMETER_BUFFER
binding point at which a single sizei typed value is stored, which contains the draw
count. maxdrawcount speci?es the maximum number of draws that are expected
to be stored in the buffer. If the value stored at drawcount into the buffer is greater
than maxdrawcount, the implementation stops processing draws after maxdraw-
count parameter sets. drawcount must be a multiple of four.
Errors
In addition to errors that would be generated by MultiDrawEle-
mentsIndirect:
An INVALID_OPERATION error is generated if no buffer is bound to the
PARAMETER_BUFFER binding point.
An INVALID_VALUE error is generated if drawcount is not a multiple of
four.
AnINVALID_VALUE error is generated if maxdrawcount is negative.
AnINVALID_OPERATION error is generated if reading a sizei typed value
OpenGL 4.6 (Core Pro?le) - February 2, 201910.5. VERTEXARRAYANDVERTEXARRAYOBJECTQUERIES 377
from the buffer bound to thePARAMETER_BUFFER target at the offset speci?ed
by drawcount would result in an out-of-bounds access.
The command
void MultiDrawElementsBaseVertex(enum mode,const
sizei *count,enum type,const void *const *indices,
sizei drawcount,const int *basevertex );
behaves identically to DrawElementsBaseVertex, except that drawcount separate
lists of elements are speci?ed instead. It is equivalent (assuming no errors are
generated) to:
if (mode ordrawcount is invalid)
generate appropriate error
else f
for (int i = 0; i < drawcount; i++)
if (count[i] > 0)
DrawElementsBaseVertex(mode, count[i], type,
indices[i], basevertex[i]);
g
The index of the draw (i in the above pseudo-code) may be read by a vertex
shader asgl_DrawID, as described in section 11.1.3.9.
Errors
In addition to errors that would be generated by DrawElementsBaseVer-
tex:
AnINVALID_VALUE error is generated if drawcount is negative.
10.4.1
This subsection is only de?ned in the compatibility pro?le.
10.5 Vertex Array and Vertex Array Object Queries
To query parameters of a vertex array object, use the command
void GetVertexArrayiv(uint vaobj,enum pname,
int *param );
OpenGL 4.6 (Core Pro?le) - February 2, 201910.5. VERTEXARRAYANDVERTEXARRAYOBJECTQUERIES 378
vaobj is the name of the vertex array object. The value of parameter pname of
vaobj is returned in param. pname must beELEMENT_ARRAY_BUFFER_BINDING.
Errors
An INVALID_OPERATION error is generated if vaobj is not the name of
an existing vertex array object.
AnINVALID_ENUM error is generated if pname is notELEMENT_ARRAY_-
BUFFER_BINDING.
To query parameters of an attribute of a vertex array object, use the commands
void GetVertexArrayIndexediv(uint vaobj,uint index,
enum pname,int *param );
void GetVertexArrayIndexed64iv(uint vaobj,uint index,
enum pname,int64 *param );
vaobj is the name of the vertex array object. The value of parameter pname
for attribute index of vaobj is returned in param.
For GetVertexArrayIndexediv, pname must be one of VERTEX_ATTRIB_-
ARRAY_ENABLED, VERTEX_ATTRIB_ARRAY_SIZE, VERTEX_ATTRIB_-
ARRAY_STRIDE, VERTEX_ATTRIB_ARRAY_TYPE, VERTEX_ATTRIB_ARRAY_-
NORMALIZED, VERTEX_ATTRIB_ARRAY_INTEGER, VERTEX_ATTRIB_ARRAY_-
LONG, VERTEX_ATTRIB_ARRAY_DIVISOR, or VERTEX_ATTRIB_RELATIVE_-
OFFSET.
For GetVertexArrayIndexed64iv, pname must be VERTEX_BINDING_-
OFFSET.
Errors
An INVALID_OPERATION error is generated if vaobj is not the name of
an existing vertex array object.
AnINVALID_VALUE error is generated if index is greater than or equal to
the value ofMAX_VERTEX_ATTRIBS.
An INVALID_ENUM error is generated if pname is not one of the valid
values listed above for the corresponding command.
Queries of vertex array state variables are quali?ed by the value ofVERTEX_-
ARRAY_BINDING to determine which vertex array object is queried. Tables 23.3
and 23.4 de?ne the set of state stored in a vertex array object.
To query parameters of an attribute of the currently bound vertex array object,
or current attribute values, use the commands
OpenGL 4.6 (Core Pro?le) - February 2, 201910.5. VERTEXARRAYANDVERTEXARRAYOBJECTQUERIES 379
void GetVertexAttribdv(uint index,enum pname,
double *params );
void GetVertexAttribfv(uint index,enum pname,
float *params );
void GetVertexAttribiv(uint index,enum pname,
int *params );
void GetVertexAttribIiv(uint index,enum pname,
int *params );
void GetVertexAttribIuiv(uint index,enum pname,
uint *params );
void GetVertexAttribLdv(uint index,enum pname,
double *params );
The value of parameter pname for the attribute numbered index of the currently
bound vertex array object is returned in params.
pname must be one of VERTEX_ATTRIB_ARRAY_-
BUFFER_BINDING, VERTEX_ATTRIB_ARRAY_ENABLED, VERTEX_ATTRIB_-
ARRAY_SIZE, VERTEX_ATTRIB_ARRAY_STRIDE, VERTEX_ATTRIB_ARRAY_-
TYPE, VERTEX_ATTRIB_ARRAY_NORMALIZED, VERTEX_ATTRIB_-
ARRAY_INTEGER, VERTEX_ATTRIB_ARRAY_LONG, VERTEX_ATTRIB_ARRAY_-
DIVISOR, VERTEX_ATTRIB_BINDING, VERTEX_ATTRIB_RELATIVE_OFFSET,
or CURRENT_VERTEX_ATTRIB. Note that all the queries except CURRENT_-
VERTEX_ATTRIB return values stored in the currently bound vertex array object
(the value ofVERTEX_ARRAY_BINDING).
Queries of VERTEX_ATTRIB_ARRAY_BUFFER_BINDING and VERTEX_-
ATTRIB_ARRAY_DIVISOR map the requested attribute index to a binding index
via theVERTEX_ATTRIB_BINDING state, and then return the value ofVERTEX_-
BINDING_BUFFER orVERTEX_BINDING_DIVISOR, respectively.
All but CURRENT_VERTEX_ATTRIB return information about generic vertex
attribute arrays. The enable state of a generic vertex attribute array is set by the
command EnableVertexAttribArray and cleared by DisableVertexAttribArray.
The size, stride, type, normalized ?ag, and unconverted integer ?ag are set by the
commands VertexAttribPointer and VertexAttribIPointer. The normalized ?ag
is always set to FALSE by VertexAttribIPointer. The unconverted integer ?ag is
always set toFALSE by VertexAttribPointer andTRUE by VertexAttribIPointer.
The query CURRENT_VERTEX_ATTRIB returns the current value for the
generic attribute index. GetVertexAttribdv and GetVertexAttribfv read and re-
turn the current attribute values as four ?oating-point values; GetVertexAttribiv
reads them as ?oating-point values and converts them to four integer values;
GetVertexAttribIiv reads and returns them as four signed integers; GetVertex-
OpenGL 4.6 (Core Pro?le) - February 2, 201910.6. REQUIREDSTATE 380
AttribIuiv reads and returns them as four unsigned integers; and GetVertexAttri-
bLdv reads and returns them as four double-precision ?oating-point values. The
results of the query are unde?ned if the current attribute values are read using one
data type but were speci?ed using a different one.
Errors
AnINVALID_VALUE error is generated if index is greater than or equal to
the value ofMAX_VERTEX_ATTRIBS.
An INVALID_OPERATION error is generated if no vertex array object is
bound (see section 10.3.1).
An INVALID_ENUM error is generated if pname is not one of the values
listed above.
The command
void GetVertexAttribPointerv(uint index,enum pname,
const void **pointer );
obtains the pointer named pname for the vertex attribute numbered index and places
the information in the array pointer. pname must be VERTEX_ATTRIB_ARRAY_-
POINTER. The value returned is queried from the currently bound vertex array
object.
Errors
AnINVALID_VALUE error is generated if index is greater than or equal to
the value ofMAX_VERTEX_ATTRIBS.
An INVALID_OPERATION error is generated if no vertex array object is
bound (see section 10.3.1).
Finally, the buffer bound toELEMENT_ARRAY_BUFFER may be queried by call-
ing GetIntegerv with pnameELEMENT_ARRAY_BUFFER_BINDING.
10.6 Required State
Let the number of supported generic vertex attributes (the value ofMAX_VERTEX_-
ATTRIBS) ben. Let the number of supported generic vertex attribute bindings (the
value ofMAX_VERTEX_ATTRIB_BINDINGS bek.
Then the state required to implement vertex arrays consists ofn boolean val-
ues,n memory pointers,n integer stride values,n symbolic constants representing
OpenGL 4.6 (Core Pro?le) - February 2, 201910.7. 381
array types, n integers representing values per element, n boolean values indi-
cating normalization,n boolean values indicating whether the attribute values are
pure integers,n boolean values indicating whether the attribute values are double
precision, three integers for the current array buffer, current element array buffer,
and current vertex array bindings, n unsigned integer vertex attribute binding in-
dices, n unsigned integer relative offsets, k integers representing vertex attribute
divisors, k unsigned integer vertex buffer bindings, k 64-bit integer vertex bind-
ing offsets, k integer vertex binding strides, an unsigned integer representing the
primitive restart index, and two booleans representing the enable state of primitive
restart and primitive restart with a ?xed index.
In the initial state, the boolean values are eachFALSE, the memory pointers are
each NULL, the strides are each zero, the array types are each FLOAT, the integers
representing values per element are each four, the normalized and pure integer
?ags are eachFALSE, the divisors are each zero, the binding indices arei for each
attribute i, the relative offsets are each zero, the vertex binding offsets are each
zero, the vertex binding strides are each 16, the restart index is zero, and the restart
enables are bothFALSE.
10.7
This section is only de?ned in the compatibility pro?le.
10.8
This section is only de?ned in the compatibility pro?le.
10.9 Conditional Rendering
Conditional rendering can be used to discard rendering commands based on the
result of an occlusion query. Conditional rendering is started and stopped using the
commands
void BeginConditionalRender(uint id,enum mode );
void EndConditionalRender(void );
id speci?es the name of an occlusion query object whose results are used to
determine if the rendering commands are discarded. If the result (SAMPLES_-
PASSED) of the query is zero, or if the result (ANY_SAMPLES_PASSED,
ANY_SAMPLES_PASSED_CONSERVATIVE, TRANSFORM_FEEDBACK_OVERFLOW,
OpenGL 4.6 (Core Pro?le) - February 2, 201910.9. CONDITIONALRENDERING 382
or TRANSFORM_FEEDBACK_STREAM_OVERFLOW) is FALSE, all rendering com-
mands described in section 2.4 are discarded and have no effect when issued be-
tween BeginConditionalRender and the corresponding EndConditionalRender.
The effect of commands setting current vertex state, such as VertexAttrib,
are unde?ned. If the result (SAMPLES_PASSED) of the query is non-zero, or
if the result (ANY_SAMPLES_PASSED, ANY_SAMPLES_PASSED_CONSERVATIVE,
TRANSFORM_FEEDBACK_OVERFLOW, or
TRANSFORM_FEEDBACK_STREAM_OVERFLOW) is TRUE, such commands are not
discarded.
mode speci?es how BeginConditionalRender interprets the results of the oc-
clusion query given by id.
If mode is QUERY_WAIT, the GL waits for the results of the query to be avail-
able and then uses the results to determine if subsquent rendering commands are
discarded.
If mode is QUERY_NO_WAIT, the GL may choose to unconditionally execute
the subsequent rendering commands without waiting for the query to complete.
If mode is QUERY_BY_REGION_WAIT, the GL will also wait for occlusion
query results and discard rendering commands if the result of the occlusion query is
zero. If the query result is non-zero, subsequent rendering commands are executed,
but the GL may discard the results of the commands for any region of the frame-
buffer that did not contribute to the sample count in the speci?ed occlusion query.
Any such discarding is done in an implementation-dependent manner, but the ren-
dering command results may not be discarded for any samples that contributed to
the occlusion query sample count.
If mode isQUERY_BY_REGION_NO_WAIT, the GL operates as inQUERY_BY_-
REGION_WAIT, but may choose to unconditionally execute the subsequent render-
ing commands without waiting for the query to complete.
If mode isQUERY_WAIT_INVERTED,QUERY_NO_WAIT_INVERTED,QUERY_-
BY_REGION_WAIT_INVERTED, or QUERY_BY_REGION_NO_WAIT_INVERTED
then the condition used to determine whether or not to render subsequent drawing
commands is negated with respect to QUERY_WAIT, QUERY_NO_WAIT, QUERY_-
BY_REGION_WAIT, orQUERY_BY_REGION_NO_WAIT, respectively.
If mode isQUERY_NO_WAIT_INVERTED orQUERY_BY_REGION_NO_WAIT_-
INVERTED, the GL may choose to unconditionally execute subsequent rendering
commands without waiting for the query to complete.
Errors
An INVALID_OPERATION error is generated by BeginConditionalRen-
OpenGL 4.6 (Core Pro?le) - February 2, 201910.10. SUBMISSIONQUERIES 383
der if called while conditional rendering is in progress.
An INVALID_VALUE error is generated by BeginConditionalRender if
id is not the name of an existing query object.
An INVALID_OPERATION error is generated by BeginConditionalRen-
der if id is the name of a query object with a target other than SAMPLES_-
PASSED, ANY_SAMPLES_PASSED, ANY_SAMPLES_PASSED_-
CONSERVATIVE, TRANSFORM_FEEDBACK_OVERFLOW, or TRANSFORM_-
FEEDBACK_STREAM_OVERFLOW; or if id is the name of a query currently in
progress.
An INVALID_ENUM error is generated by BeginConditionalRender
if mode is not QUERY_WAIT, QUERY_NO_WAIT, QUERY_BY_REGION_-
WAIT, QUERY_BY_REGION_NO_WAIT, QUERY_WAIT_INVERTED, QUERY_-
NO_WAIT_INVERTED, QUERY_BY_REGION_WAIT_INVERTED, or QUERY_-
BY_REGION_NO_WAIT_INVERTED.
AnINVALID_OPERATION error is generated by EndConditionalRender
if called while conditional rendering is not in progress.
10.10 Submission Queries
Submission queries use query objects to track the number of vertices and primitives
that are issued to the GL using draw commands.
When BeginQuery is called with a target ofVERTICES_SUBMITTED, the sub-
mitted vertices count maintained by the GL is set to zero. When a vertices submit-
ted query is active, the submitted vertices count is incremented every time a vertex
is transferred to the GL (see sections 10.3.5 and 10.4). In the case of primitive types
with adjacency information (see sections 10.1.11, 10.1.12, 10.1.13, and 10.1.14),
implementations may or may not count vertices not belonging to the main primi-
tive. In the case of line loop primitives (see section 10.1.3), implementations are
allowed to count the ?rst vertex twice for the purposes ofVERTICES_SUBMITTED
queries. Additionally, vertices corresponding to incomplete primitives may or may
not be counted.
When BeginQuery is called with a target of PRIMITIVES_SUBMITTED, the
submitted primitives count maintained by the GL is set to zero. When a primitives
submitted query is active, the submitted primitives count is incremented every time
a point, line, triangle, or patch primitive is transferred to the GL (see sections 10.1,
10.3.5, and 10.3.6). Restarting a primitive topology using the primitive restart
index has no effect on the issued primitives count. Incomplete primitives may or
may not be counted.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 11
Programmable Vertex Processing
When the program object currently in use for the vertex stage (see section 7.3)
includes a vertex shader, its shader is considered active and is used to process
vertices transferred to the GL (see section 11.1). Vertices may be further processed
by tessellation and geometry shaders (see sections 11.2 and 11.3). The resulting
transformed vertices are then processed as described in chapter 13.
If the current vertex stage program object has no vertex shader, or no program
object is current for the vertex stage, the results of programmable vertex processing
are unde?ned.
11.1 Vertex Shaders
Vertex shaders describe the operations that occur on vertex values and their associ-
ated data. When the program object currently in use for the vertex stage includes a
vertex shader, its vertex shader is considered active and is used to process vertices.
Vertex attributes are per-vertex values available to vertex shaders, and are spec-
i?ed as described in section 10.2.
11.1.1 Vertex Attributes
Vertex shaders can de?ne named attribute variables, which are bound to generic
vertex attributes transferred by drawing commands. This binding can be speci-
?ed in the shader text using thelocation quali?er, in a SPIR-V shader using the
Location decoration, by the application before the program is linked, or automat-
ically assigned by the GL when the program is linked.
When an attribute variable declared using one of the scalar or vector data types
enumerated in table 11.3 is bound to a generic attribute index i, its value(s) are
38411.1. VERTEXSHADERS 385
Data type component Components
layout quali?er used
scalar 0 or unspeci?ed x
scalar 1 y
scalar 2 z
scalar 3 w
two-component vector 0 or unspeci?ed (x;y)
two-component vector 1 (y;z)
two-component vector 2 (z;w)
three-component vector 0 or unspeci?ed (x;y;z)
three-component vector 1 (y;z;w)
four-component vector 0 or unspeci?ed (x;y;z;w)
Table 11.1: Generic attribute components accessed by attribute variables.
taken from the components of generic attributei. The generic attribute components
used depend on the type of the variable and value of the component layout
quali?er (if any) speci?ed in the variable declaration, as identi?ed in table 11.1.
An attribute variable declared using a combination of data type and component
layout quali?er not listed in this table is not supported and will result in shader
compilation errors.
When an attribute variable declared using a matrix type is bound to a generic
attribute indexi, its values are taken from consecutive generic attributes beginning
with generic attributei. Such matrices are treated as an array of column vectors
with values taken from the generic attributes identi?ed in table 11.2. Individual col-
umn vectors are taken from generic attribute components according to table 11.1,
using the vector type from table 11.2.
When an attribute variable declared using an array type is bound to generic
attribute indexi, the active array elements are assigned to consecutive generic at-
tributes beginning with generic attributei. The number of attributes and compo-
nents assigned to each element are determined according to the data type of array
elements andcomponentlayout quali?er (if any) speci?ed in the declaration of
the array, as described above.
For the 64-bit double precision types listed in table 11.3, no default attribute
values are provided if the values of the vertex attribute variable are speci?ed with
fewer components than required for the attribute variable. For example, the fourth
component of a variable of type dvec4 will be unde?ned if speci?ed using Ver-
texAttribL3dv, or using a vertex array speci?ed with VertexAttribLPointer and
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 386
Data type Column vector type Generic
layout quali?er attributes used
mat2,dmat2 two-component vector i,i + 1
mat2x3,dmat2x3 three-component vector i,i + 1
mat2x4,dmat2x4 four-component vector i,i + 1
mat3x2,dmat3x2 two-component vector i,i + 1,i + 2
mat3,dmat3 three-component vector i,i + 1,i + 2
mat3x4,dmat3x4 four-component vector i,i + 1,i + 2
mat4x2,dmat4x2 two-component vector i,i + 1,i + 2,i + 3
mat4x3,dmat4x3 three-component vector i,i + 1,i + 2,i + 3
mat4,dmat4 four-component vector i,i + 1,i + 2,i + 3
Table 11.2: Generic attributes and vector types used by column vectors of matrix
variables bound to generic attribute indexi.
Data type Command
int VertexAttribI1i
ivec2 VertexAttribI2i
ivec3 VertexAttribI3i
ivec4 VertexAttribI4i
uint VertexAttribI1ui
uvec2 VertexAttribI2ui
uvec3 VertexAttribI3ui
uvec4 VertexAttribI4ui
float VertexAttrib1*
vec2 VertexAttrib2*
vec3 VertexAttrib3*
vec4 VertexAttrib4*
double VertexAttribL1d
dvec2 VertexAttribL2d
dvec3 VertexAttribL3d
dvec4 VertexAttribL4d
Table 11.3: Scalar and vector vertex attribute types and VertexAttrib* commands
used to set the values of the corresponding generic attribute.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 387
a size of three.
The command
void BindAttribLocation(uint program,uint index,const
char *name );
speci?es that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
was bound previously, its assigned binding is replaced with index, but the new
binding becomes effective only when the program is next linked. name must be
a null-terminated string. BindAttribLocation has no effect until the program is
linked. In particular, it doesn’t modify the bindings of active attribute variables in
a program that has already been linked.
When a program is linked, any active attributes without a binding speci?ed ei-
ther through BindAttribLocation or explicitly set within the shader text or SPIR-V
binary will automatically be bound to vertex attributes by the GL. Such bindings
may be queried using the command GetAttribLocation. LinkProgram will fail
if the assigned binding of an active attribute variable would cause the GL to ref-
erence a non-existent generic attribute (one greater than or equal to the value of
MAX_VERTEX_ATTRIBS). LinkProgram will fail if the attribute bindings speci?ed
either by BindAttribLocation or explicitly set within the shader text or SPIR-V
binary do not leave enough space to assign a location for an active matrix attribute
or an active attribute array, both of which require multiple contiguous generic at-
tributes. If an active attribute has a binding explicitly set within the shader text
or SPIR-V binary and a different binding assigned by BindAttribLocation, the
assignment in the shader text or SPIR-V binary is used.
BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name to an index,
including a name that is never used as an attribute in any vertex shader object. As-
signed bindings for attribute variables that do not exist or are not active are ignored.
BindAttribLocation has no effect on SPIR-V shaders, since the locations must al-
ways be fully speci?ed in the SPIR-V shader as described in section 11.1.1.1.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_VALUE error is generated if index is greater than or equal to
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 388
the value ofMAX_VERTEX_ATTRIBS.
An INVALID_OPERATION error is generated if name starts with the re-
served"gl_" pre?x.
To determine the set of active vertex attribute variables used by a program,
applications can query the properties and active resources of thePROGRAM_INPUT
interface of a program including a vertex shader.
Additionally, the command
void GetActiveAttrib(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name );
can be used to determine properties of the active input variable assigned the index
index in program object program. If no error occurs, the command is equivalent
(assuming no errors are generated) to:
const enum props[] = f ARRAY_SIZE, TYPE g;
GetProgramResourceName(program, PROGRAM_INPUT,
index, bufSize, length, name);
GetProgramResourceiv(program, PROGRAM_INPUT,
index, 1, &props[0], 1, NULL, size);
GetProgramResourceiv(program, PROGRAM_INPUT,
index, 1, &props[1], 1, NULL, (int )type);
*
For GetActiveAttrib, all active vertex shader input variables are enumerated,
including the special built-in inputsgl_BaseInstance,gl_BaseVertex,gl_-
DrawID,gl_InstanceID, andgl_VertexID.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_VALUE error is generated if index is not the index of an
active input variable in program.
AnINVALID_VALUE error is generated for all values of index if program
does not include a vertex shader, as it has no active vertex attributes.
AnINVALID_VALUE error is generated if bufSize is negative.
The command
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 389
int GetAttribLocation(uint program,const char *name );
can be used to determine the location assigned to the active input variable named
name in program object program.
Errors
If program has been linked successfully but contains no vertex shader, no
error is generated but -1 will be returned.
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_OPERATION error is generated and -1 is returned if program
has not been linked successfully.
Otherwise, the command is equivalent to
GetProgramResourceLocation(program, PROGRAM_INPUT, name);
There is an implementation-dependent limit on the number of active at-
tribute variables in a vertex shader. A program with more than the value of
MAX_VERTEX_ATTRIBS active attribute variables may fail to link, unless device-
dependent optimizations are able to make the program ?t within available hard-
ware resources. For the purposes of this test, attribute variables of the typedvec3,
dvec4,dmat2x3,dmat2x4,dmat3,dmat3x4,dmat4x3, anddmat4 may count
as consuming twice as many attributes as equivalent single-precision types. While
these types use the same number of generic attributes as their single-precision
equivalents, implementations are permitted to consume two single-precision vec-
tors of internal storage for each three- or four-component double-precision vector.
The values of generic attributes sent to generic attribute index i are part of
current state. If a new program object has been made active, then these values
will be tracked by the GL in such a way that the same values will be observed by
attributes in the new program object that are also bound to indexi.
It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. A link error can occur if the linker determines that every path through the
shader consumes multiple aliased attributes, but implementations are not required
to generate an error in this case. The compiler and linker are allowed to assume that
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 390
no aliasing is done, and may employ optimizations that work only in the absence
of aliasing.
11.1.1.1 SPIR-V Vertex Input Interface
When a SPIR-V vertex stage is present, the vertex shader variables listed by
OpEntryPoint with the Input storage class form the vertex input attribute in-
terface. These inputs must be decorated with a Location and can also be dec-
orated with a Component decoration. These correspond to the location and
component layout discussed in section 11.1.1.
The vertex shader input variables are matched only by the Location and
Component decorations, and must have a corresponding attribute and binding in
the pipeline.
11.1.2 Vertex Shader Variables
Vertex shaders can access uniforms belonging to the current program object. Lim-
its on uniform storage and methods for manipulating uniforms are described in
section 7.6.
Vertex shaders also have access to samplers to perform texturing operations, as
described in section 7.11.
11.1.2.1 Output Variables
A vertex shader may de?ne one or more output variables or outputs (see the
OpenGL Shading Language Specification).
The OpenGL Shading Language Specification also de?nes a set of built-in out-
puts that vertex shaders can write to (see section 7.1(“Built-In Variables”) of the
OpenGL Shading Language Specification). These output variables are used as the
mechanism to communicate values to the next active stage in the vertex processing
pipeline: either the tessellation control shader, the tessellation evaluation shader,
the geometry shader, or the ?xed-function vertex processing stages leading to ras-
terization.
If the output variables are passed directly to the vertex processing stages lead-
ing to rasterization, the values of all outputs are expected to be interpolated across
the primitive being rendered, unless ?atshaded. Otherwise the values of all out-
puts are collected by the primitive assembly stage and passed on to the subsequent
pipeline stage once enough data for one primitive has been collected.
The number of components (individual scalar numeric values) of output vari-
ables that can be written by the vertex shader, whether or not a tessellation con-
trol, tessellation evaluation, or geometry shader is active, is given by the value
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 391
of the implementation-dependent constant MAX_VERTEX_OUTPUT_COMPONENTS.
For the purposes of counting input and output components consumed by a shader,
variables declared as vectors, matrices, and arrays will all consume multiple com-
ponents. Each component of variables declared as double-precision ?oating-point
scalars, vectors, or matrices may be counted as consuming two components.
When a program is linked, all components of any outputs written by a vertex
shader will count against this limit. A program whose vertex shader writes more
than the value ofMAX_VERTEX_OUTPUT_COMPONENTS components worth of out-
puts may fail to link, unless device-dependent optimizations are able to make the
program ?t within available hardware resources.
Additionally, when linking a program containing only a vertex and frag-
ment shader, there is a limit on the total number of components used as ver-
tex shader outputs or fragment shader inputs. This limit is given by the value
of the implementation-dependent constant MAX_VARYING_COMPONENTS. The
implementation-dependent constantMAX_VARYING_VECTORS has a value equal to
the value of MAX_VARYING_COMPONENTS divided by four. Each output variable
component used as either a vertex shader output or fragment shader input counts
against this limit, except for the components of gl_Position. A program con-
taining only a vertex and fragment shader that accesses more than this limit’s worth
of components of outputs may fail to link, unless device-dependent optimizations
are able to make the program ?t within available hardware resources.
Each program object can specify a set of output variables from one shader to be
recorded in transform feedback mode (see section 13.3). The variables that can be
recorded are those emitted by the ?rst active shader, in order, from the following
list:
 geometry shader
 tessellation evaluation shader
 tessellation control shader
 vertex shader
The set of variables to record can be speci?ed in shader text using the xfb_-
buffer,xfb_offset, orxfb_stridelayout quali?ers. For SPIR-V shaders,
these are speci?ed by the XfbBuffer, Offset, and XfbStride decorations, re-
spectively. When a SPIR-V entry point is using any of these for transform feed-
back, it must declare theXfb Execution Mode.
When recording output variables of each vertex in transform feedback mode, a
?xed amount of memory is reserved in the buffer bound to each transform feedback
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 392
buffer binding point. Each output variable recorded is associated with a binding
point, speci?ed by the xfb_buffer layout quali?er. Each output variable is
written to its associated transform feedback binding point at an offset speci?ed
by thexfb_offsetlayout quali?er, in basic machine units, relative to the base
of the memory reserved for its vertex. The amount of memory reserved in each
transform feedback binding point for a single vertex can be speci?ed using the
xfb_stride layout quali?er. If no xfb_stride quali?er is speci?ed for a
binding point, the stride is derived by identifying the variable associated with the
binding point having the largest offset, and then adding the offset and the size of
the variable, in basic machine units. If any variable associated with the binding
point contains double-precision ?oating-point components, the derived stride is
aligned to the next multiple of eight basic machine units. If a binding point has no
xfb_stride quali?er and no associated output variables, its stride is zero.
When noxfb_buffer,xfb_offset, orxfb_stridelayout quali?ers are
speci?ed, the set of variables to record is speci?ed with the command
void TransformFeedbackVaryings(uint program,
sizei count,const char *const *varyings,
enum bufferMode );
program speci?es the program object. count speci?es the number of output vari-
ables used for transform feedback. varyings is an array of count zero-terminated
strings specifying the names of the outputs to use for transform feedback. The
variables speci?ed in varyings can be either built-in (beginning with "gl_") or
user-de?ned variables. Each variable can either be a basic type or an array of ba-
sic types. Structure, array of array and array of structure types cannot be captured
directly. Base-level members of aggregates can be captured by specifying the fully
quali?ed path identifying the member, using the same rules with which active re-
source lists are enumerated for program interfaces as described in section 7.3.1.1,
with one exception. To allow capturing whole arrays or individual elements of an
array, there are additional rules for array variables. To capture a single element, the
name of the output array is speci?ed with a constant-integer index "name[x]"
wherename is the name of the array variable andx is the constant-integer index of
the array element. To capture the whole of the output array,name is speci?ed with-
out the array index or square brackets. Output variables are written out in the order
they appear in the array varyings. bufferMode is either INTERLEAVED_ATTRIBS
orSEPARATE_ATTRIBS, and identi?es the mode used to capture the outputs when
transform feedback is active.
The variables in varyings are assigned binding points and offsets sequentially,
as though each were speci?ed using the xfb_buffer and xfb_offset layout
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 393
quali?ers. The strides associated with each binding point are derived by adding
the offset and size of the last variable associated with that binding point. The
?rst variable in varyings is assigned a binding point and offset of zero. When
bufferMode is INTERLEAVED_ATTRIBS, each subsequent variable is assigned to
the same binding point as the previous variable and an offset equal to the sum of
the offset and size of the previous variable. When bufferMode is SEPARATE_-
ATTRIBS, each subsequent variable is assigned to the binding point following the
binding point of the previous variable with an offset of zero.
Several special identi?ers are supported when bufferMode isINTERLEAVED_-
ATTRIBS. These identi?ers do not identify output variables captured in transform
feedback mode, but can be used to modify the binding point and offsets assigned
to subsequent variables. If a string in varyings isgl_NextBuffer, the next vari-
able in varyings will be assigned to the next binding point, with an offset of zero.
If a string in varyings isgl_SkipComponents1, gl_SkipComponents2, gl_-
SkipComponents3, orgl_SkipComponents4, the variable is treated as specify-
ing a one- to four-component ?oating-point output variable with unde?ned values.
No data will be recorded for such strings, but the offset assigned to the next variable
in varyings and the stride of the assigned binding point will be affected.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
AnINVALID_VALUE error is generated if count is negative.
An INVALID_ENUM error is generated if bufferMode is not SEPARATE_-
ATTRIBS orINTERLEAVED_ATTRIBS.
An INVALID_VALUE error is generated if bufferMode is SEPARATE_-
ATTRIBS and count is greater than the value of the implementation-dependent
limitMAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
An INVALID_OPERATION error is generated if any pointer in varyings
identi?es the special names gl_NextBuffer,
gl_SkipComponents1, gl_SkipComponents2, gl_SkipComponents3,
or gl_SkipComponents4 and bufferMode is not INTERLEAVED_ATTRIBS,
or if the number of gl_NextBuffer pointers in varyings is greater than or
equal to the value ofMAX_TRANSFORM_FEEDBACK_BUFFERS.
The state set by TransformFeedbackVaryings or using transform feedback
layout quali?ers has no effect on the execution of the program until program is
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 394
subsequently linked. When LinkProgram is called, the program is linked so that
the values of the speci?ed outputs for the vertices of each primitive generated by
the GL are written to one or more buffer objects. If the set of output variables to
record in transform feedback mode is speci?ed by TransformFeedbackVaryings,
a program will fail to link if:
 the count speci?ed by TransformFeedbackVaryings is non-zero, but the
program object has no vertex, tessellation control, tessellation evaluation, or
geometry shader;
 any variable name speci?ed in the varyings array is not one of gl_-
NextBuffer, gl_SkipComponents1, gl_SkipComponents2, gl_-
SkipComponents3, or gl_SkipComponents4, and is not declared as a
built-in or user-de?ned output variable in the shader stage whose outputs
can be recorded;
 any two entries in the varyings array specify the same output variable or
include the same elements from an array variable (different elements from
the same array are permitted);
 the total number of components to capture in any output in varyings is greater
than the value of MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
and the buffer mode isSEPARATE_ATTRIBS;
 the total number of components to capture is greater than the value of
MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer
mode isINTERLEAVED_ATTRIBS; or
 the set of outputs to capture to any single binding point includes outputs from
more than one vertex stream.
If the set of output variables to record in transform feedback mode is speci?ed
usinglayout quali?ers, a program will fail to link if:
 any pair of variables associated with the same binding point overlap in mem-
ory (where the offset of the ?rst variable is less than or equal to the offset of
the second, but the sum of the offset and size of the ?rst variable is greater
than the offset of the second);
 any binding point has a stride declared using thexfb_stridelayout qual-
i?er and the sum of the offset and size of any variable associated with that
binding point exceeds the value of this stride;
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 395
 any variable containing double-precision ?oating-point components
– has an xfb_offset layout quali?er that is not a multiple of eight;
or
– is associated with a binding point with anxfb_stridelayout qual-
i?er that is not a multiple of eight;
 the sum of the offset and size of any variable exceeds the maximum
stride supported by the implementation (four times the value of MAX_-
TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS); or
 thexfb_stridelayout quali?er for any binding point exceeds the maxi-
mum stride supported by the implementation.
For transform feedback purposes, each component of outputs declared as
double-precision ?oating-point scalars, vectors, or matrices is considered to con-
sume eight basic machine units, and each component of any other type is consid-
ered to consume four basic machine units.
To determine the set of output variables in a linked program object that will
be captured in transform feedback mode and the binding points to which those
variables are written, applications can query the properties and active resources
of the TRANSFORM_FEEDBACK_VARYING and TRANSFORM_FEEDBACK_BUFFER
interfaces.
If the shader used to record output variables for transform feedback vary-
ings uses the xfb_buffer, xfb_offset, or xfb_stride layout quali?ers,
or its SPIR-V entry point declares the Xfb Execution Mode, the values speci?ed
by TransformFeedbackVaryings are ignored, and the set of variables captured
for transform feedback is instead derived from the speci?ed layout quali?ers or
SPIR-V decorations. Outputs specifying both an XfbBuffer and an Offset are
captured, while outputs not specifying both of these are not captured. Values are
captured each time the shader writes to such a decorated object.
Additionally, the command
void GetTransformFeedbackVarying(uint program,
uint index,sizei bufSize,sizei *length,sizei *size,
enum *type,char *name );
can be used to enumerate properties of a single output variable captured in trans-
form feedback mode, and is equivalent (assuming no errors are generated) to:
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 396
const enum props[] = f ARRAY_SIZE, TYPE g;
GetProgramResourceName(program, TRANSFORM_FEEDBACK_VARYING,
index, bufSize, length, name);
GetProgramResourceiv(program, TRANSFORM_FEEDBACK_VARYING,
index, 1, &props[0], 1, NULL, size);
GetProgramResourceiv(program, TRANSFORM_FEEDBACK_VARYING,
index, 1, &props[1], 1, NULL, (int )type);
*
Special output names (e.g., gl_NextBuffer, gl_SkipComponents1)
passed to TransformFeedbackVaryings in the varyings array are counted as out-
puts to be recorded for the purposes of determining the value of TRANSFORM_-
FEEDBACK_VARYINGS and for determining the variable selected by index in Get-
TransformFeedbackVarying. If index identi?es gl_NextBuffer, the values
zero andNONE will be written to size and type, respectively. If index is of the form
gl_SkipComponentsn, the valueNONE will be written to type and the number of
components n will be written to size.
GetTransformFeedbackVarying may be used to query any transform feed-
back output variable, not just those speci?ed with TransformFeedbackVarying.
11.1.3 Shader Execution
If there is an active program object present for the vertex, tessellation control,
tessellation evaluation, or geometry shader stages, the executable code for these
active programs is used to process incoming vertex values.
The following sequence of operations is performed:
 Vertices are processed by the vertex shader (see section 11.1) and assembled
into primitives as described in sections 10.1 through 10.3.
 If the current program contains a tessellation control shader, each indi-
vidual patch primitive is processed by the tessellation control shader (sec-
tion 11.2.1). Otherwise, primitives are passed through unmodi?ed. If active,
the tessellation control shader consumes its input patch and produces a new
patch primitive, which is passed to subsequent pipeline stages.
 If the current program contains a tessellation evaluation shader, each indi-
vidual patch primitive is processed by the tessellation primitive generator
(section 11.2.2) and tessellation evaluation shader (see section 11.2.3). Oth-
erwise, primitives are passed through unmodi?ed. When a tessellation eval-
uation shader is active, the tessellation primitive generator produces a new
collection of point, line, or triangle primitives to be passed to subsequent
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 397
pipeline stages. The vertices of these primitives are processed by the tes-
sellation evaluation shader. The patch primitive passed to the tessellation
primitive generator is consumed by this process.
 If the current program contains a geometry shader, each individual primitive
is processed by the geometry shader (section 11.3). Otherwise, primitives
are passed through unmodi?ed. If active, the geometry shader consumes its
input patch primitive. However, each geometry shader invocation may emit
new vertices, which are arranged into primitives and passed to subsequent
pipeline stages.
Implementations are allowed to skip the execution of certain shader invoca-
tions, and to execute additional shader invocations for any shader type during pro-
grammable vertex processing due to implementation dependent reasons, includ-
ing the execution of shader invocations that do not have an active program object
present for the particular shader stage, as long as the results of rendering otherwise
remain unchanged.
Following shader execution, the ?xed-function operations described in chap-
ter 13 are applied.
Special considerations for vertex shader execution are described in the follow-
ing sections.
11.1.3.1 Shader Only Texturing
This section describes texture functionality that is accessible through shaders (of
all types). Also refer to chapter 8 and to section 8.9(“Texture Functions”) of the
OpenGL Shading Language Specification.
11.1.3.2 Texel Fetches
The OpenGL Shading Language texelFetch built-ins provide the ability to ex-
tract a single texel from a speci?ed texture image. Texel fetches cannot access cube
maps.
The integer coordinates (i;j;k) passed to texelFetch are used to point-
sample the texture image. The level-of-detail accessed is computed by adding the
speci?ed level-of-detail parameter lod to the base level of the texture,level .
base
Texel fetch proceeds similarly to the steps described for texture access in sec-
tion 11.1.3.5, with the exception that none of the operations controlled by sampler
object state are performed, including:
 level-of-detail clamping;
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 398
 texture wrap mode application;
 ?ltering (however, a mipmapped mini?cation ?lter is required to access any
level-of-detail other than the base level);
 depth comparison.
The steps that are performed are:
 validation of texel coordinates as described below, including the computed
level-of-detail, (i;j;k), the speci?ed level for array textures, and texture
completeness;
 sRGB conversion of fetched values as described in section 8.24;
 conversion to base colorC ;
b
 component swizzling.
The results oftexelFetch built-ins are unde?ned if any of the following con-
ditions hold:
 the computed level-of-detail is less than the texture’s base level (level )
base
or greater than the maximum de?ned level,q (see section 8.14.3)
 the computed level-of-detail is not the texture’s base level and the texture’s
mini?cation ?lter isNEAREST orLINEAR
 the layer speci?ed for array textures is negative, or greater than or equal to
the number of layers in the array texture
 the texel coordinates (i;j;k) refer to a texel outside the de?ned extents of
the computed level-of-detail, where any of
i< 0 iw
s
j < 0 jh
s
k< 0 kd
s
and w ,h , andd refer to the width, height, and depth of the image, as
s s s
de?ned in section 8.5.3.
 the texture being accessed is not complete, as de?ned in section 8.17
 the texture being accessed is not bound.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 399
In all the above cases, if the context was created with robust buffer access
enabled (see section 10.3.7), the result of the texture fetch is zero, or a texture
source color of (0; 0; 0; 1) in the case of a texel fetch from an incomplete texture.
If robust buffer access is not enabled, the result of the texture fetch is unde?ned in
each case.
11.1.3.3 Multisample Texel Fetches
Multisample buffers do not have mipmaps, and there is no level-of-detail parameter
for multisample texel fetches. Instead, an integer parameter selects the sample
number to be fetched from the buffer. The number identifying the sample is the
same as the value used to query the sample location using GetMultisamplefv.
Multisample textures are not ?ltered when samples are fetched, and ?lter state is
ignored.
The results of a multisample texel fetch are unde?ned if any of the following
conditions hold:
 the texel coordinates (i;j;k) refer to a texel outside the extents of the multi-
sample texture image, where any of
i< 0 iw
s
j < 0 jh
s
k< 0 kd
s
and the size parametersw ,h , andd refer to the width, height, and depth
s s s
of the image
 the speci?ed sample number does not exist (is negative, or greater than or
equal to the number of samples in the texture).
Additionally, these fetches may only be performed on a multisample texture
sampler. No other sample or fetch commands may be performed on a multisample
texture sampler.
11.1.3.4 Texture Queries
ThetextureSize functions provide the ability to query the size of a texture im-
age. The level-of-detail value lod passed in as an argument to the texture size
functions is added to thelevel of the texture to determine a texture image level.
base
The dimensions of that image level are then returned. The value returned is
unde?ned if:
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 400
 the texture is not complete;
 the texture is not mipmap complete, and the computed texture level is not
level ; or
base
 the computed texture image level is outside the range [level ;q], whereq
base
is de?ned in section 8.14.3.
When querying the size of an array texture, both the dimensions and the layer
count are returned.
The textureQueryLevels functions provide the ability to query the num-
ber of accessible mipmap levels in a texture object associated with a sampler uni-
form. If the sampler is associated with an immutable-format texture object (see
section 8.19), the value returned will be:
min(level   1;level ) level + 1:
immut max base
Otherwise, the value returned will be an implementation-dependent value between
zero andq level +1. The value returned in that case must satisfy the following
base
constraints:
 if all levels of the texture have zero size, zero must be returned
 if the texture is complete, a non-zero value must be returned
 if the texture is complete and is accessed with a mini?cation ?lter requiring
mipmaps,q level + 1 must be returned.
base
11.1.3.5 Texture Access
Shaders have the ability to do a lookup into a texture map. The maximum number
of texture image units available to shaders are the values of the implementation-
dependent constants
 MAX_VERTEX_TEXTURE_IMAGE_UNITS (for vertex shaders),
 MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS (for tessellation control
shaders),
 MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS (for tessellation eval-
uation shaders),
 MAX_GEOMETRY_TEXTURE_IMAGE_UNITS (for geometry shaders),
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 401
 MAX_TEXTURE_IMAGE_UNITS (for fragment shaders), and
 MAX_COMPUTE_TEXTURE_IMAGE_UNITS (for compute shaders).
All active shaders combined cannot use more than the value of MAX_-
COMBINED_TEXTURE_IMAGE_UNITS texture image units. If more than one
pipeline stage accesses the same texture image unit, each such access counts sepa-
rately against theMAX_COMBINED_TEXTURE_IMAGE_UNITS limit.
When a texture lookup is performed in a shader, the ?ltered texture value is
computed in the manner described in sections 8.14 and 8.15, and converted to a
texture base colorC as shown in table 15.1, followed by application of the texture
b
swizzle as described in section 15.2.1 to compute the texture source colorC and
s
A .
s
The resulting four-component vector (R ;G ;B ;A ) is returned to the shader.
s s s s
Texture lookup functions (see section 8.9(“Texture Functions”) of the OpenGL
Shading Language Specification) may return ?oating-point, signed, or unsigned
integer values depending on the function and the internal format of the texture.
In shaders other than fragment shaders, it is not possible to perform automatic
level-of-detail calculations using partial derivatives of the texture coordinates with
respect to window coordinates as described in section 8.14. Hence, there is no au-
tomatic selection of an image array level. Minification or magni?cation of a texture
map is controlled by a level-of-detail value optionally passed as an argument in the
texture lookup functions. If the texture lookup function supplies an explicit level-
of-detail valuel, then the pre-bias level-of-detail value (x;y) = l (replacing
base
equation 8.7). If the texture lookup function does not supply an explicit level-of-
detail value, then (x;y) = 0. The scale factor(x;y) and its approximation
base
functionf(x;y) (see equation 8.11) are ignored.
Texture lookups involving textures with depth component data generate a tex-
ture base colorC either using depth data directly or by performing a comparison
b
with the D value used to perform the lookup, as described in section 8.23.1,
ref
and expanding the resulting valueR to a colorC = (R ; 0; 0; 1). In either case,
t b t
swizzling of C is then performed as described above, but only the ?rst compo-
b
nentC [0] is returned to the shader. The comparison operation is requested in the
s
shader by using any of the shadow sampler types (sampler Shadow), and in the
*
texture using the TEXTURE_COMPARE_MODE parameter. These requests must be
consistent; the results of a texture lookup are unde?ned if any of the following
conditions are true:
 The sampler used in a texture lookup function is not one of the shadow sam-
pler types, the texture object’s base internal format is DEPTH_COMPONENT
orDEPTH_STENCIL, and theTEXTURE_COMPARE_MODE is notNONE.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 402
 The sampler used in a texture lookup function is one of the shadow sam-
pler types, the texture object’s base internal format is DEPTH_COMPONENT
orDEPTH_STENCIL, and theTEXTURE_COMPARE_MODE isNONE.
 The sampler used in a texture lookup function is one of the shadow sam-
pler types, and the texture object’s base internal format is not DEPTH_-
COMPONENT orDEPTH_STENCIL.
 The sampler used in a texture lookup function is one of the shadow sampler
types, the texture object’s base internal format isDEPTH_STENCIL, and the
DEPTH_STENCIL_TEXTURE_MODE is notDEPTH_COMPONENT.
The stencil index texture internal component is ignored if the base internal
format isDEPTH_STENCIL and the value ofDEPTH_STENCIL_TEXTURE_MODE is
notSTENCIL_INDEX.
Texture lookups involving texture objects with an internal format ofDEPTH_-
STENCIL can read the stencil value as described in section 8.23 by setting
the DEPTH_STENCIL_TEXTURE_MODE to STENCIL_INDEX. Textures with a
STENCIL_INDEX base internal format may also be used to read stencil data. The
stencil value is read as an integer and assigned toR . An unsigned integer sampler
t
should be used to lookup the stencil component, otherwise the results are unde-
?ned.
If a sampler is used in a shader and the sampler’s associated texture is not
complete, as de?ned in section 8.17, (0:0; 0:0; 0:0; 1:0), in ?oating-point, will be
returned for a non-shadow sampler and 0 for a shadow sampler. In this case, if
the sampler is declared in the shader as a signed or unsigned integer sampler type,
unde?ned values are returned as speci?ed in section 9.9(“Texture Functions”) of
the OpenGL Shading Language Specification when the texture format and sampler
type are unsupported combinations.
11.1.3.6 Atomic Counter Access
Shaders have the ability to set and get atomic counters. The maximum num-
ber of atomic counters available to shaders are the values of the implementation-
dependent constants
 MAX_VERTEX_ATOMIC_COUNTERS (for vertex shaders),
 MAX_TESS_CONTROL_ATOMIC_COUNTERS (for tessellation control
shaders),
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 403
 MAX_TESS_EVALUATION_ATOMIC_COUNTERS (for tessellation evaluation
shaders),
 MAX_GEOMETRY_ATOMIC_COUNTERS (for geometry shaders),
 MAX_FRAGMENT_ATOMIC_COUNTERS (for fragment shaders), and
 MAX_COMPUTE_ATOMIC_COUNTERS (for compute shaders).
All active shaders combined cannot use more than the value of MAX_-
COMBINED_ATOMIC_COUNTERS atomic counters. If more than one pipeline stage
accesses the same atomic counter, each such access counts separately against the
MAX_COMBINED_ATOMIC_COUNTERS limit.
11.1.3.7 Image Access
Shaders have the ability to read and write to textures using image uniforms. The
maximum number of image uniforms available to individual shader stages are the
values of the implementation-dependent constants
 MAX_VERTEX_IMAGE_UNIFORMS (for vertex shaders),
 MAX_TESS_CONTROL_IMAGE_UNIFORMS (for tessellation control shaders),
 MAX_TESS_EVALUATION_IMAGE_UNIFORMS (for tessellation evaluation
shaders),
 MAX_GEOMETRY_IMAGE_UNIFORMS (for geometry shaders),
 MAX_FRAGMENT_IMAGE_UNIFORMS (for fragment shaders), and
 MAX_COMPUTE_IMAGE_UNIFORMS (for compute shaders).
All active shaders combined cannot use more than the value of MAX_-
COMBINED_IMAGE_UNIFORMS image uniforms. If more than one shader stage
accesses the same image uniform, each such access counts separately against the
MAX_COMBINED_IMAGE_UNIFORMS limit.
11.1.3.8 Shader Storage Buffer Access
Shaders have the ability to read and write to buffer memory via buffer variables in
shader storage blocks. The maximum number of shader storage blocks available to
shaders are the values of the implementation-dependent constants
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 404
 MAX_VERTEX_SHADER_STORAGE_BLOCKS (for vertex shaders)
 MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS (for tessellation control
shaders)
 MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS (for tessellation
evaluation shaders)
 MAX_GEOMETRY_SHADER_STORAGE_BLOCKS (for geometry shaders)
 MAX_FRAGMENT_SHADER_STORAGE_BLOCKS (for fragment shaders)
 MAX_COMPUTE_SHADER_STORAGE_BLOCKS (for compute shaders)
All active shaders combined cannot use more than the value of MAX_-
COMBINED_SHADER_STORAGE_BLOCKS shader storage blocks. If more than one
pipeline stage accesses the same shader storage block, each such access counts
separately against this combined limit.
11.1.3.9 Shader Inputs
Besides having access to vertex attributes and uniform variables, vertex shaders
can access the read-only built-in variablesgl_BaseInstance,gl_BaseVertex,
gl_DrawID,gl_InstanceID, andgl_VertexID.
gl_BaseInstance holds the integer value passed to the baseInstance pa-
rameter to the command that resulted in the current shader invocation. In the
case where the command has no baseInstance parameter, the value of gl_-
BaseInstance is zero.
gl_BaseVertex holds the integer value passed to the baseVertex parameter
to the command that resulted in the current shader invocation. In the case where
the command has no baseVertex parameter, the value ofgl_BaseVertex is zero.
gl_DrawID holds the integer draw number the current draw being processed
by the shader invocation. It is dynamically uniform. In MultiDraw* variants,
this is the zero-based index of the draw within the list of draws processed by the
command. In non-MultiDraw* commands, the value of gl_DrawID is always
zero.
gl_InstanceID holds the integer instance number of the current primitive in
an instanced draw call (see section 10.4).
gl_VertexID holds the integer indexi implicitly passed by DrawArrays or
one of the other drawing commands de?ned in section 10.4.
Section 7.1(“Built-In Variables”) of the OpenGL Shading Language Speci?ca-
tion also describes these variables.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 405
11.1.3.10 Shader Outputs
A vertex shader can write to user-de?ned output variables. Interpolation of these
values across the primitive is determined by the fragment shader input variable in-
terpolation quali?er. sections 4.3.6(“Output Variables”), 4.5(“Interpolation Qual-
i?ers”), and 7.1(“Built-In Variables”) of the OpenGL Shading Language Speci?-
cation for more detail.
The built-in outputgl_Position is intended to hold the homogeneous vertex
position. Writinggl_Position is optional.
The built-in output variables gl_ClipDistance andgl_CullDistance re-
spectively hold the vertex coordinate, and the clip distance and cull distance used
in the clipping stage, as described in section 13.7. If clipping is enabled, gl_-
ClipDistance should be written.
The built-in outputgl_PointSize, if written, holds the size of the point to be
rasterized, measured in pixels.
11.1.3.11 Validation
It is not always possible to determine at link time if a program object can execute
successfully, given that LinkProgram can not know the state of the remainder
of the pipeline. Therefore validation is done when the ?rst rendering command
which triggers shader invocations is issued, to determine if the set of active program
1
objects can be executed .
Errors
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL or launches compute work if the current set of active
program objects cannot be executed, for reasons including:
 A program object is active for at least one, but not all of the shader stages
that were present when the program was linked.
 One program object is active for at least two shader stages and a second
program is active for a shader stage between two stages for which the ?rst
program was active. The active compute shader is ignored for the purposes
of this test.
1
The OpenGL Specification differs from the OpenGL ES Specification in what validation takes
place at draw-time. In particular, the OpenGL Specification does not require the implementation to
detect mismatched interfaces between the shader stages as this might add extra draw-time overhead.
Depending on the implementation, developers can activate more draw-time validation by enabling
DEBUG_OUTPUT or using a debug context.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 406
 There is an active program for tessellation control, tessellation evaluation, or
geometry stages with corresponding executable shader, but there is no active
program with executable vertex shader.
 There is no current program object speci?ed by UseProgram, there is a cur-
rent program pipeline object, and the current program for any shader stage
has been relinked since being applied to the pipeline object via UsePro-
gramStages with thePROGRAM_SEPARABLE parameter set toFALSE.
 There is no current program object speci?ed by UseProgram, there is a
current program pipeline object, and that object is empty (no executable code
is installed for any stage).
 Any two active samplers in the set of active program objects are of different
types, but refer to the same texture image unit.
 The sum of the number of active samplers for each active program exceeds
the maximum number of texture image units allowed.
 The sum of the number of active atomic counters, atomic counter buffers,
image uniforms, shader output resources, shader storage blocks, texture im-
age units, and uniform blocks used by the current program objects exceeds
the corresponding combined limit (the value ofMAX_COMBINED_ATOMIC_-
COUNTERS, MAX_COMBINED_ATOMIC_COUNTER_BUFFERS, MAX_-
COMBINED_IMAGE_UNIFORMS, MAX_COMBINED_SHADER_OUTPUT_-
RESOURCES, MAX_COMBINED_SHADER_STORAGE_BLOCKS, MAX_-
COMBINED_TEXTURE_IMAGE_UNITS, and MAX_COMBINED_UNIFORM_-
BLOCKS, respectively).
TheINVALID_OPERATION error generated by these rendering commands may
not provide enough information to ?nd out why the currently active program object
would not execute. No information at all is available about a program object that
would still execute, but is inef?cient or suboptimal given the current GL state. As
a development aid, use the command
void ValidateProgram(uint program );
to validate the program object program against the current GL state. Each program
object has a boolean status, VALIDATE_STATUS, that is modi?ed as a result of
validation. This status may be queried with GetProgramiv (see section 7.14).
If validation succeeded this status will be set to TRUE, otherwise it will be set
to FALSE. If validation succeeded, no INVALID_OPERATION validation error is
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 407
generated if program is made current via UseProgram, given the current state. If
validation failed, such errors are generated under the current state.
ValidateProgram will check for all the conditions described in this section,
and may check for other conditions as well. For example, it could give a hint on
how to optimize some piece of shader code. The information log of program is
overwritten with information on the results of the validation, which could be an
empty string. The results written to the information log are typically only use-
ful during application development; an application should not expect different GL
implementations to produce identical information.
A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tions should ensure that all valid shaders and program objects may be successfully
compiled, linked and executed.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
Separable program objects may have validation failures that cannot be detected
without the complete program pipeline. Mismatched interfaces, improper usage
of program objects together, and the same state-dependent failures can result in
validation errors for such program objects. As a development aid, use the command
void ValidateProgramPipeline(uint pipeline );
to validate the program pipeline object pipeline against the current GL state. Each
program pipeline object has a boolean status,VALIDATE_STATUS, that is modi?ed
as a result of validation. This status may be queried with GetProgramPipelineiv
(see section 7.14). If validation succeeded, no INVALID_OPERATION validation
error is generated if pipeline is bound and no program is made current via UsePro-
gram, given the current state. If validation failed, such errors are generated under
the current state.
If pipeline is a name that has been generated (without subsequent deletion) by
GenProgramPipelines, but refers to a program pipeline object that has not been
previously bound, the GL ?rst creates a new state vector in the same manner as
when BindProgramPipeline creates a new program pipeline object.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.1. VERTEXSHADERS 408
Errors
AnINVALID_OPERATION error is generated if pipeline is not a name re-
turned from a previous call to GenProgramPipelines or if such a name has
since been deleted by DeleteProgramPipelines.
11.1.3.12 Unde?ned Behavior
When using array, vector or matrix variables in a shader, it is possible to access
a variable with an index computed at run time that is outside the declared extent
of the variable. Such out-of-bounds accesses have unde?ned behavior, and system
errors (possibly including program termination) may occur. The level of protection
provided against such errors in the shader is implementation-dependent.
Robust buffer access can be enabled by creating a context with robust access
enabled through the window system binding APIs. When enabled, out-of-bounds
accesses will be bounded within the working memory of the active program, cannot
access memory owned by other GL contexts, and will not result in abnormal pro-
gram termination. Out-of-bounds access to local and global variables cannot read
values from other program invocations. An out-of-bounds read may return another
value from the active program’s working memory or zero. An out-of-bounds write
may overwrite a value from the active program’s working memory or be discarded.
Out-of-bounds accesses to resources backed by buffer objects cannot read or
modify data outside of the buffer object. For resources bound to buffer ranges, ac-
cess is restricted within the buffer object from which the buffer range was created,
and not within the buffer range itself.
Out-of-bounds reads may return any of the following values:
 Values from anywhere within the buffer object.
 Zero values, or (0; 0; 0;x) vectors for vector reads wherex is a valid value
represented in the type of the vector components and may be any of
– Zero, one, or the maximum representable positive integer value, for
signed or unsigned integer components.
– 0:0 or 1:0, for ?oating-point components.
Out-of-bounds writes may modify values within the buffer object or be dis-
carded.
Out-of-bounds accesses to arrays of resources, such as an array of textures, can
only access the data of bound resources. Reads from unbound resources return
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 409
zero and writes are discarded. It is not possible to access data owned by other GL
contexts.
Applications that require de?ned behavior for out-of-bounds accesses should
range check all computed indices before dereferencing the array, vector or matrix.
11.1.4 Vertex Shader Queries
Vertex shader queries use query objects to track the number of vertex shader invo-
cations.
When BeginQuery is called with a target of VERTEX_SHADER_-
INVOCATIONS, the vertex shader invocations count maintained by the GL is set to
zero. When a vertex shader invocations query is active, the counter is incremented
every time the vertex shader is invoked (see section 11.1).
The result of vertex shader queries may be implementation dependent due to
reasons described in section 11.1.3.
11.2 Tessellation
Tessellation is a process that reads a patch primitive and generates new primitives
used by subsequent pipeline stages. The generated primitives are formed by sub-
dividing a single triangle or quad primitive according to ?xed or shader-computed
levels of detail and transforming each of the vertices produced during this subdivi-
sion.
Tessellation functionality is controlled by two types of tessellation shaders: tes-
sellation control shaders and tessellation evaluation shaders. Tessellation is con-
sidered active if and only if there is an active tessellation control or tessellation
evaluation program object.
The tessellation control shader is used to read an input patch provided by the
application, and emit an output patch. The tessellation control shader is run once
for each vertex in the output patch and computes the attributes of that vertex. Addi-
tionally, the tessellation control shader may compute additional per-patch attributes
of the output patch. The most important per-patch outputs are the tessellation lev-
els, which are used to control the number of subdivisions performed by the tessella-
tion primitive generator. The tessellation control shader may also write additional
per-patch attributes for use by the tessellation evaluation shader. If no tessellation
control shader is active, the patch provided is passed through to the tessellation
primitive generator stage unmodi?ed.
If a tessellation evaluation shader is active, the tessellation primitive generator
subdivides a triangle or quad primitive into a collection of points, lines, or triangles
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 410
according to the tessellation levels of the patch and the set oflayout declarations
speci?ed in the tessellation evaluation shader text. The tessellation levels used to
control subdivision are normally written by the tessellation control shader. If no
tessellation control shader is active, default tessellation levels are instead used.
When a tessellation evaluation shader is active, it is run on each vertex gener-
ated by the tessellation primitive generator to compute the ?nal position and other
attributes of the vertex. The tessellation evaluation shader can read the relative
location of the vertex in the subdivided output primitive, given by an (u;v) or
(u;v;w) coordinate, as well as the position and attributes of any or all of the ver-
tices in the input patch.
Tessellation operates only on patch primitives. Patch primitives are not sup-
ported by pipeline stages below the tessellation evaluation shader.
A non-separable program object or program pipeline object that includes a
tessellation shader of any kind must also include a vertex shader.
Errors
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL if tessellation is active and the primitive mode is not
PATCHES.
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL if the primitive mode isPATCHES and there is no active
tessellation evaluation program.
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL if the current program state has a tessellation shader but
no vertex shader.
11.2.1 Tessellation Control Shaders
The tessellation control shader consumes an input patch provided by the applica-
tion and emits a new output patch. The input patch is an array of vertices with at-
tributes corresponding to output variables written by the vertex shader. The output
patch consists of an array of vertices with attributes corresponding to per-vertex
output variables written by the tessellation control shader and a set of per-patch
attributes corresponding to per-patch output variables written by the tessellation
control shader. Tessellation control output variables are per-vertex by default, but
may be declared as per-patch using thepatch quali?er.
The number of vertices in the output patch is ?xed when the program is linked,
and is speci?ed in tessellation control shader source code using the outputlayout
quali?er vertices, as described in the OpenGL Shading Language Speci?ca-
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 411
tion. A program will fail to link if the output patch vertex count is not speci?ed
by any tessellation control shader object attached to the program, if it is speci-
?ed differently by multiple tessellation control shader objects, if it is less than or
equal to zero, or if it is greater than the implementation-dependent maximum patch
size. The output patch vertex count may be queried by calling GetProgramiv with
pnameTESS_CONTROL_OUTPUT_VERTICES.
Tessellation control shaders are created as described in section 7.1, using a type
ofTESS_CONTROL_SHADER. When a new input patch is received, the tessellation
control shader is run once for each vertex in the output patch. The tessellation con-
trol shader invocations collectively specify the per-vertex and per-patch attributes
of the output patch. The per-vertex attributes are obtained from the per-vertex out-
put variables written by each invocation. Each tessellation control shader invoca-
tion may only write to per-vertex output variables corresponding to its own output
patch vertex. The output patch vertex number corresponding to a given tessellation
control shader invocation is given by the built-in variablegl_InvocationID. Per-
patch attributes are taken from the per-patch output variables, which may be writ-
ten by any tessellation control shader invocation. While tessellation control shader
invocations may read any per-vertex and per-patch output variable and write any
per-patch output variable, reading or writing output variables also written by other
invocations has ordering hazards discussed below.
11.2.1.1 Tessellation Control Shader Variables
Tessellation control shaders can access uniforms belonging to the current program
object. Limits on uniform storage and methods for manipulating uniforms are
described in section 7.6.
Tessellation control shaders also have access to samplers to perform texturing
operations, as described in section 7.11.
Tessellation control shaders can access the transformed attributes of all vertices
for their input primitive using input variables. A vertex shader writing to output
variables generates the values of these input variables. Values for any inputs that
are not written by a vertex shader are unde?ned.
Additionally, tessellation control shaders can write to one or more output vari-
ables including per-vertex attributes for the vertices of the output patch and per-
patch attributes of the patch. Tessellation control shaders can also write to a set
of built-in per-vertex and per-patch outputs de?ned in the OpenGL Shading Lan-
guage. The per-vertex and per-patch attributes of the output patch are used by the
tessellation primitive generator (section 11.2.2) and may be read by a tessellation
evaluation shader (section 11.2.3).
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 412
11.2.1.2 Tessellation Control Shader Execution Environment
If there is an active program for the tessellation control stage, the executable ver-
sion of the program’s tessellation control shader is used to process patches result-
ing from the primitive assembly stage. When tessellation control shader execu-
tion completes, the input patch is consumed. A new patch is assembled from the
per-vertex and per-patch output variables written by the shader and is passed to
subsequent pipeline stages.
There are several special considerations for tessellation control shader execu-
tion described in the following sections.
11.2.1.2.1 Texture Access Section 11.1.3.1 describes texture lookup function-
ality accessible to a vertex shader. The texel fetch and texture size query function-
ality described there also applies to tessellation control shaders.
11.2.1.2.2 Tessellation Control Shader Inputs Section 7.1(“Built-In Vari-
ables”) of the OpenGL Shading Language Specification describes the built-in vari-
able arraygl_in available as input to a tessellation control shader. gl_in receives
values from equivalent built-in output variables written by the vertex shader (sec-
tion 11.1.3). Each array element of gl_in is a structure holding values for a spe-
ci?c vertex of the input patch. The length ofgl_in is equal to the implementation-
dependent maximum patch size (gl_MaxPatchVertices). Behavior is unde-
?ned if gl_in is indexed with a vertex index greater than or equal to the current
patch size. The members of each element of the gl_in array are gl_Position,
gl_PointSize,gl_CullDistance, andgl_ClipDistance.
Tessellation control shaders have available several other built-in input variables
not replicated per-vertex and not contained ingl_in, including:
 The variable gl_PatchVerticesIn holds the number of vertices in the
input patch being processed by the tessellation control shader.
 The variablegl_PrimitiveID is ?lled with the number of primitives pro-
cessed by the drawing command which generated the input vertices. The
?rst primitive generated by a drawing command is numbered zero, and the
primitive ID counter is incremented after every individual point, line, or tri-
angle primitive is processed. Restarting a primitive topology using the prim-
itive restart index has no effect on the primitive ID counter.
 The variable gl_InvocationID holds an invocation number for the cur-
rent tessellation control shader invocation. Tessellation control shaders are
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 413
invoked once per output patch vertex, and invocations are numbered begin-
ning with zero.
Similarly to the built-in inputs, each user-de?ned input variable has a value
for each vertex and thus needs to be declared as an array, or inside an input block
declared as an array. Declaring an array size is optional. If no size is speci?ed,
it will be taken from the implementation-dependent maximum patch size (gl_-
MaxPatchVertices). If a size is speci?ed, it must match the maximum patch
size; otherwise, a compile or link error will occur. Since the array size may be
larger than the number of vertices found in the input patch, behavior is unde?ned
if a per-vertex input variable is accessed using an index greater than or equal to the
number of vertices in the input patch.
Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of input variables
that can be read by the tessellation control shader, given by the value of the
implementation-dependent constantMAX_TESS_CONTROL_INPUT_COMPONENTS.
When a program is linked, all components of any input variable read by a tes-
sellation control shader will count against this limit. A program whose tessellation
control shader exceeds this limit may fail to link, unless device-dependent opti-
mizations are able to make the program ?t within available hardware resources.
Component counting rules for different variable types and variable declarations
are the same as forMAX_VERTEX_OUTPUT_COMPONENTS (see section 11.1.2.1).
11.2.1.2.3 Tessellation Control Shader Outputs Section 7.1(“Built-In Vari-
ables”) of the OpenGL Shading Language Specification describes the built-in vari-
able arraygl_out available as an output for a tessellation control shader. gl_out
passes values to equivalent built-in input variables read by subsequent shader stages
or to subsequent ?xed functionality vertex processing pipeline stages. Each array
element ofgl_out is a structure holding values for a speci?c vertex of the output
patch. The length ofgl_out is equal to the output patch size speci?ed in the tessel-
lation control shader outputlayout declaration. The members of each element of
thegl_out array aregl_Position,gl_PointSize, gl_ClipDistance, and
gl_CullDistance, and behave identically to equivalently named vertex shader
outputs (section 11.1.3).
Tessellation control shaders additionally have two built-in per-patch output ar-
rays, gl_TessLevelOuter and gl_TessLevelInner. These arrays are not
replicated for each output patch vertex and are not members of gl_out. gl_-
TessLevelOuter is an array of four ?oating-point values specifying the approxi-
mate number of segments that the tessellation primitive generator should use when
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 414
subdividing each outer edge of the primitive it subdivides. gl_TessLevelInner
is an array of two ?oating-point values specifying the approximate number of seg-
ments used to produce a regularly-subdivided primitive interior. The values writ-
ten togl_TessLevelOuter andgl_TessLevelInner need not be integers, and
their interpretation depends on the type of primitive the tessellation primitive gener-
ator will subdivide and other tessellation parameters, as discussed in the following
section.
A tessellation control shader may also declare user-de?ned per-vertex output
variables. User-de?ned per-vertex output variables are declared with the quali?er
out and have a value for each vertex in the output patch. Such variables must be
declared as arrays or inside output blocks declared as arrays. Declaring an array
size is optional. If no size is speci?ed, it will be taken from the output patch size
declared in the shader. If a size is speci?ed, it must match the maximum patch size;
otherwise, a compile or link error will occur.
While per-vertex output variables are declared as arrays indexed by vertex
number, each tessellation control shader invocation may write only to those out-
puts corresponding to its output patch vertex. Tessellation control shaders must
use the input variablegl_InvocationID as the vertex number index when writ-
ing to per-vertex output variables.
Additionally, a tessellation control shader may declare per-patch output vari-
ables using the quali?erpatch out. Unlike per-vertex outputs, per-patch outputs
do not correspond to any speci?c vertex in the patch, and are not indexed by vertex
number. Per-patch outputs declared as arrays have multiple values for the output
patch; similarly declared per-vertex outputs would indicate a single value for each
vertex in the output patch. User-de?ned per-patch outputs are not used by the tes-
sellation primitive generator, but may be read by tessellation evaluation shaders.
There are several limits on the number of components of output variables that
can be written by the tessellation control shader. The number of components
of active per-vertex output variables may not exceed the value of MAX_TESS_-
CONTROL_OUTPUT_COMPONENTS. The number of components of active per-patch
output variables may not exceed the value of MAX_TESS_PATCH_COMPONENTS.
The built-in outputs gl_TessLevelOuter and gl_TessLevelInner are not
counted against the per-patch limit. The total number of components of active per-
vertex and per-patch outputs is derived by multiplying the per-vertex output com-
ponent count by the output patch size and then adding the per-patch output compo-
nent count. The total component count may not exceed MAX_TESS_CONTROL_-
TOTAL_OUTPUT_COMPONENTS.
When a program is linked, all components of any output variable written by a
tessellation control shader will count against this limit. A program exceeding any
of these limits may fail to link, unless device-dependent optimizations are able to
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 415
make the program ?t within available hardware resources.
Component counting rules for different variable types and variable declarations
are the same as forMAX_VERTEX_OUTPUT_COMPONENTS (see section 11.1.2.1).
11.2.1.2.4 Tessellation Control Shader Execution Order For tessellation
control shaders with a declared output patch size greater than one, the shader is
invoked more than once for each input patch. The order of execution of one tessel-
lation control shader invocation relative to the other invocations for the same input
patch is largely unde?ned. The built-in function barrier provides some control
over relative execution order. When a tessellation control shader calls thebarrier
function, its execution pauses until all other invocations have also called the same
function. Output variable assignments performed by any invocation executed prior
to callingbarrier will be visible to any other invocation after the call tobarrier
returns. Shader output values read in one invocation but written by another may
be unde?ned without proper use of barrier; full rules are found in the OpenGL
Shading Language Specification.
The barrier function may only be called inside the main entry point of the
tessellation control shader and may not be called in code containing potentially di-
vergent ?ow of control. In particular,barrier may not be called inside aswitch
statement, in either sub-statement of anif statement, inside a do, for, orwhile
loop, or at any point after a return statement in the functionmain.
11.2.2 Tessellation Primitive Generation
If a tessellation evaluation shader is present, the tessellation primitive generator
consumes the input patch and produces a new set of basic primitives (points, lines,
or triangles). These primitives are produced by subdividing a geometric primitive
(rectangle or triangle) according to the per-patch tessellation levels written by the
tessellation control shader, if present, or taken from default patch parameter val-
ues. This subdivision is performed in an implementation-dependent manner. If no
tessellation evaluation shader is present, the tessellation primitive generator passes
incoming primitives through without modi?cation.
The type of subdivision performed by the tessellation primitive generator is
speci?ed by an input layout declaration in the tessellation evaluation shader us-
ing one of the identi?ers triangles, quads, and isolines. For triangles,
the primitive generator subdivides a triangle primitive into smaller triangles. For
quads, the primitive generator subdivides a rectangle primitive into smaller tri-
angles. For isolines, the primitive generator subdivides a rectangle primitive
into a collection of line segments arranged in strips stretching horizontally across
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 416
the rectangle. Each vertex produced by the primitive generator has an associated
(u;v;w) or (u;v) position in a normalized parameter space, with parameter values
in the range [0; 1], as illustrated in ?gure 11.1. Fortriangles, the vertex position
is a barycentric coordinate (u;v;w), whereu +v +w = 1, and indicates the rela-
tive in?uence of the three vertices of the triangle on the position of the vertex. For
quads and isolines, the position is a (u;v) coordinate indicating the relative
horizontal and vertical position of the vertex relative to the subdivided rectangle.
The subdivision process is explained in more detail in subsequent sections.
When no tessellation control shader is present, the tessellation levels are taken
from default patch tessellation levels. These default levels are set by calling
void PatchParameterfv(enum pname,const
float *values );
If pname isPATCH_DEFAULT_OUTER_LEVEL, values speci?es an array of four
?oating-point values corresponding to the four outer tessellation levels for each
subsequent patch. If pname is PATCH_DEFAULT_INNER_LEVEL, values speci?es
an array of two ?oating-point values corresponding to the two inner tessellation
levels.
A patch is discarded by the tessellation primitive generator if any relevant outer
tessellation level is less than or equal to zero. Patches will also be discarded if
any relevant outer tessellation level corresponds to a ?oating-point NaN (not a
number) in implementations supporting NaN. When patches are discarded, no new
primitives will be generated and the tessellation evaluation program will not be run.
Forquads, all four outer levels are relevant. Fortriangles andisolines, only
the ?rst three or two outer levels, respectively, are relevant. Negative inner levels
will not cause a patch to be discarded; they will be clamped as described below.
Each of the tessellation levels is used to determine the number and spacing
of segments used to subdivide a corresponding edge. The method used to derive
the number and spacing of segments is speci?ed by an input layout declaration
in the tessellation evaluation shader using one of the identi?ersequal_spacing,
fractional_even_spacing, orfractional_odd_spacing. If no spacing is
speci?ed in the tessellation evaluation shader,equal_spacing will be used.
Ifequal_spacing is used, the ?oating-point tessellation level is ?rst clamped
to the range [1;max], where max is the implementation-dependent maximum tes-
sellation level (the value of MAX_TESS_GEN_LEVEL). The result is rounded up to
the nearest integer n, and the corresponding edge is divided into n segments of
equal length in (u;v) space.
Iffractional_even_spacing is used, the tessellation level is ?rst clamped
to the range [2;max] and then rounded up to the nearest even integer n. If
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 417
Figure 11.1. Domain parameterization for tessellation generator primitive modes
(triangles, quads, or isolines). The coordinates illustrate the value of gl_-
TessCoord at the corners of the domain. The labels on the edges indicate the
inner (IL0 and IL1) and outer (OL0 through OL3) tessellation level values used to
control the number of subdivisions along each edge of the domain.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 418
fractional_odd_spacing is used, the tessellation level is clamped to the range
[1;max  1] and then rounded up to the nearest odd integern. If n is one, the edge
will not be subdivided. Otherwise, the corresponding edge will be divided into
n  2 segments of equal length, and two additional segments of equal length that
are typically shorter than the other segments. The length of the two additional seg-
ments relative to the others will decrease monotonically with the value ofn f,
wheref is the clamped ?oating-point tessellation level. Whenn f is zero, the
additional segments will have equal length to the other segments. As n f ap-
proaches 2.0, the relative length of the additional segments approaches zero. The
two additional segments should be placed symmetrically on opposite sides of the
subdivided edge. The relative location of these two segments is unde?ned, but
must be identical for any pair of subdivided edges with identical values off.
When the tessellation primitive generator produces triangles (in the
triangles or quads modes), the orientation of all triangles can be speci?ed by
an inputlayout declaration in the tessellation evaluation shader using the identi-
?erscw andccw. If the order iscw, the vertices of all generated triangles will have
a clockwise ordering in (u;v) or (u;v;w) space, as illustrated in ?gure 11.1. If the
order isccw, the vertices will be speci?ed in counter-clockwise order. If no layout
is speci?ed,ccw will be used.
For all primitive modes, the tessellation primitive generator is capable of gen-
erating points instead of lines or triangles. If an input layout declaration in the
tessellation evaluation shader speci?es the identi?er point_mode, the primitive
generator will generate one point for each distinct vertex produced by tessellation.
Otherwise, the primitive generator will produce a collection of line segments or
triangles according to the primitive mode. When tessellating triangles or quads in
point mode with fractional odd spacing, the tessellation primitive generator may
produce ”interior” vertices that are positioned on the edge of the patch if an inner
tessellation level is less than or equal to one. Such vertices are considered distinct
from vertices produced by subdividing the outer edge of the patch, even if there are
pairs of vertices with identical coordinates.
The points, lines, or triangles produced by the tessellation primitive generator
are passed to subsequent pipeline stages in an implementation-dependent order.
Errors
AnINVALID_ENUM error is generated if pname is notPATCH_DEFAULT_-
OUTER_LEVEL orPATCH_DEFAULT_INNER_LEVEL.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 419
11.2.2.1 Triangle Tessellation
If the tessellation primitive mode is triangles, an equilateral triangle is subdi-
vided into a collection of triangles covering the area of the original triangle. First,
the original triangle is subdivided into a collection of concentric equilateral trian-
gles. The edges of each of these triangles are subdivided, and the area between
each triangle pair is ?lled by triangles produced by joining the vertices on the sub-
divided edges. The number of concentric triangles and the number of subdivisions
along each triangle except the outermost is derived from the ?rst inner tessellation
level. The edges of the outermost triangle are subdivided independently, using the
?rst, second, and third outer tessellation levels to control the number of subdivi-
sions of theu = 0 (left),v = 0 (bottom), andw = 0 (right) edges, respectively.
The second inner tessellation level and the fourth outer tessellation level have no
effect in this mode.
If the ?rst inner tessellation level and all three outer tessellation levels are ex-
actly one after clamping and rounding, only a single triangle with (u;v;w) co-
ordinates of (0; 0; 1), (1; 0; 0), and (0; 1; 0) is generated. If the inner tessellation
level is one and any of the outer tessellation levels is greater than one, the inner
tessellation level is treated as though it were originally speci?ed as 1 + and will
result in a two- or three-segment subdivision depending on the tessellation spac-
ing. When used with fractional odd spacing, the three-segment subdivision may
produce “inner” vertices positioned on the edge of the triangle.
If any tessellation level is greater than one, tessellation begins by producing a
set of concentric inner triangles and subdividing their edges. First, the three outer
edges are temporarily subdivided using the clamped and rounded ?rst inner tes-
sellation level and the speci?ed tessellation spacing, generatingn segments. For
the outermost inner triangle, the inner triangle is degenerate – a single point at the
center of the triangle – ifn is two. Otherwise, for each corner of the outer trian-
gle, an inner triangle corner is produced at the intersection of two lines extended
perpendicular to the corner’s two adjacent edges running through the vertex of the
subdivided outer edge nearest that corner. Ifn is three, the edges of the inner trian-
gle are not subdivided and it is the ?nal triangle in the set of concentric triangles.
Otherwise, each edge of the inner triangle is divided into n  2 segments, with
then  1 vertices of this subdivision produced by intersecting the inner edge with
lines perpendicular to the edge running through then  1 innermost vertices of the
subdivision of the outer edge. Once the outermost inner triangle is subdivided, the
previous subdivision process repeats itself, using the generated triangle as an outer
triangle. This subdivision process is illustrated in ?gure 11.2.
Once all the concentric triangles are produced and their edges are subdivided,
the area between each pair of adjacent inner triangles is ?lled completely with a
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 420
Figure 11.2. Inner triangle tessellation with inner tessellation levels of (a) ?ve and
(b) four, respectively (not to scale). Solid black circles depict vertices along the
edges of the concentric triangles. The edges of inner triangles are subdivided by
intersecting the edge with segments perpendicular to the edge passing through each
inner vertex of the subdivided outer edge. Dotted lines depict edges connecting
corresponding vertices on the inner and outer triangle edges.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 421
set of non-overlapping triangles. In this subdivision, two of the three vertices of
each triangle are taken from adjacent vertices on a subdivided edge of one triangle;
the third is one of the vertices on the corresponding edge of the other triangle.
If the innermost triangle is degenerate (i.e., a point), the triangle containing it is
subdivided into six triangles by connecting each of the six vertices on that triangle
with the center point. If the innermost triangle is not degenerate, that triangle is
added to the set of generated triangles as-is.
After the area corresponding to any inner triangles is ?lled, the primitive gener-
ator generates triangles to cover area between the outermost triangles and the out-
ermost inner triangles. To do this, the temporary subdivision of the outer triangle
edges above is discarded. Instead, theu = 0,v = 0, andw = 0 edges are subdi-
vided according to the ?rst, second, and third outer tessellation levels, respectively,
and the tessellation spacing. The original subdivision of the ?rst inner triangle is
retained. The area between the outer and ?rst inner triangles is completely ?lled by
non-overlapping triangles as described above. If the ?rst (and only) inner triangle
is degenerate, a set of triangles is produced by connecting each vertex on the outer
triangle edges with the center point.
After all triangles are generated, each vertex in the subdivided triangle is as-
signed a barycentric (u;v;w) coordinate based on its location relative to the three
vertices of the outer triangle.
The algorithm used to subdivide the triangular domain in (u;v;w) space into
individual triangles is implementation-dependent. However, the set of triangles
produced will completely cover the domain, and no portion of the domain will
be covered by multiple triangles. The order in which the generated triangles are
passed to subsequent pipeline stages and the order of the vertices in those triangles
are both implementation-dependent. However, when depicted in a manner similar
to ?gure 11.2, the order of the vertices in the generated triangles will be either all
clockwise or all counter-clockwise, according to the vertex orderlayout declara-
tion.
11.2.2.2 Quad Tessellation
If the tessellation primitive mode is quads, a rectangle is subdivided into a col-
lection of triangles covering the area of the original rectangle. First, the original
rectangle is subdivided into a regular mesh of rectangles, where the number of
rectangles along theu = 0 andu = 1 (vertical) andv = 0 andv = 1 (horizon-
tal) edges are derived from the ?rst and second inner tessellation levels, respec-
tively. All rectangles, except those adjacent to one of the outer rectangle edges,
are decomposed into triangle pairs. The outermost rectangle edges are subdivided
independently, using the ?rst, second, third, and fourth outer tessellation levels to
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 422
control the number of subdivisions of the u = 0 (left), v = 0 (bottom), u = 1
(right), andv = 1 (top) edges, respectively. The area between the inner rectangles
of the mesh and the outer rectangle edges is ?lled by triangles produced by joining
the vertices on the subdivided outer edges to the vertices on the edges of the inner
rectangle mesh.
If both clamped inner tessellation levels and all four clamped outer tessella-
tion levels are exactly one, only a single triangle pair covering the outer rectangle
is generated. Otherwise, if either clamped inner tessellation level is one, that tes-
sellation level is treated as though it were originally speci?ed as 1 +, and will
result in a two- or three-segment subdivision depending on the tessellation spac-
ing. When used with fractional odd spacing, the three-segment subdivision may
produce “inner” vertices positioned on the edge of the rectangle.
If any tessellation level is greater than one, tessellation begins by subdividing
the u = 0 and u = 1 edges of the outer rectangle into m segments using the
clamped and rounded ?rst inner tessellation level and the tessellation spacing. The
v = 0 and v = 1 edges are subdivided into n segments using the second inner
tessellation level. Each vertex on theu = 0 andv = 0 edges is joined with the
corresponding vertex on theu = 1 andv = 1 edges to produce a set of vertical
and horizontal lines that divide the rectangle into a grid of smaller rectangles. The
primitive generator emits a pair of non-overlapping triangles covering each such
rectangle not adjacent to an edge of the outer rectangle. The boundary of the re-
gion covered by these triangles forms an inner rectangle, the edges of which are
subdivided by the grid vertices that lie on the edge. If either m or n is two, the
inner rectangle is degenerate, and one or both of the rectangle’s “edges” consist of
a single point. This subdivision is illustrated in ?gure 11.3.
After the area corresponding to the inner rectangle is ?lled, the primitive gen-
erator must produce triangles to cover area between the inner and outer rectangles.
To do this, the subdivision of the outer rectangle edges above is discarded. In-
stead, theu = 0,v = 0,u = 1, andv = 1 edges are subdivided according to the
?rst, second, third, and fourth outer tessellation levels, respectively, and the tes-
sellation spacing. The original subdivision of the inner rectangle is retained. The
area between the outer and inner rectangles is completely ?lled by non-overlapping
triangles. Two of the three vertices of each triangle are adjacent vertices on a sub-
divided edge of one rectangle; the third is one of the vertices on the corresponding
edge of the other triangles. If either edge of the innermost rectangle is degenerate,
the area near the corresponding outer edge is ?lled by connecting each vertex on
the outer edge with the single vertex making up the inner “edge”.
The algorithm used to subdivide the rectangular domain in (u;v) space into
individual triangles is implementation-dependent. However, the set of triangles
produced will completely cover the domain, and no portion of the domain will
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 423
Figure 11.3. Inner quad tessellation with inner tessellation levels of (a) (4; 2) and
(b) (7; 4), respectively. Gray regions on the bottom ?gure depict the 10 inner rectan-
gles, each of which will be subdivided into two triangles. Solid black circles depict
vertices on the boundary of the outer and inner rectangles, where the inner rectangle
on the top ?gure is degenerate (a single line segment). Dotted lines depict the hor-
izontal and vertical edges connecting corresponding vertices on the inner and outer
rectangle edges.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 424
be covered by multiple triangles. The order in which the generated triangles are
passed to subsequent pipeline stages and the order of the vertices in those triangles
are both implementation-dependent. However, when depicted in a manner similar
to ?gure 11.3, the order of the vertices in the generated triangles will be either all
clockwise or all counter-clockwise, according to the vertex orderlayout declara-
tion.
11.2.2.3 Isoline Tessellation
If the tessellation primitive mode isisolines, a set of independent horizontal line
segments is drawn. The segments are arranged into connected strips called isolines,
where the vertices of each isoline have a constantv coordinate andu coordinates
covering the full range [0; 1]. The number of isolines generated is derived from the
?rst outer tessellation level; the number of segments in each isoline is derived from
the second outer tessellation level. Both inner tessellation levels and the third and
fourth outer tessellation levels have no effect in this mode.
As with quad tessellation above, isoline tessellation begins with a rectangle.
The u = 0 and u = 1 edges of the rectangle are subdivided according to the
?rst outer tessellation level. For the purposes of this subdivision, the tessellation
spacing is ignored and treated asequal_spacing. An isoline is drawn connecting
each vertex on theu = 0 rectangle edge with the corresponding vertex on theu = 1
rectangle edge, except that no line is drawn between (0; 1) and (1; 1). If the number
of isolines on the subdividedu = 0 andu = 1 edges isn, this process will result
1 2 n 1
inn equally spaced lines with constantv coordinates of 0; ; ;:::; .
n n n
Each of then isolines is then subdivided according to the second outer tessella-
tion level and the tessellation spacing, resulting inm line segments. Each segment
of each line is emitted by the tessellation primitive generator, as illustrated in ?g-
ure 11.4.
The order in which the generated line segments are passed to subsequent
pipeline stages and the order of the vertices in each generated line segment are
both implementation-dependent.
11.2.3 Tessellation Evaluation Shaders
If active, the tessellation evaluation shader takes the (u;v) or (u;v;w) location
of each vertex in the primitive subdivided by the tessellation primitive generator,
and generates a vertex with a position and associated attributes. The tessellation
evaluation shader can read any of the vertices of its input patch, which is the output
patch produced by the tessellation control shader (if present) or provided by the
application and transformed by the vertex shader (if no control shader is used).
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 425
Figure 11.4. Isoline tessellation with the ?rst two outer tessellation levels of (a)
(1; 3) and (b) (4; 6), respectively. Line segments connecting the vertices marked
with solid black circles are emitted by the primitive generator. Vertices marked
with empty circles correspond to (u;v) coordinates of (0; 1) and (1; 1), where no
line segments are generated.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 426
Tessellation evaluation shaders are created as described in section 7.1, using a type
ofTESS_EVALUATION_SHADER.
Each invocation of the tessellation evaluation shader writes the attributes of
exactly one vertex. The number of vertices evaluated per patch depends on the
tessellation level values computed by the tessellation control shaders (if present)
or speci?ed as patch parameters. Tessellation evaluation shader invocations run
independently, and no invocation can access the variables belonging to another
invocation. All invocations are capable of accessing all the vertices of their corre-
sponding input patch.
If a tessellation control shader is present, the number of the vertices in the
input patch is ?xed and is equal to the tessellation control shader output patch size
parameter in effect when the program was last linked. If no tessellation control
shader is present, the input patch is provided by the application and can have a
variable number of vertices, as speci?ed by PatchParameteri.
11.2.3.1 Tessellation Evaluation Shader Variables
Tessellation evaluation shaders can access uniforms belonging to the current pro-
gram object. Limits on uniform storage and methods for manipulating uniforms
are described in section 7.6.
Tessellation evaluation shaders also have access to samplers to perform textur-
ing operations, as described in section 7.11.
Tessellation evaluation shaders can access the transformed attributes of all ver-
tices for their input primitive using input variables. If active, a tessellation control
shader writing to output variables generates the values of these input variables. If
no tessellation control shader is active, input variables will be obtained from vertex
shader outputs. Values for any input variables that are not written by a vertex or
tessellation control shader are unde?ned.
Additionally, tessellation evaluation shaders can write to one or more output
variables that will be passed to subsequent programmable shader stages or ?xed
functionality vertex pipeline stages.
11.2.3.2 Tessellation Evaluation Shader Execution Environment
If there is an active program for the tessellation evaluation stage, the executable
version of the program’s tessellation evaluation shader is used to process vertices
produced by the tessellation primitive generator. During this processing, the shader
may access the input patch processed by the primitive generator. When tessellation
evaluation shader execution completes, a new vertex is assembled from the output
variables written by the shader and is passed to subsequent pipeline stages.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 427
There are several special considerations for tessellation evaluation shader exe-
cution described in the following sections.
11.2.3.2.1 Texture Access Section 11.1.3.1 describes texture lookup function-
ality accessible to a vertex shader. The texel fetch and texture size query function-
ality described there also applies to tessellation evaluation shaders.
11.2.3.3 Tessellation Evaluation Shader Inputs
Section 7.1(“Built-In Variables”) of the OpenGL Shading Language Specification
describes the built-in variable arraygl_in available as input to a tessellation evalu-
ation shader. gl_in receives values from equivalent built-in output variables writ-
ten by a previous shader (section 11.1.3). If a tessellation control shader is active,
the values ofgl_in will be taken from tessellation control shader outputs. Other-
wise, they will be taken from vertex shader outputs. Each array element ofgl_in
is a structure holding values for a speci?c vertex of the input patch. The length
of gl_in is equal to the implementation-dependent maximum patch size (gl_-
MaxPatchVertices). Behavior is unde?ned if gl_in is indexed with a vertex
index greater than or equal to the current patch size. The members of each element
of thegl_in array aregl_Position,gl_PointSize, gl_ClipDistance, and
gl_CullDistance.
Tessellation evaluation shaders have available several other built-in input vari-
ables not replicated per-vertex and not contained ingl_in, including:
 The variables gl_PatchVerticesIn and gl_PrimitiveID are ?lled
with the number of the vertices in the input patch and a primitive number,
respectively. They behave exactly as the identically named inputs for tessel-
lation control shaders.
 The variable gl_TessCoord is a three-component ?oating-point vector
consisting of the (u;v;w) coordinate of the vertex being processed by the
tessellation evaluation shader. The values of u, v, and w are in the range
[0; 1], and vary linearly across the primitive being subdivided. For tessella-
tion primitive modes of quads or isolines, the w value is always zero.
The (u;v;w) coordinates are generated by the tessellation primitive gen-
erator in a manner dependent on the primitive mode, as described in sec-
tion 11.2.2. gl_TessCoord is not an array; it speci?es the location of the
vertex being processed by the tessellation evaluation shader, not of any ver-
tex in the input patch.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 428
 The variables gl_TessLevelOuter and gl_TessLevelInner are ar-
rays holding outer and inner tessellation levels of the patch, as used by
the tessellation primitive generator. If a tessellation control shader is ac-
tive, the tessellation levels will be taken from the corresponding outputs of
the tessellation control shader. Otherwise, the default levels provided as
patch parameters are used. Tessellation level values loaded in these vari-
ables will be prior to the clamping and rounding operations performed by
the primitive generator as described in section 11.2.2. For triangular tes-
sellation, gl_TessLevelOuter[3] and gl_TessLevelInner[1] will
be unde?ned. For isoline tessellation, gl_TessLevelOuter[2], gl_-
TessLevelOuter[3], and both values in gl_TessLevelInner are un-
de?ned.
A tessellation evaluation shader may also declare user-de?ned per-vertex input
variables. User-de?ned per-vertex input variables are declared with the quali?er
in and have a value for each vertex in the input patch. User-de?ned per-vertex
input variables have a value for each vertex and thus need to be declared as arrays
or inside input blocks declared as arrays. Declaring an array size is optional. If
no size is speci?ed, it will be taken from the implementation-dependent maximum
patch size (gl_MaxPatchVertices). If a size is speci?ed, it must match the
maximum patch size; otherwise, a compile or link error will occur. Since the array
size may be larger than the number of vertices found in the input patch, behavior is
unde?ned if a per-vertex input variable is accessed using an index greater than or
equal to the number of vertices in the input patch.
Additionally, a tessellation evaluation shader may declare per-patch input vari-
ables using the quali?erpatch in. Unlike per-vertex inputs, per-patch inputs do
not correspond to any speci?c vertex in the patch, and are not indexed by vertex
number. Per-patch inputs declared as arrays have multiple values for the input
patch; similarly declared per-vertex inputs would indicate a single value for each
vertex in the output patch. User-de?ned per-patch input variables are ?lled with
corresponding per-patch output values written by the tessellation control shader. If
no tessellation control shader is active, all such variables are unde?ned.
Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of per-vertex and
per-patch input variables that can be read by the tessellation evaluation shader,
given by the values of the implementation-dependent constants MAX_TESS_-
EVALUATION_INPUT_COMPONENTS and MAX_TESS_PATCH_COMPONENTS, re-
spectively. The built-in inputsgl_TessLevelOuter andgl_TessLevelInner
are not counted against the per-patch limit.
When a program is linked, all components of any input variable read by a tes-
OpenGL 4.6 (Core Pro?le) - February 2, 201911.2. TESSELLATION 429
sellation evaluation shader will count against this limit. A program whose tessella-
tion evaluation shader exceeds this limit may fail to link, unless device-dependent
optimizations are able to make the program ?t within available hardware resources.
Component counting rules for different variable types and variable declarations
are the same as forMAX_VERTEX_OUTPUT_COMPONENTS (see section 11.1.2.1).
11.2.3.4 Tessellation Evaluation Shader Outputs
Tessellation evaluation shaders have a number of built-in output variables used
to pass values to equivalent built-in input variables read by subsequent shader
stages or to subsequent ?xed functionality vertex processing pipeline stages. These
variables are gl_Position, gl_PointSize, gl_ClipDistance, and gl_-
CullDistance, and all behave identically to equivalently named vertex shader
outputs (see section 11.1.3). A tessellation evaluation shader may also declare
user-de?ned per-vertex output variables.
Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of output variables
that can be written by the tessellation evaluation shader, given by the values
of the implementation-dependent constant MAX_TESS_EVALUATION_OUTPUT_-
COMPONENTS.
When a program is linked, all components of any output variable written by
a tessellation evaluation shader will count against this limit. A program whose
tessellation evaluation shader exceeds this limit may fail to link, unless device-
dependent optimizations are able to make the program ?t within available hardware
resources.
Component counting rules for different variable types and variable declarations
are the same as forMAX_VERTEX_OUTPUT_COMPONENTS (see section 11.1.2.1).
11.2.4 Tessellation Shader Queries
Tessellation shader queries use query objects to track the number of tessellation
control shader and tessellation evaluation shader invocations.
When BeginQuery is called with a target of TESS_CONTROL_SHADER_-
PATCHES, the tessellation control shader patches count maintained by the GL is
set to zero. When a tessellation control shader patches query is active, the counter
is incremented every time a patch is processed by the tessellation control shader
stage (see section 11.2.1).
When BeginQuery is called with a target of TESS_EVALUATION_SHADER_-
INVOCATIONS, the tessellation evaluation shader invocations count maintained by
the GL is set to zero. When a tessellation evaluation shader invocations query is
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 430
active, the counter is incremented every time the tessellation evaluation shader is
invoked (see section 11.2.3).
The result of tessellation shader queries may be implementation dependent due
to reasons described in section 11.1.3.
11.3 Geometry Shaders
After vertices are processed, they are arranged into primitives, as described in sec-
tion 10.1. This section describes optional geometry shaders, an additional pipeline
stage de?ning operations to further process those primitives. Geometry shaders op-
erate on a single primitive at a time and emit one or more output primitives, all of
the same type, which are then processed like an equivalent OpenGL primitive spec-
i?ed by the application. The original primitive is discarded after geometry shader
execution. The inputs available to a geometry shader are the transformed attributes
of all the vertices that belong to the primitive. Additional adjacency primitives are
available which also make the transformed attributes of neighboring vertices avail-
able to the shader. The results of the shader are a new set of transformed vertices,
arranged into primitives by the shader.
The geometry shader pipeline stage is inserted after primitive assembly, prior
to transform feedback (section 13.3).
Geometry shaders are created as described in section 7.1 using a type of
GEOMETRY_SHADER. They are attached to and used in program objects as described
in section 7.3. When the program object currently in use includes a geometry
shader, its geometry shader is considered active, and is used to process primitives.
If the program object has no geometry shader, this stage is bypassed.
A non-separable program object or program pipeline object that includes a
geometry shader must also include a vertex shader.
Errors
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL if the current program state has a geometry shader but
no vertex shader.
11.3.1 Geometry Shader Input Primitives
A geometry shader can operate on one of ?ve input primitive types. Depending on
the input primitive type, one to six input vertices are available when the shader is
executed. Each input primitive type supports a subset of the primitives provided by
the GL.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 431
Errors
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL if a geometry shader is active and the primitive mode pa-
rameter is incompatible with the input primitive type of the geometry shader of
the active geometry program object, as discussed below. If a tessellation evalu-
ation shader is not active, the mode parameter passed to drawing commands is
used for purposes of this error check. Otherwise, the type of primitive emitted
by that shader is used.
A geometry shader that accesses more input vertices than are available for a
given input primitive type can be successfully compiled, because the input prim-
itive type is not part of the shader object. However, a program object containing
a shader object that accesses more input vertices than are available for the input
primitive type of the program object will not link.
The input primitive type is speci?ed in the geometry shader source code using
an input layout quali?er, as described in the OpenGL Shading Language Speci-
?cation. A program will fail to link if the input primitive type is not speci?ed by
any geometry shader object attached to the program, or if it is speci?ed differently
by multiple geometry shader objects. The input primitive type may be queried
by calling GetProgramiv with pname GEOMETRY_INPUT_TYPE. The supported
types and the corresponding OpenGL Shading Language input layout quali?er
keywords are:
Points (points)
Geometry shaders that operate on points are valid only for the POINTS primi-
tive type. There is only a single vertex available for each geometry shader invoca-
tion.
Lines (lines)
Geometry shaders that operate on line segments are valid only for the LINES,
LINE_STRIP, and LINE_LOOP primitive types. There are two vertices available
for each geometry shader invocation. The ?rst vertex refers to the vertex at the
beginning of the line segment and the second vertex refers to the vertex at the end
of the line segment. See also section 11.3.4.
Lines with Adjacency (lines_adjacency)
Geometry shaders that operate on line segments with adjacent vertices are valid
only for the LINES_ADJACENCY and LINE_STRIP_ADJACENCY primitive types.
There are four vertices available for each program invocation. The second vertex
refers to attributes of the vertex at the beginning of the line segment and the third
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 432
vertex refers to the vertex at the end of the line segment. The ?rst and fourth
vertices refer to the vertices adjacent to the beginning and end of the line segment,
respectively.
Triangles (triangles)
Geometry shaders that operate on triangles are valid for the TRIANGLES,
TRIANGLE_STRIP and TRIANGLE_FAN primitive types. There are three vertices
available for each program invocation. The ?rst, second and third vertices refer to
attributes of the ?rst, second and third vertex of the triangle, respectively.
Triangles with Adjacency (triangles_adjacency)
Geometry shaders that operate on triangles with adjacent vertices are valid
for the TRIANGLES_ADJACENCY and TRIANGLE_STRIP_ADJACENCY primitive
types. There are six vertices available for each program invocation. The ?rst, third
and ?fth vertices refer to attributes of the ?rst, second and third vertex of the tri-
angle, respectively. The second, fourth and sixth vertices refer to attributes of the
vertices adjacent to the edges from the ?rst to the second vertex, from the second
to the third vertex, and from the third to the ?rst vertex, respectively.
11.3.2 Geometry Shader Output Primitives
A geometry shader can generate primitives of one of three types. The supported
output primitive types are points (POINTS), line strips (LINE_STRIP), and triangle
strips (TRIANGLE_STRIP). The vertices output by the geometry shader are assem-
bled into points, lines, or triangles based on the output primitive type in the manner
described in section 10.7. The resulting primitives are then further processed as de-
scribed in section 11.3.4. If the number of vertices emitted by the geometry shader
is not suf?cient to produce a single primitive, nothing is drawn. The number of
vertices output by the geometry shader is limited to a maximum count speci?ed in
the shader.
The output primitive type and maximum output vertex count are speci?ed in
the geometry shader source code using an output layout quali?er, as described
in section 4.4.2.2(“Geometry Outputs”) of the OpenGL Shading Language Speci-
?cation. A program will fail to link if either the output primitive type or maximum
output vertex count are not speci?ed by any geometry shader object attached to the
program, or if they are speci?ed differently by multiple geometry shader objects.
The output primitive type and maximum output vertex count of a linked program
may be queried by calling GetProgramiv with pnamesGEOMETRY_OUTPUT_TYPE
andGEOMETRY_VERTICES_OUT, respectively.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 433
11.3.3 Geometry Shader Variables
Geometry shaders can access uniforms belonging to the current program object.
Limits on uniform storage and methods for manipulating uniforms are described in
section 7.6.
Geometry shaders also have access to samplers to perform texturing operations,
as described in section 7.11.
Geometry shaders can access the transformed attributes of all vertices for their
input primitive type using input variables. A vertex or tessellation shader (the
upstream shader for the geometry shader) writing to output variables generates
the values of these input variables. Values for any inputs that are not written by a
shader are unde?ned. Additionally, a geometry shader has access to a built-in input
that holds the ID of the current primitive. This ID is generated by the primitive
assembly stage preceding the geometry shader.
Additionally, geometry shaders can write to one or more output variables for
each vertex they output. These values are optionally ?atshaded (using the OpenGL
Shading Language quali?er flat) and clipped, then the clipped values interpo-
lated across the primitive (if not ?atshaded). The results of these interpolations are
available to the fragment shader.
11.3.4 Geometry Shader Execution Environment
If there is an active program for the geometry stage, the executable version of
the program’s geometry shader is used to process primitives resulting from the
primitive assembly stage.
There are several special considerations for geometry shader execution de-
scribed in the following sections.
11.3.4.1 Texture Access
Section 11.1.3.1 describes texture lookup functionality accessible to a vertex
shader. The texel fetch and texture size query functionality described there also
applies to geometry shaders.
11.3.4.2 Instanced Geometry Shaders
For each input primitive received by the geometry shader pipeline stage, the ge-
ometry shader may be run once or multiple times. The number of times a geom-
etry shader should be executed for each input primitive may be speci?ed using a
layout quali?er in a geometry shader of a linked program. If the invocation count
is not speci?ed in anylayout quali?er, the invocation count will be one.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 434
Each separate geometry shader invocation is assigned a unique invocation num-
ber. For a geometry shader with N invocations, each input primitive spawns
N invocations, numbered 0 through N  1. The built-in input variable gl_-
InvocationID may be used by a geometry shader invocation to determine its
invocation number.
When executing instanced geometry shaders, the output primitives generated
from each input primitive are passed to subsequent pipeline stages using the shader
invocation number to order the output. The ?rst primitives received by the subse-
quent pipeline stages are those emitted by the shader invocation numbered zero,
followed by those from the shader invocation numbered one, and so forth. Addi-
tionally, all output primitives generated from a given input primitive are passed to
subsequent pipeline stages before any output primitives generated from subsequent
input primitives.
11.3.4.3 Geometry Shader Vertex Streams
Geometry shaders may emit primitives to multiple independent vertex streams.
Each vertex emitted by the geometry shader is directed at one of the vertex streams.
As vertices are received on each stream, they are arranged into primitives of the
type speci?ed by the geometry shader output primitive type. The shading language
built-in functions EndPrimitive and EndStreamPrimitive may be used to
end the primitive being assembled on a given vertex stream and start a new empty
primitive of the same type. If an implementation supportsN vertex streams, the
individual streams are numbered 0 throughN  1. There is no requirement on the
order of the streams to which vertices are emitted, and the number of vertices emit-
ted to each stream may be completely independent, subject only to implementation-
dependent output limits.
The primitives emitted to all vertex streams are passed to the transform feed-
back stage to be captured and written to buffer objects in the manner speci?ed
by the transform feedback state. The primitives emitted to all streams but stream
zero are discarded after transform feedback. Primitives emitted to stream zero are
passed to subsequent pipeline stages for clipping, rasterization, and subsequent
fragment processing.
Geometry shaders that emit vertices to multiple vertex streams are currently
limited to using only the points output primitive type. A program will fail to
link if it includes a geometry shader that calls the EmitStreamVertex built-in
function and has any other output primitive type parameter.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 435
11.3.4.4 Geometry Shader Inputs
Section 7.1(“Built-In Variables”) of the OpenGL Shading Language Specification
describes the built-in variable array gl_in[] available as input to a geometry
shader. gl_in[] receives values from equivalent built-in output variables writ-
ten by the upstream shader, and each array element of gl_in[] is a structure
holding values for a speci?c vertex of the input primitive. The length ofgl_in[]
is determined by the geometry shader input primitive type (see section 11.3.1). The
members of each element of thegl_in[] array are:
 Structure member gl_ClipDistance[] holds the per-vertex array of clip
distances, as written by the upstream shader to the built-in output variable
gl_ClipDistance[].
 Structure member gl_CullDistance[] holds the per-vertex array of cull
distances, as written by the upstream shader to the built-in output variable
gl_CullDistance[].
 Structure member gl_PointSize holds the per-vertex point size written
by the upstream shader to the built-in output variable gl_PointSize. If
the upstream shader does not write gl_PointSize, the value of gl_-
PointSize is unde?ned, regardless of the value of the enable PROGRAM_-
POINT_SIZE.
 Structure member gl_Position holds the per-vertex position written by
the upstream shader to the built-in output variablegl_Position. Note that
writing to gl_Position from either the upstream or geometry shader is
optional (also see section 7.1(“Built-In Variables”) of the OpenGL Shading
Language Specification).
Geometry shaders also have available the built-in input variable gl_-
PrimitiveIDIn, which is not an array and has no vertex shader equivalent. It
is ?lled with the number of primitives processed by the drawing command which
generated the input vertices. The ?rst primitive generated by a drawing command
is numbered zero, and the primitive ID counter is incremented after every individ-
ual point, line, or triangle primitive is processed. For triangles drawn in point or
line mode, the primitive ID counter is incremented only once, even though multiple
points or lines may eventually be drawn. Restarting a primitive topology using the
primitive restart index has no effect on the primitive ID counter.
Similarly to the built-in inputs, each user-de?ned input has a value for each
vertex and thus needs to be declared as an array or inside an input block declared
as an array. Declaring an array size is optional. If no size is speci?ed, it will be
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 436
inferred by the linker from the input primitive type. If a size is speci?ed, it must
match the number of vertices for the input primitive type; otherwise, a link error
will occur.
Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of input variables
that can be read by the geometry shader, given by the value of the implementation-
dependent constantMAX_GEOMETRY_INPUT_COMPONENTS.
When a program is linked, all components of any input read by a geometry
shader will count against this limit. A program whose geometry shader exceeds
this limit may fail to link, unless device-dependent optimizations are able to make
the program ?t within available hardware resources.
Component counting rules for different variable types and variable declarations
are the same as forMAX_VERTEX_OUTPUT_COMPONENTS (see section 11.1.2.1).
11.3.4.5 Geometry Shader Outputs
A geometry shader is limited in the number of vertices it may emit per invocation.
The maximum number of vertices a geometry shader can possibly emit is speci?ed
in the geometry shader source and may be queried after linking by calling Get-
Programiv with pname GEOMETRY_VERTICES_OUT. If a single invocation of a
geometry shader emits more vertices than this value, the emitted vertices may have
no effect.
There are two implementation-dependent limits on the value of GEOMETRY_-
VERTICES_OUT; it may not exceed the value of MAX_GEOMETRY_OUTPUT_-
VERTICES, and the product of the total number of vertices and the sum of all
components of all active output variables may not exceed the value of MAX_-
GEOMETRY_TOTAL_OUTPUT_COMPONENTS. LinkProgram will fail if it deter-
mines that the total component limit would be violated.
A geometry shader can write to built-in as well as user-de?ned output variables.
These values are expected to be interpolated across the primitive it outputs, unless
they are speci?ed to be ?at shaded. To enable seamlessly inserting or removing a
geometry shader from a program object, the rules, names and types of the built-in
and user-de?ned output variables are the same as for the vertex shader. Refer to
section 11.1.2.1, and to sections 4.3(“Storage Quali?ers”) and 7.1(“Built-In Vari-
ables”) of the OpenGL Shading Language Specification for more detail.
After a geometry shader emits a vertex, all output variables are unde?ned, as
described in section 8.15(“Geometry Shader Functions”) of the OpenGL Shading
Language Specification.
The built-in outputgl_Position is intended to hold the homogeneous vertex
position. Writinggl_Position is optional.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 437
The built-in outputs gl_ClipDistance and gl_CullDistance hold the
clip distance and cull distance, respectively, used in the clipping stage, as described
in section 13.7.
The built-in outputgl_PointSize, if written, holds the size of the point to be
rasterized, measured in pixels.
The built-in output gl_PrimitiveID holds the primitive ID counter read by
the fragment shader, replacing the value ofgl_PrimitiveID generated by draw-
ing commands when no geometry shader is active. The geometry shader must
write to gl_PrimitiveID for the provoking vertex (see section 13.6) of a prim-
itive being generated, or the primitive ID counter read by the fragment shader for
that primitive is unde?ned.
The built-in outputgl_Layer is used in layered rendering, and discussed fur-
ther in the next section.
The built-in output gl_ViewportIndex is used to direct rendering to one of
several viewports and is discussed further in the next section.
Similarly to the limit on vertex shader output components (see sec-
tion 11.1.2.1), there is a limit on the number of components of output variables that
can be written by the geometry shader, given by the value of the implementation-
dependent constantMAX_GEOMETRY_OUTPUT_COMPONENTS.
When a program is linked, all components of any output variable written by a
geometry shader will count against this limit. A program whose geometry shader
exceeds this limit may fail to link, unless device-dependent optimizations are able
to make the program ?t within available hardware resources.
Component counting rules for different variable types and variable declarations
are the same as forMAX_VERTEX_OUTPUT_COMPONENTS (see section 11.1.2.1).
11.3.4.6 Layer and Viewport Selection
Geometry shaders can be used to render to one of several different layers of cube
map textures, three-dimensional textures, or one- or two-dimensional texture ar-
rays. This functionality allows an application to bind an entire complex texture
to a framebuffer object, and render primitives to arbitrary layers computed at run
time. For example, it can be used to project and render a scene onto all six faces
of a cubemap texture in one pass. The layer to render to is speci?ed by writing
to the built-in output variable gl_Layer. Layered rendering requires the use of
framebuffer objects (see section 9.8).
Geometry shaders may also select the destination viewport for each output
primitive. The destination viewport for a primitive may be selected in the geom-
etry shader by writing to the built-in output variable gl_ViewportIndex. This
functionality allows a geometry shader to direct its output to a different viewport
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 438
for each primitive, or to draw multiple versions of a primitive into several different
viewports.
The speci?c vertex of a primitive that is used to select the rendering layer or
viewport index is implementation-dependent and thus portable applications will
assign the same layer and viewport index for all vertices in a primitive. The
vertex conventions followed forgl_Layer andgl_ViewportIndex may be de-
termined by calling GetIntegerv with pnames LAYER_PROVOKING_VERTEX and
VIEWPORT_INDEX_PROVOKING_VERTEX, respectively. For either query, if the
value returned is PROVOKING_VERTEX, then vertex selection follows the con-
vention speci?ed by ProvokingVertex (see section 13.6). If the value returned
is FIRST_VERTEX_CONVENTION, selection is always taken from the ?rst vertex
of a primitive. If the value returned is LAST_VERTEX_CONVENTION, the selec-
tion is always taken from the last vertex of a primitive. If the value returned is
UNDEFINED_VERTEX, the selection is not guaranteed to be taken from any speci?c
vertex in the primitive. The vertex considered the provoking vertex for particular
primitive types is given in table 13.2.
11.3.4.7 Primitive Type Mismatches and Drawing Commands
Errors
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL, and no fragments will be rendered, if a mismatch exists
between the type of primitive being drawn and the input primitive type of a ge-
ometry shader. A mismatch exists under any of the following conditions:
 the input primitive type of the current geometry shader isPOINTS and mode
is notPOINTS;
 the input primitive type of the current geometry shader is LINES and mode
is notLINES,LINE_STRIP, orLINE_LOOP;
 the input primitive type of the current geometry shader is TRIANGLES and
mode is notTRIANGLES,TRIANGLE_STRIP orTRIANGLE_FAN;
 the input primitive type of the current geometry shader is LINES_-
ADJACENCY and mode is not LINES_ADJACENCY or LINE_STRIP_-
ADJACENCY; or,
 the input primitive type of the current geometry shader is TRIANGLES_-
ADJACENCY and mode is not TRIANGLES_ADJACENCY or TRIANGLE_-
STRIP_ADJACENCY.
OpenGL 4.6 (Core Pro?le) - February 2, 201911.3. GEOMETRYSHADERS 439
11.3.5 Geometry Shader Queries
Geometry shader queries use query objects to track the number of geometry shader
invocations and the number of primitives those emitted.
When BeginQuery is called with a target of GEOMETRY_SHADER_-
INVOCATIONS, the geometry shader invocations count maintained by the GL is
set to zero. When a geometry shader invocations query is active, the counter is in-
cremented every time the geometry shader is invoked (see section 11.3). In case of
instanced geometry shaders (see section 11.3.4.2), the geometry shader invocations
count is incremented for each separate instanced invocation.
When BeginQuery is called with a target of GEOMETRY_SHADER_-
PRIMITIVES_EMITTED, the geometry shader output primitives count maintained
by the GL is set to zero. When a geometry shader primitives emitted query is ac-
tive, the counter is incremented every time the geometry shader emits a primitive
to a vertex stream. Implementations may or may not count primitives emitted to a
vertex stream that is not further processed by the GL (see section 11.3.2). Restart-
ing primitive topology using the shading language built-in functions EndPrimitive
or EndStreamPrimitive does not increment the geometry shader output primitives
count.
The result of geometry shader queries may be implementation dependent due
to reasons described in section 11.1.3.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 12
This chapter is only de?ned in the compatibility pro?le.
440Chapter 13
Fixed-Function Vertex
Post-Processing
After programmable vertex processing, the following ?xed-function operations are
applied to vertices of the resulting primitives:
 Transform feedback (see section 13.3).
 Primitive queries (see section 13.4).
 Flatshading (see section 13.6).
 Primitive clipping, including client-de?ned half-spaces (see section 13.7).
 Shader output clipping (see section 13.7.1).
 Perspective division on clip coordinates (see section 13.8).
 Viewport mapping, including depth range scaling (see section 13.8.1).
 Front face determination for polygon primitives (see section 14.6.1).
 Generic attribute clipping (see section 13.7.1).
Next, rasterization is performed on primitives as described in chapter 14.
13.1
This section is only de?ned in the compatibility pro?le.
44113.2. THELASTVERTEXPROCESSINGSTAGE 442
13.2 The Last Vertex Processing Stage
In the remainder of this chapter, the last vertex processing stage is the shader stage
which passes outputs on to the operations in this chapter.
The last vertex processing stage is:
 The geometry shader stage, if a geometry shader is active;
 Otherwise, the tessellation evaluation stage, if a tessellation evaluation
shader is active;
 Otherwise, the vertex shader stage, if a vertex shader is active.
13.3 Transform Feedback
In transform feedback mode, attributes of the vertices of transformed primitives
passed to the transform feedback stage are written out to one or more buffer objects.
The vertices are fed back before ?atshading and clipping. The transformed vertices
may be optionally discarded after being stored into one or more buffer objects, or
they can be passed on down to the clipping stage for further processing. The set of
attributes captured is determined when a program is linked.
Transform feedback captures the vertices of each primitive emitted by the last
vertex processing stage.
If separable program objects are in use, the set of attributes captured is taken
from the program object active on the last vertex processing stage. The set of
attributes to capture in transform feedback mode for any other program active on a
previous shader stage is ignored.
13.3.1 Transform Feedback Objects
The set of buffer objects used to capture vertex output variables and related state are
stored in a transform feedback object. The set of attributes captured in transform
feedback mode is determined using the state of the active program object. The
name space for transform feedback objects is the unsigned integers. The name
zero designates the default transform feedback object.
The command
void GenTransformFeedbacks(sizei n,uint *ids );
returns n previously unused transform feedback object names in ids. These names
are marked as used, for the purposes of GenTransformFeedbacks only, but they
acquire transform feedback state only when they are ?rst bound.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 443
Errors
AnINVALID_VALUE error is generated if n is negative.
Transform feedback objects are deleted by calling
void DeleteTransformFeedbacks(sizei n,const
uint *ids );
ids contains n names of transform feedback objects to be deleted. After a trans-
form feedback object is deleted it has no contents, and its name is again unused.
Unused names in ids that have been marked as used for the purposes of GenTrans-
formFeedbacks are marked as unused again. Unused names in ids are silently
ignored, as is the value zero. The default transform feedback object cannot be
deleted.
Errors
AnINVALID_VALUE error is generated if n is negative.
An INVALID_OPERATION error is generated if the transform feedback
operation for any object named by ids is currently active.
The command
boolean IsTransformFeedback(uint id );
returns TRUE if id is the name of a transform feedback object. If id is zero, or
a non-zero value that is not the name of a transform feedback object, IsTrans-
formFeedback returns FALSE. No error is generated if id is not a valid transform
feedback object name.
A transform feedback object is created by binding a name returned by Gen-
TransformFeedbacks with the command
void BindTransformFeedback(enum target,uint id );
target must be TRANSFORM_FEEDBACK and id is the transform feedback object
name. The resulting transform feedback object is a new state vector, comprising
all the state and with the same initial values listed in table 23.48. Additionally, the
new object is bound to the GL state vector and is used for subsequent transform
1
feedback operations .
1
The TRANSFORM_FEEDBACK_BUFFER_BINDING generic buffer binding point has
now been moved to context state, rather than per-object state, and should be unaffected by this
command. It is possible that some drivers do not yet implement this change.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 444
BindTransformFeedback can also be used to bind an existing transform feed-
back object to the GL state for subsequent use. If the bind is successful, no change
is made to the state of the newly bound transform feedback object and any previous
binding to target is broken.
While a transform feedback buffer object is bound, GL operations on the target
to which it is bound affect the bound transform feedback object, and queries of the
target to which a transform feedback object is bound return state from the bound
object. When buffer objects are bound for transform feedback, they are attached to
the currently bound transform feedback object. Buffer objects are used for trans-
form feedback only if they are attached to the currently bound transform feedback
object.
In the initial state, a default transform feedback object is bound and treated as
a transform feedback object with a name of zero. That object is bound any time
BindTransformFeedback is called with id of zero.
Errors
An INVALID_ENUM error is generated if target is not TRANSFORM_-
FEEDBACK.
An INVALID_OPERATION error is generated if the transform feedback
operation is active on the currently bound transform feedback object, and that
operation is not paused (as described below).
An INVALID_OPERATION error is generated if id is not zero or a name
returned from a previous call to GenTransformFeedbacks, or if such a name
has since been deleted with DeleteTransformFeedbacks.
New transform feedback objects may also be created with the command
void CreateTransformFeedbacks(sizei n,uint *ids );
CreateTransformFeedbacks returns n previously unused transform feedback
object names in ids, each representing a new state vector, comprising the state and
with all the same initial values listed in table 23.48.
Errors
AnINVALID_VALUE error is generated if n is negative.
13.3.2 Transform Feedback Primitive Capture
Transform feedback for the currently bound transform feedback object is started
(made active) and ?nished (made inactive) with the commands
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 445
void BeginTransformFeedback(enum primitiveMode );
and
void EndTransformFeedback(void );
respectively. primitiveMode must be TRIANGLES, LINES, or POINTS, and speci-
?es the output type of primitives that will be recorded into the buffer objects bound
for transform feedback (see below). primitiveMode restricts the primitive types
that may be rendered while transform feedback is active, as shown in table 13.1.
EndTransformFeedback ?rst performs an implicit ResumeTransformFeed-
back (see below) if transform feedback is paused.
BeginTransformFeedback and EndTransformFeedback calls must be
paired. Transform feedback is initially inactive.
Transform feedback mode captures the values of output variables written by
the last vertex processing stage.
Errors
An INVALID_ENUM error is generated by BeginTransformFeedback if
primitiveMode is notTRIANGLES,LINES, orPOINTS.
An INVALID_OPERATION error is generated by BeginTransformFeed-
back if transform feedback is active for the current transform feedback object.
An INVALID_OPERATION error is generated by EndTransformFeed-
back if transform feedback is inactive.
Transform feedback operations for the currently bound transform feedback ob-
ject may be paused and resumed by calling
void PauseTransformFeedback(void );
and
void ResumeTransformFeedback(void );
respectively. When transform feedback operations are paused, transform feedback
is still considered active and changing most transform feedback state related to the
object results in an error. However, a new transform feedback object may be bound
while transform feedback is paused.
When transform feedback is active and not paused, all geometric primitives
generated must be compatible with the value of primitiveMode passed to Begin-
TransformFeedback.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 446
Transform Feedback Allowed render primitive
primitiveMode modes
POINTS POINTS
LINES LINES,LINE_LOOP,LINE_STRIP
TRIANGLES TRIANGLES,TRIANGLE_STRIP,TRIANGLE_FAN
Table 13.1: Legal combinations of the transform feedback primitive mode, as
passed to BeginTransformFeedback, and the current primitive mode.
Errors
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL if mode is not one of the allowed modes in table 13.1.
If a tessellation evaluation or geometry shader is active, the type of primitive
emitted by that shader is used instead of the mode parameter passed to drawing
commands for the purposes of this error check. If tessellation evaluation and
geometry shaders are both active, the output primitive type of the geometry
shader will be used for the purposes of this error. Any primitive type may be
used while transform feedback is paused.
Errors
An INVALID_OPERATION error is generated by PauseTransformFeed-
back if the currently bound transform feedback object is not active or is
paused.
AnINVALID_OPERATION error is generated by ResumeTransformFeed-
back if the currently bound transform feedback object is not active or is not
paused.
Regions of buffer objects are bound as targets of the currently bound transform
feedback object by calling one of the BindBuffer* commands (see sections 6.1
and 6.1.1 with target set to TRANSFORM_FEEDBACK_BUFFER. Alternatively, re-
gions of buffer objects may be bound directly to a transform feedback object with
the commands
void TransformFeedbackBufferRange(uint xfb,uint index,
uint buffer,intptr offset,sizeiptr size );
void TransformFeedbackBufferBase(uint xfb,uint index,
uint buffer );
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 447
xfb must be zero, indicating the default transform feedback object, or the name
of an existing transform feedback object. buffer must be zero or the name of an
existing buffer object.
TransformFeedbackBufferRange and TransformFeedbackBufferBase be-
have similarly to BindBufferRange and BindBufferBase, respectively, except
that the target of the operation is xfb, and they do not affect any binding to the
genericTRANSFORM_FEEDBACK_BUFFER target.
Errors
AnINVALID_OPERATION error is generated if xfb is not zero or the name
of an existing transform feedback object.
AnINVALID_VALUE error is generated if buffer is not zero or the name of
an existing buffer object.
An INVALID_VALUE error is generated if index is greater than or equal
to the number of binding points for transform feedback, as described in sec-
tion 6.7.1.
An INVALID_VALUE error is generated by TransformFeedbackBuffer-
Range if offset is negative.
An INVALID_VALUE error is generated by TransformFeedbackBuffer-
Range if size is less than or equal to zero.
An INVALID_VALUE error is generated by TransformFeedbackBuffer-
Range if offset or size do not satisfy the constraints described for those param-
eters for transform feedback array bindings, as described in section 6.7.1.
When an individual point, line, or triangle primitive reaches the transform feed-
back stage while transform feedback is active and not paused, the values of the
speci?ed output variables of the vertex are appended to the buffer objects bound to
the transform feedback binding points. The attributes of the ?rst vertex received af-
ter BeginTransformFeedback are written at the starting offsets of the bound buffer
objects set by BindBufferRange, and subsequent vertex attributes are appended to
the buffer object. When capturing line and triangle primitives, all attributes of the
?rst vertex are written ?rst, followed by attributes of the subsequent vertices.
When capturing vertices, the stride associated with each transform feedback
binding point indicates the number of basic machine units of storage reserved for
each vertex in the bound buffer object. For every vertex captured, each output
variable with an assigned transform feedback offset will be written to the storage
reserved for the vertex at the associated binding point. When writing output vari-
ables that are arrays or structures, individual array elements or structure members
are written in order. For vector types, individual components are written in order.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 448
For matrix types, outputs are written as an array of column vectors. If any com-
ponent of an output with an assigned transform feedback offset was not written
to by its shader, the value recorded for that component is unde?ned. The results
of writing an output variable to a transform feedback buffer are unde?ned if any
component of that variable would be written at an offset not aligned to the size of
the component. When capturing a vertex, any portion of the reserved storage not
associated with an output variable with an assigned transform feedback offset will
be unmodi?ed.
When transform feedback is paused, no vertices are recorded. When transform
feedback is resumed, subsequent vertices are appended to the bound buffer ob-
jects immediately following the last vertex written before transform feedback was
paused.
Individual lines or triangles of a strip or fan primitive will be extracted and
recorded separately. Incomplete primitives are not recorded.
When using a geometry shader that writes vertices to multiple vertex streams,
each vertex emitted may trigger a new primitive in the vertex stream to which
it was emitted. If transform feedback is active, the outputs of the primitive are
written to a transform feedback binding point if and only if the outputs directed at
that binding point belong to the vertex stream in question. All outputs assigned to
a given binding point are required to come from a single vertex stream.
If recording the vertices of a primitive to the buffer objects being used for trans-
form feedback purposes would result in either exceeding the limits of any buffer
object’s size, or in exceeding the end position oset + size  1, as set by Bind-
BufferRange, then no vertices of that primitive are recorded in any buffer object,
and the counter corresponding to the asynchronous query target TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN (see section 13.4) is not incremented. For
the purposes of this test,gl_SkipComponents variables are counted as recording
data to a buffer object.
Any transform feedback binding point used for capturing vertices must have
buffer objects bound when BeginTransformFeedback is called. A binding point
requires a bound buffer object if and only if its associated stride in the program
object used for transform feedback primitive capture is non-zero and the transform
feedback buffer is associated with output variables, blocks or block members in the
program object.
Errors
An INVALID_OPERATION error is generated by BeginTransformFeed-
back if any of these binding points does not have a buffer object bound.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 449
An INVALID_OPERATION error is generated by BeginTransformFeed-
back if no binding points would be used, either because no program object is
active or because the active program object has speci?ed no output variables
to record.
When BeginTransformFeedback is called with an active program object con-
taining a vertex, tessellation or geometry shader, the set of output variables cap-
tured during transform feedback is taken from the active program object and may
not be changed while transform feedback is active. That program object must
be active until the EndTransformFeedback is called, except while the transform
feedback object is paused.
Errors
AnINVALID_OPERATION error is generated by:
 UseProgram if the current transform feedback object is active and not
paused;
 UseProgramStages if the program pipeline object it refers to is current
and the current transform feedback object is active and not paused;
 BindProgramPipeline if the current transform feedback object is active
and not paused;
 LinkProgram or ProgramBinary if program is the name of a program
being used by one or more transform feedback objects, even if the ob-
jects are not currently bound or are paused;
 ResumeTransformFeedback if the program object being used by the
current transform feedback object is not active;
 ResumeTransformFeedback if the program pipeline object being used
by the current transform feedback object is not bound, if any of its
shader stage bindings has changed, or if a single program object is active
and overriding it; and
 BindBufferRange or BindBufferBase if target is TRANSFORM_-
FEEDBACK_BUFFER and transform feedback is currently active.
Buffers should not be simultaneously used for both transform feedback and
other purposes in the GL. Speci?cally, if a buffer object is bound to any of the
binding points in an active and not paused transform feedback object, only writes
OpenGL 4.6 (Core Pro?le) - February 2, 201913.3. TRANSFORMFEEDBACK 450
to that binding point are supported, and any other writes to or reads from the buffer
generate unde?ned values. This includes writes to another transform feedback
binding point when the same buffer is bound to more than one binding point in the
same transform feedback object. Other examples of reads or writes that could gen-
erate unde?ned values include ReadPixels to a pixel buffer object binding point
and client access to a buffer mapped with MapBuffer. Commands that attempt to
read or write to an active and unpaused transform feedback buffer will have unde-
?ned results. Generating an INVALID_OPERATION error is recommended in this
case.
However, if a buffer object is written and read sequentially by transform feed-
back and other mechanisms, it is the responsibility of the GL to ensure that data
are accessed consistently, even if the implementation performs the operations in a
pipelined manner. For example, MapBuffer may need to block pending the com-
pletion of a previous transform feedback operation.
13.3.3 Transform Feedback Draw Operations
When transform feedback is active, the values of output variables or transformed
vertex attributes are captured into the buffer objects attached to the current trans-
form feedback object. After transform feedback is complete, subsequent rendering
operations may use the contents of these buffer objects (see section 6). The number
of vertices captured from each vertex stream during transform feedback is stored in
the corresponding transform feedback object and may be used in conjunction with
the commands
void DrawTransformFeedback(enum mode,uint id );
void DrawTransformFeedbackInstanced(enum mode,
uint id,sizei instancecount );
void DrawTransformFeedbackStream(enum mode,uint id,
uint stream );
void DrawTransformFeedbackStreamInstanced(enum mode,
uint id,uint stream,sizei instancecount );
to replay the captured vertices.
DrawTransformFeedbackStreamInstanced is equivalent to call-
ing DrawArraysInstanced with mode as speci?ed, ?rst set to zero, count set to
the number of vertices captured from the vertex stream numbered stream the last
time transform feedback was active on the transform feedback object named id,
and instancecount as speci?ed.
Calling DrawTransformFeedbackInstanced is equivalent to calling Draw-
TransformFeedbackStreamInstanced with stream set to zero.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.4. PRIMITIVEQUERIES 451
Calling DrawTransformFeedbackStream is equivalent to calling Draw-
TransformFeedbackStreamInstanced with instancecount set to one.
Finally, calling DrawTransformFeedback is equivalent to calling Draw-
TransformFeedbackStreamInstanced with stream set to zero and instancecount
set to one.
Note that the vertex count is from the number of vertices recorded to the se-
lected vertex stream during the transform feedback operation. If no outputs be-
longing to the selected vertex stream are recorded, the corresponding vertex count
will be zero even if complete primitives were emitted to the selected stream.
No error is generated if the transform feedback object named by id is active;
the vertex count used for the rendering operation is set by the previous EndTrans-
formFeedback command.
Errors
An INVALID_VALUE error is generated if stream is greater than or equal
to the value ofMAX_VERTEX_STREAMS.
AnINVALID_VALUE error is generated if id is not the name of a transform
feedback object.
AnINVALID_VALUE error is generated if instancecount is negative.
AnINVALID_OPERATION error is generated if EndTransformFeedback
has never been called while the object named by id was bound.
13.4 Primitive Queries
Primitive queries use query objects to track the number of primitives in each vertex
stream that are generated by the GL and the number of primitives in each vertex
stream that are written to buffer objects in transform feedback mode.
When BeginQueryIndexed is called with a target of PRIMITIVES_-
GENERATED, the primitives generated count maintained by the GL for the vertex
stream index is set to zero. There is a separate query and counter for each vertex
stream. The number of vertex streams is given by the value of the implementation-
dependent constant MAX_VERTEX_STREAMS. When a generated primitive query
for a vertex stream is active, the primitives-generated count is incremented every
time a primitive emitted to that stream reaches the transform feedback stage (see
section 13.3), whether or not transform feedback is active. This counter counts
the number of primitives emitted by a geometry shader, if active, possibly further
tessellated into separate primitives during the transform feedback stage, if active.
When BeginQueryIndexed is called with a target of TRANSFORM_-
OpenGL 4.6 (Core Pro?le) - February 2, 201913.5. TRANSFORMFEEDBACKOVERFLOWQUERIES 452
FEEDBACK_PRIMITIVES_WRITTEN, the transform feedback primitives written
count maintained by the GL for vertex stream index is set to zero. There is a
separate query and counter for each vertex stream. When a transform feedback
primitives written query for a vertex stream is active, the counter for that vertex
stream is incremented every time the vertices of a primitive written to that stream
are recorded into one or more buffer objects. If transform feedback is not active
or if a primitive to be recorded does not ?t in a buffer object, the counter is not
incremented.
These two types of queries can be used together to determine if all primitives
in a given vertex stream have been written to the bound feedback buffers; if both
queries are run simultaneously and the query results are equal, all primitives have
been written to the buffer(s). If the number of primitives written is less than the
number of primitives generated, one or more buffers over?owed.
13.5 Transform Feedback Over?ow Queries
Transform feedback over?ow queries use query objects to track whether or not all
stream vertices were written to buffer objects in transform feedback mode.
When BeginQueryIndexed is called with a target of TRANSFORM_-
FEEDBACK_OVERFLOW, the transform feedback over?ow state maintained by the
GL is set to false. If transform feedback is active and a primitive to be recorded on
any stream does not ?t in one of the buffer objects used for capture, the over?ow
state is set to true.
When BeginQueryIndexed is called with a target of TRANSFORM_-
FEEDBACK_STREAM_OVERFLOW, the transform feedback stream over?ow state
maintained by the GL for vertex stream index is set to false. There is a sepa-
rate over?ow state for each vertex stream. If transform feedback is active and a
primitive to be recorded on stream index does not ?t in one of the buffer objects
used for capture, the over?ow state for vertex stream index is set to true.
13.6 Flatshading
Flatshading an output of the last vertex processing stage means to assign all
vertices of the primitive the same value for that output.
The output values assigned are those of the provoking vertex of the primitive.
The provoking vertex is controlled with the command
void ProvokingVertex(enum provokeMode );
OpenGL 4.6 (Core Pro?le) - February 2, 201913.7. PRIMITIVECLIPPING 453
Primitive type of polygoni First vertex convention Last vertex convention
point i i
independent line 2i  1 2i
line loop i i + 1, ifi<n
1, ifi =n
line strip i i + 1
independent triangle 3i  2 3i
triangle strip i i + 2
triangle fan i + 1 i + 2
line adjacency 4i  2 4i  1
line strip adjacency i + 1 i + 2
triangle adjacency 6i  5 6i  1
triangle strip adjacency 2i  1 2i + 3
Table 13.2: Provoking vertex selection. The output values used for ?atshading
theith primitive generated by drawing commands with the indicated primitive type
are derived from the corresponding values of the vertex whose index is shown in
the table. Vertices are numbered 1 throughn, wheren is the number of vertices
drawn.
provokeMode must be either FIRST_VERTEX_CONVENTION or LAST_VERTEX_-
CONVENTION, and controls selection of the vertex whose values are assigned to
?atshaded colors and outputs, as shown in table 13.2.
When a vertex processing stage is active, user-de?ned output variables may be
?atshaded by using the flat quali?er when declaring the output, as described in
section 4.5(“Interpolation Quali?ers”) of the OpenGL Shading Language Speci?-
cation.
The state required for ?atshading is one bit for the provoking vertex mode.
The initial value of the provoking vertex mode isLAST_VERTEX_CONVENTION.
13.7 Primitive Clipping
The command
void ClipControl(enum origin,enum depth );
controls the clipping volume behavior. origin and depth specify the clip control
origin and depth mode respectively. The interpretation of these parameters is dis-
cussed later in this section and in section 13.8.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.7. PRIMITIVECLIPPING 454
Errors
An INVALID_ENUM error is generated if origin is not LOWER_LEFT or
UPPER_LEFT.
An INVALID_ENUM error is generated if depth is not NEGATIVE_ONE_-
TO_ONE orZERO_TO_ONE.
Primitives are culled against the cull volume and then clipped to the clip vol-
ume. In clip coordinates, the view volume is de?ned by
 w x w
c c c
 w y w
c c c
z z w :
min c c
wherez is w when the clip control depth mode isNEGATIVE_ONE_TO_ONE,
min c
and 0 when the mode isZERO_TO_ONE.
This view volume may be further restricted by as many asn client-de?ned half-
spaces. n is an implementation-dependent maximum that must be at least 8, and
may be determined by calling GetIntegerv with pnameMAX_COMBINED_CLIP_-
AND_CULL_DISTANCES.
The cull volume is the intersection of up to the value of MAX_CULL_-
DISTANCES client-de?ned half-spaces (if no client-de?ned cull half-spaces are en-
abled, culling against the cull volume is skipped). The number of enabled cull
half-spaces is determined by the explicit or implicit size of the built-in arraygl_-
CullDistance in the last shader stage before rasterization which has an active
program.
A shader may write a single cull distance for each enabled cull half-space to
elements of the gl_CullDistance[] array. If the cull distance for any enabled
cull half-space is negative for all of the vertices of the primitive under considera-
tion, the primitive is discarded. Otherwise the primitive is clipped against the clip
volume as de?ned below.
The clip volume is the intersection of up to the value of MAX_CLIP_-
DISTANCES client-de?ned half-spaces with the view volume (if no client-de?ned
clip half-spaces are enabled, the clip volume is the view volume).
The last vertex processing stage may write a single clip distance for each en-
abled clip half-space to elements of the gl_ClipDistance[] array. Clip half-
spacei is then given by the set of points satisfying the inequality
c (P ) 0;
i
where c (P ) is the value of clip distance i at point P . For point primitives,
i
c (P ) is simply the clip distance for the vertex in question. For line and triangle
i
OpenGL 4.6 (Core Pro?le) - February 2, 201913.7. PRIMITIVECLIPPING 455
primitives, per-vertex clip distances are interpolated using a weighted mean, with
weights derived according to the algorithms described in sections 14.5 and 14.6.
Client-de?ned clip half-spaces are enabled or disabled by calling Enable or
Disable with targetCLIP_DISTANCEi, wherei is an integer between 0 andn  1;
specifying a value ofi enables or disables the client-de?ned clip half-space with
indexi. The constants obeyCLIP_DISTANCEi = CLIP_DISTANCE0 +i.
Depth clamping is enabled or disabled by calling Enable or Disable with target
DEPTH_CLAMP. If depth clamping is enabled, the
z z w
min c c
plane equation (see the clip volume de?nition above) is ignored by view volume
clipping (effectively, there is no near or far plane clipping).
If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded.
If the primitive is a line segment, then clipping does nothing to it if it lies
entirely within the clip volume, and discards it if it lies entirely outside the volume.
If part of the line segment lies in the volume and part lies outside, then the
line segment is clipped and new vertex coordinates are computed for one or both
vertices. A clipped line segment endpoint lies on both the original line segment
and the boundary of the clip volume.
This clipping produces a value, 0 t 1, for each clipped vertex. If the
coordinates of a clipped vertex areP and the original vertices’ coordinates areP
1
andP , thent is given by
2
P =tP + (1 t)P :
1 2
The value of t is used to clip outputs of the last vertex processing stage as
described in section 13.7.1.
If the primitive is a polygon, then it is passed if every one of its edges lies
entirely inside the clip volume and either clipped or discarded otherwise. Polygon
clipping may cause polygon edges to be clipped, but because polygon connectivity
must be maintained, these clipped edges are connected by new edges that lie along
the clip volume’s boundary. Thus, clipping may require the introduction of new
vertices into a polygon.
If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge.
Primitives rendered with user-de?ned half-spaces must satisfy a complemen-
tarity criterion. Suppose a series of primitives is drawn where each vertexi has a
single speci?ed clip distanced (or a number of similarly speci?ed clip distances,
i
OpenGL 4.6 (Core Pro?le) - February 2, 201913.7. PRIMITIVECLIPPING 456
if multiple half-spaces are enabled). Next, suppose that the same series of primi-
tives are drawn again with each such clip distance replaced by d (and the GL
i
is otherwise in the same state). In this case, primitives must not be missing any
pixels, nor may any pixels be drawn twice in regions where those primitives are
cut by the clip planes.
The state required for clipping is one bit for clip control origin, one bit for
clip control depth mode, at least 8 bits indicating which of the client-de?ned half-
spaces are enabled. In the initial state, the clip control origin isLOWER_LEFT, the
depth mode isNEGATIVE_ONE_TO_ONE, and all half-spaces are disabled.
Implementations are allowed to pass incoming primitives unchanged and to
output multiple primitives for an incoming primitive due to implementation depen-
dent reasons as long as the results of rendering otherwise remain unchanged.
13.7.1 Clipping Shader Outputs
Next, outputs of the last vertex processing stage are clipped. The output values
associated with a vertex that lies within the clip volume are unaffected by clipping.
If a primitive is clipped, however, the output values assigned to vertices produced
by clipping are clipped.
Let the output values assigned to the two verticesP andP of an unclipped
1 2
edge bec andc . The value oft (section 13.7) for a clipped pointP is used to
1 2
2
obtain the output value associated withP as
c =tc + (1 t)c :
1 2
(Multiplying an output value by a scalar means multiplying each of x, y, z, and w
by the scalar.)
Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clipping against one half-space at a time. Output value clipping is done in the
same way, so that clipped points always occur at the intersection of polygon edges
(possibly already clipped) with the clip volume’s boundary.
For outputs of the last vertex processing stage speci?ed to be interpolated
without perspective correction (using thenoperspective quali?er), the value of
t used to obtain the output value associated with P will be adjusted to produce
results that vary linearly in screen space.
Implementations need not support interpolation of output values of integer or
unsigned integer type, as all such attributes must be ?at shaded.
2
Since this computation is performed in clip space before division byw , clipped output values
c
are perspective-correct.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.8. COORDINATETRANSFORMATIONS 457
13.7.2
This subsection is only de?ned in the compatibility pro?le.
13.7.3 Primitive Clipping Queries
Primitive clipping queries use query objects to track the number of primitives that
are processed by the primitive clipping stage and the number of primitives that are
output by the primitive clipping stage and are further processed by the rasterization
stage.
When BeginQuery is called with a target of CLIPPING_INPUT_-
PRIMITIVES, the clipping input primitives count maintained by the GL is set to
zero. When a clipping input primitives query is active, the counter is incremented
every time a primitive reaches the primitive clipping stage (see section 13.7).
When BeginQuery is called with a target of CLIPPING_OUTPUT_-
PRIMITIVES, the clipping output primitives count maintained by the GL is set to
zero. When a clipping output primitives query is active, the counter is incremented
every time a primitive passes the primitive clipping stage. The actual number of
primitives output by the primitive clipping stage for a particular input primitive is
implementation dependent (see section 13.7) but must satisfy the following condi-
tions:
 If at least one vertex of the input primitive lies inside the clipping volume,
the counter is incremented by one or more.
 Otherwise, the counter is incremented by zero or more.
IfRASTERIZER_DISCARD is enabled, implementations are allowed to discard
primitives right after the optional transform feedback state (see section 14.1). As a
result, if RASTERIZER_DISCARD is enabled, the clipping input and output primi-
tives count may not be incremented.
13.8 Coordinate Transformations
Clip coordinates for a vertex result from shader execution, which yields a vertex
coordinategl_Position.
Perspective division on clip coordinates yields normalized device coordinates,
followed by a viewport transformation (see section 13.8.1) to convert these coordi-
nates into window coordinates.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.8. COORDINATETRANSFORMATIONS 458
If a vertex in clip coordinates is given by
0 1
x
c
B C
y
c
B C
@ A
z
c
w
c
then the vertex’s normalized device coordinates are
0 1
0 1
x
c
x
d w
c
B C
fy
c
@ A
y =
d @ A
wc
z
c
z
d
w
c
wheref is 1 when the clip control origin isLOWER_LEFT and 1 when the origin
isUPPER_LEFT.
13.8.1 Controlling the Viewport
The viewport transformation is determined by the selected viewport’s width and
height in pixels, p and p , respectively, and its center (o ;o ) (also in pixels).
x y x y
0 1
x
w
@ A
The vertex’s window coordinates, y ; are given by
w
z
w
0 1 0 1
p
x
x x +o
w d x
2
p
y
@ A @ A
y = y +o :
w d y
2
z sz +b
w
d
f n n+f
wheres = andb = when the clip control depth mode is NEGATIVE_-
2 2
ONE_TO_ONE, ors =f n andb =n when the mode isZERO_TO_ONE.
Multiple viewports are available and are numbered zero through the value of
MAX_VIEWPORTS minus one. If a geometry shader is active and writes to gl_-
ViewportIndex, the viewport transformation uses the viewport corresponding
to the value assigned to gl_ViewportIndex taken from an implementation-
dependent primitive vertex. If the value of the viewport index is outside the range
zero to the value ofMAX_VIEWPORTS minus one, the results of the viewport trans-
formation are unde?ned. If no geometry shader is active, or if the active geometry
shader does not write togl_ViewportIndex, the viewport numbered zero is used
by the viewport transformation.
A single vertex may be used in more than one individual primitive, in primitives
such as TRIANGLE_STRIP. In this case, the viewport transformation is applied
separately for each primitive.
OpenGL 4.6 (Core Pro?le) - February 2, 201913.8. COORDINATETRANSFORMATIONS 459
The factor and offset applied toz for each viewport encoded byn andf are
d
set using
void DepthRangeArrayv(uint ?rst,sizei count,const
double *v );
void DepthRangeIndexed(uint index,double n,
double f );
void DepthRange(double n,double f );
void DepthRangef(float n,float f );
DepthRangeArrayv is used to specify the depth range for multiple viewports
simultaneously. ?rst speci?es the index of the ?rst viewport to modify and count
speci?es the number of viewports. Viewports whose indices lie outside the range
[first;first +count) are not modi?ed. The v parameter contains the address of
an array of double types specifying near (n) and far (f) for each viewport in that
order. Values in v are each clamped to the range [0; 1] when speci?ed.
Errors
AnINVALID_VALUE error is generated if (?rst + count) is greater than the
value ofMAX_VIEWPORTS.
AnINVALID_VALUE error is generated if count is negative.
DepthRangeIndexed speci?es the depth range for a single viewport and is
equivalent (assuming no errors are generated) to:
double v[] = f n, f g;
DepthRangeArrayv(index, 1, v);
DepthRange sets the depth range for all viewports to the same values and is
equivalent (assuming no errors are generated) to:
for (uint i = 0; i < MAX_VIEWPORTS; i++)
DepthRangeIndexed(i, n, f);
z may be represented using either a ?xed-point or ?oating-point representation.
w
However, a ?oating-point representation must be used if the draw framebuffer has
a ?oating-point depth buffer. If an m-bit ?xed-point representation is used, we
k m
assume that it represents each value , where k2f0; 1;:::; 2   1g, as k
m
2  1
(e.g. 1.0 is represented in binary as a string of all ones).
Viewport transformation parameters are speci?ed using
OpenGL 4.6 (Core Pro?le) - February 2, 201913.8. COORDINATETRANSFORMATIONS 460
void ViewportArrayv(uint ?rst,sizei count,const
float *v );
void ViewportIndexedf(uint index,float x,float y,
float w,float h );
void ViewportIndexedfv(uint index,const float *v );
void Viewport(int x,int y,sizei w,sizei h );
ViewportArrayv speci?es parameters for multiple viewports simultaneously.
?rst speci?es the index of the ?rst viewport to modify and count speci?es the num-
ber of viewports. Viewports whose indices lie outside the range [rst; rst +
count) are not modi?ed. v contains the address of an array of ?oating-point values
specifying the left (x), bottom (y), width (w) and height (h) of each viewport, in
that order. x and y give the location of the viewport’s lower left corner and w and h
give the viewport’s width and height, respectively.
Errors
AnINVALID_VALUE error is generated if rst + count is greater than the
value ofMAX_VIEWPORTS.
AnINVALID_VALUE error is generated if count is negative.
ViewportIndexedf and ViewportIndexedfv specify parameters for a single
viewport and are equivalent (assuming no errors are generated) to:
float v[4] = f x, y, w, h g;
ViewportArrayv(index, 1, v);
and
ViewportArrayv(index, 1, v);
respectively.
Viewport sets the parameters for all viewports to the same values and is equiv-
alent (assuming no errors are generated) to:
for (uint i = 0; i < MAX_VIEWPORTS; i++)
ViewportIndexedf(i, 1, (float)x, (float)y, (float)w, (float)h);
The viewport parameters shown in the above equations are found from these
values as
w
o =x +
x
2
h
o =y +
y
2
p =w
x
p =h:
y
OpenGL 4.6 (Core Pro?le) - February 2, 201913.9. 461
The location of the viewport’s bottom-left corner, given by (x;y), are clamped
to be within the implementation-dependent viewport bounds range. The view-
port bounds range [min;max] tuple may be determined by calling GetFloatv with
pnameVIEWPORT_BOUNDS_RANGE (see section 22).
Viewport width and height are clamped to implementation-dependent maxi-
mums when speci?ed. The maximum width and height may be found by calling
GetFloatv with pname MAX_VIEWPORT_DIMS. The maximum viewport dimen-
sions must be greater than or equal to the larger of the visible dimensions of the
display being rendered to (if a display exists), and the largest renderbuffer image
which can be successfully created and attached to a framebuffer object (see chap-
ter 9).
Errors
AnINVALID_VALUE error is generated if either w or h is negative.
The state required to implement the viewport transformation is four integers
and two clamped ?oating-point values for each viewport. In the initial state, w and
h for each viewport are set to the width and height, respectively, of the window
into which the GL is to do its rendering. If the default framebuffer is bound but no
default framebuffer is associated with the GL context (see chapter 9), then w and h
w h
are initially set to zero.o ,o ,n, andf are set to , , 0:0, and 1:0, respectively.
x y
2 2
The precision with which the GL interprets the ?oating-point viewport
bounds is implementation-dependent and may be determined by querying the
implementation-de?ned constantVIEWPORT_SUBPIXEL_BITS.
13.9
This section is only de?ned in the compatibility pro?le.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 14
Fixed-Function Primitive
Assembly and Rasterization
Rasterization is the process by which a primitive is converted to a two-dimensional
image. Each point of this image contains such information as color and depth.
Rasterizing a primitive begins by determining which squares of an integer grid
in window coordinates are occupied by the primitive, and assigning a depth value
to each such square. This process is described in sections 14.1-14.6 for point, line,
and triangle primitives.
A grid square, including its (x;y) window coordinates, z (depth), and asso-
ciated data which may be added by fragment shaders, is called a fragment. A
fragment is located by its lower left corner, which lies on integer grid coordinates.
1 1
Rasterization operations also refer to a fragment’s center, which is offset by ( ; )
2 2
from its lower left corner (and so lies on half-integer coordinates).
Fragments need not actually be square, and rasterization rules are not affected
by the aspect ratio of fragments. Display of non-square grids, however, will cause
rasterized points and line segments to appear fatter in one direction than the other.
We assume that fragments are square, since it simpli?es antialiasing and texturing.
After rasterization, fragments are processed by the early per-fragment tests de-
scribed in section 14.9, which may modify or discard fragments.
Surviving fragments are processed by fragment shaders (see chapter 15). Frag-
ment shaders determine color values for fragments, and may also modify or replace
their assigned depth values.
Figure 14.1 diagrams the rasterization process.
Grid squares need not actually be square in the GL. Rasterization rules are not
affected by the actual aspect ratio of the grid squares. Display of non-square grids,
however, will cause rasterized points and line segments to appear fatter in one
462463
From
Primitive
Assembly
Point Line Triangle 
Rasterization Rasterization Rasterization
Pixel 
Multisample 
Scissor 
Ownership
Fragment 
Test
Test
Operations
Fragment
Other Early 
Shading
Tests
Processed 
Fragments
Figure 14.1. Rasterization, early per-fragment tests, and fragment shading. Optional
early tests described in section 14.9 are included in the “Other Early Tests” box.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.1. DISCARDINGPRIMITIVESBEFORERASTERIZATION 464
direction than the other. We assume that fragments are square, since it simpli?es
antialiasing and texturing.
Several factors affect rasterization. Primitives may be discarded before ras-
terization. Points may be given differing diameters and line segments differing
widths. A point, line segment, or polygon may be antialiased.
Rasterization only produces fragments corresponding to pixels in the frame-
buffer. Fragments which would be produced by application of any of the primitive
rasterization rules described below but which lie outside the framebuffer are not
produced, nor are they processed by any later stage of the GL, including any of the
early per-fragment tests described in section 14.9.
14.1 Discarding Primitives Before Rasterization
Primitives sent to vertex stream zero (see section 13.3) are processed further; prim-
itives emitted to any other stream are discarded. When geometry shaders are dis-
abled, all vertices are considered to be emitted to stream zero.
Primitives can be optionally discarded before rasterization by calling Enable
and Disable with target RASTERIZER_DISCARD. When enabled, primitives are
discarded immediately before the rasterization stage, but after the optional trans-
form feedback stage (see section 13.3). When disabled, primitives are passed
through to the rasterization stage to be processed normally. When enabled,
RASTERIZER_DISCARD also causes the Clear and ClearBuffer* commands to
be ignored.
The state required to control primitive discard is a bit indicating whether dis-
card is enabled or disabled. The initial value of primitive discard isFALSE.
14.2 Invariance
0
Consider a primitivep obtained by translating a primitivep through an offset (x;y)
0
in window coordinates, wherex andy are integers. As long as neitherp norp is
0 0
clipped, it must be the case that each fragmentf produced fromp is identical to
0
a corresponding fragmentf fromp except that the center off is offset by (x;y)
from the center off.
14.3 Antialiasing
The R, G, and B values of the rasterized fragment are left unaffected, but the A
value is multiplied by a ?oating-point value in the range [0; 1] that describes a
OpenGL 4.6 (Core Pro?le) - February 2, 201914.3. ANTIALIASING 465
fragment’s screen pixel coverage. The per-fragment stage of the GL can be set up
to use the A value to blend the incoming fragment with the corresponding pixel
already present in the framebuffer.
The details of how antialiased fragment coverage values are computed are dif-
?cult to specify in general. The reason is that high-quality antialiasing may take
into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
ber of grid squares neighboring the one corresponding to the fragment, and not just
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
not entirely accurate coverage computation.
In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of
uniform intensity. The square is called a fragment square and has lower left corner
(x;y) and upper right corner (x+1;y+1). We recognize that this simple box ?lter
may not produce the most favorable antialiasing results, but it provides a simple,
well-de?ned model.
A GL implementation may use other methods to perform antialiasing, subject
to the following conditions:
1. Iff andf are two fragments, and the portion off covered by some prim-
1 2 1
itive is a subset of the corresponding portion off covered by the primitive,
2
then the coverage computed forf must be less than or equal to that com-
1
puted forf .
2
2. The coverage computation for a fragment f must be local: it may depend
only onf’s relationship to the boundary of the primitive being rasterized. It
may not depend onf’sx andy coordinates.
Another property that is desirable, but not required, is:
3. The sum of the coverage values for all fragments produced by rasterizing a
particular primitive must be constant, independent of any rigid motions in
window coordinates, as long as none of those fragments lies along window
edges.
In some implementations, varying degrees of antialiasing quality may be obtained
by providing GL hints (section 21.5), allowing a user to make an image quality
versus speed tradeoff.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.3. ANTIALIASING 466
14.3.1 Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, and
polygons. The technique is to sample all primitives multiple times at each pixel.
The color sample values are resolved to a single, displayable color each time a
pixel is updated, so the antialiasing appears to be automatic at the application level.
Because each sample includes color, depth, and stencil information, the color (in-
cluding texture operation), depth, and stencil functions perform equivalently to the
single-sample mode.
An additional buffer, called the multisample buffer, is added to the framebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.
Color buffers do coexist with the multisample buffer, however.
Multisample antialiasing is most valuable for rendering polygons, because it
requires no sorting for hidden surface elimination, and it correctly handles adja-
cent polygons, object silhouettes, and even intersecting polygons. If only lines
are being rendered, the “smooth” antialiasing mechanism provided by the base GL
may result in a higher quality image. This mechanism is designed to allow multi-
sample and smooth antialiasing techniques to be alternated during the rendering of
a single scene.
If the value of SAMPLE_BUFFERS (see section 9.2.3.1) is one, the rasteriza-
tion of all primitives is changed, and is referred to as multisample rasterization.
Otherwise, primitive rasterization is referred to as single-sample rasterization.
During multisample rendering the contents of a pixel fragment are changed
in two ways. First, each fragment includes a coverage value with the value of
SAMPLES bits (see section 9.2.3.1).
The location at which shading is performed for a given sample (the shading
sample location) is queried with the command
void GetMultisamplefv(enum pname,uint index,
float *val );
pname must be SAMPLE_POSITION, and index corresponds to the sample for
which the location should be returned. The sample location is returned as two
?oating-point values in val[0] and val[1], each between 0 and 1, corresponding to
thex andy locations respectively in GL pixel space of that sample. (0:5; 0:5) thus
corresponds to the pixel center. If the multisample mode does not have ?xed sam-
ple locations, the returned values may only re?ect the locations of samples within
some pixels.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.3. ANTIALIASING 467
Errors
An INVALID_ENUM error is generated if pname is not SAMPLE_-
POSITION.
AnINVALID_VALUE error is generated if index is greater than or equal to
the value ofSAMPLES.
Second, each fragment includes SAMPLES depth values and sets of associated
data, instead of the single depth value and set of associated data that is maintained
in single-sample rendering mode. An implementation may choose to assign the
same associated data to more than one sample. The location for evaluating such
associated data can be anywhere within the pixel including the fragment center or
any of the sample locations. The different associated data values need not all be
evaluated at the same location. Each pixel fragment thus consists of integerx andy
grid coordinates,SAMPLES depth values and sets of associated data, and a coverage
value with a maximum ofSAMPLES bits.
Multisample rasterization is enabled or disabled by calling Enable or Disable
with targetMULTISAMPLE.
If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signed by single-sample rasterization, or they may be assigned as described below
for multisample rasterization.
IfMULTISAMPLE is enabled, multisample rasterization of all primitives differs
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has sample locations associated with it. These locations are exact
positions, rather than regions or areas, and each is referred to as a sample point.
These sample points do not necessarily correspond to the shading sample locations
returned by GetMultisamplefv. Their locations cannot be queried, and may lie in-
side or outside of the unit square that is considered to bound the pixel. The number
of these samples may be different than the value ofSAMPLES. Furthermore, the rel-
ative locations of sample points may be identical for each pixel in the framebuffer,
or they may differ.
If MULTISAMPLE is enabled and the current program object includes a frag-
ment shader with one or more input variables quali?ed withsample in, the data
associated with those variables will be assigned independently. The values for each
sample must be evaluated at the location of the sample. The data associated with
any other variables not quali?ed withsample in need not be evaluated indepen-
dently for each sample.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.4. POINTS 468
If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position speci?c.
The invariance requirement described in section 14.2 is relaxed for all multisample
rasterization, because the sample locations may be a function of pixel location.
14.3.1.1 Sample Shading
Sample shading can be used to specify a minimum number of unique samples to
process for each fragment. Sample shading is controlled by calling Enable or
Disable with targetSAMPLE_SHADING.
If MULTISAMPLE or SAMPLE_SHADING is disabled, sample shading has no
effect. Otherwise, an implementation must provide a minimum of
max(dmsssamplese; 1)
unique sets of fragment shader inputs for each fragment, where mss is the value
of MIN_SAMPLE_SHADING_VALUE and samples is the number of samples (the
value of SAMPLES). These are associated with the samples in an implementation-
dependent manner. The value of MIN_SAMPLE_SHADING_VALUE is speci?ed by
calling
void MinSampleShading(float value );
with value set to the desired minimum sample shading fraction. value is clamped
to [0; 1] when speci?ed. The sample shading fraction may be queried by calling
GetFloatv with pnameMIN_SAMPLE_SHADING_VALUE.
When the sample shading fraction is 1:0, a separate set of colors and other
associated data are evaluated for each sample, and each set of values is evaluated
at the sample location.
14.4 Points
A point is drawn by generating a set of fragments in the shape of a square or circle
centered around the vertex of the point. Each vertex has an associated point size
that controls the size of that square or circle.
If program point size mode is enabled, the derived point size is taken from
the (potentially clipped) shader built-ingl_PointSize written by the last vertex
processing stage and clamped to the implementation-dependent point size range.
If the value written to gl_PointSize is less than or equal to zero, or if no value
was written togl_PointSize, results are unde?ned. If program point size mode
is disabled, the derived point size is speci?ed with the command
OpenGL 4.6 (Core Pro?le) - February 2, 201914.4. POINTS 469
void PointSize(float size );
size speci?es the requested size of a point. The default value is 1.0.
Errors
AnINVALID_VALUE error is generated if size is less than or equal to zero.
Program point size mode is enabled and disabled by calling Enable or Disable
with targetPROGRAM_POINT_SIZE.
If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 17.2) instead of allowing the point width to go below a given
threshold. In this case, the width of the rasterized point is

derived size derived sizethreshold
width = (14.1)
threshold otherwise
and the fade factor is computed as follows:
(
1 derived sizethreshold
  
fade = (14.2)
2
derived size
otherwise
threshold
The point fadethreshold, is speci?ed with
void PointParameterfifg(enum pname,T param );
void PointParameterfifgv(enum pname,const T *params );
If pname isPOINT_FADE_THRESHOLD_SIZE, then param speci?es, or params
points to the point fadethreshold.
Data conversions are performed as speci?ed in section 2.2.1.
The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT_SPRITE_COORD_ORIGIN and param is
LOWER_LEFT orUPPER_LEFT. The default value isUPPER_LEFT.
Errors
An INVALID_ENUM error is generated if pname is not POINT_FADE_-
THRESHOLD_SIZE or POINT_SPRITE_COORD_ORIGIN.
AnINVALID_VALUE error is generated if negative values are speci?ed for
POINT_FADE_THRESHOLD_SIZE.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.4. POINTS 470
14.4.1 Basic Point Rasterization
Point rasterization produces a fragment for each framebuffer pixel whose center
lies inside a square centered at the point’s (x ;y ), with side length equal to the
w w
current point size.
All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. However,
the fragment shader built-in gl_PointCoord contains point sprite texture coor-
dinates. Thes point sprite texture coordinate varies from zero to one across the
point horizontally left-to-right. If POINT_SPRITE_COORD_ORIGIN is LOWER_-
LEFT, thet coordinate varies from zero to one vertically bottom-to-top. Otherwise
if the point sprite texture coordinate origin isUPPER_LEFT, thet coordinate varies
from zero to one vertically top-to-bottom. The following formula is used to eval-
uate thes andt point sprite texture coordinates:
  
1
x +  x
1
f w
2
s = + (14.3)
2 size
8
1
y +  y
< ( f w)
1 2
+ ;POINT_SPRITE_COORD_ORIGIN = LOWER_LEFT
2 size
t =
1
y +  y
( w)
f
: 1 2
  ;POINT_SPRITE_COORD_ORIGIN = UPPER_LEFT
2 size
(14.4)
wheresize is the point’s size,x andy are the (integral) window coordinates of
f f
the fragment, andx andy are the exact, unrounded window coordinates of the
w w
vertex for the point.
Not all point widths need be supported, but the width 1:0 must be provided.
The range of supported widths and the width of evenly-spaced gradations within
that range are implementation-dependent. The range and gradations may be ob-
tained using the query mechanism described in chapter 22. If, for instance, the
width range is from 0.1 to 2.0 and the gradation width is 0.1, then the widths
0:1; 0:2;:::; 1:9; 2:0 are supported. Additional point widths may also be sup-
ported. There is no requirement that these widths must be equally spaced. If
an unsupported width is requested, the nearest supported width is used instead.
14.4.2 Point Rasterization State
The state required to control point rasterization consists of the ?oating-point point
width, a bit indicating whether or not vertex program point size mode is enabled,
a bit for the point sprite texture coordinate origin, and a ?oating-point value speci-
fying the point fade threshold size.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.5. LINESEGMENTS 471
14.4.3 Point Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE_BUFFERS is one, then points
are rasterized using the following algorithm. Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (x ;y ). This region is a square with side equal
w w
to the current point width. Coverage bits that correspond to sample points that
intersect the region are 1, other coverage bits are 0. All data associated with each
sample for the fragment are the data associated with the point being rasterized.
The set of point sizes supported is equivalent to those for point sprites without
multisample.
14.5 Line Segments
A line segment results from a line strip, a line loop, or a series of separate line
segments. Line segment rasterization is controlled by several variables. Line width,
which may be set by calling
void LineWidth(float width );
with an appropriate positive ?oating-point width, controls the width of rasterized
line segments. The default width is 1:0. Antialiasing may be enabled or disabled
by calling Enable or Disable with targetLINE_SMOOTH.
Errors
An INVALID_VALUE error is generated if width is less than or equal to
zero.
14.5.1 Basic Line Segment Rasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major. x-major line segments have slope in the closed interval [ 1; 1]; all
other line segments arey-major (slope is determined by the segment’s endpoints).
We shall specify rasterization only forx-major segments except in cases where the
modi?cations fory-major segments are not self-evident.
Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
are produced by rasterizing a line segment. For each fragmentf with center at win-
dow coordinatesx andy , de?ne a diamond-shaped region that is the intersection
f f
OpenGL 4.6 (Core Pro?le) - February 2, 201914.5. LINESEGMENTS 472
of four half planes:
1
R =f (x;y)j jx xj +jy yj< g:
f f f
2
Essentially, a line segment starting atp and ending atp produces those frag-
a
b
mentsf for which the segment intersectsR , except ifp is contained inR . See
f b f
?gure 14.2.
To avoid dif?culties when an endpoint lies on a boundary ofR we (in princi-
f
ple) perturb the supplied endpoints by a tiny amount. Letp andp have window
a b
0
coordinates (x ;y ) and (x ;y ), respectively. Obtain the perturbed endpointsp
a a b b
a
2 0 2
given by (x ;y )  (; ) andp given by (x ;y )  (; ). Rasterizing the line
a a b b
b
segment starting atp and ending atp produces those fragmentsf for which the
a b
0 0 0
segment starting atp and ending onp intersectsR , except ifp is contained in
f
a
b b
R .  is chosen to be so small that rasterizing the line segment produces the same
f
fragments when is substituted for for any 0<.
When p and p lie on fragment centers, this characterization of fragments
a b
reduces to Bresenham’s algorithm with one modi?cation: lines produced in this
description are “half-open,” meaning that the ?nal fragment (corresponding top )
b
is not drawn. This means that when rasterizing a series of connected line segments,
shared endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).
Because the initial and ?nal conditions of the diamond-exit rule may be dif?cult
to implement, other line segment rasterization algorithms are allowed, subject to
the following rules:
1. The coordinates of a fragment produced by the algorithm may not deviate by
more than one unit in eitherx ory window coordinates from a corresponding
fragment produced by the diamond-exit rule.
2. The total number of fragments produced by the algorithm may differ from
that produced by the diamond-exit rule by no more than one.
3. For anx-major line, no two fragments may be produced that lie in the same
window-coordinate column (for ay-major line, no two fragments may ap-
pear in the same row).
4. If two line segments share a common endpoint, and both segments are either
x-major (both left-to-right or both right-to-left) ory-major (both bottom-to-
top or both top-to-bottom), then rasterizing both segments may not produce
duplicate fragments, nor may any fragments be omitted so as to interrupt
continuity of the connected segments.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.5. LINESEGMENTS 473
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
Figure 14.2. Visualization of Bresenham’s algorithm. A portion of a line segment is
shown. A diamond shaped region of height 1 is placed around each fragment center;
those regions that the line segment exits cause rasterization to produce correspond-
ing fragments.
Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given
byp = (x ;y ) and letp = (x ;y ) andp = (x ;y ). Set
r a a a
d d b b b
(p  p ) (p  p )
r a b a
t = : (14.5)
2
kp  pk
b a
(Note thatt = 0 atp andt = 1 atp ). The value of an associated datumf for the
a b
fragment, whether it be a shader output or the clipw coordinate, is found as
(1 t)f =w +tf =w
a a b b
f = (14.6)
(1 t)=w +t=w
a b
wheref andf are the data associated with the starting and ending endpoints of
a b
the segment, respectively;w andw are the clipw coordinates of the starting and
a b
ending endpoints of the segments, respectively. However, depth values for lines
must be interpolated by
z = (1 t)z +tz (14.7)
a b
wherez andz are the depth values of the starting and ending endpoints of the
a b
segment, respectively.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.5. LINESEGMENTS 474
The noperspective and flat keywords used to declare shader outputs
affect how they are interpolated. When neither keyword is speci?ed, interpolation
is performed as described in equation 14.6. When thenoperspective keyword
is speci?ed, interpolation is performed in the same fashion as for depth values, as
described in equation 14.7. When the flat keyword is speci?ed, no interpola-
tion is performed, and outputs are taken from the corresponding input value of the
provoking vertex corresponding to that primitive (see section 13.6).
14.5.2 Other Line Segment Features
We have just described the rasterization of non-antialiased line segments of width
one. We now describe the rasterization of line segments for general values of the
line segment rasterization parameters.
14.5.2.1
This subsection is only de?ned in the compatibility pro?le.
14.5.2.2 Wide Lines
The actual width of non-antialiased lines is determined by rounding the supplied
width to the nearest integer, then clamping it to the implementation-dependent
maximum non-antialiased line width. This implementation-dependent value must
be no less than the implementation-dependent maximum antialiased line width,
rounded to the nearest integer value, and in any event no less than 1. If rounding
the speci?ed width results in the value 0, then it is as if the value was 1.
Non-antialiased line segments of width other than one are rasterized by off-
setting them in the minor direction (for an x-major line, the minor direction is
y, and for a y-major line, the minor direction is x) and replicating fragments in
the minor direction (see ?gure 14.3). Let w be the width rounded to the near-
est integer (if w = 0, then it is as if w = 1). If the line segment has endpoints
given by (x ;y ) and (x ;y ) in window coordinates, the segment with endpoints
0 0 1 1
(x ;y   (w  1)=2) and (x ;y   (w  1)=2) is rasterized, but instead of a single
0 0 1 1
fragment, a column of fragments of heightw (a row of fragments of lengthw for
a y-major segment) is produced at each x (y for y-major) location. The lowest
fragment of this column is the fragment that would be produced by rasterizing the
segment of width 1 with the modi?ed coordinates.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.5. LINESEGMENTS 475
width = 2 width = 3
Figure 14.3. Rasterization of non-antialiased wide lines. x-major line segments
are shown. The heavy line segment is the one speci?ed to be rasterized; the light
segment is the offset segment used for rasterization. x marks indicate the fragment
centers produced by rasterization.
14.5.2.3 Antialiasing
Rasterized antialiased line segments produce fragments which intersect a rectangle
centered on the line segment. Two of the edges are parallel to the speci?ed line
segment; each is at a distance of one-half the current width from that segment:
one above the segment and one below it. The other two edges pass through the
line endpoints and are perpendicular to the direction of the speci?ed line segment.
Coverage values are computed for each fragment by computing the area of the
intersection of the rectangle with the fragment square (see ?gure 14.4; see also
section 14.3). Equation 14.6 is used to compute associated data values just as with
non-antialiased lines; equation 14.5 is used to ?nd the value oft for each fragment
whose square is intersected by the line segment’s rectangle. Not all widths need be
supported for line segment antialiasing, but width 1:0 antialiased segments must
be provided. As with the point width, a GL implementation may be queried for the
range and number of gradations of available antialiased line widths.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.5. LINESEGMENTS 476
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
Figure 14.4. The region used in rasterizing and ?nding corresponding coverage
values for an antialiased line segment (an x-major line segment is shown).
14.5.3 Line Rasterization State
The state required for line rasterization consists of the ?oating-point line width
and a bit indicating whether line antialiasing is on or off. The initial value of the
line width is 1:0. The initial state of line segment antialiasing is disabled.
14.5.4 Line Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE_BUFFERS is one, then lines
are rasterized using the following algorithm, regardless of whether line antialiasing
(LINE_SMOOTH) is enabled or disabled. Line rasterization produces a fragment for
each framebuffer pixel with one or more sample points that intersect the rectangular
region that is described in the Antialiasing portion of section 14.5.2 (Other Line
Segment Features).
Coverage bits that correspond to sample points that intersect a retained rectan-
gle are 1, other coverage bits are 0. Each depth value and set of associated data
is produced by substituting the corresponding sample location into equation 14.5,
then using the result to evaluate equation 14.7. An implementation may choose to
assign the associated data to more than one sample by evaluating equation 14.5 at
any location within the pixel including the fragment center or any one of the sam-
ple locations, then substituting into equation 14.6. The different associated data
values need not be evaluated at the same location.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.6. POLYGONS 477
Line width range and number of gradations are equivalent to those supported
for antialiased lines.
14.6 Polygons
A polygon results from a triangle arising from a triangle strip, triangle fan, or
series of separate triangles. Like points and line segments, polygon rasterization
is controlled by several variables. Polygon antialiasing is enabled or disabled by
calling Enable or Disable with targetPOLYGON_SMOOTH.
14.6.1 Basic Polygon Rasterization
The ?rst step of polygon rasterization is to determine if the polygon is back-facing
or front-facing. This determination is made based on the sign of the (clipped or
unclipped) polygon’s area computed in window coordinates. One way to compute
this area is
n 1
X
1
i i1 i1 i
a = f x y  x y (14.8)
w w w w
2
i=0
wheref = 1 when the clip control origin is LOWER_LEFT andf = 1 when the
i i
origin is UPPER_LEFT,x andy are thex andy window coordinates of theith
w w
vertex of then-vertex polygon (vertices are numbered starting at zero for purposes
of this computation) andi 1 is (i + 1) modn. The interpretation of the sign of
this value is controlled with
void FrontFace(enum dir );
Setting dir toCCW (corresponding to counter-clockwise orientation of the pro-
jected polygon in window coordinates) usesa as computed above. Setting dir to
CW (corresponding to clockwise orientation) indicates that the sign ofa should be
reversed prior to use. Front face determination requires one bit of state, and is
initially set toCCW.
Errors
AnINVALID_ENUM error is generated if dir is notCW orCCW.
If the sign ofa (including the possible reversal of this sign as determined by
FrontFace) is positive, the polygon is front-facing; otherwise, it is back-facing.
This determination is used in conjunction with the CullFace enable bit and mode
OpenGL 4.6 (Core Pro?le) - February 2, 201914.6. POLYGONS 478
value to decide whether or not a particular polygon is rasterized. The CullFace
mode is set by calling
void CullFace(enum mode );
mode must beFRONT,BACK orFRONT_AND_BACK. Culling is enabled or disabled
by calling Enable or Disable with target CULL_FACE. Front-facing polygons are
rasterized if either culling is disabled or the CullFace mode is BACK while back-
facing polygons are rasterized only if either culling is disabled or the CullFace
mode isFRONT. The initial setting of the CullFace mode isBACK. Initially, culling
is disabled.
Errors
An INVALID_ENUM error is generated if mode is not FRONT, BACK, or
FRONT_AND_BACK.
The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon edge. In such a case
we require that if two polygons lie on either side of a common edge (with identical
endpoints) on which a fragment center lies, then exactly one of the polygons results
in the production of the fragment during rasterization.
As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. De?ne barycentric coordinates for a triangle. Barycentric coordinates are
a set of three numbers, a, b, andc, each in the range [0; 1], witha +b +c = 1.
These coordinates uniquely specify any pointp within the triangle or on the trian-
gle’s boundary as
p =ap +bp +cp ;
a b c
wherep ,p , andp are the vertices of the triangle.a,b, andc can be found as
a b c
A(pp p ) A(pp p ) A(pp p )
b c a c a b
a = ; b = ; c = ;
A(p p p ) A(p p p ) A(p p p )
a b c a b c a b c
where A(lmn) denotes the area in window coordinates of the triangle with vertices
l,m, andn.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.6. POLYGONS 479
Denote an associated datum atp ,p , orp asf ,f , orf , respectively. Then
a b c a b c
the valuef of a datum at a fragment produced by rasterizing a triangle is given by
af =w +bf =w +cf =w
a a b b c c
f = (14.9)
a=w +b=w +c=w
a b c
where w , w and w are the clip w coordinates of p , p , and p , respectively.
a b c a b c
a,b, andc are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygons must be interpolated by
z =az +bz +cz (14.10)
a b c
wherez ,z , andz are the depth values ofp ,p , andp , respectively.
a b c a b c
The noperspective and flat keywords used to declare shader outputs
affect how they are interpolated. When neither keyword is speci?ed, interpolation
is performed as described in equation 14.9. When thenoperspective keyword
is speci?ed, interpolation is performed in the same fashion as for depth values, as
described in equation 14.10. When the flat keyword is speci?ed, no interpola-
tion is performed, and outputs are taken from the corresponding input value of the
provoking vertex corresponding to that primitive (see section 13.6).
For a polygon with more than three edges, such as may be produced by clipping
a triangle, we require only that a convex combination of the values of the datum
at the polygon’s vertices can be used to obtain the value assigned to each fragment
produced by the rasterization algorithm. That is, it must be the case that at every
fragment
n
X
f = af
i i
i=1
wheren is the number of vertices in the polygon,f is the value of thef at vertex
i
P
n
i; for eachi 0 a  1 and a = 1. The values of thea may differ from
i i i
i=1
fragment to fragment, but at vertexi,a = 0;j6=i anda = 1.
j i
One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
also satis?es the restrictions (in this case, the numerator and denominator of equa-
tion 14.9 should be iterated independently and a division performed for each frag-
ment).
OpenGL 4.6 (Core Pro?le) - February 2, 201914.6. POLYGONS 480
14.6.2
This subsection is only de?ned in the compatibility pro?le.
14.6.3 Antialiasing
Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interior of the polygon intersects that fragment’s square. A coverage value is com-
puted at each such fragment, and this value is saved to be applied as described
in section 17.1. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’s interior and dividing this integrated value by the area of the intersection.
For a fragment square lying entirely within the polygon, the value of a datum at the
fragment’s center may be used instead of integrating the value across the fragment.
14.6.4 Options Controlling Polygon Rasterization
The interpretation of polygons for rasterization is controlled using
void PolygonMode(enum face,enum mode );
face must be FRONT_AND_BACK, indicating that the rasterizing method described
by mode replaces the rasterizing method for both front- and back-facing polygons.
mode must be one of POINT, LINE, or FILL. Calling PolygonMode with POINT
causes the vertices of a polygon to be treated, for rasterization purposes, as if they
had been drawn with mode POINTS. LINE causes edges to be rasterized as line
segments. FILL is the default mode of polygon rasterization, corresponding to
the description in sections 14.6.1, and 14.6.3. Note that these modes affect only
the ?nal rasterization of polygons: in particular, and the polygon is clipped and
possibly culled before these modes are applied.
Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.
14.6.5 Depth Offset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determines this value is speci?ed with the commands
void PolygonOffsetClamp(float factor, ?oat units, ?oat
clamp );
OpenGL 4.6 (Core Pro?le) - February 2, 201914.6. POLYGONS 481
void PolygonOffset(float factor,float units );
factor scales the maximum depth slope of the polygon, and units scales an
implementation-dependent constant that relates to the usable resolution of the
depth buffer. The resulting values are summed to produce the polygon offset value,
which may then be clamped to a minimum or maximum value speci?ed by clamp.
The values factor, units, and clamp may each be positive, negative, or zero. Calling
the command PolygonOffset is equivalent to calling the command PolygonOffset-
Clamp with clamp equal to zero.
The maximum depth slopem of a triangle is
s
   
2 2
@z @z
w w
m = + (14.11)
@x @y
w w
where (x ;y ;z ) is a point on the triangle.m may be approximated as
w w w
   
   
@z @z
w w
   
m = max ; : (14.12)
   
@x @y
w w
The minimum resolvable differencer is an implementation-dependent param-
eter that depends on the depth buffer representation. It is the smallest difference in
window coordinatez values that is guaranteed to remain distinct throughout poly-
gon rasterization and in the depth buffer. All pairs of fragments generated by the
rasterization of two polygons with otherwise identical vertices, butz values that
w
differ byr, will have distinct depth values.
For ?xed-point depth buffer representations,r is constant throughout the range
of the entire depth buffer. For ?oating-point depth buffers, there is no single min-
imum resolvable difference. In this case, the minimum resolvable difference for a
given polygon is dependent on the maximum exponent,e, in the range ofz values
spanned by the primitive. Ifn is the number of bits in the ?oating-point mantissa,
the minimum resolvable difference,r, for the given primitive is de?ned as
e n
r = 2 :
If no depth buffer is present,r is unde?ned.
The offset valueo for a polygon is
8
>mfactor +runits; clamp = 0 orNaN
<
o = min(mfactor +runits;clamp); clamp> 0 (14.13)
>
:
max(mfactor +runits;clamp); clamp< 0
OpenGL 4.6 (Core Pro?le) - February 2, 201914.6. POLYGONS 482
m is computed as described above. If the depth buffer uses a ?xed-point represen-
tation,m is a function of depth values in the range [0; 1], ando is applied to depth
values in the same range.
The state required for polygon offset consists of three boolean state values,
POLYGON_OFFSET_POINT,POLYGON_OFFSET_LINE, andPOLYGON_OFFSET_-
FILL, which determine whether polygon offseto is applied during the rasterization
of polygons in POINT, LINE, and FILL modes, respectively, and a ?oating-point
state value,POLYGON_OFFSET_CLAMP, specifying the offset clamp.
The initial value of each of the offset enables isFALSE, and the initial value of
the offset clamp is 0:0.
If polygon offset point, line, or ?ll is enabled,o is added to the depth value of
each fragment produced by the rasterization of a polygon inPOINT,LINE, orFILL
mode, respectively.
For ?xed-point depth buffers, fragment depth values are always limited to the
range [0; 1] by clamping after offset addition is performed. Fragment depth values
are clamped even when the depth buffer uses a ?oating-point representation.
14.6.6 Polygon Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE_BUFFERS is one, then poly-
gons are rasterized using the following algorithm, regardless of whether polygon
antialiasing (POLYGON_SMOOTH) is enabled or disabled. Polygon rasterization pro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 14.6.1. If a polygon is
culled, based on its orientation and the CullFace mode, then no fragments are pro-
duced during rasterization.
Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each associated datum is produced as
described in section 14.6.1, but using the corresponding sample location instead of
the fragment center. An implementation may choose to assign the same associated
data values to more than one sample by barycentric evaluation using any location
within the pixel including the fragment center or one of the sample locations.
The noperspective and flat quali?ers affect how shader outputs are
interpolated in the same fashion as described for basic polygon rasterization in
section 14.6.1.
The rasterization described above applies only to the FILL state of Polygon-
Mode. ForPOINT andLINE, the rasterizations described in sections 14.4.3 (Point
Multisample Rasterization) and 14.5.4 (Line Multisample Rasterization) apply.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.7. 483
14.6.7 Polygon Rasterization State
The state required for polygon rasterization consists of the current state of polygon
antialiasing (enabled or disabled), the current value of the PolygonMode setting,
whether point, line, and ?ll mode polygon offsets are enabled or disabled, and
the factor and bias values of the polygon offset equation. The initial setting of
polygon antialiasing is disabled. The initial state for PolygonMode isFILL . The
initial polygon offset factor and bias values are both 0; initially polygon offset is
disabled for all modes.
14.7
This section is only de?ned in the compatibility pro?le.
14.8
This section is only de?ned in the compatibility pro?le.
14.9 Early Per-Fragment Tests
Once fragments are produced by rasterization, a number of per-fragment operations
are performed prior to fragment shader execution (see section 15). If a fragment is
discarded during any of these operations, it will not be processed by any subsequent
stage, including fragment shader execution.
Three fragment operations are performed, and a further three are optionally
performed on each fragment, in the following order:
 the pixel ownership test (see section 14.9.1);
 the scissor test (see section 14.9.2);
 multisample fragment operations (see section 14.9.3);
If early per-fragment operations are enabled, these tests are also performed:
 the stencil test (see section 17.3.3);
 the depth buffer test (see section 17.3.4); and
 occlusion query sample counting (see section 17.3.5).
OpenGL 4.6 (Core Pro?le) - February 2, 201914.9. EARLYPER-FRAGMENTTESTS 484
14.9.1 Pixel Ownership Test
The ?rst test is to determine if the pixel at location (x ;y ) in the framebuffer
w w
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate of the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
control the GL’s behavior, for instance, when a GL window is obscured.
If the draw framebuffer is a framebuffer object (see section 17.4.1), the pixel
ownership test always passes, since the pixels of framebuffer objects are owned by
the GL, not the window system. If the draw framebuffer is the default framebuffer,
the window system controls pixel ownership.
14.9.2 Scissor Test
The scissor test determines if (x ;y ) lies within the scissor rectangle de?ned by
w w
four values for each viewport. These values are set with
void ScissorArrayv(uint ?rst,sizei count,const
int *v );
void ScissorIndexed(uint index,int left,int bottom,
sizei width,sizei height );
void ScissorIndexedv(uint index,int *v );
void Scissor(int left,int bottom,sizei width,
sizei height );
ScissorArrayv de?nes a set of scissor rectangles that are each applied to the
corresponding viewport (see section 13.8.1). ?rst speci?es the index of the ?rst
scissor rectangle to modify, and count speci?es the number of scissor rectangles. v
contains the address of an array of integers containing the left, bottom, width and
height of the scissor rectangles, in that order.
If left x < left + width and bottom y < bottom + height for the
w w
selected scissor rectangle, then the scissor test passes. Otherwise, the test fails and
the fragment is discarded. For points, lines, and polygons, the scissor rectangle for
a primitive is selected in the same manner as the viewport (see section 13.8.1). For
buffer clears (see section 17.4.3), the scissor rectangle numbered zero is used for
the scissor test.
Errors
AnINVALID_VALUE error is generated by ScissorArrayv if rst +count
OpenGL 4.6 (Core Pro?le) - February 2, 201914.9. EARLYPER-FRAGMENTTESTS 485
is greater than the value ofMAX_VIEWPORTS.
AnINVALID_VALUE error is generated by ScissorArrayv if count is neg-
ative.
An INVALID_VALUE error is generated by ScissorIndexed and Scissor
if width or height is negative.
The scissor test is enabled or disabled for all viewports using Enable or Dis-
able with target SCISSOR_TEST. The test is enabled or disabled for a speci?c
viewport using Enablei or Disablei with the constantSCISSOR_TEST and the in-
dex of the selected viewport. When disabled, it is as if the scissor test always
passes. The value of the scissor test enable for viewporti can be queried by calling
IsEnabledi with target SCISSOR_TEST and indexi. The value of the scissor test
enable for viewport zero may also be queried by calling IsEnabled with the same
target, but no index parameter.
Errors
An INVALID_VALUE error is generated by Enablei, Disablei and IsEn-
abledi if target is SCISSOR_TEST and index is greater than or equal to the
value ofMAX_VIEWPORTS.
The state required consists of four integer values per viewport, and a bit in-
dicating whether the test is enabled or disabled for each viewport. In the initial
state, left = bottom = 0; and width and height are determined by the size of the
window into which the GL is to do its rendering for all viewports. If the default
framebuffer is bound but no default framebuffer is associated with the GL context
(see chapter 9), then width and height are initially set to zero. Initially, the scissor
test is disabled for all viewports.
ScissorIndexed and ScissorIndexedv specify the scissor rectangle for a single
viewport and are equivalent (assuming no errors are generated) to:
int v[] = f left, bottom, width, height g;
ScissorArrayv(index, 1, v);
and
ScissorArrayv(index, 1, v);
respectively.
Scissor sets the scissor rectangle for all viewports to the same values and is
equivalent (assuming no errors are generated) to:
OpenGL 4.6 (Core Pro?le) - February 2, 201914.9. EARLYPER-FRAGMENTTESTS 486
for (uint i = 0; i < MAX_VIEWPORTS; i++) f
ScissorIndexed(i, left, bottom, width, height);
g
Calling Enable or Disable with targetSCISSOR_TEST is equivalent, assuming
no errors, to:
for (uint i = 0; i < MAX_VIEWPORTS; i++) f
Enablei(SCISSOR_TEST, i);
/* or */
Disablei(SCISSOR_TEST, i);
g
14.9.3 Multisample Fragment Operations
This step modi?es fragment coverage values based on the values of SAMPLE_-
COVERAGE, SAMPLE_COVERAGE_VALUE, SAMPLE_COVERAGE_INVERT,
SAMPLE_MASK, SAMPLE_MASK_VALUE, and an output sample mask option-
ally written by the fragment shader. If MULTISAMPLE is disabled, or if the value
ofSAMPLE_BUFFERS is not one, this step is skipped.
All alpha values in this section refer only to the alpha component of the frag-
ment shader output linked to color number zero, index zero (see section 15.2.3).
If the fragment shader does not write to this output, the alpha value is unde?ned.
Sample coverage and sample mask operations are enabled or disabled by call-
ing Enable and Disable with targets SAMPLE_COVERAGE or SAMPLE_MASK, re-
spectively.
Next, ifSAMPLE_COVERAGE is enabled, the fragment coverage is ANDed with
a temporary coverage mask generated from the value of SAMPLE_COVERAGE_-
VALUE. If the value ofSAMPLE_COVERAGE_INVERT isTRUE, this mask is inverted
(all bit values are inverted) before it is ANDed with the fragment coverage. Finally,
if SAMPLE_MASK is enabled, the fragment coverage is ANDed with the value of
SAMPLE_MASK_VALUE. This updated coverage becomes the new fragment cover-
age value.
No speci?c algorithm is required for converting the sample coverage value to
a temporary coverage mask. It is intended that the number of 1’s in this value be
proportional to the sample coverage value, with all 1’s corresponding to a value
of 1.0 and all 0’s corresponding to 0.0. It is also intended that the algorithm be
pseudo-random in nature, to avoid image artifacts due to regular coverage sample
locations. The algorithm can and probably should be different at different pixel
locations. If it does differ, it should be de?ned relative to window, not screen,
coordinates, so that rendering results are invariant with respect to window position.
OpenGL 4.6 (Core Pro?le) - February 2, 201914.9. EARLYPER-FRAGMENTTESTS 487
The values of SAMPLE_COVERAGE_VALUE and SAMPLE_COVERAGE_INVERT
are speci?ed by calling
void SampleCoverage(float value,boolean invert );
with value set to the desired coverage value, and invert set toTRUE orFALSE. value
is clamped to [0; 1] before being stored asSAMPLE_COVERAGE_VALUE. These val-
ues may be queried as described in table 23.11.
The value ofSAMPLE_MASK_VALUE is speci?ed using
void SampleMaski(uint maskNumber,bitfield mask );
with mask set to the desired mask for mask word maskNumber. BitB of mask word
M corresponds to sample 32M +B as described in section 14.3.1. The sample
mask value is queried by calling GetIntegeri v with target set toSAMPLE_MASK_-
VALUE and the index set to maskNumber.
Errors
An INVALID_VALUE error is generated if maskNumber is greater than or
equal to the value ofMAX_SAMPLE_MASK_WORDS.
14.9.4 The Early Fragment Test Quali?er
The stencil test, depth buffer test and occlusion query sample counting are per-
formed if and only if early fragment tests are enabled in the active fragment shader
(see section 15.2.4). When early per-fragment operations are enabled, these op-
erations are performed prior to fragment shader execution, and the stencil buffer,
depth buffer, and occlusion query sample counts will be updated accordingly; these
operations will not be performed again after fragment shader execution.
When there is no active program, the active program has no fragment shader, or
the active program was linked with early fragment tests disabled, these operations
are performed only after fragment program execution, in the order described in
section 17.3.
If early fragment tests are enabled, any depth value computed by the fragment
shader has no effect. Additionally, the depth buffer, stencil buffer, and occlusion
query sample counts may be updated even for fragments or samples that would be
discarded after fragment shader execution due to per-fragment operations such as
alpha-to-coverage tests.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 15
Programmable Fragment
Processing
When the program object currently in use for the fragment stage (see section 7.3)
includes a fragment shader, its shader is considered active and is used to process
fragments resulting from rasterization (see section 14).
If the current fragment stage program object has no fragment shader, or no
fragment program object is current for the fragment stage, the results of fragment
shader execution are unde?ned.
The processed fragments resulting from fragment shader execution are then
further processed and written to the framebuffer as described in chapter 17.
15.1 Fragment Shader Variables
Fragment shaders can access uniforms belonging to the current program object.
Limits on uniform storage and methods for manipulating uniforms are described in
section 7.6.
Fragment shaders also have access to samplers to perform texturing operations,
as described in section 7.11.
Fragment shaders can read input variables or inputs that correspond to the
attributes of the fragments produced by rasterization.
The OpenGL Shading Language Specification de?nes a set of built-in inputs
that can be be accessed by a fragment shader. These built-in inputs include data
associated with a fragment such as the fragment’s position.
Additionally, the previous active shader stage may de?ne one or more output
variables (see section 11.1.2.1 and the OpenGL Shading Language Specification).
The values of these user-de?ned outputs are, if not ?at shaded, interpolated across
48815.2. SHADEREXECUTION 489
the primitive being rendered. The results of these interpolations are available when
inputs of the same name are de?ned in the fragment shader.
When interpolating input variables, the default screen-space location at which
these variables are sampled is de?ned in previous rasterization sections. The
default location may be overriden by interpolation quali?ers. When interpolat-
ing variables declared using centroid in, the variable is sampled at a location
within the pixel covered by the primitive generating the fragment. When interpo-
lating variables declared using sample in when MULTISAMPLE is enabled, the
fragment shader will be invoked separately for each covered sample and the vari-
able will be sampled at the corresponding sample point.
Additionally, built-in fragment shader functions provide further ?ne-grained
control over interpolation. The built-in functions interpolateAtCentroid
andinterpolateAtSample will sample variables as though they were declared
with the centroid or sample quali?ers, respectively. The built-in function
interpolateAtOffset will sample variables at a speci?ed (x;y) offset relative
to the center of the pixel. The range and granularity of offsets supported by this
function is implementation-dependent. If either component of the speci?ed off-
set is less than the value ofMIN_FRAGMENT_INTERPOLATION_OFFSET or greater
than the value of MAX_FRAGMENT_INTERPOLATION_OFFSET, the position used
to interpolate the variable is unde?ned. Not all values of offset may be supported;
x andy offsets may be rounded to ?xed-point values with the number of fraction
bits given by the value of the implementation-dependent constant FRAGMENT_-
INTERPOLATION_OFFSET_BITS.
A fragment shader can also write to output variables. Values written to these
outputs are used in the subsequent per-fragment operations. Output variables can
be used to write ?oating-point, integer or unsigned integer values destined for
buffers attached to a framebuffer object, or destined for color buffers attached to the
default framebuffer. Section 15.2.3 describes how to direct these values to buffers.
15.2 Shader Execution
If there is an active program object present for the fragment stage, the executable
code for that program is used to process incoming fragments that are the result of
rasterization.
Implementations are allowed to skip the execution of certain fragment shader
invocations, and to execute additional fragment shader invocations during pro-
grammable fragment processing due to implementation dependent reasons, includ-
ing the execution of fragment shader invocations when there is not an active pro-
gram object present for the fragment shader stage, as long as the results of render-
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 490
ing otherwise remain unchanged.
Following shader execution, the ?xed-function operations described in chap-
ter 17 are performed.
Special considerations for fragment shader execution are described in the fol-
lowing sections.
15.2.1 Texture Access
Section 11.1.3.1 describes texture lookup functionality accessible to a vertex
shader. The texel fetch and texture size query functionality described there also
applies to fragment shaders.
When a texture lookup is performed in a fragment shader, the GL computes
the ?ltered texture value  in the manner described in sections 8.14 and 8.15,
and converts it to a texture base color C as shown in table 15.1, followed
b
by swizzling the components of C , controlled by the values of the texture pa-
b
rametersTEXTURE_SWIZZLE_R,TEXTURE_SWIZZLE_G,TEXTURE_SWIZZLE_B,
and TEXTURE_SWIZZLE_A. If the value of TEXTURE_SWIZZLE_R is denoted by
swizzle , swizzling computes the ?rst component ofC according to
r s
if (swizzle == RED)
r
C [0] = C [0];
s b
else if (swizzle == GREEN)
r
C [0] = C [1];
s b
else if (swizzle == BLUE)
r
C [0] = C [2];
s b
else if (swizzle == ALPHA)
r
C [0] = A ;
s b
else if (swizzle == ZERO)
r
C [0] = 0;
s
else if (swizzle == ONE)
r
C [0] = 1; // float or int depending on texture component type
s
Swizzling of C [1], C [2], and A are similarly controlled by the values of
s s s
TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A, re-
spectively.
The resulting four-component vector (R ;G ;B ;A ) is returned to the frag-
s s s s
du du
ment shader. For the purposes of level-of-detail calculations, the derivatives , ,
dx dy
dv dv dw dw
, , and may be approximated by a differencing algorithm as described
dx dy dx dy
in section 8.13.1(“Derivative Functions”) of the OpenGL Shading Language Spec-
i?cation.
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 491
Texture Base Texture base color
Internal Format C A
b b
RED (R ; 0; 0) 1
t
RG (R ;G ; 0) 1
t t
RGB (R ;G ;B ) 1
t t t
RGBA (R ;G ;B ) A
t t t t
Table 15.1: Correspondence of ?ltered texture components to texture base compo-
nents.
Texture lookups involving textures with depth and/or stencil component data
are performed as described in section 11.1.3.5.
15.2.2 Shader Inputs
The OpenGL Shading Language Specification describes the values that are avail-
able as inputs to the fragment shader.
The built-in variable gl_FragCoord holds the fragment coordinate
  
x y z w for the fragment. Computing the fragment coordinate depends
f f f f
on the fragment processing pixel-center and origin conventions (discussed below)
as follows:
(
1
x   ; pixel-center convention is integer
w
2
x =
f
x ; otherwise
w
(
H y ; origin convention is upper-left
w
0
y =
f
y ; otherwise
w
(
(15.1)
0 1
y   ; pixel-center convention is integer
f
2
y =
f
0
y otherwise
f
z =z
f w
1
w =
f
w
c
  
where x y z is the fragment’s window-space position,w is thew compo-
w w w c
nent of the fragment’s clip-space position (see section 13.8), andH is the window’s
height in pixels. Note thatz already has a polygon offset added in, if enabled (see
w
section 14.6.5).z must be precisely zero or one in the case wherez is either zero
f w
or one, respectively.
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 492
Unless otherwise speci?ed by layout quali?ers in the fragment shader (see
section 4.4.1.3(“Fragment Shader Inputs”) of the OpenGL Shading Language
Specification), the fragment processing pixel-center convention is half-integer and
the fragment processing origin convention is lower left.
The built-in variable gl_FrontFacing is set to true if the fragment is gen-
erated from a front-facing primitive, and false otherwise. For fragments gener-
ated from triangle primitives (including ones resulting from primitives rendered
as points or lines), the determination is made by examining the sign of the area
computed by equation 14.8 of section 14.6.1 (including the possible reversal of
this sign controlled by FrontFace). If the sign is positive, fragments generated by
the primitive are front-facing; otherwise, they are back-facing. All other fragments
are considered front-facing.
If a geometry shader is active, the built-in variable gl_PrimitiveID con-
tains the ID value emitted by the geometry shader for the provoking vertex. If no
geometry shader is active, gl_PrimitiveID contains the number of primitives
processed by the rasterizer since the last drawing command was called. The ?rst
primitive generated by a drawing command is numbered zero, and the primitive ID
counter is incremented after every individual point, line, or polygon primitive is
processed. For polygons drawn in point or line mode, the primitive ID counter is
incremented only once, even though multiple points or lines may be drawn.
Restarting a primitive using the primitive restart index (see section 10.3) has
no effect on the primitive ID counter.
gl_PrimitiveID is only de?ned under the same conditions that gl_-
VertexID is de?ned, as described under “Shader Inputs” in section 11.1.3.9.
The built-in read-only variable gl_SampleID is ?lled with the sample num-
ber of the sample currently being processed. This variable is in the range zero
to gl_NumSamples minus one, where gl_NumSamples is the total number of
samples in the framebuffer, or one if rendering to a non-multisample framebuffer.
Using this variable in a fragment shader causes the entire shader to be evaluated
per-sample. When rendering to a non-multisample buffer, or if multisample ras-
terization is disabled,gl_SampleID will always be zero. gl_NumSamples is the
sample count of the framebuffer regardless of whether multisample rasterization is
enabled or not.
The built-in read-only variablegl_SamplePosition contains the position of
the current sample within the multi-sample draw buffer. Thex andy components
of gl_SamplePosition contain the sub-pixel coordinate of the current sample
and will have values in the range [0; 1]. The sub-pixel coordinates of the center of
the pixel are always (0:5; 0:5). Using this variable in a fragment shader causes the
entire shader to be evaluated per-sample. When rendering to a non-multisample
buffer, or if multisample rasterization is disabled, gl_SamplePosition will al-
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 493
ways be (0:5; 0:5).
The built-in variable gl_SampleMaskIn is an integer array holding bit?elds
indicating the set of fragment samples covered by the primitive corresponding to
the fragment shader invocation. The number of elements in the array is
l m
s
;
32
wheres is the value of the maximum number of color samples supported by the
implementation for any renderable internal format. Bitn of elementw in the array
is set if and only if the sample numbered 32w +n is considered covered for this
fragment shader invocation. When rendering to a non-multisample buffer, or if
multisample rasterization is disabled, all bits are zero except for bit zero of the ?rst
array element. That bit will be one if the pixel is covered and zero otherwise. Bits
in the sample mask corresponding to covered samples that will be killed due to
SAMPLE_COVERAGE or SAMPLE_MASK will not be set (see section 14.9.3). When
per-sample shading is active due to the use of a fragment input quali?ed bysample
or due to the use of the gl_SampleID or gl_SamplePosition variables, only
the bit for the current sample is set in gl_SampleMaskIn. When state speci?es
multiple fragment shader invocations for a given fragment, the bit corresponding
to each covered sample will be set in exactly one fragment shader invocation.
Similarly to the limit on geometry shader output components (see sec-
tion 11.3.4.5), there is a limit on the number of components of built-in and
user-de?ned input variables that can be read by the fragment shader, given by
the value of the implementation-dependent constant MAX_FRAGMENT_INPUT_-
COMPONENTS.
When a program is linked, all components of any input variables read by a
fragment shader will count against this limit. A program whose fragment shader
exceeds this limit may fail to link, unless device-dependent optimizations are able
to make the program ?t within available hardware resources.
Component counting rules for different variable types and variable declarations
are the same as forMAX_VERTEX_OUTPUT_COMPONENTS (see section 11.1.2.1).
15.2.3 Shader Outputs
The OpenGL Shading Language Specification describes the values that may be
output by a fragment shader. These outputs are split into two categories, user-
de?ned outputs and the built-in outputs gl_FragDepth andgl_SampleMask.
For ?xed-point depth buffers, the ?nal fragment depth written by a fragment
shader is ?rst clamped to [0; 1] and then converted to ?xed-point as if it were a
windowz value (see section 13.8.1). For ?oating-point depth buffers, conversion
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 494
is not performed but clamping is. Note that the depth range computation is not
applied here, only the conversion to ?xed-point.
The built-in integer array gl_SampleMask can be used to change the sample
coverage for a fragment from within the shader. The number of elements in the
array is
l m
s
;
32
wheres is the value of the maximum number of color samples supported by the
implementation for any renderable internal format. If bitn of elementw in the ar-
ray is set to zero, sample 32w +n should be considered uncovered for the purposes
of additional sample fragment operations, as described in section 17.3.10, and the
corresponding bits in the fragment coverage mask are set to zero. Modifying the
sample mask in this way may exclude covered samples from being processed fur-
ther at a per-fragment granularity. However, setting sample mask bits to one will
never enable samples not covered by the original primitive. If the fragment shader
is being evaluated at any frequency other than per-fragment, bits of the sample
mask not corresponding to the current fragment shader invocation do not affect the
fragment coverage mask. If a fragment shader does not statically assign a value to
gl_SampleMask, the fragment coverage mask is not modi?ed. If a value is not
assigned togl_SampleMask due to ?ow of control, the affected bits of the sample
mask are unde?ned.
Color values written by a fragment shader may be ?oating-point, signed inte-
ger, or unsigned integer. If the color buffer has a signed or unsigned normalized
?xed-point format, color values are assumed to be ?oating-point and are converted
to ?xed-point as described in equations 2.4 or 2.3, respectively; otherwise no type
conversion is applied. If the values written by the fragment shader do not match
the format(s) of the corresponding color buffer(s), the result is unde?ned.
Writing to gl_FragDepth speci?es the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value togl_-
FragDepth, then the depth value generated during rasterization is used by sub-
sequent stages of the pipeline. Otherwise, the value assigned to gl_FragDepth
is used, and is unde?ned for any fragments where statements assigning a value to
gl_FragDepth are not executed. Thus, if a shader statically assigns a value to
gl_FragDepth, then it is responsible for always writing it.
The binding of a user-de?ned output variable to components of a fragment
color number can be speci?ed explicitly in the shader text or SPIR-V shader, or
using the command
void BindFragDataLocationIndexed(uint program,
uint colorNumber,uint index,const char * name );
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 495
speci?es that the output variable name in program should be bound to fragment
color colorNumber when the program is next linked. index may be zero or one to
specify that the color will be used as either the ?rst or second color input to the
blend equation, respectively, as described in section 17.3.6.
If name was bound previously, its assigned binding is replaced with colorNum-
ber. name must be a null-terminated string.
Errors
An INVALID_VALUE error is generated if program is not the name of ei-
ther a program or shader object.
An INVALID_OPERATION error is generated if program is the name of a
shader object.
An INVALID_VALUE error is generated if index is greater than one, if
colorNumber is greater than or equal to the value of MAX_DRAW_BUFFERS
and index is zero, or if colorNumber is greater than or equal to the value of
MAX_DUAL_SOURCE_DRAW_BUFFERS and index is equal to one.
The command
void BindFragDataLocation(uint program,
uint colorNumber,const char * name );
is equivalent to
BindFragDataLocationIndexed(program, colorNumber, 0, name);
BindFragDataLocation has no effect until the program is linked. In particular,
it doesn’t modify the bindings of outputs in a program that has already been linked.
Errors
An INVALID_OPERATION error is generated if name starts with the re-
servedgl_ pre?x.
When a program is linked, each active user-de?ned fragment shader output
variable will have a binding consisting of a fragment color number, a fragment
color index, and a component index. Output variables declared with location,
component, orindexlayout quali?ers will use the values speci?ed in the shader
text. For SPIR-V shaders, these are speci?ed by theLocation,Component, and
Index decorations. Output variables without such layout or decoration quali?ers
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 496
will use the bindings speci?ed by BindFragDataLocationIndexed or BindFrag-
DataLocation, if any. BindFragDataLocation* has no effect on SPIR-V shaders,
since the locations must always be fully speci?ed as described in section 15.2.3.1.
Otherwise, the linker will automatically assign a fragment color number, using
any color number not already assigned to another active fragment shader output
variable. The fragment color index and component index of an output variable
binding will default to zero unless values are explicitly speci?ed by a layout
qualifer or BindFragDataLocationIndexed. The properties of an active fragment
shader output variable binding can be queried using the command GetProgram-
Resourceiv with a programInterface of PROGRAM_OUTPUT and props values of
LOCATION,LOCATION_INDEX, andLOCATION_COMPONENT.
When a fragment shader terminates, the value of each active user-de?ned out-
put variable is written to components of the fragment color output to which it is
bound. The set of fragment color components written is determined according to
the variable’s data type and component index binding, using the mappings in ta-
ble 11.1. For an output variable declared as an array bound to fragment color num-
ber i, individual active array elements are written to consecutive fragment color
numbers beginning withi, with the components written determined from the array
element’s data type and the array variable’s component index binding.
Output binding assignments will cause LinkProgram to fail:
 if the number of active outputs is greater than the value of MAX_DRAW_-
BUFFERS;
 if the program has an active output assigned to a location greater than or
equal to the value ofMAX_DUAL_SOURCE_DRAW_BUFFERS and has an active
output assigned an index greater than or equal to one;
 if two output variables are bound to the same output number and index with
overlapping components selected;
 if two output variables with different component types (signed integer, un-
signed integer, or ?oating-point) are bound to the same output number, even
if selected components do not overlap; or
 if the explicit binding assigments do not leave enough space for the linker to
automatically assign a location for an output array, which requires multiple
contiguous locations.
BindFragDataLocationIndexed may be issued before any shader objects are
attached to a program object. Hence it is allowed to bind any name (except a name
starting withgl_) to a color number and index, including a name that is never used
OpenGL 4.6 (Core Pro?le) - February 2, 201915.2. SHADEREXECUTION 497
as an output in any fragment shader object. Assigned bindings for variables that do
not exist are ignored.
To determine the set of fragment shader output attribute variables used by a pro-
gram, applications can query the properties and active resources of thePROGRAM_-
OUTPUT interface of a program including a fragment shader.
Additionally, the commands
int GetFragDataLocation(uint program,const
char *name );
int GetFragDataIndex(uint program,const char *name );
are provided to query the location and fragment color index assigned to a fragment
shader output variable.
Errors
If program has been linked successfully but contains no fragment shader,
no error is generated but -1 will be returned.
AnINVALID_OPERATION error is generated and -1 is returned if program
has not been linked successfully.
Otherwise, the commands are equivalent to
GetProgramResourceLocation(program, PROGRAM_OUTPUT, name);
and
GetProgramResourceLocationIndex(program, PROGRAM_OUTPUT, name);
respectively.
15.2.3.1 SPIR-V Fragment Output Interface
When a SPIR-V fragment stage is present, the variables listed byOpEntryPoint
with theOutput storage class form the fragment output interface. These variables
must be decorated with aLocation They can also be decorated with aComponent
and/or anIndex.
User-de?ned fragment shader output variables are matched only by their
Location,Component, andIndex decorations. If two outputs are placed within
the same location, they must have the same underlying type (?oating-point or in-
teger). No component aliasing of output variables is allowed. That is, there must
OpenGL 4.6 (Core Pro?le) - February 2, 201915.3. FRAGMENTSHADERQUERIES 498
not be two output variables which have the same location, component, and index,
either explicitly declared or implied. Output values written by a fragment shader
must be declared with either OpTypeFloat or OpTypeInt, and a Width of 32.
Composites of these types are also permitted.
15.2.4 Early Fragment Tests
An explicit control is provided to allow fragment shaders to enable early frag-
ment tests. If the fragment shader speci?es theearly_fragment_testslayout
quali?er, the per-fragment tests described in section 14.9 will be performed prior
to fragment shader execution. Otherwise, they will be performed after fragment
shader execution.
15.3 Fragment Shader Queries
Fragment shader queries use query objects to track the number of fragment shader
invocations.
When BeginQuery is called with a target of FRAGMENT_SHADER_-
INVOCATIONS, the fragment shader invocations count maintained by the GL is
set to zero. When a fragment shader invocations query is active, the counter is
incremented every time the fragment shader is invoked (see section 15.2).
The result of fragment shader queries may be implementation dependent due
to reasons described in section 15.2.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 16
This chapter is only de?ned in the compatibility pro?le.
499Chapter 17
Writing Fragments and Samples
to the Framebuffer
After programmable fragment processing, the following ?xed-function operations
are applied to the resulting fragments:
 Antialiasing application (see section 17.1).
 Multisample point fade (see section 17.2).
 Per-fragment operations and writing to the framebuffer (see section 17.3).
Writing to the framebuffer is the ?nal set of operations performed as a result of
drawing primitives.
Additional commands controlling the framebuffer as a whole are described in
section 17.4.
17.1 Antialiasing Application
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. The value
is multiplied by the fragment’s alpha value to yield a ?nal alpha value. The
coverage value is applied separately to each fragment color, and only applied if the
corresponding color buffer in the framebuffer has a ?xed- or ?oating-point format.
17.2 Multisample Point Fade
If multisampling is enabled and the rasterized fragment results from a point prim-
itive, then the computed fade factor from equation 14.2 is applied to the fragment.
50017.3. PER-FRAGMENTOPERATIONS 501
The fade factor is multiplied by the fragment’s alpha value to yield a ?nal alpha
value. The fade factor is applied separately to each fragment color, and only
applied if the corresponding color buffer in the framebuffer has a ?xed- or ?oating-
point format.
17.3 Per-Fragment Operations
A fragment is produced by rasterization with window coordinates of (x ;y )
w w
and depthz, as described in chapter 14. The fragment is then modi?ed by pro-
grammable fragment processing, which adds associated data as described in chap-
ter 15. The fragment is then further modi?ed, and possibly discarded by the per-
fragment operations described in this chapter. These operations are diagrammed
in ?gure 17.1, in the order in which they are performed. Finally, if the fragment
was not discarded, it is used to update the framebuffer at the fragment’s window
coordinates.
The stencil test, depth test, and occlusion query operations described in sec-
tions 17.3.3, 17.3.4, and 17.3.5 may instead be performed prior to fragment pro-
cessing, as described in section 14.9, if requested by the fragment program.
17.3.1 Alpha To Coverage
This step modi?es fragment alpha and coverage values based on the values of
SAMPLE_ALPHA_TO_COVERAGE andSAMPLE_ALPHA_TO_ONE. IfMULTISAMPLE
is disabled, if the value of SAMPLE_BUFFERS is not one, or if draw buffer zero is
not NONE and the buffer it references has an integer format, these operations are
skipped.
Alpha to coverage and alpha to one operations are enabled or disabled
by calling Enable and Disable with targets SAMPLE_ALPHA_TO_COVERAGE or
SAMPLE_ALPHA_TO_ONE, respectively.
All alpha values in this section refer only to the alpha component of the frag-
ment shader output linked to color number zero, index zero (see section 15.2.3).
If SAMPLE_ALPHA_TO_COVERAGE is enabled, a temporary coverage value is
generated where each bit is determined by the alpha value at the corresponding
sample location (see section 14.3.1). The temporary coverage value is then ANDed
with the fragment coverage value to generate a new fragment coverage value.
This temporary coverage is generated in the same manner as for sample cover-
age (see section 14.9.3), but as a function of the fragment’s alpha value, clamped
to the range [0; 1]. The function need not be identical, but it must have the same
properties of proportionality and invariance.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 502
Fragment (or sample)
Fragment
Alpha To
and Associated Data
(or sample) Fragment
Coverage
from Shader
Operations
Rasterization
Occlusion Depth Buffer Stencil
Blending
Query (*) Test (*) Test (*)
Framebuffer Framebuffer Framebuffer
Additional
SRGB Multisample
Dithering Logicop
Conversion Fragment
Operations
Framebuffer
Write To
Framebuffer
Figure 17.1. Per-fragment operations. The boxes labelled with “(*)” may instead
be performed during early per-fragment operations, as described in section 14.9.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 503
Next, if SAMPLE_ALPHA_TO_ONE is enabled, each alpha value is replaced by
the maximum representable alpha value for ?xed-point color buffers, or by 1.0 for
?oating-point buffers. Otherwise, the alpha values are not changed.
17.3.2
This subsection is only de?ned in the compatibility pro?le.
17.3.3 Stencil Test
The stencil test conditionally discards a fragment based on the outcome of a com-
parison between the value in the stencil buffer at location (x ;y ) and a reference
w w
value. The test is enabled or disabled with the Enable and Disable commands,
using targetSTENCIL_TEST. When disabled, the stencil test and associated modi-
?cations are not made, and the fragment is always passed.
The stencil test is controlled with
void StencilFunc(enum func,int ref,uint mask );
void StencilFuncSeparate(enum face,enum func,int ref,
uint mask );
void StencilOp(enum sfail,enum dpfail,enum dppass );
void StencilOpSeparate(enum face,enum sfail,enum dpfail,
enum dppass );
There are two sets of stencil-related state, the front stencil state set and the
back stencil state set. Stencil tests and writes use the front set of stencil state
when processing fragments rasterized from non-polygon primitives (points and
lines) and front-facing polygon primitives while the back set of stencil state is
used when processing fragments rasterized from back-facing polygon primitives.
For the purposes of stencil testing, a primitive is still considered a polygon even if
the polygon is to be rasterized as points or lines due to the current polygon mode.
Whether a polygon is front- or back-facing is determined in the same manner used
for face culling (see section 14.6.1).
StencilFuncSeparate and StencilOpSeparate take a face argument which can
beFRONT,BACK, orFRONT_AND_BACK and indicates which set of state is affected.
StencilFunc and StencilOp set front and back stencil state to identical values.
StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is used
in the unsigned stencil comparison. Stencil comparison operations and queries of
s
ref clamp its value to the range [0; 2   1], where s is the number of bits in the
stencil buffer attached to the draw framebuffer. Thes least signi?cant bits of mask
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 504
are bitwise ANDed with both the reference and the stored stencil value, and the
resulting masked values are those that participate in the comparison controlled by
func. func is a symbolic constant that determines the stencil comparison function;
the eight symbolic constants areNEVER,ALWAYS,LESS,LEQUAL,EQUAL,GEQUAL,
GREATER, orNOTEQUAL. Accordingly, the stencil test passes never, always, and if
the masked reference value is less than, less than or equal to, equal to, greater than
or equal to, greater than, or not equal to the masked stored value in the stencil
buffer.
StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
areKEEP,ZERO,REPLACE,INCR,DECR,INVERT,INCR_WRAP, andDECR_WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wise inverting it, incrementing without saturation, and decrementing without satu-
ration.
For purposes of increment and decrement, the stencil bits are considered as an
unsigned integer. Incrementing or decrementing with saturation clamps the stencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
value results in 0, and decrementing 0 results in the maximum representable value.
The same symbolic values are given to indicate the stencil action if the depth
buffer test (see section 17.3.4) fails (dpfail), or if it passes (dppass).
If the stencil test fails, the incoming fragment is discarded. The state required
consists of the most recent values passed to StencilFunc or StencilFuncSeparate
and to StencilOp or StencilOpSeparate, and a bit indicating whether stencil test-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and
back stencil reference values are both zero, the front and back stencil comparison
functions are bothALWAYS, and the front and back stencil masks are both set to the
s
value 2   1, wheres is greater than or equal to the number of bits in the deepest
stencil buffer supported by the GL implementation. Initially, all three front and
back stencil operations areKEEP.
If there is no stencil buffer, no stencil modi?cation can occur, and it is as if the
stencil tests always pass, regardless of any calls to StencilFunc.
17.3.4 Depth Buffer Test
The depth buffer test discards the incoming fragment if a depth comparison fails.
The comparison is enabled or disabled with the generic Enable and Disable com-
mands using target DEPTH_TEST. When disabled, the depth comparison and sub-
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 505
sequent possible updates to the depth buffer value are bypassed and the fragment is
passed to the next operation. The stencil value, however, is modi?ed as indicated
below as if the depth buffer test passed. If enabled, the comparison takes place and
the depth buffer and stencil value may subsequently be modi?ed.
The comparison is speci?ed with
void DepthFunc(enum func );
This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s z value is less than, less
w
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (x ;y )
w w
coordinates.
If depth clamping (see section 13.7) is enabled, before the incoming fragment’s
z is comparedz is clamped to the range [min(n;f); max(n;f)], wheren andf
w w
are the current near and far depth range values (see section 13.8.1)
If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (x ;y ) coordinates is updated according to the function
w w
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (x ;y )
w w
location is set to the fragment’sz value. In this case the stencil value is updated
w
according to the function currently in effect for depth buffer test success.
The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
isLESS and the test is disabled.
If there is no depth buffer, it is as if the depth buffer test always passes.
17.3.5 Occlusion Queries
Occlusion queries use query objects to track the number of fragments that are
not discarded by earlier stages. An occlusion query can be started and ?nished
by calling BeginQuery and EndQuery, respectively, with a target ofSAMPLES_-
PASSED,ANY_SAMPLES_PASSED, orANY_SAMPLES_PASSED_CONSERVATIVE.
When an occlusion query is started with target SAMPLES_PASSED, the
samples-passed count maintained by the GL is set to zero. When an occlusion
query is active, the samples-passed count is incremented for each fragment still
being processed after the depth test. If the value of SAMPLE_BUFFERS is zero,
then the samples-passed count is incremented by one for each fragment. If the
value of SAMPLE_BUFFERS is one, then the samples-passed count is incremented
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 506
by the number of samples whose coverage bit is set. However, implementations,
at their discretion, may instead increase the samples-passed count by the value of
SAMPLES if any sample in the fragment is covered.
When an occlusion query ?nishes and all fragments generated by commands
issued prior to EndQuery have been generated, the samples-passed count is written
to the corresponding query object as the query result value, and the query result for
that object is marked as available.
When an occlusion query is started with the target ANY_SAMPLES_PASSED,
the samples-boolean state maintained by the GL is set toFALSE. While that occlu-
sion query is active, the samples-boolean state is set to TRUE for each fragment
still being processed after the depth test. When the target is ANY_SAMPLES_-
PASSED_CONSERVATIVE, an implementation may choose to use a less precise
version of the test which can additionally set the samples-boolean state to TRUE
in some other implementation-dependent cases. This may offer better performance
on some implementations at the expense of false positives. When the occlusion
query ?nishes, the samples-boolean state ofFALSE orTRUE is written to the corre-
sponding query object as the query result value, and the query result for that object
is marked as available.
17.3.6 Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(x ;y ) location.
w w
Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions, and a constant blend color to obtain a new set of R, G, B, and A values,
as described below.
If the color buffer is ?xed-point, the components of the source and destination
values and blend factors are each clamped to [0; 1] or [ 1; 1] respectively for an un-
signed normalized or signed normalized color buffer prior to evaluating the blend
equation. If the color buffer is ?oating-point, no clamping occurs. The resulting
four values are sent to the next operation.
Blending applies only if the color buffer has a ?xed-point or ?oating-point
format. If the color buffer has an integer format, proceed to the next operation.
Blending is enabled or disabled for an individual draw buffer with the com-
mands
void Enablei(enum target,uint index );
void Disablei(enum target,uint index );
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 507
target is the symbolic constantBLEND and index is an integeri specifying the draw
buffer associated with the symbolic constant DRAW_BUFFERi. If the color buffer
associated withDRAW_BUFFERi is one ofFRONT,BACK,LEFT,RIGHT, orFRONT_-
AND_BACK (specifying multiple color buffers), then the state enabled or disabled
is applicable for all of the buffers. Blending can be enabled or disabled for all
draw buffers using Enable or Disable with target BLEND. If blending is disabled
for a particular draw buffer, or if logical operation on color values is enabled (sec-
tion 17.3.9), proceed to the next operation.
If multiple fragment colors are being written to multiple buffers (see sec-
tion 17.4.1), blending is computed and applied separately for each fragment color
and the corresponding buffer.
Errors
An INVALID_VALUE error is generated by Enablei, Disablei and IsEn-
abledi if target is BLEND and index is greater than or equal to the value of
MAX_DRAW_BUFFERS.
17.3.6.1 Blend Equation
Blending is controlled by the blend equation. This equation can be simultaneously
set to the same value for all draw buffers using the commands
void BlendEquation(enum mode );
void BlendEquationSeparate(enum modeRGB,
enum modeAlpha );
or for an individual draw buffer using the indexed commands
void BlendEquationi(uint buf,enum mode );
void BlendEquationSeparatei(uint buf,enum modeRGB,
enum modeAlpha );
BlendEquationSeparate and BlendEquationSeparatei argument modeRGB
determines the RGB blend equation while modeAlpha determines the alpha blend
equation. BlendEquation and BlendEquationi argument mode determines both
the RGB and alpha blend equations. mode, modeRGB, and modeAlpha must be
one of the blend equation modes in table 17.1. BlendEquation and BlendEqua-
tionSeparate modify the blend equations for all draw buffers. BlendEquationi
and BlendEquationSeparatei modify the blend equations associated with an in-
dividual draw buffer. The buf argument is an integeri that indicates that the blend
equations should be modi?ed forDRAW_BUFFERi.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 508
Errors
An INVALID_VALUE error is generated if buf is not in the range zero to
the value ofMAX_DRAW_BUFFERS minus one.
AnINVALID_ENUM error is generated if any of mode, modeRGB, or mod-
eAlpha are not one of the blend equation modes in table 17.1.
Signed or unsigned normalized ?xed-point destination (framebuffer) com-
ponents are represented as described in section 2.3.5. Constant color compo-
nents, ?oating-point destination components, and source (fragment) components
are taken to be ?oating-point values. If source components are represented in-
ternally by the GL as ?xed-point values, they are also interpreted according to
section 2.3.5.
Prior to blending, signed and unsigned normalized ?xed-point color compo-
nents undergo an implied conversion to ?oating-point using equations 2.2 and 2.1,
respectively. This conversion must leave the values zero and one invariant. Blend-
ing computations are treated as if carried out in ?oating-point, and will be per-
formed with a precision and dynamic range no lower than that used to represent
destination components.
If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB (see section 9.2.3), the R, G, and B destination
color values (after conversion from ?xed-point to ?oating-point) are considered to
be encoded for the sRGB color space and hence must be linearized prior to their
use in blending. Each R, G, and B component is converted in the same fashion
described for sRGB texture components in section 8.24.
If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is notSRGB, no linearization is performed.
The resulting linearized R, G, and B and unmodi?ed A values are recombined
as the destination color used in blending computations.
Table 17.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
In the table, the s subscript on a color component abbreviation (R, G, B, or
A) refers to the source color component for an incoming fragment, thed subscript
on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and thec subscript on a color component
abbreviation refers to the constant blend color component. A color component ab-
breviation without a subscript refers to the new color component resulting from
blending. Additionally,S ,S ,S , andS are the red, green, blue, and alpha com-
r g b a
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 509
Mode RGB Components Alpha Component
FUNC_ADD R =R S +R D A =A S +A D
s r d r s a d a
G =G S +G D
s g d g
B =B S +B D
s b d b
FUNC_SUBTRACT R =R S  R D A =A S  A D
s r d r s a d a
G =G S  G D
s g d g
B =B S  B D
s b d b
FUNC_REVERSE_SUBTRACT R =R D  R S A =A D  A S
d r s r d a s a
G =G D  G S
g s g
d
B =B D  B S
d b s b
MIN R = min(R ;R ) A = min(A ;A )
s d s d
G = min(G ;G )
s
d
B = min(B ;B )
s d
MAX R = max(R ;R ) A = max(A ;A )
s d s d
G = max(G ;G )
s
d
B = max(B ;B )
s d
Table 17.1: RGB and alpha blend equations.
ponents of the source weighting factors determined by the source blend function,
and D , D , D , and D are the red, green, blue, and alpha components of the
r g b a
destination weighting factors determined by the destination blend function. Blend
functions are described below.
17.3.6.2 Blend Functions
The weighting factors used by the blend equation are determined by the blend
functions. There are four possible sources for weighting factors. These are the
constant color (R ;G ;B ;A ) set with BlendColor (see below), the ?rst source
c c c c
color (R ;G ;B ;A ), the second source color (R ;G ;B ;A ), and the
s0 s0 s0 s0 s1 s1 s1 s1
destination color (the existing content of the draw buffer). Additionally the special
constantsZERO andONE are available as weighting factors.
Blend functions are simultaneously speci?ed for all draw buffers using the
commands
void BlendFunc(enum src,enum dst );
void BlendFuncSeparate(enum srcRGB,enum dstRGB,
enum srcAlpha,enum dstAlpha );
or for an individual draw buffer using the indexed commands
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 510
void BlendFunci(uint buf,enum src,enum dst );
void BlendFuncSeparatei(uint buf,enum srcRGB,
enum dstRGB,enum srcAlpha,enum dstAlpha );
BlendFuncSeparate and BlendFuncSeparatei arguments srcRGB and
dstRGB determine the source and destination RGB blend functions, respectively,
while srcAlpha and dstAlpha determine the source and destination alpha blend
functions. BlendFunc and BlendFunci argument src determines both RGB and
alpha source functions, while dst determines both RGB and alpha destination func-
tions. BlendFuncSeparate and BlendFunc modify the blend functions for all
draw buffers. BlendFuncSeparatei and BlendFunci modify the blend functions
associated with an individual draw buffer. The buf argument is an integer i that
indicates that the blend functions should be modi?ed forDRAW_BUFFERi.
The possible source and destination blend functions and their corresponding
computed blend factors are summarized in table 17.2.
Errors
An INVALID_VALUE error is generated if buf is not in the range zero to
the value ofMAX_DRAW_BUFFERS minus one.
AnINVALID_ENUM error is generated if any of src, dst, srcRGB, dstRGB,
srcAlpha, or dstAlpha are not one of the blend functions in table 17.2.
17.3.6.3 Dual Source Blending and Multiple Draw Buffers
Blend functions that require the second color input, (R ;G ;B ;A ) (SRC1_-
s1 s1 s1 s1
COLOR,SRC1_ALPHA,ONE_MINUS_SRC1_COLOR, orONE_MINUS_SRC1_ALPHA)
may consume hardware resources that could otherwise be used for rendering to
multiple draw buffers. Therefore, the number of draw buffers that can be attached
to a framebuffer may be lower when using dual-source blending.
The maximum number of draw buffers that may be attached to a single frame-
buffer when using dual-source blending functions is implementation-dependent
and may be queried by calling GetIntegerv with pname MAX_DUAL_SOURCE_-
DRAW_BUFFERS. When using dual-source blending,MAX_DUAL_SOURCE_DRAW_-
BUFFERS should be used in place of MAX_DRAW_BUFFERS to determine the max-
imum number of draw buffers that may be attached to a single framebuffer. The
value of MAX_DUAL_SOURCE_DRAW_BUFFERS must be at least 1. If the value of
MAX_DUAL_SOURCE_DRAW_BUFFERS is 1, then dual-source blending and multiple
draw buffers cannot be used simultaneously.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 511
Function RGB Blend Factors Alpha Blend Factor
(S ;S ;S ) or (D ;D ;D ) S orD
r g b r g b a a
ZERO (0; 0; 0) 0
ONE (1; 1; 1) 1
SRC_COLOR (R ;G ;B ) A
s0 s0 s0 s0
ONE_MINUS_SRC_COLOR (1; 1; 1)  (R ;G ;B ) 1 A
s0 s0 s0 s0
DST_COLOR (R ;G ;B ) A
d d d d
ONE_MINUS_DST_COLOR (1; 1; 1)  (R ;G ;B ) 1 A
d d d d
SRC_ALPHA (A ;A ;A ) A
s0 s0 s0 s0
ONE_MINUS_SRC_ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
s0 s0 s0 s0
DST_ALPHA (A ;A ;A ) A
d d d d
ONE_MINUS_DST_ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
d d d d
CONSTANT_COLOR (R ;G ;B ) A
c c c c
ONE_MINUS_CONSTANT_COLOR (1; 1; 1)  (R ;G ;B ) 1 A
c c c c
CONSTANT_ALPHA (A ;A ;A ) A
c c c c
ONE_MINUS_CONSTANT_ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
c c c c
1
SRC_ALPHA_SATURATE (f;f;f) 1
SRC1_COLOR (R ;G ;B ) A
s1 s1 s1 s1
ONE_MINUS_SRC1_COLOR (1; 1; 1)  (R ;G ;B ) 1 A
s1 s1 s1 s1
SRC1_ALPHA (A ;A ;A ) A
s1 s1 s1 s1
ONE_MINUS_SRC1_ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
s1 s1 s1 s1
Table 17.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1
f = min(A ; 1 A ).
s0 d
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 512
Errors
AnINVALID_OPERATION error is generated by any command that trans-
fers vertices to the GL if either blend function requires the second color input
for any draw buffer, and any draw buffers greater than or equal to the value of
MAX_DUAL_SOURCE_DRAW_BUFFERS have values other thanNONE.
17.3.6.4 Generation of Second Color Source for Blending
When using a fragment shader with dual-source blending functions, the color out-
puts are bound to the ?rst and second inputs of the blender using BindFragDat-
aLocationIndexed as described in section 15.2.3. Data written to the ?rst of these
outputs becomes the ?rst source color input to the blender (corresponding toSRC_-
COLOR and SRC_ALPHA). Data written to the second of these outputs generates
the second source color input to the blender (corresponding to SRC1_COLOR and
SRC1_ALPHA).
If the second color input to the blender is not written in the shader, or if no
output is bound to the second input of a blender, the result of the blending operation
is not de?ned.
17.3.6.5 Blend Color
The constant colorC to be used in blending is speci?ed with the command
c
void BlendColor(float red,float green,float blue,
float alpha );
The constant color can be used in both the source and destination blending
functions. If destination framebuffer components use an unsigned normalized
?xed-point representation, the constant color components are clamped to the range
[0; 1] when computing blend factors.
17.3.6.6 Blending State
The state required for blending, for each draw buffer, is two integers for the RGB
and alpha blend equations, four integers indicating the source and destination RGB
and alpha blending functions, and a bit indicating whether blending is enabled or
disabled. Additionally, four ?oating-point values to store the RGBA constant blend
color are required.
For all draw buffers, the initial blend equations for RGB and alpha are both
FUNC_ADD, and the initial blending functions areONE for the source RGB and alpha
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 513
functions andZERO for the destination RGB and alpha functions. Initially, blending
is disabled for all draw buffers. The initial constant blend color is (R; G; B; A) =
(0; 0; 0; 0).
The value of the blend enable for draw buffer i may be queried by calling
IsEnabledi with target BLEND and indexi, and the values of the blend equations
and functions may be queried by calling GetIntegeri v with the corresponding
target as shown in table 23.21 and indexi.
The value of the blend enable, or the blend equations and functions for draw
buffer zero may also be queried by calling IsEnabled or GetIntegerv respectively,
with the same target but no index parameter.
Blending occurs once for each color buffer currently enabled for blending and
for writing (section 17.4.1) using each buffer’s color forC . If a color buffer has
d
noA value, thenA is taken to be 1.
d
17.3.7 sRGB Conversion
If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
1
to the destination buffer is SRGB (see section 9.2.3), the R, G, and B values after
blending are converted into the non-linear sRGB color space by computing
8
>
0:0; c  0
> l
>
>
<
12:92c; 0<c < 0:0031308
l l
c = (17.1)
s
0:41666
>
1:055c   0:055; 0:0031308c < 1
> l
l
>
>
:
1:0; c  1
l
wherec is the R, G, or B element andc is the result (effectively converted into an
l s
sRGB color space).
If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is notSRGB, then
c =c:
s l
The resulting c values for R, G, and B, and the unmodi?ed A form a new
s
RGBA color value. If the color buffer is ?xed-point, each component is clamped
to the range [0; 1] and then converted to a ?xed-point value using equation 2.3. The
resulting four values are sent to the subsequent dithering operation.
1
Note that only unsigned normalized ?xed-point color buffers may be SRGB-encoded. Signed
normalized ?xed-point + SRGB encoding is not de?ned.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 514
17.3.8 Dithering
Dithering selects between two representable color values. A representable value is
a value that has an exact representation in the color buffer. Dithering selects, for
each color component, either the largest representable color value (for that partic-
ular color component) that is less than or equal to the incoming color component
value, c, or the smallest representable color value that is greater than or equal to
c. The selection may depend on thex andy coordinates of the pixel, as well as
w w
on the exact value ofc. If one of the two values does not exist, then the selection
defaults to the other value.
Many dithering selection algorithms are possible, but an individual selection
must depend only on the incoming component value and the fragment’sx andy
window coordinates. If dithering is disabled, then one of the two values above is
selected, in an implementation-dependent manner that must not depend on thex
w
andy coordinates of the pixel.
w
Dithering is enabled and disabled by calling Enable or Disable with target
DITHER. The state required is a single bit. Initially, dithering is enabled.
17.3.9 Logical Operation
Finally, a logical operation is applied between the incoming fragment’s color val-
ues and the color values stored at the corresponding location in the framebuffer.
The result replaces the values in the framebuffer at the fragment’s (x ;y ) coor-
w w
dinates.
The logical operation on color values is enabled or disabled by calling Enable
or Disable with target COLOR_LOGIC_OP. If the logical operation is enabled for
color values, it is as if blending were disabled, regardless of the value ofBLEND. If
multiple fragment colors are being written to multiple buffers (see section 17.4.1),
the logical operation is computed and applied separately for each fragment color
and the corresponding buffer.
Logical operation has no effect on a ?oating-point destination color buffer,
or when FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer isSRGB (see section 9.2.3). However, if logical operation
is enabled, blending is still disabled.
The logical operation is selected by
void LogicOp(enum op );
op must be one of the logicop modes in table 17.3, which also describes the result-
ing operation when that mode is selected. s is the value of the incoming fragment
OpenGL 4.6 (Core Pro?le) - February 2, 201917.3. PER-FRAGMENTOPERATIONS 515
Logicop Mode Operation
CLEAR 0
AND s^d
AND_REVERSE s^:d
COPY s
AND_INVERTED :s^d
NOOP d
XOR s xord
OR s_d
NOR :(s_d)
EQUIV :(s xord)
INVERT :d
OR_REVERSE s_:d
COPY_INVERTED :s
OR_INVERTED :s_d
NAND :(s^d)
SET all 1’s
Table 17.3: Logical operation op arguments to LogicOp and their corresponding
operations.
andd is the value stored in the framebuffer.
Logical operations are performed independently for each red, green, blue, and
alpha value of each color buffer that is selected for writing. The required state is
an integer indicating the logical operation, and a bit indicating whether the logical
operation is enabled or disabled. The initial state is for the logic operation to be
given byCOPY, and to be disabled.
Errors
An INVALID_VALUE error is generated if op is not one of the logicop
modes in table 17.3.
17.3.10 Additional Multisample Fragment Operations
If the DrawBuffer mode (see section 17.4.1) is NONE, no change is made to any
multisample or color buffer. Otherwise, fragment processing is as described below.
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, the
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 516
stencil test, depth test, blending, dithering, and logical operations are performed
for each pixel sample, rather than just once for each fragment. Failure of the sten-
cil or depth test results in termination of the processing of that sample, rather than
discarding of the fragment. All operations are performed on the color, depth, and
stencil values stored in the multisample renderbuffer attachments if a draw frame-
buffer object is bound, or otherwise in the multisample buffer of the default frame-
buffer. The contents of the color buffers are not modi?ed at this point.
Stencil, depth, blending, dithering, and logical operations are performed for
a pixel sample only if that sample’s fragment coverage bit is a value of 1. If the
corresponding coverage bit is 0, no operations are performed for that sample.
If MULTISAMPLE is disabled, and the value of SAMPLE_BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
because the fragment coverage must be set to full coverage. Further optimization
is allowed, however. An implementation may choose to identify a centermost sam-
ple, and to perform stencil and depth tests on only that sample. Regardless of the
outcome of the stencil test, all multisample buffer stencil sample values are set to
the appropriate new stencil value. If the depth test passes, all multisample buffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
value of the incoming fragment. Otherwise, no change is made to any multisample
buffer color or depth value.
If a draw framebuffer object is not bound, after all operations have been com-
pleted on the multisample buffer, the sample values for each color in the multisam-
ple buffer are combined to produce a single color value, and that value is written
into the corresponding color buffers selected by DrawBuffer or DrawBuffers. An
implementation may defer the writing of the color buffers until a later time, but the
state of the framebuffer must behave as if the color buffers were updated as each
fragment was processed. The method of combination is not speci?ed. If the frame-
buffer contains sRGB values, then it is recommended that the an average of sam-
ple values is computed in a linearized space, as for blending (see section 17.3.6).
Otherwise, a simple average computed independently for each color component is
recommended.
17.4 Whole Framebuffer Operations
The preceding sections described the operations that occur as individual fragments
are sent to the framebuffer. This section describes operations that control or affect
the whole framebuffer.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 517
17.4.1 Selecting Buffers for Writing
The ?rst such operation is controlling the color buffers into which each of the
fragment color values is written. This is accomplished with either *DrawBuffer
or *DrawBuffers commands described below.
The set of buffers of a framebuffer object to which fragment color zero is writ-
ten is controlled with the commands
void DrawBuffer(enum buf );
void NamedFramebufferDrawBuffer(uint framebuffer,
enum buf );
For DrawBuffer, the framebuffer object is that bound to the DRAW_-
FRAMEBUFFER binding. For NamedFramebufferDrawBuffer, framebuffer is
zero or the name of a framebuffer object. If framebuffer is zero, then the default
draw framebuffer is affected.
If the default framebuffer is affected (see section 9), buf must be one of the values
listed in table 17.4. In this case, buf is a symbolic constant specifying zero, one,
two, or four buffers for writing. These constants refer to the four potentially visible
buffers (front left, front right, back left, and back right). Arguments that omit
reference to LEFT or RIGHT refer to both left and right buffers. Arguments that
omit reference toFRONT orBACK refer to both front and back buffers.
If a framebuffer object is affected, buf must be one of the values listed in ta-
ble 17.5, which summarizes the constants and the buffers they indicate. In this case,
buf speci?es a single color buffer for writing. Specifying COLOR_ATTACHMENTi
enables drawing only to the image attached to the framebuffer at that attachment
point.
Errors
An INVALID_OPERATION error is generated by NamedFramebuffer-
DrawBuffer if framebuffer is not zero or the name of an existing framebuffer
object.
An INVALID_ENUM error is generated if buf is not one of the values in
tables 17.5 or 17.4.
An INVALID_OPERATION error is generated if the default framebuffer is
affected and buf is a value (other thanNONE) that does not indicate one of the
color buffers allocated to the default framebuffer.
An INVALID_OPERATION error is generated if a framebuffer object is
affected and buf is one of the constants from table 17.4 (other than NONE), or
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 518
Symbolic Front Front Back Back
Constant Left Right Left Right
NONE
FRONT_LEFT 
FRONT_RIGHT 
BACK_LEFT 
BACK_RIGHT 
FRONT  
BACK  
LEFT  
RIGHT  
FRONT_AND_BACK    
Table 17.4: Arguments to DrawBuffer when the context is bound to a default
framebuffer, and the buffers they indicate. The same arguments are valid for Read-
Buffer, but only a single buffer is selected as discussed in section 18.2.1.
COLOR_ATTACHMENTm andm is greater than or equal to the value ofMAX_-
COLOR_ATTACHMENTS.
DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
The set of buffers of a framebuffer object to which all fragment colors are
written is controlled with the commands
The commands
void DrawBuffers(sizei n,const enum *bufs );
Symbolic Constant Meaning
NONE No buffer
COLOR_ATTACHMENTi (see caption) Output fragment color to image attached
at color attachment pointi
Table 17.5: Arguments to DrawBuffer(s) and ReadBuffer when the context is
bound to a framebuffer object, and the buffers they indicate. i in COLOR_-
ATTACHMENTi may range from zero to the value of MAX_COLOR_ATTACHMENTS
minus one.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 519
Symbolic Front Front Back Back
Constant Left Right Left Right
NONE
FRONT_LEFT 
FRONT_RIGHT 
BACK_LEFT 
BACK_RIGHT 
Table 17.6: Arguments to DrawBuffers when the default framebuffer is affected,
and the buffers they indicate.
void NamedFramebufferDrawBuffers(uint framebuffer,
sizei n,const enum *bufs );
For DrawBuffers, the framebuffer object is that bound to the DRAW_-
FRAMEBUFFER binding. For NamedFramebufferDrawBuffers, framebuffer is the
name of the framebuffer object. If framebuffer is zero, then the default framebuffer
is affected.
n speci?es the number of buffers in bufs. bufs is a pointer to an array of values
specifying the buffer to which each fragment color is written.
Each buffer listed in bufs must be one of the values from tables 17.5 or 17.6.
Further, acceptable values for the constants in bufs depend on whether the default
framebuffer or a framebuffer object is affected. For more information about frame-
buffer objects, see section 9.
If the default framebuffer is affected, then each of the constants must be one of
the values listed in table 17.6 or the special valueBACK. WhenBACK is used, n must
be 1 and color values are written into the left buffer for single-buffered contexts, or
into the back left buffer for double-buffered contexts.
If a framebuffer object is affected, then each of the constants must be one of
the values listed in table 17.5.
In both cases, the draw buffers being de?ned correspond in order to the re-
spective fragment colors. The draw buffer for fragment colors beyond n is set to
NONE.
The maximum number of draw buffers is implementation-dependent. The
number of draw buffers supported may be queried by calling GetIntegerv with
pnameMAX_DRAW_BUFFERS.
Except forNONE, a buffer may not appear more than once in the array pointed
to by bufs.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 520
If a fragment shader writes to a user-de?ned output variable, DrawBuffers
speci?es a set of draw buffers into which each of the multiple output colors de-
?ned by these variables are separately written. If a fragment shader writes to no
user-de?ned output variables, the values of the fragment colors following shader
execution are unde?ned, and may differ for each fragment color. If some, but not
all user-de?ned output variables are written, the values of fragment colors corre-
sponding to unwritten variables are similarly unde?ned.
The order of writes to user-de?ned output variables is unde?ned. If the same
image is attached to multiple attachment points of a framebuffer object and differ-
ent values are written to outputs bound to those attachments, the resulting value in
the attached image is unde?ned. Similarly unde?ned behavior results during any
other per-fragment operations where a multiply-attached image may be written to
by more than one output, such as during blending.
Errors
An INVALID_OPERATION error is generated by NamedFramebuffer-
DrawBuffers if framebuffer is not zero or the name of an existing framebuffer
object.
AnINVALID_VALUE error is generated if n is negative, or greater than the
value ofMAX_DRAW_BUFFERS.
AnINVALID_ENUM error is generated if any value in bufs is not one of the
values in tables 17.5 or 17.6.
An INVALID_OPERATION error is generated if a buffer other than NONE
is speci?ed more than once in the array pointed to by bufs.
An INVALID_ENUM error is generated if any value in bufs is FRONT,
LEFT, RIGHT, or FRONT_AND_BACK. This restriction applies to both the de-
fault framebuffer and framebuffer objects, and exists because these constants
may themselves refer to multiple buffers, as shown in table 17.4.
An INVALID_OPERATION error is generated for the default framebuffer
if any value in bufs isBACK, and n is not one.
An INVALID_OPERATION error is generated if the default framebuffer is
affected and any value in bufs is a constant (other than NONE or BACK) that
does not indicate one of the color buffers allocated to the default framebuffer.
An INVALID_OPERATION error is generated if the GL is bound to a
draw framebuffer object and theith argument is a value other than COLOR_-
ATTACHMENTi orNONE.
Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequent pixel color value writes to affect the indicated buffers. If a framebuffer
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 521
object is affected and a draw buffer selects an attachment that has no image at-
tached, then that fragment color is not written.
SpecifyingNONE as the draw buffer for a fragment color will inhibit that frag-
ment color from being written.
Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
The type of context is selected at GL initialization.
The state required to handle color buffer selection for each framebuffer is an
integer for each supported fragment color. For the default framebuffer, in the initial
state the draw buffer for fragment color zero is BACK if there is a back buffer;
FRONT if there is no back buffer; andNONE if no default framebuffer is associated
with the context. For framebuffer objects, in the initial state the draw buffer for
fragment color zero is COLOR_ATTACHMENT0. For both the default framebuffer
and framebuffer objects, the initial state of draw buffers for fragment colors other
then zero isNONE.
The draw buffer of the currently bound draw framebuffer selected for fragment
colori may be queried by calling GetIntegerv with pname set toDRAW_BUFFERi.
DRAW_BUFFER is equivalent toDRAW_BUFFER0.
17.4.2 Fine Control of Buffer Updates
Writing of bits to each of the logical buffers after all per-fragment operations have
been performed may be masked. The commands
void ColorMask(boolean r,boolean g,boolean b,
boolean a );
void ColorMaski(uint buf,boolean r,boolean g,
boolean b,boolean a );
control writes to the active draw buffers.
ColorMask and ColorMaski are used to mask the writing of R, G, B and A
values to the draw buffer or buffers. ColorMaski sets the mask for a particular
draw buffer. The mask forDRAW_BUFFERi is modi?ed by passingi as the parame-
ter buf. r, g, b, and a indicate whether R, G, B, or A values, respectively, are written
or not (a value ofTRUE means that the corresponding value is written). The mask
speci?ed by r, g, b, and a is applied to the color buffer associated with DRAW_-
BUFFERi. For any i where the value of DRAW_BUFFERi is one of FRONT, BACK,
LEFT, RIGHT, or FRONT_AND_BACK, specifying multiple color buffers, the mask
is applied to all of the buffers.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 522
ColorMask sets the mask for all draw buffers to the same values as speci?ed
by r, g, b, and a.
Errors
An INVALID_VALUE error is generated by ColorMaski if buf is greater
than the value ofMAX_DRAW_BUFFERS minus one.
In the initial state, all color values are enabled for writing for all draw buffers.
The value of the color writemask for draw bufferi may be queried by calling
GetBooleani v with targetCOLOR_WRITEMASK and indexi. The value of the color
writemask for draw buffer zero may also be queried by calling GetBooleanv with
pnameCOLOR_WRITEMASK.
The depth buffer can be enabled or disabled for writingz values using
w
void DepthMask(boolean mask );
If mask is non-zero, the depth buffer is enabled for writing; otherwise, it is disabled.
In the initial state, the depth buffer is enabled for writing.
The commands
void StencilMask(uint mask );
void StencilMaskSeparate(enum face,uint mask );
control the writing of particular bits into the stencil planes.
The least signi?cants bits of mask, wheres is the number of bits in the stencil
buffer, specify an integer mask. Where a 1 appears in this mask, the corresponding
bit in the stencil buffer is written; where a 0 appears, the bit is not written. The face
parameter of StencilMaskSeparate can be FRONT, BACK, or FRONT_AND_BACK
and indicates whether the front or back stencil mask state is affected. StencilMask
sets both front and back stencil mask state to identical values.
Fragments generated by front-facing primitives use the front mask and frag-
ments generated by back-facing primitives use the back mask (see section 17.3.3).
The clear operation always uses the front stencil write mask when clearing the
stencil buffer.
The state required for the various masking operations is two integers for the
front and back stencil values, and a bit for depth values. A set of four bits is also
required indicating which color components of an RGBA value should be written.
In the initial state, the integer masks are all ones, as are the bits controlling depth
value and RGBA component writing.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 523
17.4.2.1 Fine Control of Multisample Buffer Updates
When the value ofSAMPLE_BUFFERS is one, ColorMask, DepthMask, and Sten-
cilMask or StencilMaskSeparate control the modi?cation of values in the multi-
sample buffer. The color mask has no effect on modi?cations to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffers enabled by DrawBuffer.
17.4.3 Clearing the Buffers
The GL provides a means for setting portions of every pixel in a particular buffer
to the same value. The argument to
void Clear(bitfield buf );
is zero or the bitwise OR of one or more values indicating which buffers are
to be cleared. The values are COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, and
STENCIL_BUFFER_BIT, indicating the buffers currently enabled for color writ-
ing, the depth buffer, and the stencil buffer (see below), respectively. The value
to which each buffer is cleared depends on the setting of the clear value for that
buffer. If buf is zero, no buffers are cleared.
Errors
AnINVALID_VALUE error is generated if buf contains any bits other than
COLOR_BUFFER_BIT,DEPTH_BUFFER_BIT, orSTENCIL_BUFFER_BIT.
void ClearColor(float r,float g,float b,float a );
sets the clear value for ?xed-point and ?oating-point color buffers. The speci?ed
components are stored as ?oating-point values.
The command
void ClearDepth(double d );
void ClearDepthf(float d );
sets the depth value used when clearing the depth buffer.d is clamped to the range
[0; 1] when speci?ed. When clearing a ?xed-point depth buffer,d is converted to
?xed-point according to the rules for a windowz value given in section 13.8.1. No
conversion is applied when clearing a ?oating-point depth buffer.
The command
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 524
void ClearStencil(int s );
takes a single integer argument that is the value to which to clear the stencil buffer.
s is masked to the number of bitplanes in the stencil buffer.
When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, sRGB conversion (see sec-
tion 17.3.7), and dithering. The masking operations described in section 17.4.2 are
also applied. If a buffer is not present, then a Clear directed at that buffer has no
effect.
Unsigned normalized ?xed-point and signed normalized ?xed-point RGBA
color buffers are cleared to color values derived by clamping each component of the
clear color to the range [0; 1] or [ 1; 1] respectively, then converting the (possibly
sRGB converted and/or dithered) color to ?xed-point using equations 2.3 or 2.4,
respectively. The result of clearing integer color buffers is unde?ned.
The state required for clearing is a clear value for each of the color buffer,
the depth buffer, and the stencil buffer. Initially, the RGBA color clear value is
(0:0; 0:0; 0:0; 0:0), the depth buffer clear value is 1.0, and the stencil buffer clear
index is 0.
17.4.3.1 Clearing Individual Buffers
Individual buffers of a framebuffer object may be cleared with the commands
void ClearBufferfif uigv(enum buffer,int drawbuffer,
const T *value );
void ClearNamedFramebufferfif uigv(uint framebuffer,
enum buffer,int drawbuffer,const T *value );
For ClearBuffer*, the framebuffer object is the bound draw framebuffer ob-
ject. For ClearNamedFramebuffer*, framebuffer is the name of the framebuffer
object. If framebuffer is zero, the default draw framebuffer is affected.
buffer and drawbuffer identify a buffer to clear, and value speci?es the value
or values to clear it to. The *fv, *iv, and *uiv forms of these commands should be
used to clear ?xed- and ?oating-point, signed integer, and unsigned integer color
buffers respectively.
If buffer is COLOR, a particular draw buffer DRAW_BUFFERi is speci?ed by
passing i as the parameter drawbuffer, and value points to a four-element vec-
tor specifying the R, G, B, and A color to clear that draw buffer to. If the value
of DRAW_BUFFERi is NONE, the command has no effect. Otherwise, the value of
DRAW_BUFFERi is one of the possible values in tables 17.4 and 17.5 identifying
one or more color buffers, each of which is cleared to the same value. Clamping
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 525
and conversion for ?xed-point color buffers are performed in the same fashion as
for ClearColor.
If buffer is DEPTH, drawbuffer must be zero, and value points to the single
depth value to clear the depth buffer to. Clamping and type conversion for ?xed-
point depth buffers are performed in the same fashion as for ClearDepth. Only the
*fv forms of these commands should be used to clear depth buffers; other forms do
not accept a buffer ofDEPTH.
If buffer is STENCIL, drawbuffer must be zero, and value points to the single
stencil value to clear the stencil buffer to. Masking is performed in the same fashion
as for ClearStencil. Only the *iv forms of these commands should be used to clear
stencil buffers; other forms do not accept a buffer ofSTENCIL.
Both depth and stencil buffers of a framebuffer object may be cleared with the
commands
void ClearBuffer?(enum buffer,int drawbuffer,
float depth,int stencil );
void ClearNamedFramebuffer?(uint framebuffer,
enum buffer,int drawbuffer,float depth,int stencil );
For ClearBuffer?, the framebuffer object is the bound draw framebuffer ob-
ject. For ClearNamedFramebuffer?, framebuffer is the name of the framebuffer
object. If framebuffer is zero, the default draw framebuffer is affected.
buffer must beDEPTH_STENCIL and drawbuffer must be zero. depth and sten-
cil are the values to clear the depth and stencil buffers to, respectively. Clamping
and type conversion of depth for ?xed-point depth buffers is performed in the same
fashion as for ClearDepth. Masking of stencil for stencil buffers is performed in
the same fashion as for ClearStencil. These commands are equivalent to clearing
the depth and stencil buffers separately, but may be faster when a buffer of internal
format DEPTH_STENCIL is being cleared. The same per-fragment and masking
operations de?ned for Clear are applied.
For all forms of ClearBuffer* and ClearNamedFramebuffer*, the result of
these commands is unde?ned if no conversion between the type of the speci?ed
value and the type of the buffer being cleared is de?ned (for example, if Clear-
Bufferiv is called for a ?xed- or ?oating-point buffer, or if ClearBufferfv is called
for a signed or unsigned integer buffer). This is not an error.
Errors
An INVALID_OPERATION error is generated by ClearNamedFrame-
buffer* if framebuffer is not zero or the name of an existing framebuffer ob-
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 526
ject.
An INVALID_ENUM error is generated by ClearBufferiv and Clear-
NamedFramebufferiv if buffer is notCOLOR orSTENCIL.
An INVALID_ENUM error is generated by ClearBufferuiv and Clear-
NamedFramebufferuiv if buffer is notCOLOR.
An INVALID_ENUM error is generated by ClearBufferfv and Clear-
NamedFramebufferfv if buffer is notCOLOR orDEPTH.
An INVALID_ENUM error is generated by ClearBuffer? and Clear-
NamedFramebuffer? if buffer is notDEPTH_STENCIL.
AnINVALID_VALUE error is generated if buffer isCOLOR and drawbuffer
is negative, or greater than the value ofMAX_DRAW_BUFFERS minus one; or if
buffer isDEPTH,STENCIL, orDEPTH_STENCIL and drawbuffer is not zero.
17.4.3.2 Clearing the Multisample Buffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as speci?ed by the Clear mask bit COLOR_BUFFER_BIT and
the DrawBuffer mode. If the DrawBuffer mode isNONE, the color samples of the
multisample buffer cannot be cleared using Clear.
If the Clear mask bits DEPTH_BUFFER_BIT or STENCIL_BUFFER_BIT are
set, then the corresponding depth or stencil samples, respectively, are cleared.
The Clear*Buffer* commands also clear color, depth, or stencil samples of
multisample buffers corresponding to the speci?ed buffer.
Masking and scissoring affect clearing the multisample buffer in the same way
as they affect clearing the corresponding color, depth, and stencil buffers.
17.4.4 Invalidating Framebuffer Contents
To signal that the GL need not preserve all contents of a framebuffer object (inval-
idating portions of every pixel or a subregion of pixels), use the commands
void InvalidateSubFramebuffer(enum target,
sizei numAttachments,const enum *attachments,int x,
int y,sizei width,sizei height );
void InvalidateNamedFramebufferSubData(uint framebuffer,
sizei numAttachments,const enum *attachments,int x,
int y,sizei width,sizei height );
For InvalidateSubFramebuffer, the framebuffer object is that bound to target,
which must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER or FRAMEBUFFER.
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 527
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. For InvalidateNamed-
FramebufferSubData, framebuffer is the name of the framebuffer object. If
framebuffer is zero, the default draw framebuffer is affected.
numAttachments indicates how many attachments are supplied in the attach-
ments list. If an attachment is speci?ed that does not exist in the framebuffer ob-
ject, it is ignored. x and y are the origin (with lower left-hand corner at (0; 0)) and
width and height are the width and height, respectively, of the pixel rectangle to
be invalidated. Any of these pixels lying outside of the window allocated to the
current GL context (for the default framebuffer), or outside of the attachments of
the framebuffer object, are ignored.
If the framebuffer object is not complete, these commands may be ignored.
Errors
An INVALID_ENUM error is generated by InvalidateSubFramebuffer if
target is notFRAMEBUFFER,DRAW_FRAMEBUFFER, orREAD_FRAMEBUFFER.
An INVALID_OPERATION error is generated by InvalidateNamed-
FramebufferData if framebuffer is not zero or the name of an existing frame-
buffer object.
An INVALID_VALUE error is generated if numAttachments, width, or
height is negative.
An INVALID_ENUM error is generated if a framebuffer object is affected,
and any element of attachments is not one of the values in table 9.2.
An INVALID_OPERATION error is generated if attachments contains
COLOR_ATTACHMENTm wherem is greater than or equal to the value ofMAX_-
COLOR_ATTACHMENTS.
An INVALID_ENUM error is generated if the default framebuffer is af-
fected, and any elements of attachments are not one of:
 FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, and BACK_RIGHT, identi-
fying that speci?c buffer
 COLOR, which is treated as BACK_LEFT for a double-buffered context
andFRONT_LEFT for a single-buffered context
 DEPTH, identifying the depth buffer
 STENCIL, identifying the stencil buffer.
The commands
void InvalidateFramebuffer(enum target,
OpenGL 4.6 (Core Pro?le) - February 2, 201917.4. WHOLEFRAMEBUFFEROPERATIONS 528
sizei numAttachments,const enum *attachments );
void InvalidateNamedFramebufferData(uint framebuffer,
sizei numAttachments,const enum *attachments );
are equivalent to
InvalidateSubFramebuffer(target, numAttachments, attachments,
0, 0, vw, vh);
and
InvalidateNamedFramebufferSubData(framebuffer, numAttachments,
attachments, 0, 0, vw, vh);
respectively, where vw and vh are equal to the maximum viewport width and
height, respectively, obtained by queryingMAX_VIEWPORT_DIMS.
17.4.5
This subsection is only de?ned in the compatibility pro?le.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 18
Reading and Copying Pixels
Pixels may be read from the framebuffer using ReadPixels. BlitFramebuffer can
be used to copy a block of pixels from one portion of the framebuffer to another.
18.1
This section is only de?ned in the compatibility pro?le.
18.2 Reading Pixels
The method for reading pixels from the framebuffer and placing them in pixel pack
buffer or client memory is diagrammed in ?gure 18.1. We describe the stages of
the pixel reading process in the order in which they occur.
18.2.1 Selecting Buffers for Reading
When reading pixels from a color buffer of a framebuffer object, the buffer selected
for reading is termed the read buffer, and is controlled with the commands
void ReadBuffer(enum src );
void NamedFramebufferReadBuffer(uint framebuffer,
enum src );
For ReadBuffer, the target framebuffer object is that bound to READ_-
FRAMEBUFFER. For NamedFramebufferReadBuffer, framebuffer is zero or the
name of the target framebuffer object. If framebuffer is zero, then the default read
framebuffer is affected.
52918.2. READINGPIXELS 530
RGBA pixel data in
Convert to float
Pixel Storage
Clamp to [0,1]
Operations
Pack
byte, short, int, float, or packed
pixel component data stream
Figure 18.1. Operation of ReadPixels. Operations in dashed boxes are not per-
formed for all data formats. Depth and stencil pixel paths are not shown.
If the default framebuffer is affected (see section 9), src must be one of the
values listed in table 17.4, includingNONE.FRONT_AND_BACK,FRONT, andLEFT
refer to the front left buffer, BACK refers to the back left buffer, and RIGHT refers
to the front right buffer. Other constants correspond directly to the buffers that they
name. The initial value of the read buffer for the default framebuffer is FRONT
if there is no back buffer; BACK if there is a back buffer; and NONE if no default
framebuffer is associated with the context.
If a framebuffer object is affected, src must be one of the values listed in ta-
ble 17.5, includingNONE. SpecifyingCOLOR_ATTACHMENTi enables reading from
the image attached to the framebuffer at that attachment point. The initial value of
the read buffer for framebuffer objects isCOLOR_ATTACHMENT0.
The read buffer of the currently bound read framebuffer may be queried by
calling GetIntegerv with pname set toREAD_BUFFER.
Errors
An INVALID_OPERATION error is generated by NamedFramebuffer-
ReadBuffer if framebuffer is not zero or the name of an existing framebuffer
OpenGL 4.6 (Core Pro?le) - February 2, 201918.2. READINGPIXELS 531
object.
An INVALID_ENUM error is generated if src is not one of the values in
tables 17.4 or 17.5.
An INVALID_OPERATION error is generated if the default framebuffer is
affected and src is a value (other thanNONE) that does not indicate any of the
color buffers allocated to the default framebuffer.
An INVALID_OPERATION error is generated if a framebuffer object is
affected, and src is one of the constants from table 17.4 (other than NONE,
or COLOR_ATTACHMENTm where m is greater than or equal to the value of
MAX_COLOR_ATTACHMENTS).
18.2.2 ReadPixels
Initially, zero is bound for the PIXEL_PACK_BUFFER, indicating that image read
and query commands such as ReadPixels return pixel results into client memory
pointer parameters. However, if a non-zero buffer object is bound as the current
pixel pack buffer, then the pointer parameter is treated as an offset into the desig-
nated buffer object.
Pixels are read with the commands
void ReadPixels(int x,int y,sizei width,sizei height,
enum format,enum type,void *data );
void ReadnPixels(int x,int y,sizei width,
sizei height,enum format,enum type,sizei bufSize,
void *data );
The arguments after x and y to ReadPixels are described in section 8.4.4. The pixel
storage modes that apply to ReadPixels and other commands that query images
(see section 8.11) are summarized in table 18.1.
Errors
An INVALID_OPERATION error is generated if the value of READ_-
FRAMEBUFFER_BINDING (see section 9) is non-zero, the read framebuffer
is framebuffer complete, and the effective value ofSAMPLE_BUFFERS for the
read framebuffer is one.
AnINVALID_VALUE error is generated if width, height, or bufSize is neg-
ative.
AnINVALID_OPERATION error is generated by ReadnPixels if the buffer
size required to store the requested data is greater than bufSize.
OpenGL 4.6 (Core Pro?le) - February 2, 201918.2. READINGPIXELS 532
Parameter Name Type Initial Value Valid Range
PACK_SWAP_BYTES boolean FALSE TRUE/FALSE
PACK_LSB_FIRST boolean FALSE TRUE/FALSE
PACK_ROW_LENGTH integer 0 [0;1)
PACK_SKIP_ROWS integer 0 [0;1)
PACK_SKIP_PIXELS integer 0 [0;1)
PACK_ALIGNMENT integer 4 1,2,4,8
PACK_IMAGE_HEIGHT integer 0 [0;1)
PACK_SKIP_IMAGES integer 0 [0;1)
PACK_COMPRESSED_BLOCK_WIDTH integer 0 [0;1)
PACK_COMPRESSED_BLOCK_HEIGHT integer 0 [0;1)
PACK_COMPRESSED_BLOCK_DEPTH integer 0 [0;1)
PACK_COMPRESSED_BLOCK_SIZE integer 0 [0;1)
Table 18.1: PixelStore parameters pertaining to ReadPixels, GetCompressed-
TexImage and GetTexImage.
Preferred values for format and type may be determined by call-
ing GetIntegerv with pnames IMPLEMENTATION_COLOR_READ_FORMAT and
IMPLEMENTATION_COLOR_READ_TYPE, respectively. The preferred format may
vary depending on the format of the selected read buffer of the currently bound
read framebuffer.
Errors
AnINVALID_OPERATION error is generated by GetIntegerv if pname is
IMPLEMENTATION_COLOR_READ_FORMAT or IMPLEMENTATION_COLOR_-
READ_TYPE and any of:
 the read framebuffer is not framebuffer complete.
 the read framebuffer is a framebuffer object, and the selected read buffer
(see section 18.2.1) has no image attached.
 the selected read buffer isNONE.
18.2.3 Obtaining Pixels from the Framebuffer
If the format isDEPTH_COMPONENT, then values are obtained from the depth buffer.
OpenGL 4.6 (Core Pro?le) - February 2, 201918.2. READINGPIXELS 533
If there is a multisample buffer (the value of SAMPLE_BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
choose any function of the depth sample values at each pixel.
If the format is DEPTH_STENCIL, then values are taken from both the depth
buffer and the stencil buffer. type must beUNSIGNED_INT_24_8 orFLOAT_32_-
UNSIGNED_INT_24_8_REV.
If there is a multisample buffer, then values are obtained from the depth and
stencil samples in this buffer. It is recommended that the depth and stencil values of
the centermost sample be used, though implementations may choose any function
of the depth and stencil sample values at each pixel.
If the format isSTENCIL_INDEX, then values are taken from the stencil buffer.
If there is a multisample buffer, then values are obtained from the stencil sam-
ples in this buffer. It is recommended that the stencil value of the centermost sam-
ple be used, though implementations may choose any function of the stencil sample
values at each pixel.
For all other formats, values are obtained from the color buffer selected by the
read buffer.
Errors
An INVALID_ENUM error is generated if format is DEPTH_STENCIL and
type is not UNSIGNED_INT_24_8 or FLOAT_32_UNSIGNED_INT_24_8_-
REV.
An INVALID_OPERATION error is generated if format is DEPTH_-
COMPONENT and there is no depth buffer; if format is STENCIL_INDEX and
there is no stencil buffer; or if format is DEPTH_STENCIL and either there is
no depth buffer, or there is no stencil buffer.
AnINVALID_FRAMEBUFFER_OPERATION error is generated if the object
bound toREAD_FRAMEBUFFER_BINDING is not framebuffer complete (as de-
?ned in section 9.4.2).
An INVALID_OPERATION error is generated if format selects a color
buffer while the read buffer isNONE, or if the GL is using a framebuffer object
(the value ofREAD_FRAMEBUFFER_BINDING is non-zero) and the read buffer
selects an attachment that has no image attached.
ReadPixels obtains values from the selected buffer from each pixel with lower
left hand corner at (x+i;y +j) for 0i<width and 0j <height; this pixel
is said to be theith pixel in thejth row. If any of these pixels lies outside of the
window allocated to the current GL context, or outside of the image attached to the
OpenGL 4.6 (Core Pro?le) - February 2, 201918.2. READINGPIXELS 534
currently bound read framebuffer object, then the values obtained for those pixels
are unde?ned. When READ_FRAMEBUFFER_BINDING is zero, values are also un-
de?ned for individual pixels that are not owned by the current context. Otherwise,
ReadPixels obtains values from the selected buffer, regardless of how those values
were placed there.
If format is one of RED, GREEN, BLUE, RG, RGB, RGBA, BGR, or BGRA, then
red, green, blue, and alpha values are obtained from the selected buffer at each
pixel location.
AnINVALID_OPERATION error is generated if format is an integer format and
the color buffer is not an integer format, or if the color buffer is an integer format
and format is not an integer format.
When READ_FRAMEBUFFER_BINDING is non-zero, the red, green, blue, and
alpha values are obtained by ?rst reading the internal component values of the
corresponding value in the image attached to the selected logical buffer. Internal
components are converted to an RGBA color by taking each R, G, B, and A com-
ponent present according to the base internal format of the buffer (as shown in
table 8.11). If G, B, or A values are not present in the internal format, they are
taken to be zero, zero, and one respectively.
18.2.4 Conversion of RGBA values
This step applies only if format is notSTENCIL_INDEX,DEPTH_COMPONENT, or
DEPTH_STENCIL. The R, G, B, and A values form a group of elements.
For a signed or unsigned normalized ?xed-point color buffer, each element is
converted to ?oating-point using equations 2.2 or 2.1, respectively. For an integer
or ?oating-point color buffer, the elements are unmodi?ed.
18.2.5 Conversion of Depth values
This step applies only if format is DEPTH_COMPONENT or DEPTH_STENCIL and
the depth buffer uses a ?xed-point representation. An element is taken to be a
?xed-point value in [0; 1] withm bits, wherem is the number of bits in the depth
buffer (see section 13.8.1). No conversion is necessary if the depth buffer uses a
?oating-point representation.
18.2.6
This subsection is only de?ned in the compatibility pro?le.
OpenGL 4.6 (Core Pro?le) - February 2, 201918.2. READINGPIXELS 535
18.2.7
This subsection is only de?ned in the compatibility pro?le.
18.2.8 Final Conversion
Read color clamping is controlled by calling
void ClampColor(enum target,enum clamp );
with target set to CLAMP_READ_COLOR. If clamp is TRUE, read color clamping is
enabled; if clamp isFALSE, read color clamping is disabled. If clamp isFIXED_-
ONLY, read color clamping is enabled if the selected read color buffer has ?xed-
point components.
For an integer RGBA color, each component is clamped to the representable
range of type.
For a ?oating-point RGBA color, if type isFLOAT orHALF_FLOAT, each com-
ponent is clamped to [0; 1] if read color clamping is enabled. Then the appropriate
conversion formula from table 18.2 is applied to the component.
If type isUNSIGNED_INT_10F_11F_11F_REV and format isRGB, each com-
ponent is clamped to [0; 1] if read color clamping is enabled. The returned data are
then packed into a series of uint values. The red, green, and blue components
are converted to unsigned 11-bit ?oating-point, unsigned 11-bit ?oating-point, and
unsigned 10-bit ?oating-point as described in sections 2.3.4.3 and 2.3.4.4. The re-
sulting red 11 bits, green 11 bits, and blue 10 bits are then packed as the 1st, 2nd,
and 3rd components of theUNSIGNED_INT_10F_11F_11F_REV format as shown
in table 8.8.
If type isUNSIGNED_INT_5_9_9_9_REV and format isRGB, each component
is clamped to [0; 1] if read color clamping is enabled. The returned data are then
packed into a series of uint values. The red, green, and blue components are
converted tored ,green ,blue , andexp integers as described in section 8.5.2
s s s s
when internalformat is RGB9_E5. red ,green ,blue , andexp are then packed
s s s s
as the 1st, 2nd, 3rd, and 4th components of the UNSIGNED_INT_5_9_9_9_REV
format as shown in table 8.8.
For other types, and for a ?oating-point or unsigned normalized ?xed-point
color buffer, each component is clamped to [0; 1] whether or not read color clamp-
ing is enabled. For a signed normalized ?xed-point color buffer, each component
is clamped to [0; 1] if read color clamping is enabled, or if type represents un-
signed integer components; otherwise type represents signed integer components,
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 536
and each component is clamped to [ 1; 1]. Following clamping, the appropriate
1
conversion formula from table 18.2 is applied to the component .
For an index, if the type is notFLOAT orHALF_FLOAT, ?nal conversion consists
of masking the index with the value given in table 18.3. If the type is FLOAT or
HALF_FLOAT, then the integer index is converted to a GL float or half data
value.
18.2.9 Placement in Pixel Pack Buffer or Client Memory
If a pixel pack buffer is bound (as indicated by a non-zero value ofPIXEL_PACK_-
BUFFER_BINDING), data is an offset into the pixel pack buffer and the pixels are
packed into the buffer relative to this offset; otherwise, data is a pointer to a block
of client memory and the pixels are packed into the client memory relative to the
pointer.
An INVALID_OPERATION error is generated if a pixel pack buffer object is
bound and packing the pixel data according to the pixel pack storage state would
access memory beyond the size of the pixel pack buffer’s memory size.
An INVALID_OPERATION error is generated if a pixel pack buffer object is
bound and data is not evenly divisible by the number of basic machine units needed
to store in memory the corresponding GL data type from table 8.2 for the type
parameter.
Groups of elements are placed in memory just as they are taken from mem-
ory when transferring pixel rectangles to the GL. That is, theith group of thejth
row (corresponding to theith pixel in thejth row) is placed in memory just where
the ith group of the jth row would be taken from when transferring pixels. See
Unpacking under section 8.4.4.1. The only difference is that the storage mode
parameters whose names begin withPACK_ are used instead of those whose names
begin withUNPACK_. If the format is RED,GREEN, orBLUE, only the correspond-
ing single element is written. Likewise if the format is RG, RGB, or BGR, only the
corresponding two or three elements are written. Otherwise all the elements of
each group are written.
18.3 Copying Pixels
Several commands copy pixel data between regions of the framebuffer (see sec-
tion 18.3.1), or between regions of textures and renderbuffers (see section 18.3.2).
1
OpenGL 4.2 changes the behavior of ReadPixels to allow readbacks from a signed normalized
color buffer to a signed integer type without loss of information.
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 537
type Parameter GL Data Type Component
Conversion Formula
UNSIGNED_BYTE ubyte Equation 2.3,b = 8
BYTE byte Equation 2.4,b = 8
UNSIGNED_SHORT ushort Equation 2.3,b = 16
SHORT short Equation 2.4,b = 16
UNSIGNED_INT uint Equation 2.3,b = 32
INT int Equation 2.4,b = 32
HALF_FLOAT half c =f
FLOAT float c =f
UNSIGNED_BYTE_3_3_2 ubyte Equation 2.3,b = bit?eld width
UNSIGNED_BYTE_2_3_3_REV ubyte Equation 2.3,b = bit?eld width
UNSIGNED_SHORT_5_6_5 ushort Equation 2.3,b = bit?eld width
UNSIGNED_SHORT_5_6_5_REV ushort Equation 2.3,b = bit?eld width
UNSIGNED_SHORT_4_4_4_4 ushort Equation 2.3,b = bit?eld width
UNSIGNED_SHORT_4_4_4_4_REV ushort Equation 2.3,b = bit?eld width
UNSIGNED_SHORT_5_5_5_1 ushort Equation 2.3,b = bit?eld width
UNSIGNED_SHORT_1_5_5_5_REV ushort Equation 2.3,b = bit?eld width
UNSIGNED_INT_8_8_8_8 uint Equation 2.3,b = bit?eld width
UNSIGNED_INT_8_8_8_8_REV uint Equation 2.3,b = bit?eld width
UNSIGNED_INT_10_10_10_2 uint Equation 2.3,b = bit?eld width
UNSIGNED_INT_2_10_10_10_REV uint Equation 2.3,b = bit?eld width
UNSIGNED_INT_24_8 uint Equation 2.3,b = bit?eld width
UNSIGNED_INT_10F_11F_11F_REV uint Special
UNSIGNED_INT_5_9_9_9_REV uint Special
FLOAT_32_UNSIGNED_INT_24_8_REV float c =f (depth only)
Table 18.2: Reversed component conversions, used when component data are being
returned to client memory. Color and depth components are converted from the
internal ?oating-point representation (f) to a datum of the speci?ed GL data type
(c). All arithmetic is done in the internal ?oating-point format. These conversions
apply to component data returned by GL query commands and to components of
pixel data returned to client memory. The equations remain the same even if the
implemented ranges of the GL data types are greater than the minimum required
ranges (see table 2.2).
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 538
type Parameter Index Mask
8
UNSIGNED_BYTE 2   1
7
BYTE 2   1
16
UNSIGNED_SHORT 2   1
15
SHORT 2   1
32
UNSIGNED_INT 2   1
31
INT 2   1
8
UNSIGNED_INT_24_8 2   1
8
FLOAT_32_UNSIGNED_INT_24_8_REV 2   1
Table 18.3: Index masks used by ReadPixels. Floating-point data are not masked.
For all such commands, if the source and destination are identical or are differ-
ent views of the same underlying texture image, and if the source and destination
regions overlap in that framebuffer, renderbuffer, or texture image, pixel values
resulting from the copy operation are unde?ned.
18.3.1 Blitting Pixel Rectangles
To transfer a rectangle of pixel values from one region of a source framebuffer to
another region of a destination framebuffer, use the commands
void BlitFramebuffer(int srcX0,int srcY0,int srcX1,
int srcY1,int dstX0,int dstY0,int dstX1,int dstY1,
bitfield mask,enum ?lter );
void BlitNamedFramebuffer(uint readFramebuffer,
uint drawFramebuffer,int srcX0,int srcY0,int srcX1,
int srcY1,int dstX0,int dstY0,int dstX1,int dstY1,
bitfield mask,enum ?lter );
For BlitFramebuffer, the source and destination framebuffers are those bound
to READ_FRAMEBUFFER and DRAW_FRAMEBUFFER respectively. For BlitNamed-
Framebuffer, readFramebuffer and drawFramebuffer are the names of the source
and destination framebuffer objects respectively.
If no framebuffer is bound to READ_FRAMEBUFFER or DRAW_FRAMEBUFFER
(for BlitFramebuffer), or if readFramebuffer or drawFramebuffer is zero (for Blit-
NamedFramebuffer), then the default read or draw framebuffer is used as the
corresponding source or destination framebuffer, respectively.
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 539
mask is zero or the bitwise OR of one or more values indicating which buffers
are to be copied. The values areCOLOR_BUFFER_BIT,DEPTH_BUFFER_BIT, and
STENCIL_BUFFER_BIT, which are described in section 17.4.3. The pixels corre-
sponding to these buffers are copied from the source rectangle bounded by the lo-
cations (srcX0;srcY 0) and (srcX1;srcY 1) to the destination rectangle bounded
by the locations (dstX0;dstY 0) and (dstX1;dstY 1).
Pixels have half-integer center coordinates. Only pixels whose centers lie
within the destination rectangle are written by BlitFramebuffer. Linear ?lter sam-
pling (see below) may result in pixels outside the source rectangle being read.
If mask is zero, no buffers are copied.
When the color buffer is transferred, values are taken from the read buffer of the
read framebuffer and written to each of the draw buffers of the draw framebuffer.
The actual region taken from the read framebuffer is limited to the intersection
of the source buffers being transferred, which may include the color buffer selected
by the read buffer, the depth buffer, and/or the stencil buffer depending on mask.
The actual region written to the draw framebuffer is limited to the intersection of
the destination buffers being written, which may include multiple draw buffers,
the depth buffer, and/or the stencil buffer depending on mask. Whether or not the
source or destination regions are altered due to these limits, the scaling and offset
applied to pixels being transferred is performed as though no such limits were
present.
If the source and destination rectangle dimensions do not match, the source im-
age is stretched to ?t the destination rectangle. ?lter must beLINEAR orNEAREST,
and speci?es the method of interpolation to be applied if the image is stretched.
LINEAR ?ltering is allowed only for the color buffer. If the source and destination
dimensions are identical, no ?ltering is applied. If either the source or destination
rectangle speci?es a negative width or height (X1 < X0 orY 1 < Y 0), the im-
age is reversed in the corresponding direction. If both the source and destination
rectangles specify a negative width or height for the same direction, no reversal is
performed. If a linear ?lter is selected and the rules of LINEAR sampling would
require sampling outside the bounds of a source buffer, it is as though CLAMP_-
TO_EDGE texture sampling were being performed. If a linear ?lter is selected and
sampling would be required outside the bounds of the speci?ed source region, but
within the bounds of a source buffer, the implementation may choose to clamp
while sampling or not.
If the source and destination buffers are identical, and the source and destina-
tion rectangles overlap, the result of the blit operation is unde?ned as described in
the introduction to section 18.3.
When values are taken from the read buffer, ifFRAMEBUFFER_SRGB is enabled
and the value ofFRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the frame-
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 540
buffer attachment corresponding to the read buffer isSRGB (see section 9.2.3), the
red, green, and blue components are converted from the non-linear sRGB color
space according to equation 8.17.
When values are written to the draw buffers, blit operations bypass most of the
fragment pipeline. The only fragment operations which affect a blit are the pixel
ownership test, the scissor test, and sRGB conversion (see section 17.3.7). Color,
depth, and stencil masks (see section 17.4.2) are ignored.
If the read framebuffer is layered (see section 9.8), pixel values are read from
layer zero. If the draw framebuffer is layered, pixel values are written to layer zero.
If both read and draw framebuffers are layered, the blit operation is still performed
only on layer zero.
If a buffer is speci?ed in mask and does not exist in both the read and draw
framebuffers, the corresponding bit is silently ignored.
If the color formats of the read and draw buffers do not match, and mask in-
cludes COLOR_BUFFER_BIT, pixel groups are converted to match the destination
format. However, colors are clamped only if all draw color buffers have ?xed-point
components. Format conversion is not supported for all data types, as described
below.
If the read framebuffer is multisampled (its effective value of SAMPLE_-
BUFFERS is one) and the draw framebuffer is not (its value ofSAMPLE_BUFFERS is
zero), the samples corresponding to each pixel location in the source are converted
to a single sample before being written to the destination. ?lter is ignored. If the
source formats are integer types or stencil values, a single sample’s value is se-
lected for each pixel. If the source formats are ?oating-point or normalized types,
the sample values for each pixel are resolved in an implementation-dependent
manner. If the source formats are depth values, sample values are resolved in an
implementation-dependent manner where the result will be between the minimum
and maximum depth values in the pixel.
If the read framebuffer is not multisampled and the draw framebuffer is mul-
tisampled, the value of the source sample is replicated in each of the destination
samples.
If both the read and draw framebuffers are multisampled, and their effective
values of SAMPLES are identical, the samples are copied without modi?cation
(other than possible format conversion) from the read framebuffer to the draw
framebuffer. Note that the samples in the draw buffer are not guaranteed to be at
the same sample location as the read buffer, so rendering using this newly created
buffer can potentially have geometry cracks or incorrect antialiasing. This may
occur if the sizes of the framebuffers do not match or if the source and destination
rectangles are not de?ned with the same (X0;Y 0) and (X1;Y 1) bounds.
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 541
Errors
AnINVALID_OPERATION error is generated by BlitNamedFramebuffer
if readFramebuffer or drawFramebuffer is not zero or the name of an existing
framebuffer object.
An INVALID_VALUE error is generated if mask contains any bits other
than COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, or STENCIL_BUFFER_-
BIT.
AnINVALID_ENUM error is generated if ?lter is notLINEAR orNEAREST.
An INVALID_OPERATION error is generated if mask includes DEPTH_-
BUFFER_BIT orSTENCIL_BUFFER_BIT, and ?lter is notNEAREST.
AnINVALID_FRAMEBUFFER_OPERATION error is generated if either the
read framebuffer or the draw framebuffer is not framebuffer complete (sec-
tion 9.4.2).
An INVALID_OPERATION error is generated if mask includes DEPTH_-
BUFFER_BIT or STENCIL_BUFFER_BIT, and the source and destination
depth and stencil buffer formats do not match.
An INVALID_OPERATION error is generated if ?lter is LINEAR and the
read buffer contains integer data.
An INVALID_OPERATION error is generated if either the read or draw
framebuffer is multisampled, and the dimensions of the source and destination
rectangles provided to BlitFramebuffer are not identical.
An INVALID_OPERATION error is generated if both the read and draw
framebuffers are multisampled, and their effective values ofSAMPLES are not
identical.
AnINVALID_OPERATION error is generated if format conversions are not
supported, which occurs under any of the following conditions:
 The read buffer contains ?xed-point or ?oating-point values and any
draw buffer contains neither ?xed-point nor ?oating-point values.
 The read buffer contains unsigned integer values and any draw buffer
does not contain unsigned integer values.
 The read buffer contains signed integer values and any draw buffer does
not contain signed integer values.
18.3.2 Copying Between Images
The command
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 542
void CopyImageSubData(uint srcName,enum srcTarget,
int srcLevel,int srcX,int srcY,int srcZ,
uint dstName,enum dstTarget,int dstLevel,int dstX,
int dstY,int dstZ,sizei srcWidth,sizei srcHeight,
sizei srcDepth );
may be used to copy a region of texel data between two image objects. An image
object may be either a texture or a renderbuffer.
CopyImageSubData does not perform general-purpose conversions such as
scaling, resizing, blending, color-space, or format conversions. It should be con-
sidered to operate in a manner similar to a CPU memcpy. CopyImageSubData
can copy between images with different internal formats, provided the formats are
compatible.
CopyImageSubData also allows copying between certain types of compressed
and uncompressed internal formats as described in table 18.4. This copy does not
perform on-the-?y compression or decompression. When copying from an un-
compressed internal format to a compressed internal format, each texel of uncom-
pressed data becomes a single block of compressed data. When copying from a
compressed internal format to an uncompressed internal format, a block of com-
pressed data becomes a single texel of uncompressed data. The texel size of the
uncompressed format must be the same size as the block size of the compressed
formats. Thus it is permitted to copy between a 128-bit uncompressed format and
a compressed format which uses 8-bit 4 4 blocks, or between a 64-bit uncom-
pressed format and a compressed format which uses 4-bit 4 4 blocks.
The source object is identi?ed by srcName and srcTarget. Similarly the des-
tination object is identi?ed by dstName and dstTarget. The interpretation of the
name depends on the value of the corresponding target parameter. If the target
parameter is RENDERBUFFER, the name is interpreted as the name of a render-
buffer object. If the target parameter is a texture target, the name is interpreted as
a texture object. All non-proxy texture targets are accepted, with the exception of
TEXTURE_BUFFER and the cubemap face selectors described in table 8.19.
srcLevel and dstLevel identify the source and destination level-of-detail. For
textures, this must be a valid level-of-detail in the texture object. For renderbuffers,
this value must be zero.
srcX, srcY, and srcZ specify the lower left texel coordinates of a srcWidth-wide
by srcHeight-high by srcDepth-deep rectangular subregion of the source texture
image. Similarly, dstX, dstY and dstZ specify the coordinates of a subregion of
the destination texture image. The source and destination subregions must be con-
tained entirely within the speci?ed level of the corresponding image objects. The
dimensions are always speci?ed in texels, even for compressed texture formats.
OpenGL 4.6 (Core Pro?le) - February 2, 201918.3. COPYINGPIXELS 543
But it should be noted that if only one of the source and destination textures is
compressed then the number of texels touched in the compressed image will be a
factor of the block size larger than in the uncompressed image.
Slices of a one-dimensional array, two-dimensional array, cube map array, or
three dimensional texture, or faces of a cube map texture are all compatible pro-
vided they share a compatible internal format, and multiple slices or faces may
be copied between these objects with a single call by specifying the starting slice
with srcZ and dstZ, and the number of slices to be copied with srcDepth. Cube-
map textures always have six faces which are selected by a zero-based face index,
according to the order speci?ed in table 8.19.
For the purposes of CopyImageSubData, two internal formats are considered
compatible if any of the following conditions are met:
 the formats are the same If the formats are the same but are a base internal
format, the the implementation’s effective internal format (see the end of
section 8.5) for each image must be the same.
 the formats are considered compatible according to the compatibility rules
used for texture views as de?ned in section 8.18. In particular, if both in-
ternal formats are listed in the same entry of table 8.22, they are considered
compatible
 one format is compressed and the other is uncompressed and table 18.4 lists
the two formats in the same row.
Unde?ned pixel values result from overlapping copies, as described in the in-
troduction to section 18.3.
Errors
An INVALID_OPERATION error is generated if the texel size of the un-
compressed image is not equal to the block size of the compressed image.
An INVALID_ENUM error is generated if either target is not
RENDERBUFFER or a valid non-proxy texture target; is TEXTURE_BUFFER or
one of the cubemap face selectors described in table 8.19; or if the target does
not match the type of the object.
An INVALID_OPERATION error is generated if either object is a texture
and the texture is not complete (as de?ned in section 8.17, but ignoring
format-based completeness rules), or if the source and destination internal for-
mats are not compatible, or if the number of samples do not match.
AnINVALID_VALUE error is generated if either name does not correspond
OpenGL 4.6 (Core Pro?le) - February 2, 201918.4. PIXELDRAWANDREADSTATE 544
Texel / Uncompressed Compressed
Block Size internal format internal format
128-bit RGBA32UI, COMPRESSED_RG_RGTC2, COMPRESSED_-
RGBA32I,RGBA32F SIGNED_RG_RGTC2, COMPRESSED_-
RGBA_BPTC_UNORM, COMPRESSED_-
SRGB_ALPHA_BPTC_UNORM,
COMPRESSED_RGB_BPTC_SIGNED_FLOAT,
COMPRESSED_RGB_BPTC_UNSIGNED_-
FLOAT
64-bit RGBA16F, RG32F, COMPRESSED_RED_RGTC1,
RGBA16UI, RG32UI, COMPRESSED_SIGNED_RED_RGTC1
RGBA16I, RG32I,
RGBA16, RGBA16_-
SNORM
Table 18.4: Compatible internal formats for copying between compressed and un-
compressed internal formats with CopyImageSubData. Formats in the same row
can be copied between each other.
to a valid renderbuffer or texture object according to the corresponding target
parameter.
An INVALID_VALUE error is generated if srcLevel and dstLevel are not
valid levels for the corresponding images.
An INVALID_VALUE error is generated if srcWidth, srcHeight, or sr-
cDepth is negative.
An INVALID_VALUE error is generated if the dimensions of either sub-
region exceeds the boundaries of the corresponding image object, or if the
image format is compressed and the dimensions of the subregion fail to meet
the alignment constraints of the format.
An INVALID_OPERATION error is generated if the formats are not com-
patible.
18.4 Pixel Draw and Read State
The state required for pixel operations consists of the parameters that are set with
PixelStore. This state has been summarized in tables 8.1 and 18.1. Additional
state includes a three-valued integer controlling clamping during ?nal conversion.
The initial value of read color clamping isFIXED_ONLY. State set with PixelStore
OpenGL 4.6 (Core Pro?le) - February 2, 201918.4. PIXELDRAWANDREADSTATE 545
is GL client state.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 19
Compute Shaders
In addition to graphics-oriented shading operations such as vertex, tessellation,
geometry, and fragment shading, generic computation may be performed by the
GL through the use of compute shaders. The compute pipeline is a form of single-
stage machine that runs generic shaders. Compute shaders are created as described
in section 7.1 using a type parameter of COMPUTE_SHADER. They are attached to
and used in program objects as described in section 7.3.
Compute workloads are formed from groups of work items called workgroups
and processed by the executable code for a compute program. A workgroup is a
collection of shader invocations that execute the same code, potentially in paral-
lel. An invocation within a workgroup may share data with other members of the
same workgroup through shared variables (see section 4.3.8(“Shared Variables”)
of the OpenGL Shading Language Specification) and issue memory and control
barriers to synchronize with other members of the same workgroup. One or more
workgroups is launched by calling:
void DispatchCompute(uint num groups x,
uint num groups y,uint num groups z );
Each workgroup is processed by the active program object for the compute
shader stage. The active program for the compute shader stage will be determined
in the same manner as the active program for other pipeline stages, as described
in section 7.3. While the individual shader invocations within a workgroup are
executed as a unit, workgroups are executed completely independently and in un-
speci?ed order.
num groups x, num groups y and num groups z specify the number of work-
groups that will be dispatched in the X, Y and Z dimensions, respectively. The
built-in vector variable gl_NumWorkGroups will be initialized with the contents
546547
of the num groups x, num groups y and num groups z parameters. The maximum
number of workgroups that may be dispatched at one time may be determined by
calling GetIntegeri v with target set toMAX_COMPUTE_WORK_GROUP_COUNT and
index set to zero, one, or two, representing the X, Y, and Z dimensions respectively.
If the workgroup count in any dimension is zero, no workgroups are dispatched.
The workgroup size in each dimension is speci?ed at compile time using an
inputlayout quali?er in one or more of the compute shaders attached to the pro-
gram (see section 4.4.1.4(“Compute Shader Inputs”) of the OpenGL Shading Lan-
guage Specification). After the program has been linked, the workgroup size of the
program may be queried by calling GetProgramiv with pnameCOMPUTE_WORK_-
GROUP_SIZE. This will return an array of three integers containing the workgroup
size of the compute program as speci?ed by its inputlayout quali?er(s).
The maximum workgroup size may be determined by calling GetIntegeri v
with target set toMAX_COMPUTE_WORK_GROUP_SIZE and index set to 0, 1, or 2 to
retrieve the maximum workgroup size in the X, Y and Z dimension, respectively.
Furthermore, the maximum number of invocations in a single workgroup (i.e., the
product of the three dimensions) may be determined by calling GetIntegerv with
pname set toMAX_COMPUTE_WORK_GROUP_INVOCATIONS.
Errors
AnINVALID_OPERATION error is generated if there is no active program
for the compute shader stage.
An INVALID_VALUE error is generated if any of num groups x, num -
groups y and num groups z are greater than the maximum workgroup count
for the corresponding dimension.
The command
void DispatchComputeIndirect(intptr indirect );
is equivalent to calling DispatchCompute with num groups x, num groups y and
num groups z initialized with the three uint values contained in the buffer cur-
rently bound to the DISPATCH_INDIRECT_BUFFER binding at an offset, in basic
machine units, speci?ed in indirect. If any of num groups x, num groups y or
num groups z is greater than the value of MAX_COMPUTE_WORK_GROUP_COUNT
for the corresponding dimension then the results are unde?ned.
Errors
AnINVALID_OPERATION error is generated if there is no active program
OpenGL 4.6 (Core Pro?le) - February 2, 201919.1. COMPUTESHADERVARIABLES 548
for the compute shader stage.
An INVALID_VALUE error is generated if indirect is negative or is not a
multiple of the size, in basic machine units, ofuint.
An INVALID_OPERATION error is generated if the command would
source data beyond the end of the buffer object.
An INVALID_OPERATION error is generated if zero is bound to the
DISPATCH_INDIRECT_BUFFER binding.
19.1 Compute Shader Variables
Compute shaders can access uniform variables belonging to the current program
object. Limits on uniform storage and methods for manipulating uniforms are
described in section 7.6.
There is a limit to the total size of all variables declared asshared in a single
program object. This limit, expressed in units of basic machine units, may be
queried as the value of MAX_COMPUTE_SHARED_MEMORY_SIZE. The total size
required for a given program object is implementation-dependent. However, this
total size may not exceed the largest block size that would be obtained if all active
variables declared asshared were instead declared as arbitrarily ordered members
of a shader storage block quali?ed withstd430.
19.2 Compute Shader Queries
Compute shader queries use query objects to track the number of compute shader
invocations.
When BeginQuery is called with a target of COMPUTE_SHADER_-
INVOCATIONS, the compute shader invocations count maintained by the GL is
set to zero. When a compute shader invocations query is active, the counter is
incremented every time the compute shader is invoked (see chapter 19).
Implementations are allowed to skip the execution of certain compute shader
invocations, and to execute additional compute shader invocations due to imple-
mentation dependent reasons as long as the results of rendering otherwise remain
unchanged.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 20
Debug Output
Application developers can obtain details about errors, unde?ned behavior,
implementation-dependent performance warnings, or other useful hints from the
GL in the form of debug output.
Debug output is communicated through a stream of debug messages that are
generated as GL commands are executed. The application can choose to receive
these messages either through a callback routine, or by querying for them from a
message log.
Controls are provided for disabling messages that the application does not care
about, and for inserting application-generated messages into the stream.
Different levels of debug output may be provided, depending on how the con-
1
text was created. If the context is not a debug context (e.g. if it was created without
the CONTEXT_FLAG_DEBUG_BIT set in the CONTEXT_FLAGS state, as described
in section 22.2), then the GL may optionally not generate any debug messages, but
the commands described in this chapter will otherwise operate without error.
Debug output functionality is enabled or disabled by calling Enable or Disable
with targetDEBUG_OUTPUT. If the context is a debug context (if it was created with
theCONTEXT_FLAG_DEBUG_BIT set inCONTEXT_FLAGS) then the initial value of
DEBUG_OUTPUT isTRUE; otherwise the initial value isFALSE.
In a debug context, ifDEBUG_OUTPUT is disabled the GL will not generate any
debug output logs or callbacks. Enabling DEBUG_OUTPUT again will enable full
debug output functionality.
In a non-debug context, ifDEBUG_OUTPUT is later enabled, the level of debug
output logging is de?ned by the GL implementation, which may have zero debug
1
Debug contexts are speci?ed at context creation time, using window system binding APIs such as
those speci?ed in theGLX_ARB_create_context andWGL_ARB_create_context
extensions for GLX and WGL, respectively.
54920.1. DEBUGMESSAGES 550
Debug Output Message Source Messages Generated by
DEBUG_SOURCE_API The GL
DEBUG_SOURCE_SHADER_COMPILER The GLSL shader compiler or compilers
for other extension-provided languages
DEBUG_SOURCE_WINDOW_SYSTEM The window system, such as WGL or
GLX
DEBUG_SOURCE_THIRD_PARTY External debuggers or third-party middle-
ware libraries
DEBUG_SOURCE_APPLICATION The application
DEBUG_SOURCE_OTHER Sources that do not ?t to any of the ones
listed above
Table 20.1: Sources of debug output messages. Each message must originate from
a source listed in this table.
output.
Full debug output support is guaranteed only in a debug context.
20.1 Debug Messages
A debug message is uniquely identi?ed by the source that generated it, a type
within that source, and an unsigned integer ID identifying the message within that
type. The message source is one of the symbolic constants listed in table 20.1. The
message type is one of the symbolic constants listed in table 20.2.
Each message source and type pair contains its own namespace of messages
with every message being associated with an ID. The assignment of IDs to mes-
sages within a namespace is implementation-dependent. There can potentially be
overlap between the namespaces of two different pairs of source and type, so mes-
sages can only be uniquely distinguished from each other by the full combination
of source, type and ID.
Each message is also assigned a severity level that roughly describes its im-
portance across all sources and types along a single global axis. The severity of a
message is one of the symbolic constants de?ned in table 20.3. Because messages
can be disabled by their severity, the global volume of debug output can be limited.
Every message also has a null-terminated string representation that is used to
describe the message. The contents of the string can change slightly between dif-
ferent instances of the same message (e.g. which parameter value caused a speci?c
GL error to occur). The format of a message string is left as implementation-
OpenGL 4.6 (Core Pro?le) - February 2, 201920.1. DEBUGMESSAGES 551
Debug Output Message Type Informs about
DEBUG_TYPE_ERROR Events that generated an error
DEBUG_TYPE_DEPRECATED_BEHAVIOR Behavior that has been marked for depre-
cation
DEBUG_TYPE_UNDEFINED_BEHAVIOR Behavior that is unde?ned according to
the speci?cation
DEBUG_TYPE_PERFORMANCE Implementation-dependent performance
warnings
DEBUG_TYPE_PORTABILITY Use of extensions or shaders in a way that
is highly vendor-speci?c
DEBUG_TYPE_MARKER Annotation of the command stream
DEBUG_TYPE_PUSH_GROUP Entering a debug group
DEBUG_TYPE_POP_GROUP Leaving a debug group
DEBUG_TYPE_OTHER Types of events that do not ?t any of the
ones listed above
Table 20.2: Types of debug output messages. Each message is associated with one
of these types that describes the nature of the message.
Severity Level Token Suggested examples of messages
DEBUG_SEVERITY_HIGH Any GL error; dangerous unde?ned be-
havior; any shader compiler and linker er-
rors;
DEBUG_SEVERITY_MEDIUM Severe performance warnings; GLSL or
other shader compiler and linker warn-
ings; use of currently deprecated behav-
ior
DEBUG_SEVERITY_LOW Performance warnings from redundant
state changes; trivial unde?ned behavior
DEBUG_SEVERITY_NOTIFICATION Any message which is not an error or per-
formance concern
Table 20.3: Severity levels of messages. Each debug output message is associated
with one of these severity levels.
OpenGL 4.6 (Core Pro?le) - February 2, 201920.2. DEBUGMESSAGECALLBACK 552
dependent, although it should at least represent a concise description of the event
that caused the message to be generated. Messages with different IDs should also
have suf?ciently distinguishable string representations to warrant their separation.
The lengths of all messages, including their null terminators, is guaranteed to
be less than or equal to the value of the implementation-dependent constantMAX_-
DEBUG_MESSAGE_LENGTH.
Messages can be either enabled or disabled. Messages that are disabled will
not be generated. All messages are initially enabled unless their assigned severity
is DEBUG_SEVERITY_LOW. The enabled state of messages can be changed using
the command DebugMessageControl.
20.2 Debug Message Callback
Applications can provide a callback function for receiving debug messages using
the command
void DebugMessageCallback(DEBUGPROC callback,const
void *userParam );
with callback storing the address of the callback function. callback must be a
function whose prototype is of the form
void callback(enum source,enum type,uint id,
enum severity,sizei length,const char *message,
const void *userParam );
Additionally, callback must be declared with the same platform-dependent
calling convention used in the de?nition of the type DEBUGPROC. Anything else
will result in unde?ned behavior.
Only one debug callback can be speci?ed for the current context, and further
calls overwrite the previous callback. Specifying NULL as the value of callback
clears the current callback and disables message output through callbacks. Appli-
cations can provide user-speci?ed data through the pointer userParam. The context
will store this pointer and will include it as one of the parameters in each call to the
callback function.
If the application has speci?ed a callback function for receiving debug out-
put, the implementation will call that function whenever any enabled message is
generated. The source, type, ID, and severity of the message are speci?ed by the
DEBUGPROC parameters source, type, id, and severity, respectively. The string
representation of the message is stored in message and its length (excluding the
OpenGL 4.6 (Core Pro?le) - February 2, 201920.3. DEBUGMESSAGELOG 553
null-terminator) is stored in length. The parameter userParam is the user-speci?ed
parameter that was given when calling DebugMessageCallback.
Applications that specify a callback function must be aware of certain special
conditions when executing code inside a callback when it is called by the GL,
regardless of the debug source.
The memory for message is owned and managed by the GL, and should only
be considered valid for the duration of the function call.
The behavior of calling any GL or window system function from within the
callback function is unde?ned and may lead to program termination.
Care must also be taken in securing debug callbacks for use with asynchronous
debug output by multi-threaded GL implementations. Section 20.8 describes this
in further detail.
IfDEBUG_OUTPUT is disabled, then the GL will not call the callback function.
20.3 Debug Message Log
IfDEBUG_CALLBACK_FUNCTION isNULL, then debug messages are instead stored
in an internal message log up to some maximum number of messages as de?ned
by the value ofMAX_DEBUG_LOGGED_MESSAGES.
Each context stores its own message log and will only store messages gener-
ated by commands operating in that context. If the message log ?lls up, then any
subsequently generated messages will not be placed in the log until the message
log is cleared, and will instead be discarded.
Applications can query the number of messages currently in the log by obtain-
ing the value of DEBUG_LOGGED_MESSAGES, and the string length (including its
null terminator) of the oldest message in the log through the value of DEBUG_-
NEXT_LOGGED_MESSAGE_LENGTH.
To fetch message data stored in the log, the command GetDebugMessageLog
can be used.
If DEBUG_CALLBACK_FUNCTION is not NULL, no generated messages will be
stored in the log but will instead be passed to the debug callback routine as de-
scribed in section 20.2.
IfDEBUG_OUTPUT is disabled, then no messages are added to the message log.
20.4 Controlling Debug Messages
Applications can control the volume of debug output in the active debug group (see
section 20.6) by disabling speci?c groups of messages with the command
OpenGL 4.6 (Core Pro?le) - February 2, 201920.4. CONTROLLINGDEBUGMESSAGES 554
void DebugMessageControl(enum source,enum type,
enum severity,sizei count,const uint *ids,
boolean enabled );
If enabled is TRUE, the referenced subset of messages will be enabled. If
FALSE, then those messages will be disabled.
This command can reference different subsets of messages by ?rst considering
the set of all messages, and ?ltering out messages based on the following ways:
 If source, type, or severity is DONT_CARE, then messages from all sources,
of all types, or of all severities are referenced respectively.
 When values other than DONT_CARE are speci?ed, all messages whose
source, type, or severity match the speci?ed source, type, or severity respec-
tively will be referenced.
 If count is greater than zero, then ids is an array of count message IDs for
the speci?ed combination of source and type. In this case, source and type
must not beDONT_CARE, and severity must beDONT_CARE,
Unrecognized message IDs in ids are ignored. If count is zero, the value if
ids is ignored.
Although messages are grouped into an implicit hierarchy by their sources and
types, there is no explicit per-source, per-type or per-severity enabled state. Instead,
the enabled state is stored individually for each message. There is no difference
between disabling all messages from one source in a single call, and individually
disabling all messages from that source using their types and IDs.
If DEBUG_OUTPUT is disabled, then it is as if messages of every source, type,
or severity are disabled.
Errors
AnINVALID_ENUM error is generated if any of source, type, and severity
is neitherDONT_CARE nor one of the symbols from, respectively, tables 20.1,
20.2, and 20.3.
AnINVALID_VALUE error is generated if count is negative,
An INVALID_OPERATION error is generated if count is greater than zero
and either source or type isDONT_CARE, or severity is notDONT_CARE.
OpenGL 4.6 (Core Pro?le) - February 2, 201920.5. EXTERNALLYGENERATEDMESSAGES 555
20.5 Externally Generated Messages
To support applications and third-party libraries generating their own messages,
such as ones containing timestamp information or signals about speci?c render
system events, the following function can be called
void DebugMessageInsert(enum source,enum type,uint id,
enum severity,int length,const char *buf );
The value of id speci?es the ID for the message and severity indicates its sever-
ity level as de?ned by the caller. The string buf contains the string representation
of the message. The parameter length contains the number of characters in buf. If
length is negative, it is implied that buf contains a null terminated string.
Errors
IfDEBUG_OUTPUT is disabled, then calls to DebugMessageInsert are dis-
carded, but do not generate an error.
AnINVALID_ENUM error is generated if type is not one of the values from
table 20.2, or if source is not DEBUG_SOURCE_APPLICATION or DEBUG_-
SOURCE_THIRD_PARTY.
AnINVALID_ENUM error is generated if severity is not one of the severity
levels listed in table 20.3.
AnINVALID_VALUE error is generated if the number of characters in buf,
excluding the null terminator when length is negative, is not less than the value
ofMAX_DEBUG_MESSAGE_LENGTH.
20.6 Debug Groups
Debug groups provide a method for annotating a command stream with discrete
groups of commands using a descriptive text. Debug output messages, either gener-
ated by the implementation or inserted by the application with DebugMessageIn-
sert are written to the active debug group (the top of the debug group stack). Debug
groups are strictly hierarchical. Their sequences may be nested within other debug
groups but can not overlap. If no debug group has been pushed by the application
then the active debug group is the default debug group.
The command
void PushDebugGroup(enum source,uint id,sizei length,
const char *message );
OpenGL 4.6 (Core Pro?le) - February 2, 201920.6. DEBUGGROUPS 556
pushes a debug group described by the string message into the command stream.
The value of id speci?es the ID of messages generated. The parameter length
contains the number of characters in message. If length is negative, it is im-
plied that message contains a null terminated string. The message has the spec-
i?ed source and id, type DEBUG_TYPE_PUSH_GROUP, and severity DEBUG_-
SEVERITY_NOTIFICATION. The GL will put a new debug group on top of the
debug group stack which inherits control of the volume of debug output of the de-
bug group previously residing on the top of the debug group stack. Because debug
groups are strictly hierarchical, any additional control of the debug output volume
will only apply within the active debug group and the debug groups pushed on top
of the active debug group.
Errors
An INVALID_ENUM error is generated if the value of source is neither
DEBUG_SOURCE_APPLICATION norDEBUG_SOURCE_THIRD_PARTY.
AnINVALID_VALUE error is generated if length is negative and the num-
ber of characters in message, excluding the null-terminator, is not less than the
value ofMAX_DEBUG_MESSAGE_LENGTH.
ASTACK_OVERFLOW error is generated if PushDebugGroup is called and
the stack contains the value ofMAX_DEBUG_GROUP_STACK_DEPTH minus one
elements.
The command
void PopDebugGroup(void );
pops the active debug group. After popping a debug group, the GL will also
generate a debug output message describing its cause based on the message
string, the source, and an id submitted to the associated PushDebugGroup com-
mand. DEBUG_TYPE_PUSH_GROUP and DEBUG_TYPE_POP_GROUP share a sin-
gle namespace for message id. severity has the value DEBUG_SEVERITY_-
NOTIFICATION and type has the valueDEBUG_TYPE_POP_GROUP. Popping a de-
bug group restores the debug output volume control of the parent debug group.
Errors
ASTACK_UNDERFLOW error is generated if PopDebugGroup is called and
only the default debug group is on the stack.
OpenGL 4.6 (Core Pro?le) - February 2, 201920.7. DEBUGLABELS 557
Identi?er Object Type
BUFFER buffer
FRAMEBUFFER framebuffer
PROGRAM_PIPELINE program pipeline
PROGRAM program
QUERY query
RENDERBUFFER renderbuffer
SAMPLER sampler
SHADER shader
TEXTURE texture
TRANSFORM_FEEDBACK transform feedback
VERTEX_ARRAY vertex array
Table 20.4: Object namespace identi?ers and the corresponding object types.
20.7 Debug Labels
Debug labels provide a method for annotating any object (texture, buffer, shader,
etc.) with a descriptive text label. These labels may then be used by the debug
output (see chapter 20) or an external tool such as a debugger or pro?ler to describe
labelled objects.
The command
void ObjectLabel(enum identi?er,uint name,sizei length,
const char *label );
labels the object identi?ed by name and its namespace identi?er. identi?er must be
one of the tokens in table 20.4, indicating the type of the object corresponding to
name.
label contains a string used to label an object. length contains the number
of characters in label. If length is negative, then label contains a null-terminated
string. If label isNULL, any debug label is effectively removed from the object.
Errors
AnINVALID_ENUM error is generated if identi?er is not one of the object
types listed in table 20.4.
AnINVALID_VALUE error is generated if name is not the name of a valid
object of the type speci?ed by identi?er.
OpenGL 4.6 (Core Pro?le) - February 2, 201920.8. ASYNCHRONOUSANDSYNCHRONOUSDEBUGOUTPUT 558
AnINVALID_VALUE error is generated if the number of characters in la-
bel, excluding the null terminator when length is negative, is not less than the
value ofMAX_LABEL_LENGTH.
The command
void ObjectPtrLabel(void *ptr,sizei length,const
char *label );
labels the sync object identi?ed by ptr. length and label match the corresponding
arguments of ObjectLabel.
Errors
An INVALID_VALUE error is generated if ptr is not the name of a sync
object.
AnINVALID_VALUE error is generated if the number of characters in la-
bel, excluding the null terminator when length is negative, is not less than the
value ofMAX_LABEL_LENGTH.
A label is part of the state of the object to which it is associated. The initial
state of an object’s label is the empty string. Labels need not be unique.
20.8 Asynchronous and Synchronous Debug Output
The behavior of how and when the GL driver is allowed to generate debug mes-
sages, and subsequently either call back to the application or place the message in
the debug message log, is affected by the state DEBUG_OUTPUT_SYNCHRONOUS.
This state can be modi?ed by the Enable and Disable commands. Its initial value
isFALSE.
WhenDEBUG_OUTPUT_SYNCHRONOUS is disabled, the driver is optionally al-
lowed to concurrently call the debug callback routine from potentially multiple
threads, including threads that the context that generated the message is not cur-
rently bound to. The implementation may also call the callback routine asyn-
chronously after the GL command that generated the message has already returned.
The application is fully responsible for ensuring thread safety due to debug call-
backs under these circumstances. In this situation the userParam value may be
helpful in identifying which application thread’s command originally generated
the debug callback.
When DEBUG_OUTPUT_SYNCHRONOUS is enabled, the driver guarantees syn-
chronous calls to the callback routine by the context. When synchronous callbacks
OpenGL 4.6 (Core Pro?le) - February 2, 201920.9. DEBUGOUTPUTQUERIES 559
are enabled, all calls to the callback routine will be made by the thread that owns
the current context; all such calls will be made serially by the current context; and
each call will be made before the GL command that generated the debug message
is allowed to return.
When no callback is speci?ed andDEBUG_OUTPUT_SYNCHRONOUS is disabled,
the driver can still asynchronously place messages in the debug message log, even
after the context thread has returned from the GL function that generated those
messages. When DEBUG_OUTPUT_SYNCHRONOUS is enabled, the driver guaran-
tees that all messages are added to the log before the GL function returns.
Enabling synchronous debug output greatly simpli?es the responsibilities of
the application for making its callback functions thread-safe, but may potentially
result in drastically reduced driver performance.
The DEBUG_OUTPUT_SYNCHRONOUS only guarantees intra-context synchro-
nization for the callbacks of messages generated by that context, and does not
guarantee synchronization across multiple contexts. If multiple contexts are con-
currently used by the application, it is allowed for those contexts to also concur-
rently call their designated callbacks, and the application is responsible for han-
dling thread safety in that situation even ifDEBUG_OUTPUT_SYNCHRONOUS is en-
abled in all contexts.
20.9 Debug Output Queries
Pointers set with debug output commands are queried with the generic GetPoint-
erv command (see section 22.2). pnames DEBUG_CALLBACK_FUNCTION and
DEBUG_CALLBACK_USER_PARAM respectively query the current callback function
and the user parameter to that function set with DebugMessageCallback.
When no debug callback is set, debug messages are stored in a debug message
log as described in section 20.3. Messages may be queried from the log by calling
uint GetDebugMessageLog(uint count,sizei bufSize,
enum *sources,enum *types,uint *ids,enum *severities,
sizei *lengths,char *messageLog );
GetDebugMessageLog fetches a maximum of count messages from the mes-
sage log, and will return the number of messages successfully fetched.
Messages will be fetched from the log in order of oldest to newest. Those
messages that were fetched will be removed from the log.
The sources, types, severities, IDs, and string lengths of fetched messages will
be stored in the application-provided arrays sources, types, severities, ids, and
lengths, respectively. The application is responsible for allocating enough space
OpenGL 4.6 (Core Pro?le) - February 2, 201920.9. DEBUGOUTPUTQUERIES 560
for each array to hold up to count elements. The string representations of all
fetched messages are stored in the messageLog array. If multiple messages are
fetched, their strings are concatenated into the same messageLog array and will
be separated by single null terminators. The last string in the array will also be
null-terminated. The maximum size of messageLog, including the space used by
all null terminators, is given by bufSize.
If a message’s string, including its null terminator, can not fully ?t within the
messageLog array’s remaining space, then that message and any subsequent mes-
sages will not be fetched and will remain in the log. The string lengths stored in
the array lengths include the space for the null terminator of each string.
Any or all of the arrays sources, types, ids, severities, lengths and messageLog
can also beNULL pointers, which causes attributes for such arrays to be discarded
when messages are fetched. However, those messages will still be removed from
the log. Thus to simply delete up to count messages from the message log while ig-
noring their attributes, the application can call GetDebugMessageLog withNULL
pointers for all attribute arrays.
If the context is not a debug context, then the GL can opt to never add messages
to the message log, so that GetDebugMessageLog will always return zero.
Errors
An INVALID_VALUE error is generated if bufSize is negative and mes-
sageLog is notNULL.
The command
void GetObjectLabel(enum identi?er,uint name,
sizei bufSize,sizei *length,char *label );
returns in label the string labelling an object. identi?er and name specify the
namespace and name of the object, and match the corresponding arguments of
ObjectLabel (see section 20.7).
label will be null-terminated. The actual number of characters written into
label, excluding the null terminator, is returned in length. If length is NULL, no
length is returned. The maximum number of characters that may be written into
label, including the null terminator, is speci?ed by bufSize. If no debug label was
speci?ed for the object then label will contain a null-terminated empty string, and
zero will be returned in length. If label is NULL and length is non-NULL then no
string will be returned and the length of the label will be returned in length.
OpenGL 4.6 (Core Pro?le) - February 2, 201920.9. DEBUGOUTPUTQUERIES 561
Errors
AnINVALID_ENUM error is generated is identi?er is not one of the object
types listed in table 20.4.
AnINVALID_VALUE error is generated if name is not the name of a valid
object of the type speci?ed by identi?er.
AnINVALID_VALUE error is generated if bufSize is negative.
The command
void GetObjectPtrLabel(void *ptr,sizei bufSize,
size *length,char *label );
returns in label the string labelling the sync object identi?ed by ptr. bufSize, length,
and label match the corresponding arguments of GetObjectLabel.
Errors
An INVALID_VALUE error is generated if ptr is not the name of a sync
object.
AnINVALID_VALUE error is generated if bufSize is negative.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 21
Special Functions
This chapter describes additional functionality that does not ?t easily into any of
the preceding chapters, including hints in?uencing GL behavior (see section 21.5).
21.1
This section is only de?ned in the compatibility pro?le.
21.2
This section is only de?ned in the compatibility pro?le.
21.3
This section is only de?ned in the compatibility pro?le.
21.4
This section is only de?ned in the compatibility pro?le.
21.5 Hints
Certain aspects of GL behavior, when there is room for variation, may be controlled
with hints. A hint is speci?ed using
void Hint(enum target,enum hint );
56221.6. 563
Target Hint description
LINE_SMOOTH_HINT Line sampling quality
POLYGON_SMOOTH_HINT Polygon sampling quality
TEXTURE_COMPRESSION_HINT Quality and performance of
texture image compression
FRAGMENT_SHADER_DERIVATIVE_HINT Derivative accuracy for fragment
processing built-in functions
dFdx,dFdy andfwidth
Table 21.1: Hint targets and descriptions.
target is a symbolic constant indicating the behavior to be controlled, and hint is a
symbolic constant indicating what type of behavior is desired. The possible targets
are described in table 21.1. For each target, hint must be one of FASTEST, indi-
cating that the most ef?cient option should be chosen;NICEST, indicating that the
highest quality option should be chosen; andDONT_CARE, indicating no preference
in the matter.
For the texture compression hint, a hint ofFASTEST indicates that texture im-
ages should be compressed as quickly as possible, whileNICEST indicates that the
texture images should be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, andNICEST should be
used if the compression results are to be retrieved by GetCompressedTexImage
(section 8.11) for reuse.
The interpretation of hints is implementation-dependent. An implementation
may ignore them entirely.
The initial value of all hints isDONT_CARE.
Errors
AnINVALID_ENUM error is generated if target is not one of the values in
table 21.1.
AnINVALID_ENUM error is generated if hint is notFASTEST,NICEST, or
DONT_CARE.
21.6
This section is only de?ned in the compatibility pro?le.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 22
Context State Queries
The state required to describe the GL machine is enumerated in chapter 23, and is
set using commands described in previous chapters.
State that is part of GL objects can usually be queried using commands de-
scribed together with the commands to set that state. Such commands operate
either directly on a named object, or indirectly through a binding in the GL context
(such as a currently bound framebuffer object).
The commands in this chapter describe queries for state directly associated
with the context, rather than with an object. Data conversions may be done when
querying context state, as described in section 2.2.2.
22.1 Simple Queries
Much of the GL state is completely identi?ed by symbolic constants. The values
of these state variables can be obtained using a set of Get commands.
Valid values of the symbolic constants allowed as parameter names to the var-
ious queries in this section are not summarized here, because there are many al-
lowed parameters. Instead they are described elsewhere in the Specification to-
gether with the commands such state is relevant to, as well as in the state tables in
chapter 23.
There are ?ve commands for obtaining simple state variables:
void GetBooleanv(enum pname,boolean *data );
void GetIntegerv(enum pname,int *data );
void GetInteger64v(enum pname,int64 *data );
void GetFloatv(enum pname,float *data );
void GetDoublev(enum pname,double *data );
56422.1. SIMPLEQUERIES 565
The commands obtain boolean, integer, 64-bit integer, ?oating-point, or double-
precision state variables. pname is a symbolic constant indicating the state variable
to return. data is a pointer to a scalar or array of the indicated type in which to
place the returned data.
Errors
AnINVALID_ENUM error is generated if pname is not state queriable with
these commands.
Indexed simple state variables are queried with the commands
void GetBooleani v(enum target,uint index,
boolean *data );
void GetIntegeri v(enum target,uint index,int *data );
void GetFloati v(enum target,uint index,float *data );
void GetDoublei v(enum target,uint index,double *data );
void GetInteger64i v(enum target,uint index,
int64 *data );
target is the name of the indexed state and index is the index of the particular
element being queried. data is a pointer to a scalar or array of the indicated type in
which to place the returned data.
Errors
AnINVALID_ENUM error is generated if target is not indexed state queri-
able with these commands.
AnINVALID_VALUE error is generated if index is outside the valid range
for the indexed state target.
Finally,
boolean IsEnabled(enum cap );
can be used to determine if cap is currently enabled (as with Enable) or disabled.
Errors
An INVALID_ENUM error is generated if cap is not enable state queriable
with IsEnabled.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.2. POINTER,STRING,ANDRELATEDCONTEXTQUERIES 566
boolean IsEnabledi(enum target,uint index );
can be used to determine if the indexed state corresponding to target and index is
enabled or disabled.
Errors
AnINVALID_ENUM error is generated if target is not indexed enable state
queriable with IsEnabledi.
AnINVALID_VALUE error is generated if index is outside the valid range
for the indexed state target.
22.2 Pointer, String, and Related Context Queries
Pointers in the current GL context are queried with the command
void GetPointerv(enum pname,void **params );
pname is a symbolic constant indicating the pointer to return. params is a pointer
to a variable in which to place the single returned pointer value.
pnames of DEBUG_CALLBACK_FUNCTION and DEBUG_CALLBACK_USER_-
PARAM, return debug output state as described in section 20.9.
Errors
An INVALID_ENUM error is generated if pname is not one of the names
described above.
String queries return pointers to UTF-8 encoded, null-terminated static strings
1
describing properties of the current GL context . The command
ubyte *GetString(enum name );
accepts name values of RENDERER, VENDOR, VERSION, and SHADING_-
LANGUAGE_VERSION. The format of the RENDERER and VENDOR strings is
implementation-dependent. The VERSION and SHADING_LANGUAGE_VERSION
strings are laid out as follows:
<version number><space><vendor-speci?c information>
1
Applications making copies of these static strings should never use a ?xed-length buffer, because
the strings may grow unpredictably between releases, resulting in buffer over?ow when copying.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.2. POINTER,STRING,ANDRELATEDCONTEXTQUERIES 567
Value OpenGL Pro?le
CONTEXT_CORE_PROFILE_BIT Core
CONTEXT_COMPATIBILITY_PROFILE_BIT Compatibility
Table 22.1: Context pro?le bits returned by theCONTEXT_PROFILE_MASK query.
The version number is either of the form major number.minor number or major -
number.minor number.release number, where the numbers all have one or more
digits. The minor number forSHADING_LANGUAGE_VERSION is always two dig-
its, matching the OpenGL Shading Language Specification release number. For
example, this query might return the string "4.20" while the corresponding
VERSION query returns "4.2". The release number and vendor speci?c infor-
mation are optional. However, if present, then they pertain to the server and their
format and contents are implementation-dependent.
GetString returns the version number (in the VERSION string) that can be
supported by the current GL context. Thus, if the client and server support different
versions a compatible version is returned.
Errors
AnINVALID_ENUM error is generated if name is notRENDERER,VENDOR,
VERSION, orSHADING_LANGUAGE_VERSION.
The context version may also be queried by calling GetIntegerv with pname
MAJOR_VERSION and MINOR_VERSION, which respectively return the same val-
ues as major number and minor number in theVERSION string.
The pro?le implemented by the context may be queried by calling GetIntegerv
with valueCONTEXT_PROFILE_MASK, which returns a mask containing one of the
bits in table 22.1, corresponding to the API pro?le implemented by the context (see
appendix E.1).
Flags de?ning additional properties of the context may be queried by calling
GetIntegerv with pnameCONTEXT_FLAGS.
If CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT is set in CONTEXT_FLAGS,
then the context is a forward-compatible context as de?ned in appendix E, and the
deprecated features described in that appendix are not supported; otherwise the
context is a full context, and all features described in the speci?cation are sup-
ported.
IfCONTEXT_FLAG_DEBUG_BIT is set inCONTEXT_FLAGS, then the context is
a debug context, enabling full support for debug output as described in chapter 20.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.2. POINTER,STRING,ANDRELATEDCONTEXTQUERIES 568
IfCONTEXT_FLAG_ROBUST_ACCESS_BIT is set inCONTEXT_FLAGS, then ro-
bust buffer access will be enabled for drawing commands using vertex arrays, as
described in section 10.3.7.
If CONTEXT_FLAG_NO_ERROR_BIT is set in CONTEXT_FLAGS, then no error
behavior is enabled, as described in section 2.3.1.1.
The behavior of the context when it is made no longer current (released) by the
platform binding may be queried by calling GetIntegerv with pnameCONTEXT_-
RELEASE_BEHAVIOR. If the behavior isCONTEXT_RELEASE_BEHAVIOR_FLUSH,
any pending commands on the context will be ?ushed. If the behavior is NONE,
pending commands are not ?ushed.
The default value is CONTEXT_RELEASE_BEHAVIOR_FLUSH, and may in
some cases be changed using platform-speci?c context creation extensions.
Indexed strings are queried with the command
ubyte *GetStringi(enum name,uint index );
name is the name of the indexed state and index is the index of the particular ele-
ment being queried.
If name isEXTENSIONS, the extension name corresponding to the indexth sup-
ported extension will be returned. index may range from zero to the value ofNUM_-
EXTENSIONS minus one. There is no de?ned relationship between any particular
extension name and the index values; an extension name may correspond to a dif-
ferent index in different GL contexts and/or implementations.
If name isSHADING_LANGUAGE_VERSION, a version string for one of the sup-
ported versions of the OpenGL Shading Language and OpenGL ES Shading Lan-
guage is returned. index may range from zero to the value of NUM_SHADING_-
LANGUAGE_VERSIONS minus one. The format of the returned string is identical to
the text that may follow#version in shader program source and is formatted as
the version number followed, for versions in which language pro?les are de?ned,
by a space and a pro?le name. For example, a returned string containing "420
core" indicates support for OpenGL Shading Language 4.20, core pro?le. An
empty string indicates support for OpenGL Shading Language 1.10, which did not
include the#version compiler directive. The pro?le string will always be present
in the returned string when it is accepted by that version of the OpenGL Shading
Language, even though there is a default pro?le string in versions 1.50 and greater.
Version strings 100, 300 es, and 310 es correspond to OpenGL ES Shading
Language versions 1.00, 3.00 and 3.10, respectively.
An index of zero will always return the string for the version of the most recent
shading language supported by the GL and the pro?le of the shading language
corresponding to the pro?le of the API (e.g. the ?rst entry returned in an OpenGL
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 569
4.30 core pro?le context will be "430 core" and the ?rst entry returned in an
OpenGL 4.30 compatibility pro?le context will be "430 compatibility").
There is no de?ned ordering of the returned strings for other values of index.
If name isSPIR_V_EXTENSIONS, the SPIR-V extension name corresponding
to the indexth supported SPIR-V extension (speci?ed as the Name String in the cor-
responding SPIR-V extension document) will be returned. index may range from
zero to the value of NUM_SPIR_V_EXTENSIONS minus one. The value of NUM_-
SPIR_V_EXTENSIONS can be queried using the GetInteger command. There is
no de?ned relationship between any particular extension name and the index val-
ues; a SPIR-V extension name may correspond to a different index in different GL
contexts and/or implementations.
Errors
An INVALID_ENUM error is generated if name is not EXTENSIONS,
SHADING_LANGUAGE_VERSION orSPIR_V_EXTENSIONS.
AnINVALID_VALUE error is generated if index is outside the valid range
for the indexed state name.
22.3 Internal Format Queries
Information about implementation-dependent support for internal formats can be
queried with the command
void GetInternalformativ(enum target,enum internalformat,
enum pname,sizei bufSize,int *params );
void GetInternalformati64v(enum target,
enum internalformat,enum pname,sizei bufSize,
int64 *params );
internalformat can be any value. TheINTERNALFORMAT_SUPPORTED pname
can be used to determine if the internal format is supported, and the other pnames
are de?ned in terms of whether or not the format is supported.
target indicates the usage of the internalformat, and must be one the targets
listed in table 22.2.
No more than bufSize integers will be written into params. If more data are
available, they will be ignored and no error will be generated.
pname indicates the information to query. The following subsections list the
valid values for pname and de?ne their meaning and the values that may be re-
turned. In the following descriptions, the term resource is used to generically re-
fer to an object of the appropriate type that has been created with internalformat
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 570
Target Usage
TEXTURE_1D 1D texture
TEXTURE_1D_ARRAY 1D array texture
TEXTURE_2D 2D texture
TEXTURE_2D_ARRAY 2D array texture
TEXTURE_2D_MULTISAMPLE 2D multisample texture
TEXTURE_2D_MULTISAMPLE_ARRAY 2D multisample array texture
TEXTURE_3D 3D texture
TEXTURE_BUFFER buffer texture
TEXTURE_CUBE_MAP cube map texture
TEXTURE_CUBE_MAP_ARRAY cube map array texture
TEXTURE_RECTANGLE rectangle texture
RENDERBUFFER renderbuffer
Table 22.2: Possible targets that internalformat can be used with and the corre-
sponding usage meaning.
and target. If the particular target and internalformat combination does not make
sense, or if a particular type of target is not supported by the implementation the
unsupported answer should be given. This is not an error.
All properties may be queried via either GetInternalformat* command. Data
conversions are done as de?ned in section 2.2.2.
22.3.1 Supported Operation Queries
Queries that return information about supported types of operations will return one
of the following values in params:
 NONE: the requested resource or operation is not supported at all by the im-
plementation.
 CAVEAT_SUPPORT: the requested operation is supported by the implemen-
tation, but there may be some implementation-speci?c caveats that make
support less than optimal. For example using the feature may result in re-
duced performance (relative to other formats or features), such as software
rendering or other mechanisms of emulating the desired feature.
If a query reports that there is a caveat and the debug output functionality
is enabled (see section 20), the GL will generate a debug output message
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 571
describing the caveat. The message has the sourceDEBUG_SOURCE_API, the
typeDEBUG_TYPE_PERFORMANCE, and an implementation-dependent ID.
 FULL_SUPPORT: the requested operation is fully supported by the imple-
mentation.
Possible pnames for supported types of operations, and their meanings, in-
clude:
 CLEAR_BUFFER: Support for using the resource with ClearBuffer*Data
commands is returned in params.
 CLEAR_TEXTURE: Support for using the resource with ClearTex*Image
commands is returned in params.
 COMPUTE_TEXTURE: Support for using the resource as a source for texture
sampling in a compute shader is written to params.
 FILTER: Support for ?lter types other than NEAREST or NEAREST_-
MIPMAP_NEAREST for the resource is written to params. This indicates
if sampling from such resources supports setting the MIN/MAG ?lters to
LINEAR values.
 FRAGMENT_TEXTURE: Support for using the resource as a source for texture
sampling in a fragment shader is written to params.
 FRAMEBUFFER_BLEND: Support for rendering to the resource via frame-
buffer attachment when blending is enabled is returned in params.
 FRAMEBUFFER_RENDERABLE: Support for rendering to the resource via
framebuffer attachment is returned in params.
 FRAMEBUFFER_RENDERABLE_LAYERED: Support for layered rendering to
the resource via framebuffer attachment is returned in params.
 GEOMETRY_TEXTURE: Support for using the resource as a source for texture
sampling in a geometry shader is written to params.
 MANUAL_GENERATE_MIPMAP: Support for manually generating mipmaps
for the resource is returned in params.
 READ_PIXELS: Support for reading pixels from the resource when it is at-
tached to a framebuffer is returned in params.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 572
 SHADER_IMAGE_ATOMIC: Support for using the resource with atomic mem-
ory operations from shaders is written to params.
 SHADER_IMAGE_LOAD: Support for using the resource with image load op-
erations in shaders is written to params. In this case the internalformat is the
value of the format parameter that would be passed to BindImageTexture.
 SHADER_IMAGE_STORE: Support for using the resource with image store
operations in shaders is written to params. In this case the internalformat is
the value of the format parameter that is passed to BindImageTexture.
 SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: Support for using the re-
source both as a source for texture sampling while it is bound as a buffer
for depth test is written to params. For example, a depth (or stencil) texture
could be bound simultaneously for texturing while it is bound as a depth
(and/or stencil) buffer without causing a feedback loop, provided that depth
writes are disabled.
 SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: Support for using the re-
source both as a source for texture sampling while performing depth writes
to the resources is written to params. For example, a depth-stencil texture
could be bound simultaneously for stencil texturing while it is bound as a
depth buffer. Feedback loops cannot occur because sampling a stencil tex-
ture only returns the stencil portion, and thus writes to the depth buffer do
not modify the stencil portions.
 SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: Support for using the re-
source both as a source for texture sampling while it is bound as a buffer for
stencil test is written to params. For example, a depth (or stencil) texture
could be bound simultaneously for texturing while it is bound as a depth
(and/or stencil) buffer without causing a feedback loop, provided that stencil
writes are disabled.
 SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: Support for using the
resource both as a source for texture sampling while performing stencil
writes to the resources is written to params. For example, a depth-stencil
texture could be bound simultaneously for depth-texturing while it is bound
as a stencil buffer. Feedback loops cannot occur because sampling a depth
texture only returns the depth portion, and thus writes to the stencil buffer
could not modify the depth portions.
 SRGB_READ: Support for converting from sRGB colorspace on read opera-
tions (see section 8.24) from the resource is returned in params.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 573
 SRGB_WRITE: Support for converting to sRGB colorspace on write opera-
tions to the resource is returned in params. This indicates that writing to
framebuffers with this internal format will encode to sRGB color spaces
whenFRAMEBUFFER_SRGB is enabled (see section 17.3.7).
 TESS_CONTROL_TEXTURE: Support for using the resource as a source for
texture sampling in a tessellation control shader is written to params.
 TESS_EVALUATION_TEXTURE: Support for using the resource as a source
for texture sampling in a tessellation evaluation shader is written to params.
 TEXTURE_GATHER: Support for using the resource with texture gather oper-
ations is written to params.
 TEXTURE_GATHER_SHADOW: Support for using resource with texture gather
operations with shadow samplers is written to params.
 TEXTURE_SHADOW: Support for using the resource with shadow samplers is
written to params.
 TEXTURE_VIEW: Support for using the resource with the TextureView com-
mand is returned in params.
 VERTEX_TEXTURE: Support for using the resource as a source for texture
sampling in a vertex shader is written to params.
22.3.2 Other Internal Format Queries
Other supported values for pname, their meanings, and their possible return values
include:
 COLOR_COMPONENTS: If the internal format contains any color components
(R, G, B, or A),TRUE is returned in params. If the internal format is unsup-
ported or contains no color components,FALSE is returned.
 COLOR_ENCODING: The color encoding for the resource is returned in
params. Possible values for color buffers are LINEAR or SRGB, for linear
or sRGB-encoded color components, respectively. For non-color formats
(such as depth or stencil), or for unsupported resources, the value NONE is
returned.
 COLOR_RENDERABLE: If internalformat is color-renderable (as de?ned in
section 9.4), TRUE is returned in params. If the internal format is unsup-
ported, or the internal format is not color-renderable,FALSE is returned.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 574
 DEPTH_COMPONENTS: If the internal format contains a depth component
(D), TRUE is returned in params. If the internal format is unsupported or
contains no depth component,FALSE is returned.
 DEPTH_RENDERABLE: If internalformat is depth-renderable (as de?ned in
section 9.4), TRUE is returned in params. If the internal format is unsup-
ported, or if the internal format is not depth-renderable,FALSE is returned.
 GET_TEXTURE_IMAGE_FORMAT: The implementation-preferred format to
pass to GetTexImage when querying texture image data from this resource.
Possible values include any value that is legal to pass for the format parame-
ter to GetTexImage, orNONE if the resource does not support this operation,
or if GetTexImage is not supported.
 GET_TEXTURE_IMAGE_TYPE: The implementation-preferred type to pass to
GetTexImage when querying texture image data from this resource. Possi-
ble values include any value that is legal to pass for the type parameter to
GetTexImage, orNONE if the resource does not support this operation, or if
GetTexImage is not supported.
 IMAGE_COMPATIBILITY_CLASS: The compatibility class of the resource
when used as an image texture is returned in params. This corre-
sponds to the value from the Class column in table 8.27. The possi-
ble values returned are IMAGE_CLASS_4_X_32, IMAGE_CLASS_2_X_32,
IMAGE_CLASS_1_X_32, IMAGE_CLASS_4_X_16, IMAGE_CLASS_2_X_-
16, IMAGE_CLASS_1_X_16, IMAGE_CLASS_4_X_8, IMAGE_CLASS_2_-
X_8, IMAGE_CLASS_1_X_8, IMAGE_CLASS_11_11_10, and IMAGE_-
CLASS_10_10_10_2, which correspond to the 4x32, 2x32, 1x32, 4x16,
2x16, 1x16, 4x8, 2x8, 1x8, the class (a) 11/11/10 packed ?oating-point for-
mat, and the class (b) 10/10/10/2 packed formats, respectively. If the re-
source is not supported for image textures, or if image textures are not sup-
ported,NONE is returned.
 IMAGE_FORMAT_COMPATIBILITY_TYPE: The matching criteria use for the
resource when used as an image textures is returned in params. This
is equivalent to calling GetTexParameter with pname set to IMAGE_-
FORMAT_COMPATIBILITY_TYPE. Possible values are IMAGE_FORMAT_-
COMPATIBILITY_BY_SIZE or IMAGE_FORMAT_COMPATIBILITY_BY_-
CLASS. If the resource is not supported for image textures, or if image tex-
tures are not supported,NONE is returned.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 575
 IMAGE_PIXEL_FORMAT: The pixel format of the resource when used as an
image texture is returned in params. This is the value from the Pixelformat
column in table 8.27. If the resource is not supported for image textures, or
if image textures are not supported,NONE is returned.
 IMAGE_PIXEL_TYPE: The pixel type of the resource when used as an image
texture is returned in params. This is the value from the Pixel type column
in table 8.27. If the resource is not supported for image textures, or if image
textures are not supported,NONE is returned.
 IMAGE_TEXEL_SIZE: The size of a texel of the resource when used as an
image texture is returned in params. This is the value from the Size column
in table 8.27. If the resource is not supported for image textures, or if image
textures are not supported, zero is returned.
 INTERNALFORMAT_PREFERRED: The implementation-preferred internal
format for representing resources of the speci?ed internalformat is returned
in params. The preferred internal format should have no less precision than
the requested one. If the speci?ed internalformat is already a preferred for-
mat, or if there is no better format that is compatible, the queried internalfor-
mat value is written to params. If the internalformat is not supported,NONE
is returned.
 INTERNALFORMAT_RED_SIZE, INTERNALFORMAT_GREEN_-
SIZE, INTERNALFORMAT_BLUE_SIZE, INTERNALFORMAT_ALPHA_SIZE,
INTERNALFORMAT_DEPTH_SIZE, INTERNALFORMAT_STENCIL_SIZE, or
INTERNALFORMAT_SHARED_SIZE:
For uncompressed internal formats, queries of these values return the ac-
tual resolutions that would be used for storing image components for the
resource. For compressed internal formats, the resolutions returned spec-
ify the component resolution of an uncompressed internal format that pro-
duces an image of roughly the same quality as the compressed algorithm.
For textures this query will return the same information as querying Get-
TexLevelParameter* for the corresponding TEXTURE_ _SIZE (except in
*
cases where GetTexLevelParameter* does not support such a query). If
the internal format is unsupported, or if a particular component is not present
in the format, 0 is written to params.
 INTERNALFORMAT_RED_TYPE, INTERNALFORMAT_GREEN_-
TYPE, INTERNALFORMAT_BLUE_TYPE, INTERNALFORMAT_ALPHA_TYPE,
INTERNALFORMAT_DEPTH_TYPE, orINTERNALFORMAT_STENCIL_TYPE:
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 576
For uncompressed internal formats, queries for these values return the data
type used to store the component. For compressed internal formats the
types returned specify how components are interpreted after decompres-
sion. For textures this query returns the same information as querying
GetTexLevelParameter* for the corresponding TEXTURE_ _TYPE (ex-
*
cept in cases where GetTexLevelParameter* does not support such a
query). Possible values returned include NONE, SIGNED_NORMALIZED,
UNSIGNED_NORMALIZED, FLOAT, INT, and UNSIGNED_INT, representing
missing, signed normalized ?xed-point, unsigned normalized ?xed-point,
?oating-point, signed unnormalized integer, and unsigned unnormalized in-
teger components respectively. NONE is returned for all component types if
the format is unsupported.
 INTERNALFORMAT_SUPPORTED: If internalformat is an internal format that
is supported by the implementation in at least some subset of possible oper-
ations, TRUE is written to params. If internalformat if not a valid token for
any internal format usage,FALSE is returned.
internalformats that must be supported include:
– sized internal formats from tables 8.12- 8.13 and 8.16,
– any speci?c compressed internal format from table 8.14,
– any image unit format from table 8.26,
– any generic compressed internal format from table 8.14, if the imple-
mentation accepts it for any texture speci?cation commands, and
– any unsized or base internal format, if the implementation accepts it for
texture or image speci?cation.
In other words, any internalformat accepted by any of the com-
mands: ClearBufferData, ClearBufferSubData, CompressedTexIm-
age1D, CompressedTexImage2D, CompressedTexImage3D, CopyTex-
Image1D, CopyTexImage2D, RenderbufferStorage, Renderbuffer-
StorageMultisample, TexBuffer, TexImage1D, TexImage2D, TexIm-
age3D, TexImage2DMultisample, TexImage3DMultisample, TexStor-
age1D, TexStorage2D, TexStorage3D, TexStorage2DMultisample, TexS-
torage3DMultisample, and TextureView, and any valid format accepted by
BindImageTexture, must be supported.
 MAX_COMBINED_DIMENSIONS: The maximum combined dimensions for
the resource is returned in params. The combined dimensions is the prod-
uct of the individual dimensions of the resource. For multisampled surfaces
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 577
the number of samples is considered an additional dimension. Note that the
32
value returned can be 2 and should be queried with GetInternalfor-
mati64v.
This value should be considered a recommendation for applications. There
may be system-dependant reasons why allocations larger than this size may
fail, even if there might appear to be suf?cient memory available when
queried via some other means. This also does not provide a guarantee that
allocations smaller than this will succeed because this value is not affected
by existing resource allocations.
For one-dimensional targets this is the maximum single dimension. For
one-dimensional array targets this is the maximum combined width and
layers. For two-dimensional targets this is the maximum combined width
and height. For two-dimensional multisample targets this is the combined
width, height and samples. For two-dimensional array targets this is the max
combined width, height and layers. For two-dimensional multisample array
targets, this is the max combined width, height, layers and samples. For
three-dimensional targets this is the maximum combined width, height and
depth. For cube map targets this is the maximum combined width, height
and faces. For cube map array targets this is the maximum width, height and
layer-faces. If the resource is unsupported, zero is returned.
 MAX_DEPTH: The maximum supported depth for the resource is returned in
params. For resources with three or more dimensions, the third dimension is
considered the depth. If the resource does not have at least three dimensions,
or if the resource is unsupported, zero is returned.
 MAX_HEIGHT: The maximum supported height for the resource is returned in
params. For resources with two or more dimensions, the second dimension
is considered the height. If the resource does not have at least two dimen-
sions, or if the resource is unsupported, zero is returned.
 MAX_LAYERS: The maximum supported number of layers for the resource is
returned in params. For 1D array targets, the value returned is the same as
the MAX_HEIGHT. For 2D and cube array targets, the value returned is the
same as the MAX_DEPTH. If the resource does not support layers, or if the
resource is unsupported, zero is returned.
 MAX_WIDTH: The maximum supported width for the resource is returned in
params. For resources with only one dimension, that dimension is consid-
ered the width. If the resource is unsupported, zero is returned.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 578
 MIPMAP: If the resource supports mipmaps, TRUE is returned in params. If
the resource is not supported, or if mipmaps are not supported for this type
of resource,FALSE is returned.
 NUM_SAMPLE_COUNTS: The number of sample counts that would be re-
turned by queryingSAMPLES is returned in params.
– If internalformat is not color-renderable, depth-renderable, or stencil-
renderable (as de?ned in section 9.4), or if target does not support mul-
tiple samples (is not TEXTURE_2D_MULTISAMPLE, TEXTURE_2D_-
MULTISAMPLE_ARRAY, orRENDERBUFFER), zero is returned.
 READ_PIXELS_FORMAT: The format to pass to ReadPixels to obtain the
best performance and image quality when reading from framebuffers with
internalformat is returned in params. Possible values include any value that
is legal to pass for the format parameter to ReadPixels, orNONE if internal-
format is not supported or can never be a valid source for ReadPixels.
 READ_PIXELS_TYPE: The type to pass to ReadPixels to obtain the best
performance and image quality when reading from framebuffers with inter-
nalformat is returned in params. Possible values include any value that is
legal to pass for the type parameter to ReadPixels, or NONE if the internal
format is not supported or can never be a source for ReadPixels.
 SAMPLES: The sample counts supported for internalformat and target are
written into params, in descending numeric order. Only positive values are
returned.
– Note that querying SAMPLES with a bufSize of one will return just the
maximum supported number of samples for this format.
– The maximum value inSAMPLES is guaranteed to be at least the lowest
of the following:
 The value of MAX_INTEGER_SAMPLES, if internalformat is a
signed or unsigned integer format.
 The value of MAX_DEPTH_TEXTURE_SAMPLES, if internalformat
is a depth/stencil-renderable format and target isTEXTURE_2D_-
MULTISAMPLE orTEXTURE_2D_MULTISAMPLE_ARRAY.
 The value of MAX_COLOR_TEXTURE_SAMPLES, if internalfor-
mat is a color-renderable format and target is TEXTURE_2D_-
MULTISAMPLE orTEXTURE_2D_MULTISAMPLE_ARRAY.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.3. INTERNALFORMATQUERIES 579
 The value ofMAX_SAMPLES.
– If internalformat is not color-renderable, depth-renderable, or stencil-
renderable (as de?ned in section 9.4), or if target does not sup-
port multiple samples (i.e. other than TEXTURE_2D_MULTISAMPLE,
TEXTURE_2D_MULTISAMPLE_ARRAY, orRENDERBUFFER), params is
not modi?ed.
 STENCIL_COMPONENTS: If the internal format contains a stencil component
(S), TRUE is returned in params. If the internal format is unsupported or
contains no stencil component,FALSE is returned.
 STENCIL_RENDERABLE: If internalformat is stencil-renderable (as de?ned
in section 9.4), TRUE is returned in params. If the internal format is unsup-
ported, or if the internal format is not stencil-renderable,FALSE is returned.
 TEXTURE_COMPRESSED: If internalformat is a compressed format that is
supported for this type of resource,TRUE is returned in params. If the inter-
nal format is not compressed, or the type of resource is not supported,FALSE
is returned.
 TEXTURE_COMPRESSED_BLOCK_HEIGHT: If the resource contains a com-
pressed format, the height of a compressed block (in texels) is returned in
params. If the internal format is not compressed, or the resource is not sup-
ported, 0 is returned.
 TEXTURE_COMPRESSED_BLOCK_SIZE: If the resource contains a com-
pressed format, the number of bytes per block is returned in params. If
the internal format is not compressed, or the resource is not supported, 0 is
returned. Together with the block width and height queries this allows the
bitrate to be computed, and may be useful in conjunction with ARB com-
pressed texture pixel storage).
 TEXTURE_COMPRESSED_BLOCK_WIDTH: If the resource contains a com-
pressed format, the width of a compressed block (in texels) is returned in
params. If the internal format is not compressed, or the resource is not sup-
ported, 0 is returned.
 TEXTURE_IMAGE_FORMAT: The implementation-preferred format to pass to
TexImage*D or TexSubImage*D when specifying texture image data for
this resource is returned in params. Possible values include any value that
is legal to pass for the format parameter to the Tex*Image*D commands, or
NONE if the resource is not supported for this operation.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.4. TRANSFORMFEEDBACKSTATEQUERIES 580
 TEXTURE_IMAGE_TYPE: The implementation-preferred type to pass to Tex-
Image*D or TexSubImage*D when specifying texture image data for this
resource is returned in params. Possible values include any value that is le-
gal to pass for the type parameter to the Tex*Image*D commands, orNONE
if the resource is not supported for this operation.
 VIEW_COMPATIBILITY_CLASS: The compatibility class of the resource
when used as a texture view is returned in params. The compatibility class
is one of the values from the Class column of table 8.22. If the resource has
no other formats that are compatible, the resource does not support views, or
if texture views are not supported,NONE is returned.
Errors
AnINVALID_ENUM error is generated if target is not one of the targets in
table 22.2, or if pname is not one of the parameters described above.
AnINVALID_VALUE error is generated if bufSize is negative.
22.4 Transform Feedback State Queries
State of the currently bound transform feedback object may be queried by call-
ing GetIntegerv, GetIntegeri v, GetInteger64i v, GetBooleanv, or other query
functions with the query target set to one of the tokens listed in table 23.48.
Alternatively, the state of a transform feedback object may be queried with the
commands
void GetTransformFeedbackiv(uint xfb,enum pname,
int *param );
void GetTransformFeedbacki v(uint xfb,enum pname,
uint index,int *param );
void GetTransformFeedbacki64 v(uint xfb,enum pname,
uint index,int64 *param );
xfb must be zero, indicating the default transform feedback object, or the name
of an existing transform feedback object. pname must be one of the tokens listed in
table 23.48, depending on the command name as shown in the errors section below.
For indexed state, index is the index of the transform feedback stream. param is
the address of a variable to receive the result of the query.
OpenGL 4.6 (Core Pro?le) - February 2, 201922.5. INDEXEDBINDINGSTATEQUERIES 581
Errors
An INVALID_OPERATION error is generated by GetTransformFeed-
back* if xfb is not zero or the name of an existing transform feedback object.
An INVALID_ENUM error is generated by GetTransformFeedbackiv
if pname is not TRANSFORM_FEEDBACK_PAUSED or TRANSFORM_-
FEEDBACK_ACTIVE.
An INVALID_ENUM error is generated by GetTransformFeedbacki v if
pname is notTRANSFORM_FEEDBACK_BUFFER_BINDING.
An INVALID_ENUM error is generated by GetTransformFeedbacki64 v
if pname is not TRANSFORM_FEEDBACK_BUFFER_START or TRANSFORM_-
FEEDBACK_BUFFER_SIZE.
An INVALID_VALUE error is generated by GetTransformFeedbacki v
and GetTransformFeedbacki64 v if index is greater than or equal to the num-
ber of binding points for transform feedback, as described in section 6.7.1.
22.5 Indexed Binding State Queries
The name of the texture object bound to the active texture unit may be queried by
calling GetIntegerv with pnameTEXTURE_BINDING_1D,TEXTURE_BINDING_-
1D_-
ARRAY, TEXTURE_BINDING_2D, TEXTURE_BINDING_2D_ARRAY, TEXTURE_-
BINDING_2D_MULTISAMPLE, TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY,
TEXTURE_BINDING_3D, TEXTURE_BINDING_BUFFER, TEXTURE_BINDING_-
CUBE_MAP, TEXTURE_BINDING_CUBE_MAP_ARRAY, or TEXTURE_BINDING_-
RECTANGLE. Likewise, the current sampler bound to the active texture unit may
be queried by calling GetIntegerv with pnameSAMPLER_BINDING.
To query the bound texture or sampler object bound to a speci?c texture unit
without changing the active texture selector, call GetIntegeri v with one of the
valid pnames listed above, and with index set to the zero-based texture unit index
to be queried.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Chapter 23
State Tables
The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of the simple
queries in section 22.1 are listed with just one of these commands – the one that
is most appropriate given the type of the data to be returned. These state vari-
ables cannot be obtained using IsEnabled. However, state variables for which
IsEnabled is listed as the query command can also be obtained using any of the
simple queries. State variables for which any other command is listed as the query
command can be obtained by using that command or any of its typed variants,
although information may be lost when not using the listed command. Unless oth-
erwise speci?ed, when ?oating-point state is returned as integer values or integer
state is returned as ?oating-point values it is converted in the fashion described in
section 2.2.2.
State table entries indicate a type for each variable. Table 23.1 explains these
types. The type actually identi?es all state associated with the indicated descrip-
tion; in certain cases only a portion of this state is returned. This is the case with
textures, where only the selected texture or texture parameter is returned.
The abbreviations max., min., and no. are used interchangeably with maximum,
minimum, and number, respectively, to help ?t tables without over?owing pages.
582583
Type code Explanation
B Boolean
BMU Basic machine units
C Color (?oating-point R, G, B, and A values)
E Enumerated value (as described in spec body)
Z Integer
+
Z Non-negative integer or enumerated value
Z ,Z k-valued integer (k indicatesk is minimum)
k k
R Floating-point number
+
R Non-negative ?oating-point number
[a;b]
R Floating-point number in the range [a;b]
k
R k-tuple of ?oating-point numbers
S null-terminated string
I Image
Y Pointer (data type unspeci?ed)
ntype n copies of typetype (n indicatesn is minimum)
Table 23.1: State Variable Types
OpenGL 4.6 (Core Pro?le) - February 2, 2019584
Table 23.2: Current Values and Associated Data
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
PATCH VERTICES Z GetIntegerv 3 No. of vertices in input patch 10.1
Default outer tess. level w/o control
PATCH DEFAULT OUTER LEVEL 4R GetFloatv (1:0; 1:0; 1:0; 1:0) 11.2.2
shader
Default inner tess. level w/o control
PATCH DEFAULT INNER LEVEL 2R GetFloatv (1:0; 1:0) 11.2.2
shader585
Table 23.3: Vertex Array Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
VERTEX ATTRIB ARRAY ENABLED 16B GetVertexAttribiv FALSE Vertex attrib array enable 10.3
VERTEX ATTRIB ARRAY SIZE 16Z GetVertexAttribiv 4 Vertex attrib array size 10.3
5
+
VERTEX ATTRIB ARRAY STRIDE 16Z GetVertexAttribiv 0 Vertex attrib array stride 10.3
VERTEX ATTRIB ARRAY TYPE 16E GetVertexAttribiv FLOAT Vertex attrib array type 10.3
Vertex attrib array nor-
VERTEX ATTRIB ARRAY NORMALIZED 16B GetVertexAttribiv FALSE 10.3
malized
Vertex attrib array has
VERTEX ATTRIB ARRAY INTEGER 16B GetVertexAttribiv FALSE 10.3
unconverted integers
Vertex attrib array has
VERTEX ATTRIB ARRAY LONG 16B GetVertexAttribiv FALSE 10.3
unconverted doubles
Vertex attrib array in-
+
VERTEX ATTRIB ARRAY DIVISOR 16Z GetVertexAttribiv 0 10.4
stance divisor
GetVertex- Vertex attrib array
VERTEX ATTRIB ARRAY POINTER 16Y NULL 10.3
AttribPointerv pointer
– S GetObjectLabel empty Debug label 20.9586
Table 23.4: Vertex Array Object State (cont.)
y The ith attribute defaults to a value of i.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Element array buffer
+
ELEMENT ARRAY BUFFER BINDING Z GetIntegerv 0 10.3.10
binding
Attribute array buffer
+
VERTEX ATTRIB ARRAY BUFFER BINDING 16Z GetVertexAttribiv 0 6
binding
Vertex buffer binding
VERTEX ATTRIB BINDING 16Z GetVertexAttribiv iy 10.3
16
used by vertex attribi
Byte offset added to ver-
+
VERTEX ATTRIB RELATIVE OFFSET 16Z GetVertexAttribiv 0 tex binding offset for this 10.3
attribute
Byte offset of the ?rst
element in data store of
VERTEX BINDING OFFSET 16Z GetInteger64i v 0 10.3
the buffer bound to ver-
tex bindingi
Stride between elements
VERTEX BINDING STRIDE 16Z GetIntegeri v 16 10.3
in vertex bindingi
Instance divisor for ver-
VERTEX BINDING DIVISOR 16Z GetIntegeri v 16 10.3
tex bindingi
Name of buffer bound to
VERTEX BINDING BUFFER 16Z GetIntegeri v 16 10.3
vertex bindingi587
Table 23.5: Vertex Array Data (not in Vertex Array objects)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
ARRAY BUFFER BINDING Z GetIntegerv 0 Current buffer binding 6
Indirect command buffer
+
DRAW INDIRECT BUFFER BINDING Z GetIntegerv 0 10.3.11
binding
Current vertex array ob-
+
VERTEX ARRAY BINDING Z GetIntegerv 0 10.3.1
ject binding
Indirect parameter buffer
+
PARAMETER BUFFER BINDING Z GetIntegerv 0 10.4
binding
PRIMITIVE RESTART B IsEnabled FALSE Primitive restart enable 10.3
Primitive restart ?xed in-
PRIMITIVE RESTART FIXED INDEX B IsEnabled FALSE 10.3.6
dex enable
+
PRIMITIVE RESTART INDEX Z GetIntegerv 0 Primitive restart index 10.3.6588
Table 23.6: Buffer Object State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
– nBMU GetBufferSubData - Buffer data 6
+
BUFFER SIZE nZ GetBufferParameteri64v 0 Buffer data size 6
BUFFER USAGE nE GetBufferParameteriv STATIC_DRAW Buffer usage pattern 6
BUFFER ACCESS nE GetBufferParameteriv READ_WRITE Buffer access ?ag 6.3
+
BUFFER ACCESS FLAGS nZ GetBufferParameteriv 0 Extended buffer access ?ag 6.3
TRUE if buffer’s data store is im-
BUFFER IMMUTABLE STORAGE B GetBufferParameteriv FALSE 6
mutable,FALSE otherwise
+
BUFFER STORAGE FLAGS Z GetBufferParameteriv 0 Buffer object storage ?ags 6
BUFFER MAPPED nB GetBufferParameteriv FALSE Buffer map ?ag 6.3
BUFFER MAP POINTER nY GetBufferPointerv NULL Mapped buffer pointer 6.3
+
BUFFER MAP OFFSET nZ GetBufferParameteri64v 0 Start of mapped buffer range 6.3
+
BUFFER MAP LENGTH nZ GetBufferParameteri64v 0 Size of mapped buffer range 6.3
– S GetObjectLabel empty Debug label 20.9589
Table 23.7: Transformation state
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
VIEWPORT 164R GetFloati v See sec. 13.8.1 Viewport origin & extent 13.8.1
[0;1]
DEPTH RANGE 162R GetDoublei v 0,1 Depth range near & far 13.8.1
ith user clipping plane
CLIP DISTANCEi 8B IsEnabled FALSE 13.7
enabled
CLIP ORIGIN Z GetIntegerv LOWER_LEFT Clip origin 13.7
2
CLIP DEPTH MODE Z GetIntegerv NEGATIVE_ONE_TO_ONE Clip depth mode 13.7
2
DEPTH CLAMP B IsEnabled FALSE Depth clamping enabled 13.7
Object bound for trans-
+
TRANSFORM FEEDBACK BINDING Z GetIntegerv 0 13.3
form feedback operations
Buffer object bound to
TRANSFORM FEEDBACK BUFFER BIND-
+
Z GetIntegerv 0 generic bind point for 6.7
ING
transform feedback590
Table 23.8: Coloring
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
FIXED_-
CLAMP READ COLOR E GetIntegerv Read color clamping 18.2.8
ONLY
LAST_-
Provoking vertex con-
PROVOKING VERTEX E GetIntegerv VERTEX_- 13.6
vention
CONVENTION591
Table 23.9: Rasterization
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Discard primitives before rasteriza-
RASTERIZER DISCARD B IsEnabled FALSE 14.1
tion
+
POINT SIZE R GetFloatv 1.0 Point size 14.4
+
POINT FADE THRESHOLD SIZE R GetFloatv 1.0 Threshold for alpha attenuation 14.4
POINT SPRITE COORD ORIGIN E GetIntegerv UPPER_LEFT Origin orientation for point sprites 14.4
+
LINE WIDTH R GetFloatv 1.0 Line width 14.5
LINE SMOOTH B IsEnabled FALSE Line antialiasing on 14.5592
Table 23.10: Rasterization (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
CULL FACE B IsEnabled FALSE Polygon culling enabled 14.6.1
CULL FACE MODE E GetIntegerv BACK Cull front-/back-facing polygons 14.6.1
Polygon frontface CW/CCW indica-
FRONT FACE E GetIntegerv CCW 14.6.1
tor
POLYGON SMOOTH B IsEnabled FALSE Polygon antialiasing on 14.6
Polygon rasterization mode (front &
POLYGON MODE E GetIntegerv FILL 14.6.4
back)
POLYGON OFFSET CLAMP R GetFloatv 0 Polygon offset clamp 14.6.5
POLYGON OFFSET FACTOR R GetFloatv 0 Polygon offset factor 14.6.5
POLYGON OFFSET UNITS R GetFloatv 0 Polygon offset units 14.6.5
Polygon offset enable for POINT
POLYGON OFFSET POINT B IsEnabled FALSE 14.6.5
mode rasterization
Polygon offset enable for LINE
POLYGON OFFSET LINE B IsEnabled FALSE 14.6.5
mode rasterization
Polygon offset enable for FILL
POLYGON OFFSET FILL B IsEnabled FALSE 14.6.5
mode rasterization593
Table 23.11: Multisampling
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
MULTISAMPLE B IsEnabled TRUE Multisample rasterization 14.3.1
SAMPLE ALPHA TO COVERAGE B IsEnabled FALSE Modify coverage from alpha 17.3.1
SAMPLE ALPHA TO ONE B IsEnabled FALSE Set alpha to max 17.3.1
SAMPLE COVERAGE B IsEnabled FALSE Mask to modify coverage 14.9.3
+
Coverage mask value
SAMPLE COVERAGE VALUE R GetFloatv 1 14.9.3
SAMPLE COVERAGE INVERT B GetBooleanv FALSE Invert coverage mask value 14.9.3
SAMPLE SHADING B IsEnabled FALSE Sample shading enable 14.9.3
Fraction of multisamples to use for
+
MIN SAMPLE SHADING VALUE R GetFloatv 0 14.3.1.1
sample shading
SAMPLE MASK B IsEnabled FALSE Additional sample mask 14.9.3
+
SAMPLE MASK VALUE nZ GetIntegeri v All bits of all words set Additional sample mask value 14.9.3594
Table 23.12: Textures (state per texture unit)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Texture object bound to
+
TEXTURE BINDING xD 803Z GetIntegerv 0 8.1
TEXTURE_xD
Texture object bound to
+
TEXTURE BINDING 1D ARRAY 80Z GetIntegerv 0 8.1
TEXTURE_1D_ARRAY
Texture object bound to
+
TEXTURE BINDING 2D ARRAY 80Z GetIntegerv 0 8.1
TEXTURE_2D_ARRAY
Texture object bound
+
TEXTURE BINDING CUBE MAP ARRAY to TEXTURE_CUBE_-
80Z GetIntegerv 0 8.1
MAP_ARRAY
Texture object bound
+
TEXTURE BINDING RECTANGLE 80Z GetIntegerv 0 to TEXTURE_- 8.1
RECTANGLE
Texture object bound to
+
TEXTURE BINDING BUFFER 80Z GetIntegerv 0 8.1
TEXTURE_BUFFER
Texture object bound to
+
TEXTURE BINDING CUBE MAP 80Z GetIntegerv 0 8.1
TEXTURE_CUBE_MAP
Texture object bound
+
TEXTURE BINDING 2D MULTISAMPLE 80Z GetIntegerv 0 to TEXTURE_2D_- 8.22
MULTISAMPLE
Texture object bound
TEXTURE BINDING 2D MULTISAMPLE - to TEXTURE_2D_-
+
80Z GetIntegerv 0 8.22
ARRAY MULTISAMPLE_-
ARRAY595
Table 23.13: Textures (state per texture unit) (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Sampler object bound to
+
SAMPLER BINDING 80Z GetIntegerv 0 8.2
active texture unit
xD texture image at l.o.d.
TEXTURE xD 03I GetTexImage See ch. 8 8
i
TEXTURE 1D ARRAY 0I GetTexImage See ch. 8 1D texture image at rowi 8
2D texture image at slice
TEXTURE 2D ARRAY 0I GetTexImage See ch. 8 8
i
Cube map array texture
TEXTURE CUBE MAP ARRAY 0I GetTexImage See ch. 8 8
image at l.o.d.i
Rectangle texture image
TEXTURE RECTANGLE 0I GetTexImage See ch. 8 8
at l.o.d. zero
+x face cube map tex-
TEXTURE CUBE MAP POSITIVE X 0I GetTexImage See sec. 8.5 8.5
ture image at l.o.d.i
 x face cube map tex-
TEXTURE CUBE MAP NEGATIVE X 0I GetTexImage See sec. 8.5 8.5
ture image at l.o.d.i
+y face cube map texture
TEXTURE CUBE MAP POSITIVE Y 0I GetTexImage See sec. 8.5 8.5
image at l.o.d.i
 y face cube map texture
TEXTURE CUBE MAP NEGATIVE Y 0I GetTexImage See sec. 8.5 8.5
image at l.o.d.i
+z face cube map texture
TEXTURE CUBE MAP POSITIVE Z 0I GetTexImage See sec. 8.5 8.5
image at l.o.d.i
 z face cube map texture
TEXTURE CUBE MAP NEGATIVE Z
0I GetTexImage See sec. 8.5 8.5
image at l.o.d.i596
Table 23.14: Textures (state per texture object)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
TEXTURE SWIZZLE R E GetTexParameteriv RED Red component swizzle 8.10
Green component swiz-
TEXTURE SWIZZLE G E GetTexParameteriv GREEN 8.10
zle
TEXTURE SWIZZLE B E GetTexParameteriv BLUE Blue component swizzle 8.10
Alpha component swiz-
TEXTURE SWIZZLE A E GetTexParameteriv ALPHA 8.10
zle
TEXTURE BORDER COLOR C GetTexParameterfv 0.0,0.0,0.0,0.0 Border color 8
TEXTURE MIN FILTER E GetTexParameteriv See sec. 8.22 Minification function 8.14
TEXTURE MAG FILTER E GetTexParameteriv LINEAR Magnification function 8.15
TEXTURE WRAP S Texcoords wrap mode
E GetTexParameteriv See sec. 8.22 8.14.2
Texcoord t wrap mode
TEXTURE WRAP T E GetTexParameteriv See sec. 8.22 (2D, 3D, cube map tex- 8.14.2
tures only)
Texcoord r wrap mode
TEXTURE WRAP R E GetTexParameteriv See sec. 8.22 8.14.2
(3D textures only)
TEXTURE TARGET E GetTextureParameteriv NONE Target of texture object 8.11
TEXTURE MIN LOD R GetTexParameterfv -1000 Min level-of-detail 8
TEXTURE MAX LOD Max. level-of-detail
R GetTexParameterfv 1000 8
+
TEXTURE BASE LEVEL Z GetTexParameterfv 0 Base texture array 8
+
TEXTURE MAX LEVEL Z GetTexParameterfv 1000 Max. texture array level 8
Texture level-of-detail
TEXTURE LOD BIAS R GetTexParameterfv 0.0 8.14
bias (bias )
texobj597
Table 23.15: Textures (state per texture object) (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Depth stencil texture
DEPTH STENCIL TEXTURE MODE
E GetTexParameteriv DEPTH_COMPONENT 8.16
mode
TEXTURE COMPARE MODE E GetTexParameteriv NONE Comparison mode 8.23
TEXTURE COMPARE FUNC E GetTexParameteriv LEQUAL Comparison function 8.23
Compatibility rules for
IMAGE FORMAT COMPATIBILITY TYPE E GetTexParameteriv See sec. 8.26 texture use with image 8.26
units
Size and format im-
TEXTURE IMMUTABLE FORMAT B GetTexParameteriv FALSE 8.19
mutable
+
TEXTURE IMMUTABLE LEVELS Z GetTexParameteriv 0 Storage no. of levels 8.18
+
TEXTURE VIEW MIN LEVEL Z GetTexParameteriv 0 View base texture level 8.18
+
TEXTURE VIEW NUM LEVELS Z GetTexParameteriv 0 View no. of texture levels 8.18
+
TEXTURE VIEW MIN LAYER Z GetTexParameteriv 0 View min array layer 8.18
+
TEXTURE VIEW NUM LAYERS Z GetTexParameteriv 0 View no. of array layers 8.18
– Debug label
S GetObjectLabel empty 20.9
Maximum degree of
TEXTURE MAX ANISOTROPY R GetTexParameterfv 1.0 8.14
anisotropy598
Table 23.16: Textures (state per texture image)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
TEXTURE WIDTH Z GetTexLevelParameteriv 0 Speci?ed width 8
+
TEXTURE HEIGHT Z GetTexLevelParameteriv 0 Speci?ed height (2D/3D) 8
+
TEXTURE DEPTH Z GetTexLevelParameteriv 0 Speci?ed depth (3D) 8
+
TEXTURE SAMPLES Z GetTexLevelParameteriv 0 No. of samples per texel 8.8
Whether the image uses a
TEXTURE FIXED SAMPLE LOCATIONS B GetTexLevelParameteriv TRUE 8.8
?xed sample pattern
Internal format (see sec-
TEXTURE INTERNAL FORMAT E GetTexLevelParameteriv RGBA orR8 8
tion 8.22)
Component resolution (x
is RED, GREEN, BLUE,
+
TEXTURE x SIZE 6Z GetTexLevelParameteriv 0 8
ALPHA, DEPTH, or
STENCIL)
Shared exponent ?eld
+
TEXTURE SHARED SIZE Z GetTexLevelParameteriv 0 8
resolution
Component type (x is
TEXTURE x TYPE E GetTexLevelParameteriv NONE RED, GREEN, BLUE, 8.11
ALPHA, orDEPTH)599
Table 23.17: Textures (state per texture image) (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
True if image has a com-
TEXTURE COMPRESSED B GetTexLevelParameteriv FALSE 8.7
pressed internal format
Size (in ubytes) of
+
TEXTURE COMPRESSED IMAGE SIZE
Z GetTexLevelParameteriv 0 8.7
compressed image
Buffer object bound as
TEXTURE BUFFER DATA STORE BIND- the data store for the ac-
+
Z GetTexLevelParameteriv 0 8.1
ING tive image unit’s buffer
texture
Offset into buffer’s data
store used for the active
TEXTURE BUFFER OFFSET nZ GetTexLevelParameteriv 0 8.9
image unit’s buffer tex-
ture
Size of the buffer’s data
store used for the active
TEXTURE BUFFER SIZE nZ GetTexLevelParameteriv 0 8.9
image unit’s buffer tex-
ture600
Table 23.18: Textures (state per sampler object)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
TEXTURE BORDER COLOR C GetSamplerParameterfv 0.0,0.0,0.0,0.0 Border color 8
TEXTURE COMPARE FUNC E GetSamplerParameteriv LEQUAL Comparison function 8.23
TEXTURE COMPARE MODE E GetSamplerParameteriv NONE Comparison mode 8.23
Texture level-of-detail
TEXTURE LOD BIAS R GetSamplerParameterfv 0.0 8.14
bias (bias )
texobj
TEXTURE MAX LOD R GetSamplerParameterfv 1000 Max. level-of-detail 8
TEXTURE MAG FILTER E GetSamplerParameteriv LINEAR Magnification function 8.15
TEXTURE MIN FILTER E GetSamplerParameteriv NEAREST_MIPMAP_LINEAR Minification function 8.14
TEXTURE MIN LOD R GetSamplerParameterfv -1000 Min level-of-detail 8
Maximum degree of
TEXTURE MAX ANISOTROPY R GetSamplerParameterfv 1.0 8.14
anisotropy
TEXTURE WRAP S E GetSamplerParameteriv REPEAT Texcoords wrap mode 8.14.2
Texcoord t wrap mode
TEXTURE WRAP T (2D, 3D, cube map tex-
E GetSamplerParameteriv REPEAT 8.14.2
tures only)
Texcoord r wrap mode
TEXTURE WRAP R E GetSamplerParameteriv REPEAT 8.14.2
(3D textures only)
– S GetObjectLabel empty Debug label 20.9601
Table 23.19: Texture Environment and Generation
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
ACTIVE TEXTURE E GetIntegerv TEXTURE0 Active texture unit selector 10.2602
Table 23.20: Pixel Operations
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
SCISSOR TEST 16B IsEnabledi FALSE Scissoring enabled 14.9.2
SCISSOR BOX 164Z GetIntegeri v See sec. 14.9.2 Scissor box 14.9.2
STENCIL TEST B IsEnabled FALSE Stenciling enabled 17.3.3
Front stencil function
STENCIL FUNC E GetIntegerv ALWAYS 17.3.3
+
STENCIL VALUE MASK Z GetIntegerv See sec. 17.3.3 Front stencil mask 17.3.3
+
STENCIL REF Z GetIntegerv 0 Front stencil reference value 17.3.3
STENCIL FAIL E GetIntegerv KEEP Front stencil fail action 17.3.3
STENCIL PASS DEPTH FAIL E GetIntegerv KEEP Front stencil depth buffer fail action 17.3.3
Front stencil depth buffer pass ac-
STENCIL PASS DEPTH PASS E GetIntegerv KEEP 17.3.3
tion
STENCIL BACK FUNC E GetIntegerv ALWAYS Back stencil function 17.3.3
+
Back stencil mask
STENCIL BACK VALUE MASK Z GetIntegerv See sec. 17.3.3 17.3.3
+
STENCIL BACK REF Z GetIntegerv 0 Back stencil reference value 17.3.3
STENCIL BACK FAIL E GetIntegerv KEEP Back stencil fail action 17.3.3
STENCIL BACK PASS DEPTH FAIL E GetIntegerv KEEP Back stencil depth buffer fail action 17.3.3
STENCIL BACK PASS DEPTH PASS E GetIntegerv KEEP Back stencil depth buffer pass action 17.3.3
DEPTH TEST B IsEnabled FALSE Depth buffer enabled 17.3.4
DEPTH FUNC E GetIntegerv LESS Depth buffer test function 17.3.4603
Table 23.21: Pixel Operations (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Blending enabled for
BLEND 8B IsEnabledi FALSE 17.3.6
draw bufferi
Blending source RGB
BLEND SRC RGB 8E GetIntegeri v ONE 17.3.6
function for draw bufferi
Blending source A func-
BLEND SRC ALPHA 8E GetIntegeri v ONE 17.3.6
tion for draw bufferi
Blending dest. RGB
BLEND DST RGB 8E GetIntegeri v ZERO 17.3.6
function for draw bufferi
Blending dest. A func-
BLEND DST ALPHA 8E GetIntegeri v ZERO 17.3.6
tion for draw bufferi
RGB blending equation
BLEND EQUATION RGB 8E GetIntegeri v FUNC_ADD 17.3.6
for draw bufferi
Alpha blending equation
BLEND EQUATION ALPHA 8E GetIntegeri v FUNC_ADD 17.3.6
for draw bufferi
BLEND COLOR C GetFloatv 0.0,0.0,0.0,0.0 Constant blend color 17.3.6
sRGB update and blend-
FRAMEBUFFER SRGB B IsEnabled FALSE 17.3.6
ing enable
DITHER B IsEnabled TRUE Dithering enabled 17.3.8
COLOR LOGIC OP B IsEnabled FALSE Color logic op enabled 17.3.9
LOGIC OP MODE E GetIntegerv COPY Logic op function 17.3.9604
Table 23.22: Framebuffer Control
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Color write en-
COLOR WRITEMASK 84B GetBooleani v (TRUE,TRUE,TRUE,TRUE) ables (R,G,B,A) 17.4.2
for draw bufferi
Depth buffer en-
DEPTH WRITEMASK B GetBooleanv TRUE 17.4.2
abled for writing
Front stencil
+
STENCIL WRITEMASK Z GetIntegerv 1’s 17.4.2
buffer writemask
Back stencil
+
STENCIL BACK WRITEMASK Z GetIntegerv 1’s 17.4.2
buffer writemask
Color buffer clear
COLOR CLEAR VALUE C GetFloatv 0.0,0.0,0.0,0.0 17.4.3
value
Depth buffer clear
+
DEPTH CLEAR VALUE R GetFloatv 1 17.4.3
value
Stencil clear
+
STENCIL CLEAR VALUE Z GetIntegerv 0 17.4.3
value605
Table 23.23: Framebuffer (state per target binding point)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Framebuffer object bound to
+
DRAW FRAMEBUFFER BINDING Z GetIntegerv 0 9.2
DRAW_FRAMEBUFFER
Framebuffer object bound to
+
READ FRAMEBUFFER BINDING Z GetIntegerv 0 9.2
READ_FRAMEBUFFER606
Table 23.24: Framebuffer (state per framebuffer object)
y This state is queried from the currently bound read framebuffer.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Draw buffer selected for
DRAW BUFFERi 8E GetIntegerv See sec. 17.4.1 17.4.1
color outputi
READ BUFFER E GetIntegerv See sec. 18.2 Read source buffery 18.2
GetFramebuffer- Default width of frame-
+
FRAMEBUFFER DEFAULT WIDTH Z 0 9.2.1
Parameteriv buffer w/o attachments
GetFramebuffer- Default height of frame-
+
FRAMEBUFFER DEFAULT HEIGHT Z 0 9.2.1
Parameteriv buffer w/o attachments
Default layer count of
GetFramebuffer-
+
FRAMEBUFFER DEFAULT LAYERS Z 0 framebuffer w/o attach- 9.2.1
Parameteriv
ments
Default sample count of
GetFramebuffer-
+
FRAMEBUFFER DEFAULT SAMPLES Z 0 framebuffer w/o attach- 9.2.1
Parameteriv
ments
Default sample location
FRAMEBUFFER DEFAULT FIXED SAMPLE LOCA- GetFramebuffer-
B FALSE pattern of framebuffer 9.2.1
TIONS Parameteriv
w/o attachments
– S GetObjectLabel empty Debug label 20.9607
Table 23.25: Framebuffer (state per attachment point)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
GetFramebuffer- Type of image attached
FRAMEBUFFER ATTACHMENT OBJECT TYPE E Attachment- NONE to framebuffer attach- 9.2.2
Parameteriv ment point
GetFramebuffer- Name of object at-
+
FRAMEBUFFER ATTACHMENT OBJECT NAME Z Attachment- 0 tached to framebuffer 9.2.2
Parameteriv attachment point
GetFramebuffer- Mipmap level of texture
+
FRAMEBUFFER ATTACHMENT TEXTURE LEVEL Z Attachment- 0 image attached, if object 9.2.8
Parameteriv attached is texture
Cubemap face of texture
GetFramebuffer-
FRAMEBUFFER ATTACHMENT TEXTURE CUBE - image attached, if object
E Attachment- NONE 9.2.8
MAP FACE attached is cubemap tex-
Parameteriv
ture
GetFramebuffer- Layer of texture image
FRAMEBUFFER ATTACHMENT TEXTURE LAYER Z Attachment- 0 attached, if object at- 9.2.8
Parameteriv tached is 3D texture
GetFramebuffer-
Framebuffer attachment
FRAMEBUFFER ATTACHMENT LAYERED B Attachment- FALSE 9.8
is layered
Parameteriv
GetFramebuffer-
Encoding of components
FRAMEBUFFER ATTACHMENT COLOR ENCODING E Attachment- - 9.2.3
in the attached image
Parameteriv
GetFramebuffer-
Data type of components
FRAMEBUFFER ATTACHMENT COMPONENT TYPE E Attachment- - 9.2.3
in the attached image
Parameteriv
Size in bits of attached
GetFramebuffer- image’s x component; x
+
FRAMEBUFFER ATTACHMENT x SIZE Z Attachment- - is RED, GREEN, BLUE, 9.2.3
Parameteriv ALPHA, DEPTH, or
STENCIL608
Table 23.26: Renderbuffer (state per target and binding point)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Renderbuffer object bound to
RENDERBUFFER BINDING Z GetIntegerv 0 9.2.4
RENDERBUFFER609
Table 23.27: Renderbuffer (state per renderbuffer object)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
RENDERBUFFER WIDTH Z GetRenderbufferParameteriv 0 Width of renderbuffer 9.2.4
+
RENDERBUFFER HEIGHT Z GetRenderbufferParameteriv 0 Height of renderbuffer 9.2.4
RENDERBUFFER INTERNAL FORMAT E GetRenderbufferParameteriv RGBA Internal format of renderbuffer 9.2.4
Size in bits of renderbuffer image’s
+
RENDERBUFFER RED SIZE Z GetRenderbufferParameteriv 0 9.2.4
red component
Size in bits of renderbuffer image’s
+
RENDERBUFFER GREEN SIZE Z GetRenderbufferParameteriv 0 9.2.4
green component
Size in bits of renderbuffer image’s
+
RENDERBUFFER BLUE SIZE Z GetRenderbufferParameteriv 0 9.2.4
blue component
Size in bits of renderbuffer image’s
+
RENDERBUFFER ALPHA SIZE Z GetRenderbufferParameteriv 0 9.2.4
alpha component
Size in bits of renderbuffer image’s
+
RENDERBUFFER DEPTH SIZE Z GetRenderbufferParameteriv 0 9.2.4
depth component
Size in bits of renderbuffer image’s
+
RENDERBUFFER STENCIL SIZE Z GetRenderbufferParameteriv 0 9.2.4
stencil component
+
RENDERBUFFER SAMPLES Z GetRenderbufferParameteriv 0 No. of samples 9.2.4
Debug label
– S GetObjectLabel empty 20.9610
Table 23.28: Pixels
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
UNPACK SWAP BYTES B GetBooleanv FALSE Value ofUNPACK_SWAP_BYTES 8.4.1
UNPACK LSB FIRST B GetBooleanv FALSE Value ofUNPACK_LSB_FIRST 8.4.1
Value of UNPACK_IMAGE_-
+
UNPACK IMAGE HEIGHT Z GetIntegerv 0 8.4.1
HEIGHT
+
Value ofUNPACK_SKIP_IMAGES
UNPACK SKIP IMAGES Z GetIntegerv 0 8.4.1
+
UNPACK ROW LENGTH Z GetIntegerv 0 Value ofUNPACK_ROW_LENGTH 8.4.1
+
UNPACK SKIP ROWS Z GetIntegerv 0 Value ofUNPACK_SKIP_ROWS 8.4.1
+
UNPACK SKIP PIXELS Z GetIntegerv 0 Value ofUNPACK_SKIP_PIXELS 8.4.1
+
UNPACK ALIGNMENT Z GetIntegerv 4 Value ofUNPACK_ALIGNMENT 8.4.1
Value of UNPACK_-
+
UNPACK COMPRESSED BLOCK WIDTH Z GetIntegerv 0 8.4.1
COMPRESSED_BLOCK_WIDTH
Value of UNPACK_-
+
UNPACK COMPRESSED BLOCK HEIGHT Z GetIntegerv 0 8.4.1
COMPRESSED_BLOCK_HEIGHT
Value of UNPACK_-
+
UNPACK COMPRESSED BLOCK DEPTH Z GetIntegerv 0 8.4.1
COMPRESSED_BLOCK_DEPTH
Value of UNPACK_-
+
UNPACK COMPRESSED BLOCK SIZE Z GetIntegerv 0 8.4.1
COMPRESSED_BLOCK_SIZE
+
PIXEL UNPACK BUFFER BINDING Z GetIntegerv 0 Pixel unpack buffer binding 6.7611
Table 23.29: Pixels (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
PACK SWAP BYTES B GetBooleanv FALSE Value ofPACK_SWAP_BYTES 18.2
PACK LSB FIRST B GetBooleanv FALSE Value ofPACK_LSB_FIRST 18.2
+
PACK IMAGE HEIGHT Z GetIntegerv 0 Value ofPACK_IMAGE_HEIGHT 18.2
+
PACK SKIP IMAGES Z GetIntegerv 0 Value ofPACK_SKIP_IMAGES 18.2
+
PACK ROW LENGTH Z GetIntegerv 0 Value ofPACK_ROW_LENGTH 18.2
+
Value ofPACK_SKIP_ROWS
PACK SKIP ROWS Z GetIntegerv 0 18.2
+
PACK SKIP PIXELS Z GetIntegerv 0 Value ofPACK_SKIP_PIXELS 18.2
+
PACK ALIGNMENT Z GetIntegerv 4 Value ofPACK_ALIGNMENT 18.2
Value of PACK_COMPRESSED_-
+
PACK COMPRESSED BLOCK WIDTH Z GetIntegerv 0 18.2
BLOCK_WIDTH
Value of PACK_COMPRESSED_-
+
PACK COMPRESSED BLOCK HEIGHT Z GetIntegerv 0 18.2
BLOCK_HEIGHT
Value of PACK_COMPRESSED_-
+
PACK COMPRESSED BLOCK DEPTH Z GetIntegerv 0 18.2
BLOCK_DEPTH
Value of PACK_COMPRESSED_-
+
PACK COMPRESSED BLOCK SIZE Z GetIntegerv 0 18.2
BLOCK_SIZE
+
PIXEL PACK BUFFER BINDING Z GetIntegerv 0 Pixel pack buffer binding 18.2612
Table 23.30: Shader Object State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
SHADER TYPE E GetShaderiv - Type of shader (see table 7.1 7.1
DELETE STATUS B GetShaderiv FALSE Shader ?agged for deletion 7.1
COMPILE STATUS B GetShaderiv FALSE Last compile succeeded 7.1
– S GetShaderInfoLog Empty string Info log for shader objects 7.14
+
INFO LOG LENGTH Z GetShaderiv 0 Length of info log 7.14
– S GetShaderSource Empty string Source code for a shader 7.1
+
SHADER SOURCE LENGTH Z GetShaderiv 0 Length of source code 7.14
– S GetObjectLabel empty Debug label 20.9
Shader is associated with a SPIR-V
SPIR V BINARY B GetShaderiv FALSE 7.2
module.613
Table 23.31: Program Pipeline Object State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Program object updated
+
ACTIVE PROGRAM Z GetProgramPipelineiv 0 by Uniform* when PPO 7.4
bound
Name of current vertex
+
VERTEX SHADER Z GetProgramPipelineiv 0 7.4
shader program object
Name of current geom-
+
GEOMETRY SHADER Z GetProgramPipelineiv 0 etry shader program ob- 7.4
ject
Name of current frag-
+
FRAGMENT SHADER Z GetProgramPipelineiv 0 ment shader program ob- 7.4
ject
Name of current compute
+
COMPUTE SHADER Z GetProgramPipelineiv 0 7.4
shader program object
Name of current TCS
+
TESS CONTROL SHADER
Z GetProgramPipelineiv 0 7.4
program object
Name of current TES
+
TESS EVALUATION SHADER Z GetProgramPipelineiv 0 7.4
program object
Validate status of pro-
VALIDATE STATUS B GetProgramPipelineiv FALSE 7.4
gram pipeline object
Info log for program
– S GetProgramPiplineInfoLog empty 7.14
pipeline object
+
INFO LOG LENGTH Z GetProgramPipelineiv 0 Length of info log 7.4
– S GetObjectLabel empty Debug label 20.9614
Table 23.32: Program Object State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Name of current program
+
CURRENT PROGRAM Z GetIntegerv 0 7.3
object
Current program pipeline
+
PROGRAM PIPELINE BINDING Z GetIntegerv 0 7.4
object binding
Program object can
PROGRAM SEPARABLE B GetProgramiv FALSE be bound for separate 7.3
pipeline stages
DELETE STATUS B GetProgramiv FALSE Program object deleted 7.3
Last link attempt suc-
LINK STATUS B GetProgramiv FALSE 7.3
ceeded
Last validate attempt suc-
VALIDATE STATUS B GetProgramiv FALSE 7.3
ceeded
No. of attached shader
+
ATTACHED SHADERS Z GetProgramiv 0 7.14
objects
+
– 0Z GetAttachedShaders empty Shader objects attached 7.14
Info log for program ob-
– S GetProgramInfoLog empty 7.14
ject
+
INFO LOG LENGTH Z GetProgramiv 0 Length of info log 7.3
Length of program bi-
+
PROGRAM BINARY LENGTH Z GetProgramiv 0 7.5
nary
Retrievable binary hint
PROGRAM BINARY RETRIEVABLE HINT B GetProgramiv FALSE 7.5
enabled
Binary representation of
– 0BMU GetProgramBinary – 7.5
program
Local work size of a
+
COMPUTE WORK GROUP SIZE 3Z GetProgramiv f0;:::g 19
linked compute program
– S GetObjectLabel empty Debug label 20.9615
Table 23.33: Program Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
ACTIVE UNIFORMS Z GetProgramiv 0 No. of active uniforms 7.6
Location of active uni-
– 0Z GetUniformLocation – 7.14
forms
+
– 0Z GetActiveUniform – Size of active uniform 7.6
+
– Type of active uniform
0Z GetActiveUniform – 7.6
– 0char GetActiveUniform empty Name of active uniform 7.6
Max. active uniform
+
ACTIVE UNIFORM MAX LENGTH Z GetProgramiv 0 7.14
name length
–   GetUniform 0 Uniform value 7.6
+
ACTIVE ATTRIBUTES Z GetProgramiv 0 No. of active attributes 11.1.1
Location of active
– 0Z GetAttribLocation – 11.1.1
generic attribute
+
– 0Z GetActiveAttrib – Size of active attribute 11.1.1
+
– 0Z GetActiveAttrib – Type of active attribute 11.1.1
– 0char GetActiveAttrib empty Name of active attribute 11.1.1
Max. active attribute
+
ACTIVE ATTRIBUTE MAX LENGTH Z GetProgramiv 0 7.14
name length616
Table 23.34: Program Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
GEOMETRY VERTICES OUT Z GetProgramiv 0 Max. no. of output vertices 11.3.4
GEOMETRY INPUT TYPE E GetProgramiv TRIANGLES Primitive input type 11.3.1
GEOMETRY OUTPUT TYPE E GetProgramiv TRIANGLE_STRIP Primitive output type 11.3.2
No. of times a geom.
GEOMETRY SHADER INVOCA-
+
GetProgramiv 1 shader should be executed
Z 11.3.4.2
TIONS
for each input primitive
TRANSFORM FEEDBACK BUFFER - INTERLEAVED_- Transform feedback mode
E GetProgramiv 7.14
MODE ATTRIBS for the program
TRANSFORM FEEDBACK VARY- No. of outputs to stream to
+
Z GetProgramiv 0 7.14
INGS buffer object(s)
Max. transform feed-
TRANSFORM FEEDBACK VARY-
+
Z GetProgramiv 0 back output variable name 7.14
ING MAX LENGTH
length
GetTransform- Size of each transform
+
– Z - 11.1.2.1
FeedbackVarying feedback output variable
GetTransform- Type of each transform
+
– Z - 11.1.2.1
FeedbackVarying feedback output variable
GetTransform- Name of each transform
+
– 0 char - 11.1.2.1
FeedbackVarying feedback output variable617
Table 23.35: Program Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
No. of active uniform
+
ACTIVE UNIFORM BLOCKS Z GetProgramiv 0 7.6.2
blocks in a program
ACTIVE UNIFORM BLOCK MAX - Length of longest active
+
Z GetProgramiv 0 7.6.2
NAME LENGTH uniform block name
UNIFORM TYPE 0E GetActiveUniformsiv - Type of active uniform 7.6.2
+
UNIFORM SIZE GetActiveUniformsiv - Size of active uniform
0Z 7.6.2
+
UNIFORM NAME LENGTH 0Z GetActiveUniformsiv - Uniform name length 7.6.2
UNIFORM BLOCK INDEX 0Z GetActiveUniformsiv - Uniform block index 7.6.2
UNIFORM OFFSET 0Z GetActiveUniformsiv - Uniform buffer offset 7.6.2618
Table 23.36: Program Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Uniform buffer array
UNIFORM ARRAY STRIDE 0Z GetActiveUniformsiv - 7.6.2
stride
Uniform buffer intra-
UNIFORM MATRIX STRIDE 0Z GetActiveUniformsiv - 7.6.2
matrix stride
Whether uniform is a
UNIFORM IS ROW MAJOR 0B GetActiveUniformsiv - 7.6.2
row-major matrix
Uniform buffer binding
GetActive-
+
UNIFORM BLOCK BINDING Z 0 point associated with the 7.6.2
UniformBlockiv
speci?ed uniform block
Size of the storage
GetActive-
+
UNIFORM BLOCK DATA SIZE Z - needed to hold this 7.6.2
UniformBlockiv
uniform block’s data
GetActive- Uniform block name
+
UNIFORM BLOCK NAME LENGTH Z - 7.6.2
UniformBlockiv length
Count of active uniforms
UNIFORM BLOCK ACTIVE UNI- GetActive-
+
Z - in the speci?ed uniform 7.6.2
FORMS UniformBlockiv
block
Array of active uniform
UNIFORM BLOCK ACTIVE UNI- GetActive-
+
nZ - indices of the speci?ed 7.6.2
FORM INDICES UniformBlockiv
uniform block
True if uniform block
UNIFORM BLOCK REFERENCED - GetActive-
B 0 is actively referenced by 7.6.2
BY VERTEX SHADER UniformBlockiv
the vertex stage
True if uniform block
UNIFORM BLOCK REFERENCED - GetActive-
B 0 is actively referenced by 7.6.2
BY TESS CONTROL SHADER UniformBlockiv
tess. control stage
True if uniform block
UNIFORM BLOCK REFERENCED - GetActive-
B 0 is actively referenced by 7.6.2
BY TESS EVALUTION SHADER UniformBlockiv
tess. evaluation stage619
Table 23.37: Program Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
True if uniform block
UNIFORM BLOCK REFERENCED - GetActive-
B 0 is actively referenced by 7.6.2
BY GEOMETRY SHADER UniformBlockiv
the geometry stage
True if uniform block
UNIFORM BLOCK REFERENCED - GetActive-
B 0 is actively referenced by 7.6.2
BY FRAGMENT SHADER UniformBlockiv
the fragment stage
True if uniform block is
UNIFORM BLOCK REFERENCED - GetActive-
B FALSE referenced by the com- 7.6.2
BY COMPUTE SHADER UniformBlockiv
pute stage
Output patch size for
+
TESS CONTROL OUTPUT VERTICES GetProgramiv 0
Z 11.2.1
tess. control shader
Base primitive type for
TESS GEN MODE E GetProgramiv QUADS 11.2.2
tess. prim. generator
Spacing of tess. prim.
TESS GEN SPACING E GetProgramiv EQUAL generator edge subdivi- 11.2.2
sion
Order of vertices in prim-
TESS GEN VERTEX ORDER E GetProgramiv CCW itives generated by tess. 11.2.2
primitive generator
Tess. prim. generator
TESS GEN POINT MODE B GetProgramiv FALSE 11.2.2
emits points?620
Table 23.38: Program Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
ACTIVE SUBROUTINE UNIFORM - No. of subroutine unif.
+
6Z GetProgramStageiv 0 7.10
LOCATIONS locations in the shader
No. of subroutine unif.
+
ACTIVE SUBROUTINE UNIFORMS 6Z GetProgramStageiv 0 7.10
variables in the shader
No. of subroutine func-
+
ACTIVE SUBROUTINES 6Z GetProgramStageiv 0 7.10
tions in the shader
ACTIVE SUBROUTINE UNIFORM - Max. subroutine uniform
+
6Z GetProgramStageiv 0 7.10
MAX LENGTH name length
ACTIVE SUBROUTINE MAX - Max. subroutine name
+
6Z GetProgramStageiv 0 7.10
LENGTH length
No. of subroutines com-
GetActive-
+
NUM COMPATIBLE SUBROUTINES 6 0Z - patible with a sub. uni- 7.10
SubroutineUniformiv
form
List of subroutines com-
GetActive-
+
COMPATIBLE SUBROUTINES 6 00Z - patible with a sub. uni- 7.10
SubroutineUniformiv
form
GetActive- No. of elements in sub.
+
UNIFORM SIZE 6 0Z - 7.10
SubroutineUniformiv uniform array
GetActive- Length of sub. uniform
+
UNIFORM NAME LENGTH -
6 0Z 7.10
SubroutineUniformiv name
GetActive-
– 6 0S Subroutine- - Sub. uniform name string 7.10
UniformName
GetActive- Length of subroutine
– 6 0S - 7.10
SubroutineName name
GetActive-
– 6 0S - Subroutine name string 7.10
SubroutineName621
Table 23.39: Program Object State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
No. of active atomic
ACTIVE ATOMIC COUNTER -
+
Z GetProgramiv 0 counter buffers (AACBs) 7.7
BUFFERS
used by a program
ATOMIC COUNTER BUFFER BIND- GetActiveAtomic- Binding point associated
+
nZ - 7.7
ING CounterBufferiv with an AACB
ATOMIC COUNTER BUFFER DATA - GetActiveAtomic- Min size required by an
+
nZ - 7.7
SIZE CounterBufferiv AACB
ATOMIC COUNTER BUFFER AC- GetActiveAtomic- No. of active atomic
+
nZ - 7.7
TIVE ATOMIC COUNTERS CounterBufferiv counters in an AACB
ATOMIC COUNTER BUFFER AC- GetActiveAtomic- List of active atomic
+
mnZ - 7.7
TIVE ATOMIC COUNTER INDICES CounterBufferiv counters in an AACB
ATOMIC COUNTER BUFFER REFER- GetActiveAtomic- AACB has a counter used
nB FALSE 7.7
ENCED BY VERTEX SHADER CounterBufferiv by vertex shaders
ATOMIC COUNTER BUFFER REF-
GetActiveAtomic- AACB has a counter used
ERENCED BY TESS CONTROL - nB FALSE 7.7
CounterBufferiv by tess. control shaders
SHADER
ATOMIC COUNTER BUFFER REF- AACB has a counter
GetActiveAtomic-
ERENCED BY TESS EVALUTION - nB FALSE used by tess. evaluation 7.7
CounterBufferiv
SHADER shaders
ATOMIC COUNTER BUFFER REFER- GetActiveAtomic- AACB has a counter used
nB FALSE 7.7
ENCED BY GEOMETRY SHADER CounterBufferiv by geometry shaders
ATOMIC COUNTER BUFFER REFER- GetActiveAtomic- AACB has a counter used
nB FALSE 7.7
ENCED BY FRAGMENT SHADER CounterBufferiv by fragment shaders
ATOMIC COUNTER BUFFER REFER- GetActiveAtomic- AACB has a counter used
B FALSE 7.7
ENCED BY COMPUTE SHADER CounterBufferiv by compute shaders
UNIFORM ATOMIC COUNTER - AACB associated with
+
nZ GetActiveUniformsiv - 7.7
BUFFER INDEX an active uniform622
Table 23.40: Program Interface State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
GetProgram- No. of active resources
+
ACTIVE RESOURCES nZ 0 7.3.1
Interfaceiv on an interface
GetProgram- Max. name length for ac-
+
MAX NAME LENGTH nZ 0 7.3.1
Interfaceiv tive resources
GetProgram- Max. no. of active vari-
+
MAX NUM ACTIVE VARIABLES nZ 0 7.3.1
Interfaceiv ables for active resources
Max. no. of compati-
MAX NUM COMPATIBLE SUBROU- GetProgram-
+
nZ 0 ble subroutines for sub- 7.3.1
TINES Interfaceiv
routine uniforms623
Table 23.41: Program Object Resource State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
GetProgram- List of active variables
+
ACTIVE VARIABLES Z - 7.3.1
Resourceiv owned by active resource
GetProgram- Active resource array
+
ARRAY SIZE Z - 7.3.1
Resourceiv size
GetProgram- Active resource array
+
ARRAY STRIDE Z - 7.3.1
Resourceiv stride in memory
GetProgram- Index of atomic counter
+
ATOMIC COUNTER BUFFER INDEX Z - 7.3.1
Resourceiv buffer owning resource
GetProgram- Index of interface block
+
BLOCK INDEX Z - 7.3.1
Resourceiv owning resource
GetProgram- Buffer binding assigned
+
BUFFER BINDING Z - 7.3.1
Resourceiv to active resource
GetProgram- Min. buffer data size re-
+
BUFFER DATA SIZE Z - 7.3.1
Resourceiv quired for resource
List of compatible sub-
GetProgram-
+
COMPATIBLE SUBROUTINES - routines for active sub-
Z 7.3.1
Resourceiv
routine uniform
GetProgram- Is active input/output a
+
IS PER PATCH Z - 7.3.1
Resourceiv per-patch attribute?
GetProgram- Active resource stored as
+
IS ROW MAJOR Z - 7.3.1
Resourceiv a row major matrix?
GetProgram- Location assigned to ac-
+
LOCATION Z - 7.3.1
Resourceiv tive resource
GetProgram- Location component as-
+
LOCATION COMPONENT Z - 7.3.1
Resourceiv signed to active resources
GetProgram- Location index assigned
+
LOCATION INDEX Z - 7.3.1
Resourceiv to active resource
GetProgram- Active resource matrix
+
MATRIX STRIDE Z - 7.3.1
Resourceiv stride in memory624
Table 23.42: Program Object Resource State (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
GetProgram- Length of active resource
+
NAME LENGTH Z - 7.3.1
Resourceiv name
GetProgram- No. of active variables
+
NUM ACTIVE VARIABLES Z - 7.3.1
Resourceiv owned by active resource
No. of compatible sub-
GetProgram-
+
NUM COMPATIBLE SUBROUTINES Z - routines for active sub- 7.3.1
Resourceiv
routine uniform
GetProgram- Active resource offset in
+
OFFSET Z - 7.3.1
Resourceiv memory
GetProgram- Active resource used by
+
REFERENCED BY VERTEX SHADER Z - 7.3.1
Resourceiv vertex shader?
REFERENCED BY TESS CONTROL - GetProgram- Active resource used by
+
Z - 7.3.1
SHADER Resourceiv tess. control shader?
REFERENCED BY TESS EVALUA- GetProgram- Active resource used by
+
Z - 7.3.1
TION SHADER Resourceiv tess. evaluation shader?
REFERENCED BY GEOMETRY - GetProgram- Active resource used by
+
-
Z 7.3.1
SHADER Resourceiv geometry shader?
REFERENCED BY FRAGMENT - GetProgram- Active resource used by
+
Z - 7.3.1
SHADER Resourceiv fragment shader?
REFERENCED BY COMPUTE - GetProgram- Active resource used by
+
Z - 7.3.1
SHADER Resourceiv compute shader?
Array size of top level
GetProgram-
+
TOP LEVEL ARRAY SIZE Z - shd. storage block mem- 7.3.1
Resourceiv
ber
Array stride of top level
GetProgram-
+
TOP LEVEL ARRAY STRIDE Z - shd. storage block mem- 7.3.1
Resourceiv
ber
GetProgram-
+
TYPE Z - Active resource data type 7.3.1
Resourceiv625
Table 23.43: Vertex and Geometry Shader State(not part of program
objects)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Current generic vertex attribute val-
4
CURRENT VERTEX ATTRIB 16R GetVertexAttribfv 0.0,0.0,0.0,1.0 10.2
ues
PROGRAM POINT SIZE B IsEnabled FALSE Point size mode 14.4626
Table 23.44: Query Object State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
QUERY RESULT Z GetQueryObjectuiv 0 orFALSE Query object result 4.2.3
QUERY RESULT AVAILABLE B GetQueryObjectiv TRUE Is the query object result available? 4.2.3
– S GetObjectLabel empty Debug label 20.9
QUERY TARGET E GetQueryObjectiv NONE Target of query object 4.2627
Table 23.45: Image State (state per image unit)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get
Initial
Get value Type Command Value Description Sec.
+
IMAGE BINDING NAME 8Z GetIntegeri v 0 Name of bound texture object 8.26
+
IMAGE BINDING LEVEL 8Z GetIntegeri v 0 Level of bound texture object 8.26
Texture object bound with multiple
IMAGE BINDING LAYERED 8B GetBooleani v FALSE 8.26
layers
Layer of bound texture, if not lay-
+
IMAGE BINDING LAYER 8Z GetIntegeri v 0 8.26
ered
Read and/or write access for bound
IMAGE BINDING ACCESS 8E GetIntegeri v READ_ONLY 8.26
texture
Format used for accesses to bound
+
IMAGE BINDING FORMAT 8Z GetIntegeri v R8 8.26
texture628
Table 23.46: Atomic Counter Buffer Binding State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Current value of generic
+
ATOMIC COUNTER BUFFER BINDING Z GetIntegerv 0 atomic counter buffer bind- 6.8
ing
Buffer object bound to
+
ATOMIC COUNTER BUFFER BINDING nZ GetIntegeri v 0 each atomic counter buffer 6.8
binding point
Start offset of binding
+
ATOMIC COUNTER BUFFER START nZ GetInteger64i v 0 range for each atomic 6.8
counter buffer
Size of binding range for
+
ATOMIC COUNTER BUFFER SIZE nZ GetInteger64i v 0 6.8
each atomic counter buffer629
Table 23.47: Shader Storage Buffer Binding State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Current value of generic
+
SHADER STORAGE BUFFER BINDING Z GetIntegerv 0 shader storage buffer bind- 7.8
ing
Buffer object bound to
+
SHADER STORAGE BUFFER BINDING nZ GetIntegeri v 0 each shader storage buffer 7.8
binding point
Start offset of binding
+
SHADER STORAGE BUFFER START nZ GetInteger64i v 0 range for each shader 7.8
storage buffer
Size of binding range for
+
SHADER STORAGE BUFFER SIZE nZ GetInteger64i v 0 7.8
each shader storage buffer630
Table 23.48: Transform Feedback Object State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Buffer object bound to
+
TRANSFORM FEEDBACK BUFFER BINDING nZ GetIntegeri v 0 each transform feedback 6.7
attribute stream
Start offset of binding
+
TRANSFORM FEEDBACK BUFFER START nZ GetInteger64i v 0 range for each transform 6.7
feedback attrib. stream
Size of binding range for
+
TRANSFORM FEEDBACK BUFFER SIZE nZ GetInteger64i v 0 each transform feedback 6.7
attrib. stream
Is transform feedback
TRANSFORM FEEDBACK PAUSED B GetBooleanv FALSE 6.7
paused on this object?
Is transform feedback ac-
TRANSFORM FEEDBACK ACTIVE B GetBooleanv FALSE 6.7
tive on this object?
– S GetObjectLabel empty Debug label 20.9631
Table 23.49: Uniform Buffer Binding State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
Uniform buffer object
+
UNIFORM BUFFER BINDING Z GetIntegerv 0 bound to the context for 7.6.2
buffer object manipulation
Uniform buffer object
+
bound to the speci?ed
UNIFORM BUFFER BINDING nZ GetIntegeri v 0 7.6.2
context binding point
Start of bound uniform
+
UNIFORM BUFFER START nZ GetInteger64i v 0 6.7
buffer region
Size of bound uniform
+
UNIFORM BUFFER SIZE nZ GetInteger64i v 0 6.7
buffer region632
Table 23.50: Sync Object State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
OBJECT TYPE E GetSynciv SYNC_FENCE Type of sync object 4.1
SYNC STATUS E GetSynciv UNSIGNALED Sync object status 4.1
SYNC CONDITION E GetSynciv SYNC_GPU_COMMANDS_COMPLETE Sync object condition 4.1
+
SYNC FLAGS Z GetSynciv 0 Sync object ?ags 4.1
– S GetObjectPtrLabel empty Debug label 20.9633
Table 23.51: Hints
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
LINE SMOOTH HINT E GetIntegerv DONT_CARE Line smooth hint 21.5
Polygon smooth hint
POLYGON SMOOTH HINT E GetIntegerv DONT_CARE 21.5
TEXTURE COMPRESSION HINT E GetIntegerv DONT_CARE Texture compression quality hint 21.5
Fragment shader derivative accu-
FRAGMENT SHADER DERIVATIVE HINT E GetIntegerv DONT_CARE 21.5
racy hint634
Table 23.52: Compute Dispatch State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
+
DISPATCH INDIRECT BUFFER BINDING Z GetIntegerv 0 Indirect dispatch buffer binding 19635
Table 23.53: Implementation Dependent Values
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Flush behavior when context is re-
CONTEXT RELEASE BEHAVIOR E GetIntegerv See sec. 22.2 22.2
leased
+
MAX CLIP DISTANCES Z GetIntegerv 8 Max. no. of user clipping planes 13.7
+
MAX CULL DISTANCES Z GetIntegerv 8 Max. no. of user culling planes 13.7
+
Max. combined no. of user clipping
MAX COMBINED CLIP AND CULL DISTANCES Z GetIntegerv 8 13.7
No. of bits of subpixel precision in
+
SUBPIXEL BITS Z GetIntegerv 4 14
screenx andy
w w
+ 32
MAX ELEMENT INDEX Z GetInteger64v 2   1 Max. element index 10.4
Primitive restart support for
PRIMITIVE RESTART FOR PATCHES SUPPORTED B GetBooleanv – 10.3.6
PATCHES
+
MAX 3D TEXTURE SIZE Z GetIntegerv 2048 Max. 3D texture image dimension 8.5
Max. 2D/1D texture image dimen-
+
MAX TEXTURE SIZE Z GetIntegerv 16384 8.5
sion
+
MAX ARRAY TEXTURE LAYERS Z GetIntegerv 2048 Max. no. of layers for texture arrays 8.5
Max. absolute texture level-of-
+
MAX TEXTURE LOD BIAS R GetFloatv 2.0 8.14
detail bias
Max. cube map texture image di-
+
MAX CUBE MAP TEXTURE SIZE Z GetIntegerv 16384 8.5
mension
Max. width and height of render-
+
MAX RENDERBUFFER SIZE Z GetIntegerv 16384 9.2.4
buffers
Limit of maximum degree of
MAX TEXTURE MAX ANISOTROPY R GetFloatv 16.0 8.14
anisotropy636
Table 23.54: Implementation Dependent Values (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
+
MAX VIEWPORT DIMS 2Z GetFloatv See sec. 13.8.1 Max. viewport dimensions 13.8.1
Max. no. of active view-
+
MAX VIEWPORTS Z GetIntegerv 16 13.8.1
ports
No. of bits of sub-
+
VIEWPORT SUBPIXEL BITS Z GetIntegerv 0 pixel precision for view- 13.8.1
port bounds
Viewport bounds range
VIEWPORT BOUNDS RANGE 2R GetFloatv y [min;max] y (at least 13.8.1
[ 32768; 32767])
Vertex convention fol-
LAYER PROVOKING VERTEX E GetIntegerv See sec. 11.3.4 11.3.4
lowed bygl_Layer
Vertex convention
VIEWPORT INDEX PROVOKING VERTEX E GetIntegerv See sec. 11.3.4 followed by gl_- 11.3.4
ViewportIndex
Range (lo to hi) of point
+
POINT SIZE RANGE 2R GetFloatv 1,1 14.4
sprite sizes
Point sprite size granular-
+
POINT SIZE GRANULARITY R GetFloatv – 14.4
ity
Range (lo to hi) of aliased
+
ALIASED LINE WIDTH RANGE 2R GetFloatv 1,1 14.5
line widths
Range (lo to hi) of an-
+
SMOOTH LINE WIDTH RANGE 2R GetFloatv 1,1 14.5
tialiased line widths
Antialiased line width
+
SMOOTH LINE WIDTH GRANULARITY GetFloatv
R – 14.5
granularity
Recommended max no. of
+
MAX ELEMENTS INDICES Z GetIntegerv – DrawRangeElements in- 10.3
dices
Recommended max no. of
+
MAX ELEMENTS VERTICES Z GetIntegerv – DrawRangeElements ver- 10.3
tices637
Table 23.55: Implementation Dependent Values (cont.)
y The value ofTEXTURE_BUFFER_OFFSET_ALIGNMENT is the maximum allowed,
not the minimum.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Max. offset added to ver-
MAX VERTEX ATTRIB RELATIVE OFFSET Z GetIntegerv 2047 10.3
tex buffer binding offset
Max. no. of vertex
MAX VERTEX ATTRIB BINDINGS Z GetIntegerv 16 10.3
16
buffers
Max. vertex attribute
MAX VERTEX ATTRIB STRIDE Z GetIntegerv 2048 10.3
stride
No. of compressed tex-
+
NUM COMPRESSED TEXTURE FORMATS Z GetIntegerv 18 8.7
ture formats
Enumerated compressed
+
COMPRESSED TEXTURE FORMATS 18Z GetIntegerv - 8.7
texture formats
No. of addressable texels
+
MAX TEXTURE BUFFER SIZE Z GetIntegerv 65536 8.9
for buffer textures
Max. width & height of
+
MAX RECTANGLE TEXTURE SIZE Z GetIntegerv 16384 8.5
rectangle textures
No. of program binary
+
NUM PROGRAM BINARY FORMATS Z GetIntegerv 0 7.5
formats
Enumerated program bi-
+
PROGRAM BINARY FORMATS 0Z GetIntegerv N/A 7.5
nary formats
No. of shader binary for-
+
NUM SHADER BINARY FORMATS Z GetIntegerv 0 7.2
mats
Enumerated shader bi-
+
SHADER BINARY FORMATS GetIntegerv
0Z - 7.2
nary formats
Shader compiler sup-
SHADER COMPILER B GetBooleanv TRUE 7
ported
Min byte alignment of
+
MIN MAP BUFFER ALIGNMENT Z GetIntegerv 64 pointers returned by 6.3
Map*Buffer
Min. required alignment
+
TEXTURE BUFFER OFFSET ALIGNMENT Z GetIntegerv 256y 8.9
for texture buffer offsets638
Table 23.56: Implementation Dependent Version and Extension Support
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Major version no. sup-
+
MAJOR VERSION GetIntegerv
Z – 22.2
ported
Minor version no. sup-
+
MINOR VERSION Z GetIntegerv – 22.2
ported
Context full/forward-
+
CONTEXT FLAGS Z GetIntegerv – 22.2
compatible ?ag
+
CONTEXT PROFILE MASK Z GetIntegerv – Context pro?le mask 22.2
Supported individual ex-
EXTENSIONS nS GetStringi – 22.2
tension names
No. of individual exten-
+
NUM EXTENSIONS Z GetIntegerv 0 22.2
sion names
RENDERER GetString Renderer string
S – 22.2
Latest Shading Language
SHADING LANGUAGE VERSION S GetString – 22.2
version supported
Supported Shading Lan-
SHADING LANGUAGE VERSION nS GetStringi – 22.2
guage versions
No. of supported Shad-
+
NUM SHADING LANGUAGE VERSIONS Z GetIntegerv 3 22.2
ing Language versions
Supported SPIR-V ex-
SPIR V EXTENSIONS nS GetStringi - 22.2
tension names
No. of supported SPIR-V
+
NUM SPIR V EXTENSIONS Z GetIntegerv 0 22.2
extension names
VENDOR GetString Vendor string
S – 22.2
OpenGL version sup-
VERSION S GetString – 22.2
ported639
Table 23.57: Implementation Dependent Vertex Shader Limits
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
No. of active vertex at-
+
MAX VERTEX ATTRIBS Z GetIntegerv 16 10.2
tributes
No. of components
+
MAX VERTEX UNIFORM COMPONENTS Z GetIntegerv 1024 for vertex shader uniform 7.6
variables
No. of vectors for vertex
+
MAX VERTEX UNIFORM VECTORS Z GetIntegerv 256 7.6
shader uniform variables
Max. no. of vertex uni-
+
MAX VERTEX UNIFORM BLOCKS GetIntegerv
Z 14 7.6.2
form buffers per program
Max. no. of components
+
MAX VERTEX OUTPUT COMPONENTS Z GetIntegerv 64 of outputs written by a 11.1.2.1
vertex shader
No. of texture image
+
MAX VERTEX TEXTURE IMAGE UNITS Z GetIntegerv 16 units accessible by a ver- 11.1.3.5
tex shader
No. of atomic counter
+
MAX VERTEX ATOMIC COUNTER BUFFERS Z GetIntegerv 0 buffers accessed by a ver- 7.7
tex shader
No. of atomic coun-
+
MAX VERTEX ATOMIC COUNTERS Z GetIntegerv 0 ters accessed by a vertex 11.1.3.6
shader
No. of shader storage
+
MAX VERTEX SHADER STORAGE BLOCKS Z GetIntegerv 0 blocks accessed by a ver- 7.8
tex shader640
Table 23.58: Implementation Dependent Tessellation Shader Limits
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Max. level supported by
+
MAX TESS GEN LEVEL Z GetIntegerv 64 11.2.2
tess. primitive generator
+
MAX PATCH VERTICES Z GetIntegerv 32 Max. patch size 10.1
No. of words for tess.
+
MAX TESS CONTROL UNIFORM COMPONENTS Z GetIntegerv 1024 control shader (TCS) 11.2.1.1
uniforms
No. of tex. image units
+
MAX TESS CONTROL TEXTURE IMAGE UNITS Z GetIntegerv 16 11.1.3
for TCS
No. components for TCS
+
MAX TESS CONTROL OUTPUT COMPONENTS Z GetIntegerv 128 11.2.1.2
per-vertex outputs
No. components for TCS
+
MAX TESS PATCH COMPONENTS Z GetIntegerv 120 11.2.1.2
per-patch outputs
MAX TESS CONTROL TOTAL OUTPUT COMPO- Total no. components for
+
Z GetIntegerv 4096 11.2.1.2
NENTS TCS outputs
No. components for TCS
+
MAX TESS CONTROL INPUT COMPONENTS Z GetIntegerv 128 11.2.1.2
per-vertex inputs
No. of supported uni-
+
MAX TESS CONTROL UNIFORM BLOCKS Z GetIntegerv 14 7.6.2
form blocks for TCS
No. of atomic counter
+
MAX TESS CONTROL ATOMIC COUNTER BUFFERS Z GetIntegerv 0 (AC) buffers accessed by 7.7
a TCS
No. of ACs accessed by
+
MAX TESS CONTROL ATOMIC COUNTERS Z GetIntegerv 0 7.7
a TCS
No. of shader storage
+
MAX TESS CONTROL SHADER STORAGE BLOCKS Z GetIntegerv 0 blocks accessed by a tess. 7.8
control shader641
Table 23.59: Implementation Dependent Tessellation Shader Limits (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
No. of words for tess.
+
MAX TESS EVALUATION UNIFORM COMPONENTS Z GetIntegerv 1024 evaluation shader (TES) 11.2.3.1
uniforms
No. of tex. image units
+
MAX TESS EVALUATION TEXTURE IMAGE UNITS Z GetIntegerv 16 11.1.3
for TES
No. components for TES
+
MAX TESS EVALUATION OUTPUT COMPONENTS Z GetIntegerv 128 11.2.3.2
per-vertex outputs
No. components for TES
+
MAX TESS EVALUATION INPUT COMPONENTS Z GetIntegerv 128 11.2.3.2
per-vertex inputs
No. of supported uni-
+
MAX TESS EVALUATION UNIFORM BLOCKS Z GetIntegerv 14 7.6.2
form blocks for TES
MAX TESS EVALUATION ATOMIC COUNTER - No. of AC buffers ac-
+
Z GetIntegerv 0 11.1.3.6
BUFFERS cessed by a TES
No. of ACs accessed by
+
MAX TESS EVALUATION ATOMIC COUNTERS GetIntegerv
Z 0 11.1.3.6
a TES
No. of shader storage
MAX TESS EVALUATION SHADER STORAGE -
+
Z GetIntegerv 0 blocks accessed by a tess. 7.8
BLOCKS
evaluation shader642
Table 23.60: Implementation Dependent Geometry Shader Limits
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
No. of components
+
MAX GEOMETRY UNIFORM COMPONENTS Z GetIntegerv 1024 for geometry shader (GS) 11.3.3
uniform variables
Max. no. of GS uniform
+
MAX GEOMETRY UNIFORM BLOCKS Z GetIntegerv 14 7.6.2
buffers per program
Max. no. of components
+
MAX GEOMETRY INPUT COMPONENTS Z GetIntegerv 64 11.3.4.4
of inputs read by a GS
Max. no. of components
+
MAX GEOMETRY OUTPUT COMPONENTS Z GetIntegerv 128 of outputs written by a 11.3.4.5
GS
Max. no. of vertices that
+
MAX GEOMETRY OUTPUT VERTICES GetIntegerv
Z 256 11.3.4
any GS can emit
Max. no. of total compo-
nents (all vertices) of ac-
+
MAX GEOMETRY TOTAL OUTPUT COMPONENTS Z GetIntegerv 1024 11.3.4
tive outputs that a GS can
emit
No. of texture image
+
MAX GEOMETRY TEXTURE IMAGE UNITS Z GetIntegerv 16 11.3.4
units accessible by a GS
Max. supported GS invo-
+
MAX GEOMETRY SHADER INVOCATIONS Z GetIntegerv 32 11.3.4.2
cation count
Total no. of vertex
+
MAX VERTEX STREAMS Z GetIntegerv 4 11.3.4.2
streams
No. of atomic counter
+
MAX GEOMETRY ATOMIC COUNTER BUFFERS Z GetIntegerv 0 7.7
buffers accessed by a GS
No. of atomic counters
+
MAX GEOMETRY ATOMIC COUNTERS Z GetIntegerv 0 11.1.3.6
accessed by a GS
No. of shader storage
+
MAX GEOMETRY SHADER STORAGE BLOCKS Z GetIntegerv 0 7.8
blocks accessed by a GS643
Table 23.61: Implementation Dependent Fragment Shader Limits
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
No. of components
+
MAX FRAGMENT UNIFORM COMPONENTS Z GetIntegerv 1024 for fragment shader (FS) 15.1
uniform variables
No. of vectors for FS uni-
+
MAX FRAGMENT UNIFORM VECTORS Z GetIntegerv 256 15.1
form variables
Max. no. of FS uniform
+
MAX FRAGMENT UNIFORM BLOCKS Z GetIntegerv 14 7.6.2
buffers per program
Max. no. of components
+
MAX FRAGMENT INPUT COMPONENTS Z GetIntegerv 128 15.2.2
of inputs read by a FS
No. of texture image
+
MAX TEXTURE IMAGE UNITS GetIntegerv
Z 16 11.1.3.5
units accessible by a FS
Min texel offset for
MIN PROGRAM TEXTURE GATHER OFFSET Z GetIntegerv -8 8.14.1
textureGather
Max. texel offset for
+
MAX PROGRAM TEXTURE GATHER OFFSET Z GetIntegerv 7 8.14.1
textureGather
No. of atomic counter
+
MAX FRAGMENT ATOMIC COUNTER BUFFERS GetIntegerv
Z 1 7.7
buffers accessed by a FS
No. of atomic counters
+
MAX FRAGMENT ATOMIC COUNTERS Z GetIntegerv 8 11.1.3.6
accessed by a FS
No. of shader storage
+
MAX FRAGMENT SHADER STORAGE BLOCKS Z GetIntegerv 8 7.8
blocks accessed by a FS644
Table 23.62: Implementation Dependent Compute Shader Limits
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Max. no. of workgroups
(WG) that may be dis-
+
MAX COMPUTE WORK GROUP COUNT 3Z GetIntegeri v 65535 patched by a single dis- 19
patch command (per di-
mension)
Max. local size of a com-
+
MAX COMPUTE WORK GROUP SIZE 3Z GetIntegeri v 1024 (x, y), 64 (z) 19
pute WG (per dimension)
Max. total compute
+
MAX COMPUTE WORK GROUP INVOCATIONS Z GetIntegerv 1024 shader (CS) invocations 19
in a single local WG
Max. no. of uniform
+
MAX COMPUTE UNIFORM BLOCKS Z GetIntegerv 14 blocks per compute pro- 7.6.2
gram
Max. no. of texture im-
+
MAX COMPUTE TEXTURE IMAGE UNITS Z GetIntegerv 16 age units accessible by a 11.1.3.5
CS
No. of atomic counter
+
MAX COMPUTE ATOMIC COUNTER BUFFERS Z GetIntegerv 8 7.7
buffers accessed by a CS
No. of atomic counters
+
MAX COMPUTE ATOMIC COUNTERS Z GetIntegerv 8 11.1.3.6
accessed by a CS
Max. total storage size of
all variables declared as
+
MAX COMPUTE SHARED MEMORY SIZE Z GetIntegerv 32768 shared in all CSs linked 19.1
into a single program ob-
ject
No. of components for
+
MAX COMPUTE UNIFORM COMPONENTS GetIntegerv
Z 1024 19.1
CS uniform variables
No. of image variables in
+
MAX COMPUTE IMAGE UNIFORMS Z GetIntegerv 8 11.1.3
compute shaders
No. of words for com-
pute shader uniform
MAX COMBINED COMPUTE UNIFORM COMPO-
+
Z GetIntegerv * variables in all uniform 19.1
NENTS
blocks, including the
default
No. of shader stor-
+
MAX COMPUTE SHADER STORAGE BLOCKS Z GetIntegerv 8 age blocks accessed by a 7.8
compute shader645
Table 23.63: Implementation Dependent Aggregate Shader Limits
y The value ofUNIFORM_BUFFER_OFFSET_ALIGNMENT is the maximum allowed,
not the minimum.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get
Minimum
Get value Type Command Value Description Sec.
MIN PROGRAM TEXEL OFFSET Z GetIntegerv -8 Min texel offset allowed in lookup 11.1.3.5
MAX PROGRAM TEXEL OFFSET Z GetIntegerv 7 Max. texel offset allowed in lookup 11.1.3.5
Max. no. of uniform buffer binding
+
MAX UNIFORM BUFFER BINDINGS Z GetIntegerv 84 7.6.2
points on the context
Max. size in basic machine units of
+
MAX UNIFORM BLOCK SIZE Z GetIntegerv 16384 7.6.2
a uniform block
Min. required alignment for uni-
+
UNIFORM BUFFER OFFSET ALIGNMENT Z GetIntegerv 256y 7.6.2
form buffer sizes and offsets
Max. no. of uniform buffers per
+
MAX COMBINED UNIFORM BLOCKS Z GetIntegerv 70 7.6.2
program
No. of components for output vari-
+
MAX VARYING COMPONENTS Z GetIntegerv 60 11.1.2.1
ables
+
MAX VARYING VECTORS Z GetIntegerv 15 No. of vectors for output variables 11.1.2.1
Total no. of texture units accessible
+
MAX COMBINED TEXTURE IMAGE UNITS Z GetIntegerv 80 11.1.3.5
by the GL
Max. no. of subroutines per shader
+
MAX SUBROUTINES Z GetIntegerv 256 7.10
stage
Max. no. of subroutine uniform lo-
+
MAX SUBROUTINE UNIFORM LOCATIONS Z GetIntegerv 1024 7.10
cations per stage
Max. no. of user-assignable uni-
+
MAX UNIFORM LOCATIONS Z GetIntegerv 1024 7.6
form locations646
Table 23.64: Implementation Dependent Aggregate Shader Limits (cont.)
y The value ofSHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT is the maximum
allowed, not the minimum.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Max. no. of atomic counter buffer
+
MAX ATOMIC COUNTER BUFFER BINDINGS Z GetIntegerv 1 6.8
bindings
Max. size in basic machine units of
+
MAX ATOMIC COUNTER BUFFER SIZE Z GetIntegerv 32 7.7
an atomic counter buffer
Max. no. of atomic counter buffers
+
MAX COMBINED ATOMIC COUNTER BUFFERS Z GetIntegerv 1 7.7
per program
Max. no. of atomic counter uni-
+
MAX COMBINED ATOMIC COUNTERS Z GetIntegerv 8 11.1.3.6
forms per program
Max. no. of shader storage buffer
+
MAX SHADER STORAGE BUFFER BINDINGS Z GetIntegerv 8 7.8
bindings in the context
Max. size in basic machine units of
+ 27
MAX SHADER STORAGE BLOCK SIZE Z GetInteger64v 2 7.8
a shader storage block
No. of shader storage blocks ac-
+
MAX COMBINED SHADER STORAGE BLOCKS Z GetIntegerv 8 7.8
cessed by a program
Min. required alignment for shader
+
SHADER STORAGE BUFFER OFFSET ALIGNMENT Z GetIntegerv 256y 7.8
storage buffer binding offsets647
Table 23.65: Implementation Dependent Aggregate Shader Limits (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
No. of units for image
+
MAX IMAGE UNITS Z GetIntegerv 8 8.26
load/store/atom
Limit on active image
units + shader storage
+
MAX COMBINED SHADER OUTPUT RESOURCES Z GetIntegerv 8 8.26
blocks + fragment out-
puts
Max. allowed samples
+
MAX IMAGE SAMPLES Z GetIntegerv 0 for a texture level bound 8.26
to an image unit
No. of image variables in
+
MAX VERTEX IMAGE UNIFORMS Z GetIntegerv 0 11.1.3.7
vertex shaders
No. of image variables in
+
MAX TESS CONTROL IMAGE UNIFORMS Z GetIntegerv 0 11.1.3.7
tess. control shaders
No. of image variables in
+
MAX TESS EVALUATION IMAGE UNIFORMS Z GetIntegerv 0 11.1.3.7
tess. eval. shaders
No. of image variables in
+
MAX GEOMETRY IMAGE UNIFORMS Z GetIntegerv 0 11.1.3.7
geometry shaders
No. of image variables in
+
MAX FRAGMENT IMAGE UNIFORMS Z GetIntegerv 8 11.1.3.7
fragment shaders
No. of image variables in
+
MAX COMBINED IMAGE UNIFORMS Z GetIntegerv 8 11.1.3.7
all shaders648
Table 23.66: Implementation Dependent Aggregate Shader Limits (cont.)
y The minimum value for each stage isMAX_stage_UNIFORM_BLOCKS
MAX_UNIFORM_BLOCK_SIZE / 4 +MAX_stage_UNIFORM_COMPONENTS
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
No. of words for vertex
MAX COMBINED VERTEX UNIFORM COMPO- shader uniform variables
+
Z GetIntegerv y 7.6.2
NENTS in all uniform blocks (in-
cluding default)
No. of words for ge-
ometry shader uniform
MAX COMBINED GEOMETRY UNIFORM COMPO-
+
GetIntegerv variables in all uni-
Z y 7.6.2
NENTS
form blocks (including
default)
No. of words for TCS
MAX COMBINED TESS CONTROL UNIFORM COM- uniform variables in all
+
Z GetIntegerv y 11.2.1.1
PONENTS uniform blocks (includ-
ing default)
No. of words for TES
MAX COMBINED TESS EVALUATION UNIFORM - uniform variables in all
+
Z GetIntegerv y 11.2.3.1
COMPONENTS uniform blocks (includ-
ing default)
No. of words for frag-
ment shader uniform
MAX COMBINED FRAGMENT UNIFORM COMPO-
+
Z GetIntegerv y variables in all uni- 7.6.2
NENTS
form blocks (including
default)649
Table 23.67: Debug Output State
y The initial value ofDEBUG_OUTPUT is TRUE in a debug context andFALSE
in a non-debug context.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
The current debug output
DEBUG CALLBACK FUNCTION Y GetPointerv NULL 20.2
callback function pointer
The current debug output
DEBUG CALLBACK USER PARAM Y GetPointerv NULL 20.2
callback user parameter
The no. of messages cur-
+
DEBUG LOGGED MESSAGES GetIntegerv 0 rently in the debug mes-
Z 20.3
sage log
The string length of the
DEBUG NEXT LOGGED MESSAGE -
+
Z GetIntegerv 0 oldest debug message in 20.3
LENGTH
the debug message log
The enabled state for
DEBUG OUTPUT SYNCHRONOUS B IsEnabled FALSE synchronous debug mes- 20.8
sage callbacks
Debug group stack
+
DEBUG GROUP STACK DEPTH Z GetIntegerv 1 20.6
pointer
Depends
The enabled state for de-
DEBUG OUTPUT B IsEnabled on the 20
bug output functionality
contexty650
Table 23.68: Implementation Dependent Debug Output State
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
The max length of a de-
bug message string, in-
+
MAX DEBUG MESSAGE LENGTH Z GetIntegerv 1 20.1
cluding its null termina-
tor
The max no. of messages
+
MAX DEBUG LOGGED MESSAGES Z GetIntegerv 1 stored in the debug mes- 20.3
sage log
+
MAX DEBUG GROUP STACK DEPTH Z GetIntegerv 64 Max. group stack depth 20.6
Max. length of a label
+
MAX LABEL LENGTH Z GetIntegerv 256 20.7
string651
Table 23.69: Implementation Dependent Values (cont.)
y These queries return the maximum no. of samples for all internal formats required to
support multisampled rendering.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Max. width for frame-
+
MAX FRAMEBUFFER WIDTH Z GetIntegerv 16384 9.2.1
buffer object
Max. height for frame-
+
MAX FRAMEBUFFER HEIGHT Z GetIntegerv 16384 9.2.1
buffer object
Max. layer count for lay-
+
MAX FRAMEBUFFER LAYERS Z GetIntegerv 2048 9.2.1
ered framebuffer object
Max. sample count for
+
MAX FRAMEBUFFER SAMPLES Z GetIntegerv 4 9.2.1
framebuffer object
Max. no. of sample mask
+
MAX SAMPLE MASK WORDS Z GetIntegerv 1 14.9.3
words
Max. no. of sam-
+
MAX SAMPLES Z GetIntegerv 4 ples supported for 9.2.4
multisamplingy
Max. no. of samples
supported for all color
+
MAX COLOR TEXTURE SAMPLES Z GetIntegerv 1 22.3
formats in a multisample
texturey
Max. no. of sam-
ples supported for all
+
MAX DEPTH TEXTURE SAMPLES Z GetIntegerv 1 22.3
depth/stencil formats in a
multisample texturey
Max. no. of samples sup-
+
MAX INTEGER SAMPLES Z GetIntegerv 1 ported for all integer for- 22.3
mat multisample buffersy
Asynchronous query
+
QUERY COUNTER BITS nZ GetQueryiv See sec. 4.2.3 4.2.3
counter bits
Max. WaitSync timeout
+
MAX SERVER WAIT TIMEOUT Z GetInteger64v 0 4.1.1
interval652
Table 23.70: Implementation Dependent Values (cont.)
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Furthest negative offset
MIN FRAGMENT INTERPOLATION OFFSET R GetFloatv -0.5 for interpolate- 15.1
AtOffset
Furthest positive offset
MAX FRAGMENT INTERPOLATION OFFSET R GetFloatv +0.5 for interpolate- 15.1
AtOffset
Subpixel bits for
+
FRAGMENT INTERPOLATION OFFSET BITS Z GetIntegerv 4 interpolate- 15.1
AtOffset
Max. no. of active draw
+
MAX DRAW BUFFERS Z GetIntegerv 8 17.4.1
buffers
Max. no. of active draw
+
MAX DUAL SOURCE DRAW BUFFERS Z GetIntegerv 1 buffers when using dual- 17.3.6
source blending
Max. no. of FBO at-
+
MAX COLOR ATTACHMENTS Z GetIntegerv 8 tachment points for color 9.2.7
buffers653
Table 23.71: Internal Format Dependent Values
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Supported sample counts
+
SAMPLES 0Z GetInternalformativ y 22.3
y See section 22.3
No. of supported sample
+
NUM SAMPLE COUNTS Z GetInternalformativ 1 22.3
counts654
Table 23.72: Implementation Dependent Transform Feedback Limits
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
Max. no. of components
MAX TRANSFORM FEEDBACK INTERLEAVED -
+
Z GetIntegerv 64 to write to a single buffer 13.3
COMPONENTS
in interleaved mode
Max. no. of separate
attributes or outputs that
+
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS Z GetIntegerv 4 13.3
can be captured in trans-
form feedback
Max. no. of components
MAX TRANSFORM FEEDBACK SEPARATE COMPO-
+
Z GetIntegerv 4 per attribute or output in 13.3
NENTS
separate mode
Max. no. of buffer objs
+
MAX TRANSFORM FEEDBACK BUFFERS Z GetIntegerv 4 to write with transform 13.3
feedback655
Table 23.73: Framebuffer Dependent Values
y Unlike most framebuffer-dependent state, which is queried from the currently bound
draw framebuffer, this state is queried from the currently bound read framebuffer.n is the
value ofSAMPLES.
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Minimum
Get value Type Command Value Description Sec.
True if front & back
DOUBLEBUFFER GetBooleanv
B – 17.4.1
buffers exist
True if left & right
STEREO B GetBooleanv – 22
buffers exist
No. of multisample
SAMPLE BUFFERS Z GetIntegerv 0 14.3.1
2
buffers
+
SAMPLES Z GetIntegerv 0 Coverage mask size 14.3.1
[0;1]
SAMPLE POSITION n 2R GetMultisamplefv – Explicit sample positions 14.3.1
Implementation pre-
IMPLEMENTATION COLOR READ FORMAT E GetIntegerv y 18.2.2
ferred pixel format
Implementation pre-
IMPLEMENTATION COLOR READ TYPE E GetIntegerv y 18.2.2
ferred pixel type656
Table 23.74: Miscellaneous
OpenGL 4.6 (Core Pro?le) - February 2, 2019
Get Initial
Get value Type Command Value Description Sec.
– nE GetError 0 Current error code(s) 2.3.1
True if there is a corresponding error
– nB – FALSE 2.3.1
+
CURRENT QUERY nZ GetQueryiv 0 Active query object names 4.2.3
+
QUERY BUFFER BINDING Z GetIntegeriv 0 Query result buffer binding 4.2.3
Buffer object bound to copy buffer
+
COPY READ BUFFER BINDING Z GetIntegerv 0 6.6
“read” bind point
Buffer object bound to copy buffer
+
COPY WRITE BUFFER BINDING Z GetIntegerv 0 6.6
“write” bind point
Reset noti?cation behavior
RESET NOTIFICATION STRATEGY Z GetIntegerv See sec. 2.3.2 2.3.2
2
Buffer object bound to generic tex-
+
TEXTURE BUFFER BINDING Z GetIntegerv 0 8.1
ture buffer bind point
TEXTURE CUBE MAP SEAMLESS B IsEnabled FALSE Seamless cube map ?ltering enable 8.13Appendix A
Invariance
The OpenGL speci?cation is not pixel exact. It therefore does not guarantee an ex-
act match between images produced by different GL implementations. However,
the speci?cation does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
vide justi?cation for those cases that require exact matches.
A.1 Repeatability
The obvious and most fundamental case is repeated issuance of a series of GL com-
mands. For any given GL and framebuffer state vector, and for any GL command,
the resulting GL and framebuffer state must be identical whenever the command is
executed on that initial GL and framebuffer state. This repeatability requirement
doesn’t apply when using shaders containing side effects (image and buffer vari-
able stores and atomic operations, and atomic counter operations), because these
memory operations are not guaranteed to be processed in a de?ned order.
One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatability is testability.
Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirable to ensure useful operation.
657A.2. MULTI-PASSALGORITHMS 658
A.2 Multi-pass Algorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:
 “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
ferent color or using the XOR logical operation.
 Using stencil operations to compute capping planes.
On the other hand, invariance rules can greatly increase the complexity of high-
performance implementations of the GL. Even the weak repeatability requirement
signi?cantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
to be identical, something that may be very dif?cult to achieve (for example, if the
hardware does ?oating-point operations with different precision than the software).
What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.
A.3 Invariance Rules
For a given instantiation of an OpenGL rendering context:
Rule 1 For any given GL and framebuffer state vector, and for any given GL com-
mand, the resulting GL and framebuffer state must be identical each time the com-
mand is executed on that initial GL and framebuffer state.
Rule 2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):
Required:
 Framebuffer contents (all bitplanes)
 The color buffers enabled for writing
 Scissor parameters (other than enable)
OpenGL 4.6 (Core Pro?le) - February 2, 2019A.3. INVARIANCERULES 659
 Writemasks (color, depth, stencil)
 Clear values (color, depth, stencil)
Strongly suggested:
 Stencil parameters (other than enable)
 Depth test parameters (other than enable)
 Blend parameters (other than enable)
 Logical operation parameters (other than enable)
 Pixel storage state
 Polygon offset parameters (other than enables, and except as they affect
the depth values of fragments)
Corollary 1 Fragment generation is invariant with respect to the state values
marked with in Rule 2.
Rule 3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it.
Corollary 2 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.
Rule 4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ‘the same shader’ means a
program object that is populated with the same source strings, which are compiled
and then linked, possibly multiple times, and which program object is then executed
using the same GL state vector. Invariance is relaxed for shaders with side effects,
such as accessing atomic counters (see section A.5).
Rule 5 All fragment shaders that either conditionally or unconditionally assign
gl_FragCoord.z to gl_FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl_FragDepth actually is
done.
If a sequence of GL commands speci?es primitives to be rendered with shaders
containing side effects (image and buffer variable stores and atomic operations,
and atomic counter operations), invariance rules are relaxed. In particular, rule 1,
corollary 2, and rule 4 do not apply in the presence of shader side effects.
The following weaker versions of rules 1 and 4 apply to GL commands involv-
ing shader side effects:
OpenGL 4.6 (Core Pro?le) - February 2, 2019A.4. TESSELLATIONINVARIANCE 660
Rule 6 For any given GL and framebuffer state vector, and for any given GL com-
mand, the contents of any framebuffer state not directly or indirectly affected by
results of shader image or buffer variable stores or atomic operations, or atomic
counter operations must be identical each time the command is executed on that
initial GL and framebuffer state.
Rule 7 The same vertex or fragment shader will produce the same result when run
multiple times with the same input as long as:
 shader invocations do not use image atomic operations or atomic counters;
 no framebuffer memory is written to more than once by image stores, unless
all such stores write the same value; and
 no shader invocation, or other operation performed to process the sequence
of commands, reads memory written to by an image store.
When any sequence of GL commands triggers shader invocations that perform
image stores, atomic operations, or atomic counter operations, and subsequent GL
commands read the memory written by those shader invocations, these operations
must be explicitly synchronized. For more details, see section 7.13.
A.4 Tessellation Invariance
When using a program containing tessellation evaluation shaders, the ?xed-
function tessellation primitive generator consumes the input patch speci?ed by an
application and emits a new set of primitives. The following invariance rules are
intended to provide repeatability guarantees. Additionally, they are intended to al-
low an application with a carefully crafted tessellation evaluation shader to ensure
that the sets of triangles generated for two adjacent patches have identical vertices
along shared patch edges, avoiding “cracks” caused by minor differences in the
positions of vertices along shared edges.
Rule 1 When processing two patches with identical outer and inner tessellation
levels, the tessellation primitive generator will emit an identical set of point, line,
or triangle primitives as long as the active program used to process the patch prim-
itives has tessellation evaluation shaders specifying the same tessellation mode,
spacing, vertex order, and point mode input layout quali?ers. Two sets of primi-
tives are considered identical if and only if they contain the same number and type
of primitives and the generated tessellation coordinates for the vertex numberedm
of the primitive numberedn are identical for all values ofm andn.
OpenGL 4.6 (Core Pro?le) - February 2, 2019A.4. TESSELLATIONINVARIANCE 661
Rule 2 The set of vertices generated along the outer edge of the subdivided prim-
itive in triangle and quad tessellation, and the tessellation coordinates of each,
depends only on the corresponding outer tessellation level and the spacing input
layout quali?er in the tessellation evaluation shader of the active program.
Rule 3 The set of vertices generated when subdividing any outer primitive edge is
always symmetric. For triangle tessellation, if the subdivision generates a vertex
with tessellation coordinates of the form (0;x; 1 x), (x; 0; 1 x), or (x; 1 x; 0),
it will also generate a vertex with coordinates of exactly (0; 1 x;x), (1 x; 0;x),
or (1 x;x; 0), respectively. For quad tessellation, if the subdivision generates
a vertex with coordinates of (x; 0) or (0;x), it will also generate a vertex with
coordinates of exactly (1 x; 0) or (0; 1 x), respectively. For isoline tessellation,
if it generates vertices at (0;x) and (1;x) wherex is not zero, it will also generate
vertices at exactly (0; 1 x) and (1; 1 x), respectively.
Rule 4 The set of vertices generated when subdividing outer edges in triangular
and quad tessellation must be independent of the speci?c edge subdivided, given
identical outer tessellation levels and spacing. For example, if vertices at (x; 1 
x; 0) and (1 x;x; 0) are generated when subdividing thew = 0 edge in triangular
tessellation, vertices must be generated at (x; 0; 1 x) and (1 x; 0;x) when
subdividing an otherwise identicalv = 0 edge. For quad tessellation, if vertices
at (x; 0) and (1 x; 0) are generated when subdividing thev = 0 edge, vertices
must be generated at (0;x) and (0; 1 x) when subdividing an otherwise identical
u = 0 edge.
Rule 5 When processing two patches that are identical in all respects enumerated
in rule 1 except for vertex order, the set of triangles generated for triangle and
quad tessellation must be identical except for vertex and triangle order. For each
triangle n produced by processing the ?rst patch, there must be a triangle n
1 2
produced when processing the second patch each of whose vertices has the same
tessellation coordinates as one of the vertices inn .
1
Rule 6 When processing two patches that are identical in all respects enumerated
in rule 1 other than matching outer tessellation levels and/or vertex order, the set
of interior triangles generated for triangle and quad tessellation must be identical
in all respects except for vertex and triangle order. For each interior trianglen
1
produced by processing the ?rst patch, there must be a trianglen produced when
2
processing the second patch each of whose vertices has the same tessellation co-
ordinates as one of the vertices in n . A triangle produced by the tessellator is
1
considered an interior triangle if none of its vertices lie on an outer edge of the
subdivided primitive.
OpenGL 4.6 (Core Pro?le) - February 2, 2019A.5. ATOMICCOUNTERINVARIANCE 662
Rule 7 For quad and triangle tessellation, the set of triangles connecting an inner
and outer edge depends only on the inner and outer tessellation levels correspond-
ing to that edge and the spacing input layout quali?er.
Rule 8 The value of all de?ned components ofgl_TessCoord will be in the range
[0; 1]. Additionally, for any de?ned componentx ofgl_TessCoord, the results of
computing 1:0 x in a tessellation evaluation shader will be exact. Some ?oating-
point values in the range [0; 1] may fail to satisfy this property, but such values may
never be used as tessellation coordinate components.
A.5 Atomic Counter Invariance
When using a program containing atomic counters, the following invariance rules
are intended to provide repeatability guarantees but within certain constraints.
Rule 1 When a single shader type within a program accesses an atomic counter
with onlyatomicCounterIncrement, any individual shader invocation is guar-
anteed to get a unique value returned.
Corollary 1 Also holds true withatomicCounterDecrement.
Corollary 2 This does not hold true foratomicCounter.
Corollary 3 Repeatability is relaxed. While a unique value is returned to the
shader, even given the same initial state vector and buffer contents, it is not guar-
anteed that the same unique value will be returned for each individual invocation
of a shader (for example, on any single vertex, or any single fragment). It is wholly
the shader writer’s responsibility to respect this constraint.
Rule 2 When two or more shader types within a program access an atomic counter
with only atomicCounterIncrement, there is no repeatability of the ordering
of operations between stages. For example, some number of vertices may be pro-
cessed, then some number of fragments may be processed.
Corollary 4 This also holds true with atomicCounterDecrement and
atomicCounter.
OpenGL 4.6 (Core Pro?le) - February 2, 2019A.6. WHATALLTHISMEANS 663
A.6 What All This Means
Hardware accelerated GL implementations are expected to default to software op-
eration when some GL state vectors are encountered. Even the weak repeatability
requirement means, for example, that OpenGL implementations cannot apply hys-
teresis to this swap, but must instead guarantee that a given mode vector implies
that a subsequent command always is executed in either the hardware or the soft-
ware machine.
The stronger invariance rules constrain when the switch from hardware to soft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled, but it should not be made when a change is made to the blending param-
eters.
Because ?oating-point values may be represented using different formats in
different renderers (hardware and software), many OpenGL state values may
change subtly when renderers are swapped. This is the type of state value change
that invariance rule 1 in section A.3 seeks to avoid.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix B
Corollaries
The following observations are derived from the body and the other appendixes of
the speci?cation. Absence of an observation from this list in no way impugns its
veracity.
1. The error semantics of upward compatible OpenGL revisions may change,
and features deprecated in a previous revision may be removed. Otherwise,
only additions can be made to upward compatible revisions.
2. GL query commands are not required to satisfy the semantics of the Flush
or the Finish commands. All that is required is that the queried state be con-
sistent with complete execution of all previously executed GL commands.
3. Application speci?ed point size and line width must be returned as speci?ed
when queried. Implementation-dependent clamping affects the values only
while they are in use.
4. The mask speci?ed as the third argument to StencilFunc affects the operands
of the stencil comparison function, but has no direct effect on the update of
the stencil buffer. The mask speci?ed by StencilMask has no effect on the
stencil comparison function; it limits the effect of the update of the stencil
buffer.
5. There is no atomicity requirement for OpenGL rendering commands, even
at the fragment level.
6. Because rasterization of non-antialiased polygons is point sampled, poly-
gons that have no area generate no fragments when they are rasterized in
FILL mode, and the fragments generated by the rasterization of “narrow”
polygons may not form a continuous array.
664665
7. OpenGL does not force left- or right-handedness on any of its coordinates
systems.
8. (No pixel dropouts or duplicates.) Let two polygons share an identical edge.
That is, there exist vertices A and B of an edge of one polygon, and vertices
C and D of an edge of the other polygon; the positions of vertex A and C are
identical; and the positions of vertex B and D are identical. Vertex positions
are identical if the gl_Position values output by the vertex (or if active,
geometry) shader are identical. Then, when the fragments produced by ras-
terization of both polygons are taken together, each fragment intersecting the
interior of the shared edge is produced exactly once.
9. Dithering algorithms may be different for different components. In particu-
lar, alpha may be dithered differently from red, green, or blue, and an imple-
mentation may choose to not dither alpha at all.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix C
The OpenGL SPIR-V Execution
Environment
C.1 Required Versions and Formats
Implementations must support the 1.0 version of SPIR-V and the 1.0 version of
the SPIR-V Extended Instructions for the OpenGL Shading Language (see sec-
tion 1.3.4).
A SPIR-V module passed into ShaderBinary is interpreted as a series of 32-
bit words in host endianness, with literal strings packed as described in section 2.2
of the SPIR-V Specification. The ?rst few words of the SPIR-V module must be
a magic number and a SPIR-V version number, as described in section 2.3 of the
SPIR-V Specification.
C.2 Valid SPIR-V Built-In Variable Decorations
Implementations must support the built-in variable decorations described in ta-
ble C.1:
C.3 Valid SPIR-V Capabilities
Implementations
must support the capability operands declared by OpCapability, described in
table C.2.
666C.4. VALIDATIONRULES 667
C.4 Validation Rules
In addition to what is allowed and disallowed above:
 Every entry point must have no return value and accept no arguments.
 TheLogical addressing model must be selected.
 Scope for execution must be limited to
– Workgroup
– Subgroup
 Scope for memory must be limited to
– Device
– Workgroup
– Invocation
 Storage Class must be limited to
– UniformConstant
– Input
– Uniform
– Output
– Workgroup
– Private
– Function
– AtomicCounter
– Image
 Images
– OpTypeImage must declare a scalar 32-bit ?oat or 32-bit integer type
for theSampled Type.
– OpSampledImage, OpImageQuerySizeLod,
and OpImageQueryLevels must only consume an Image operand
whose type has itsSampled operand set to 1.
– TheDepth operand ofOpTypeImage is ignored.
OpenGL 4.6 (Core Pro?le) - February 2, 2019C.4. VALIDATIONRULES 668
 AtomicCounter storage class
– Unless otherwise speci?ed, variables declared in theAtomicCounter
storage class must be unsigned 32-bit integers.
– When using the Atomic Instructions, the Memory Semantics
operand must be AtomicCounterMemory, without inclusion of
memory-ordering bits (implyingRelaxed semantics).
 Decorations
– The Flat, NoPerspective, Sample, and Centroid decorations
must not be used on variables with storage class other than Input or
on variables used in the interface of non-fragment shader entry points.
– ThePatch decoration must not be used on variables in the interface of
a vertex, geometry, or fragment shader stage’s entry point.
– OpTypeRuntimeArray must only be used for the last member of an
OpTypeStruct in the Uniform storage class, and be decorated as
BufferBlock
– If the Xfb Execution Mode is set, any output variable that is at least
partially captured:
 must be decorated with an XfbBuffer, declaring the capturing
buffer
 must have at least one captured output variable in the capturing
buffer decorated with an XfbStride (and all such XfbStride
values for the capturing buffer must be equal)
– If theXfb Execution Mode is set, any captured output:
 must be a non-structure decorated with Offset or a member of
a structure whose type member is decorated withOffset (not all
members of such a struct need be captured)
 must be a numerical type scalar, vector, matrix, or array of these
 must have anOffset that is a multiple of its ?rst component
 must have anOffset that is a multiple of 8 if any captured output
in the capturing buffer is a 64-bit type, in which case the corre-
spondingXfbStride must also be a multiple of 8
 must not overlap (i.e., alias in any capturing buffer) any other cap-
tured output
 must not have anOffset that causes over?ow of theXfbStride
 Compute Shaders
OpenGL 4.6 (Core Pro?le) - February 2, 2019C.5. PRECISIONANDOPERATIONOFSPIR-VINSTRUCTIONS 669
– For each compute shader entry point, either a LocalSize execution
mode or an object decorated with the WorkgroupSize decoration
must be speci?ed.
 Recursion
– For all entry points, the static function-call graph rooted at that entry
point must not contain cycles.
C.5 Precision and Operation of SPIR-V Instructions
The following rules apply to both single and double-precision ?oating point in-
structions:
 Positive and negative in?nities and positive and negative zeros are generated
as dictated by IEEE-754, but subject to the precisions allowed in the follow-
ing table.
 Dividing a non-zero by a zero results in the appropriately signed IEEE-754
Inf .
 Any denormalized value input into a shader or potentially generated by any
instruction in a shader may be ?ushed to 0.
 The rounding mode cannot be set and is unde?ned.
 NaN s are not required to be generated. Instructions that operate on a NaN
are not required to return a NaN as the result.
 Support for signaling NaN s is optional and exceptions are never raised.
The precision of double-precision instructions is at least that of single preci-
sion. For single precision (32 bit) instructions, precisions are required to be at least
as described in table C.3.
C.6 Precision of GLSL.std.450 Instructions
GLSL.std.450 extended instructions speci?cally de?ned in terms of the instructions
in table C.4 inherit the precisions described in that table. GLSL.std.450 extended
instructions not listed in, or de?ned in terms of those instructions have unde?ned
precision. These include, for example, the trigonometric functions and determi-
nant.
OpenGL 4.6 (Core Pro?le) - February 2, 2019C.6. PRECISIONOFGLSL.STD.450INSTRUCTIONS 670
For the OpSRem and OpSMod instructions, if either operand is negative the re-
sult is unde?ned.
OpenGL 4.6 (Core Pro?le) - February 2, 2019C.6. PRECISIONOFGLSL.STD.450INSTRUCTIONS 671
Built-in Variable Decoration
BaseInstance
BaseVertex
ClipDistance
CullDistance
DrawIndex
FragCoord
FragDepth
FrontFacing
GlobalInvocationId
HelperInvocation
InstanceId
InvocationId
Layer
LocalInvocationId
LocalInvocationIndex
NumWorkgroups
PatchVertices
PointCoord
PointSize
Position
PrimitiveId
SampleId
SampleMask
SamplePosition
TessCoord
TessLevelInner
TessLevelOuter
VertexId
ViewportIndex
WorkgroupId
WorkgroupSize
Table C.1: Built-in Variable Decorations
OpenGL 4.6 (Core Pro?le) - February 2, 2019C.6. PRECISIONOFGLSL.STD.450INSTRUCTIONS 672
OpCapability Operand
AtomicStorageOps
AtomicStorage
ClipDistance
CullDistance
DerivativeControl
DrawParameters
Float64
GeometryPointSize
GeometryStreams
Geometry
Image1D
ImageBuffer
ImageCubeArray
ImageGatherExtended
ImageMSArray
ImageQuery
ImageRect
InterpolationFunction
Matrix
MultiViewport
SampleRateShading
Sampled1D
SampledBuffer
SampledCubeArray
SampledImageArrayDynamicIndexing
SampledRect
Shader
StorageBufferArrayDynamicIndexing
StorageImageArrayDynamicIndexing
StorageImageExtendedFormats
StorageImageMultisample
StorageImageWriteWithoutFormat
SubgroupVoteKHR
TessellationPointSize
Tessellation
TransformFeedback
UniformBufferArrayDynamicIndexing
Table C.2: Valid SPIR-V Capabilities
OpenGL 4.6 (Core Pro?le) - February 2, 2019C.6. PRECISIONOFGLSL.STD.450INSTRUCTIONS 673
Instruction Precision
OpFAdd Correctly rounded
OpFSub Correctly rounded
OpFMul Correctly rounded
OpFOrdEqual,OpFUnordEqual Correct result
OpFOrdLessThan,OpFUnordLessThan Correct result
OpFOrdGreaterThan,OpFUnordGreaterThan Correct result
OpFOrdLessThanEqual,OpFUnordLessThanEqual Correct result
OpFOrdGreaterThanEqual,OpFUnordGreaterThanEqual Correct result
 126 126
OpFDiv 2.5 ULP forb in the range [2 ; 2 ]
conversions between types Correctly rounded
Table C.3: 32-Bit Precision
Instruction Precision
fma() Inherited fromOpFMul followed byOpFAdd.
exp(x),exp2(x) (3 + 2jxj) ULP
 21
log(),log2() 3 ULP outside the range [0:5; 2:0]; absolute error< 2 inside the range [0:5; 2:0]
pow(x,y) Inherited fromexp2(y log2(x))
*
sqrt() Inherited from 1.0 /inversesqrt()
inversesqrt() 2 ULP
Table C.4: GLSL.std.450 Precision
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix D
Compressed Texture Image
Formats
The compressed texture formats used by OpenGL are described in the speci?cally
identi?ed sections of the Khronos Data Format Specification, version 1.1, available
at URL
https://www.khronos.org/registry/dataformat/specs/1.1/dataformat.1.1.html
Unless otherwise described, the quantities encoded in these compressed for-
mats are treated as normalized, unsigned values.
Those formats listed as sRGB-encoded have in-memory representations ofR,
0 0 0
G and B components which are nonlinearly-encoded as R , G , and B ; any al-
0 0 0
pha component is unchanged. As part of ?ltering, the nonlinear R , G , and B
values are converted to linearR,G, andB components; any alpha component is
unchanged. The conversion between linear and nonlinear encoding is performed
as described in theKHR_DF_TRANSFER_SRGB section of the Khronos Data Format
Specification.
D.1 RGTC Compressed Texture Image Formats
RGTC formats are described in the “RGTC Compressed Texture Image Formats”
chapter of the Khronos Data Format Specification. The mapping between OpenGL
RGTC formats and that speci?cation is shown in table D.1.
674D.2. BPTCCOMPRESSEDTEXTUREIMAGEFORMATS 675
OpenGL format Data Format Specification
description
COMPRESSED_RED_RGTC1 BC4 unsigned
COMPRESSED_SIGNED_RED_RGTC1 BC4 signed
COMPRESSED_RG_RGTC2 BC5 unsigned
COMPRESSED_SIGNED_RG_RGTC2 BC5 signed
Table D.1: Mapping of OpenGL RGTC formats to descriptions.
OpenGL format Data Format Specification
description
COMPRESSED_RGBA_BPTC_UNORM BC7, linear encoding
COMPRESSED_SRGB_ALPHA_BPTC_UNORM BC7, sRGB encoding
COMPRESSED_RGB_BPTC_SIGNED_FLOAT BC6H, signed format
COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT BC6H, unsigned format
Table D.2: Mapping of OpenGL BPTC formats to descriptions.
D.2 BPTC Compressed Texture Image Formats
BPTC formats are described in the “BPTC2 Compressed Texture Image Formats”
chapter of the Khronos Data Format Specification. The mapping between OpenGL
BPTC formats and that speci?cation is shown in table D.2.
D.3 ETC Compressed Texture Image Formats
ETC formats are described in the “ETC2 Compressed Texture Image Formats”
chapter of the Khronos Data Format Specification. The mapping between OpenGL
ETC formats and that speci?cation is shown in table D.3.
OpenGL 4.6 (Core Pro?le) - February 2, 2019D.3. ETCCOMPRESSEDTEXTUREIMAGEFORMATS 676
OpenGL format Data Format Specification
description
COMPRESSED_R11_EAC Unsigned R11 EAC
COMPRESSED_SIGNED_R11_EAC Signed R11 EAC
COMPRESSED_RG11_EAC Unsigned RG11 EAC
COMPRESSED_SIGNED_RG11_EAC Signed RG11 EAC
COMPRESSED_RGB8_ETC2 RGB ETC2
COMPRESSED_SRGB8_ETC2 RGB ETC2 with sRGB encoding
COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGB ETC2 with punchthrough
alpha
COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGB ETC2 with punchthrough
alpha and sRGB encoding
COMPRESSED_RGBA8_ETC2_EAC RGBA ETC2
COMPRESSED_SRGB8_ALPHA8_ETC2_EAC RGBA ETC2 with sRGB encod-
ing
Table D.3: Mapping of OpenGL ETC formats to descriptions.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix E
Pro?les and the Deprecation
Model
OpenGL 3.0 introduced a deprecation model in which certain features are marked
as deprecated. Deprecated features are expected to be completely removed from a
future version of OpenGL. Deprecated features are summarized in section E.2.
To aid developers in writing applications which will run on such future ver-
sions, it is possible to create an OpenGL context which does not support depre-
cated features. Such a context is called a forward compatible context, while a
context supporting all OpenGL features is called a full context. Forward compat-
ible contexts cannot restore deprecated functionality through extensions, but they
may support additional, non-deprecated functionality through extensions.
Pro?les de?ne subsets of OpenGL functionality targeted to speci?c application
domains. Starting with OpenGL 3.2, two pro?les are de?ned (see below). Future
versions may de?ne additional pro?les addressing embedded systems or other do-
mains. OpenGL implementations are not required to support all de?ned pro?les,
but must support the core pro?le described below.
To enable application control of deprecation and pro?les, new context creation
APIs have been de?ned as extensions to GLX, WGL and EGL. These APIs allow
specifying a particular version, pro?le, and full or forward compatible status, and
will either create a context compatible with the request, or fail (if, for example,
requesting an OpenGL version or pro?le not supported by the implementation).
Only the ARB may de?ne OpenGL pro?les and deprecated features.
677E.1. COREANDCOMPATIBILITYPROFILES 678
E.1 Core and Compatibility Pro?les
The core pro?le of OpenGL de?nes essential functionality for the modern pro-
grammable shading model introduced in OpenGL 2.0, but does not include features
marked as removed for that version of the Specification (see section E.2).
The compatibility pro?le does not remove any functionality.
It is not possible to implement both core and compatibility pro?les in a single
GL context, since the core pro?le mandates functional restrictions not present in the
compatibility pro?le. Refer to the WGL_ARB_create_context_profile and
GLX_ARB_create_context_profile extensions (see appendix K.3.3.66) for
information on creating a context implementing a speci?c pro?le.
E.2 Deprecated and Removed Features
OpenGL 3.0 de?ned a set of deprecated features. OpenGL 3.1 removed most of the
deprecated features and moved them into the optional GL_ARB_compatibility
extension. The OpenGL 3.2 core pro?le removes the same features as OpenGL
3.1, while the optional compatibility pro?le supports all those features.
Deprecated and removed features are summarized below in two groups: fea-
tures which are marked deprecated by the core pro?le, but have not yet been re-
moved, and features actually removed from the core pro?le of the current version
of OpenGL (no features have been removed from or deprecated in the compatibility
pro?le).
Functions which have been removed will generate an INVALID_OPERATION
error if called in the core pro?le or in a forward-compatible context. Functions
which are partially removed (e.g. no longer accept some parameter values) will
generate the errors appropriate for any other unrecognized value of that parame-
ter when a removed parameter value is passed in the core pro?le or a forward-
compatible context. Functions which are deprecated but have not yet been removed
from the core pro?le continue to operate normally except in a forward-compatible
context, where they are also removed.
E.2.1 Deprecated But Still Supported Features
The following features are deprecated, but still present in the core pro?le. They
may be removed from a future version of OpenGL, and are removed in a forward-
compatible context implementing the core pro?le.
 Wide lines - LineWidth values greater than 1.0 will generate anINVALID_-
VALUE error.
OpenGL 4.6 (Core Pro?le) - February 2, 2019E.2. DEPRECATEDANDREMOVEDFEATURES 679
 Global component limit query - the implementation-dependent values
MAX_VARYING_COMPONENTS andMAX_VARYING_FLOATS.
 The query targets NUM_COMPRESSED_TEXTURE_FORMATS and
COMPRESSED_TEXTURE_FORMATS (see section 8.5).
 Bitmap pack/unpack state for bitmaps - the pixel pack parametersUNPACK_-
LSB_FIRST andPACK_LSB_FIRST.
E.2.2 Removed Features
 Application-generated object names - the names of all object types, such as
buffer, query, and texture objects, must be generated using the correspond-
ing Gen* commands. Trying to bind an object name not returned by a Gen*
command will result in anINVALID_OPERATION error. This behavior is al-
ready the case for framebuffer, renderbuffer, and vertex array objects. Object
types which have default objects (objects named zero), such as vertex ar-
ray, framebuffer, and texture objects, may also bind the default object, even
though it is not returned by Gen*.
 Color index mode - no color index visuals are supplied by the window
system-binding APIs such as GLX and WGL, so the default framebuffer
is always in RGBA mode. All language and state related to color index
mode vertex, rasterization, and fragment processing behavior is removed.
COLOR_INDEX formats are also deprecated.
 OpenGL Shading Language versions 1.10 and 1.20. These versions of the
shading language depend on many API features that have also been depre-
cated.
 Begin / End primitive speci?cation - Begin, End, and EdgeFlag*; Color*,
FogCoord*, Index*, Normal3*, SecondaryColor3*, TexCoord*, Ver-
tex*; and all associated state. Vertex arrays and array drawing commands
must be used to draw primitives. However, VertexAttrib* and the current
vertex attribute state are retained in order to provide default attribute values
for disabled attribute arrays.
 Edge ?ags and ?xed-function vertex processing - ColorPointer, EdgeFlag-
Pointer, FogCoordPointer, IndexPointer, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexPointer, EnableClientState, Dis-
ableClientState, and InterleavedArrays, ClientActiveTexture; Frus-
tum, LoadIdentity, LoadMatrix, LoadTransposeMatrix, MatrixMode,
OpenGL 4.6 (Core Pro?le) - February 2, 2019E.2. DEPRECATEDANDREMOVEDFEATURES 680
MultMatrix, MultTransposeMatrix, Ortho, PopMatrix, PushMatrix,
Rotate, Scale, and Translate; Enable/Disable targets RESCALE_NORMAL
and NORMALIZE; TexGen* and Enable/Disable targets TEXTURE_-
GEN_ , Material*, Light*, LightModel*, and ColorMaterial, Shade-
*
Model, and Enable/Disable targetsLIGHTING,VERTEX_PROGRAM_TWO_-
SIDE, LIGHTi, and COLOR_MATERIAL; ClipPlane; and all associated
?xed-function vertex array, multitexture, matrix and matrix stack, normal
and texture coordinate, lighting, and clipping state. A vertex shader must be
de?ned in order to draw primitives.
Language referring to edge ?ags in the current speci?cation is modi?ed as
though all edge ?ags areTRUE.
Note that the FrontFace and ClampColor commands are not deprecated,
as they still affect other non-deprecated functionality; however, the Clam-
pColor targetsCLAMP_VERTEX_COLOR andCLAMP_FRAGMENT_COLOR are
deprecated.
 Client vertex and index arrays - all vertex array attribute and element array
index pointers must refer to buffer objects. The default vertex array object
(the name zero) is also deprecated. Calling VertexAttribPointer when no
buffer object or no vertex array object is bound will generate anINVALID_-
OPERATION error, as will calling any array drawing command when no ver-
tex array object is bound.
 Rectangles - Rect*.
 Current raster position - RasterPos* and WindowPos*, and all associated
state.
 Two-sided color selection - Enable target VERTEX_PROGRAM_TWO_-
SIDE; OpenGL Shading Language built-ins gl_BackColor and gl_-
BackSecondaryColor; and all associated state.
 Non-sprite points - Enable/Disable targets POINT_SMOOTH and POINT_-
SPRITE, and all associated state. Point rasterization is always performed as
thoughPOINT_SPRITE were enabled.
 Wide lines and line stipple - LineWidth is not deprecated, but values greater
than 1.0 will generate an INVALID_VALUE error; LineStipple and En-
able/Disable target LINE_STIPPLE, and all associated state.
OpenGL 4.6 (Core Pro?le) - February 2, 2019E.2. DEPRECATEDANDREMOVEDFEATURES 681
 Quadrilateral and polygon primitives - vertex array drawing modes
POLYGON, QUADS, and QUAD_STRIP, related descriptions of rasterization
of non-triangle polygons, and all associated state.
 Separate polygon draw mode - PolygonMode face values of FRONT and
BACK; polygons are always drawn in the same mode, no matter which face
is being rasterized.
 Polygon Stipple - PolygonStipple and Enable/Disable target POLYGON_-
STIPPLE, and all associated state.
 Pixel transfer modes and operations - all pixel transfer modes, including
pixel maps, shift and bias, color table lookup, color matrix, and convolu-
tion commands and state, and all associated state and commands de?ning
that state.
 Pixel drawing - DrawPixels and PixelZoom. However, the language de-
scribing pixel rectangles in section 8.4 is retained as it is required for Tex-
Image* and ReadPixels.
 Bitmaps - Bitmap and theBITMAP external format.
 Legacy OpenGL 1.0 pixel formats - the values 1, 2, 3, and 4 are no longer
accepted as internal formats by TexImage* or any other command taking
an internal format argument. The initial internal format of a texel array is
RGBA instead of 1. TEXTURE_COMPONENTS is deprecated; always use
TEXTURE_INTERNAL_FORMAT.
 Legacy pixel formats - all ALPHA, LUMINANCE, LUMINANCE_ALPHA, and
INTENSITY external and internal formats, including compressed, ?oating-
point, and integer variants; all references to luminance and intensity formats
elsewhere in the speci?cation, including conversion to and from those for-
mats; and all associated state, including state describing the allocation or
format of luminance and intensity texture or framebuffer components.
 Depth texture mode - DEPTH_TEXTURE_MODE. Section 8.23.1 is to be
changed so thatr is returned to texture samplers directly, and the OpenGL
Shading Language 1.30 Specification is to be changed so that (r; 0; 0; 1) is
always returned from depth texture samplers in this case.
 Texture wrap mode CLAMP - CLAMP is no longer accepted as a value of
texture parameters TEXTURE_WRAP_S, TEXTURE_WRAP_T, or TEXTURE_-
WRAP_R.
OpenGL 4.6 (Core Pro?le) - February 2, 2019E.2. DEPRECATEDANDREMOVEDFEATURES 682
 Texture borders - the border value to TexImage* must always be zero, or an
INVALID_VALUE error is generated (section 8.5); all language in section 8
referring to nonzero border widths during texture image speci?cation and
texture sampling; and all associated state.
 Automatic mipmap generation - TexParameter* target GENERATE_-
MIPMAP, and all associated state.
 Fixed-function fragment processing - AreTexturesResident, Prioritize-
Textures, and TexParameter target TEXTURE_PRIORITY; TexEnv target
TEXTURE_ENV, and all associated parameters; TexEnv target TEXTURE_-
FILTER_CONTROL, and parameter nameTEXTURE_LOD_BIAS; Enable tar-
gets of all dimensionalities (TEXTURE_1D, TEXTURE_2D, TEXTURE_3D,
TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, and TEXTURE_CUBE_MAP);
Enable target COLOR_SUM; Enable target FOG, Fog, and all associated pa-
rameters; the implementation-dependent values MAX_TEXTURE_UNITS and
MAX_TEXTURE_COORDS; and all associated state.
 Alpha test - AlphaFunc and Enable/Disable target ALPHA_TEST, and all
associated state.
 Accumulation buffers - ClearAccum, andACCUM_BUFFER_BIT is not valid
as a bit in the argument to Clear (section 17.4.3); Accum; theACCUM_ _-
*
BITS framebuffer state describing the size of accumulation buffer compo-
nents; and all associated state.
Window system-binding APIs such as GLX and WGL may choose to either
not expose window con?gs containing accumulation buffers, or to ignore
accumulation buffers when the default framebuffer bound to a GL context
contains them.
 Pixel copying - CopyPixels (the comments also applying to CopyTexImage
will be moved to section 8.6).
 Auxiliary color buffers, includingAUXi targets of the default framebuffer.
 Context framebuffer size queries - RED_BITS, GREEN_BITS, BLUE_BITS,
ALPHA_BITS,DEPTH_BITS, andSTENCIL_BITS.
 Evaluators - Map*, EvalCoord*, MapGrid*, EvalMesh*, EvalPoint*, and
all evaluator map enables, and all associated state.
 Selection and feedback modes - RenderMode, InitNames, PopName,
PushName, LoadName, and SelectBuffer; FeedbackBuffer and
PassThrough; and all associated state.
OpenGL 4.6 (Core Pro?le) - February 2, 2019E.2. DEPRECATEDANDREMOVEDFEATURES 683
 Display lists - NewList, EndList, CallList, CallLists, ListBase, GenLists,
IsList, and DeleteLists; all references to display lists and behavior when
compiling commands into display lists elsewhere in the speci?cation; and all
associated state.
 Hints - the PERSPECTIVE_CORRECTION_HINT, POINT_SMOOTH_HINT,
FOG_HINT, andGENERATE_MIPMAP_HINT targets to Hint (section 21.5).
 Attribute stacks - PushAttrib, PushClientAttrib, PopAttrib, Pop-
ClientAttrib, the MAX_ATTRIB_STACK_DEPTH, MAX_CLIENT_ATTRIB_-
STACK_DEPTH, ATTRIB_STACK_DEPTH, and CLIENT_ATTRIB_STACK_-
DEPTH state, the client and server attribute stacks, and the values ALL_-
ATTRIB_BITS and CLIENT_ALL_ATTRIB_BITS.
 Uni?ed extension string -EXTENSIONS target to GetString.
 Token names and queries - all token names and queries not otherwise men-
tioned above for deprecated state, as well as all query entry points where
all valid targets of that query are deprecated state (chapter 22 and the state
tables).
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix F
Version 4.2
OpenGL version 4.2, released on August 8, 2011, is the fourteenth revision since
the original version 1.0.
Separate versions of the OpenGL 4.2 Specification exist for the core and com-
patibility pro?les described in appendix E, respectively subtitled the “Core Pro-
?le” and the “Compatibility Pro?le”. This document describes the Core Pro?le.
An OpenGL 4.2 implementation must be able to create a context supporting the
core pro?le, and may also be able to create a context supporting the compatibility
pro?le.
Material speci?c to the compatibility pro?le speci?cation is marked in a dis-
tinct color to clearly call out differences between the two pro?les.
The OpenGL 4.2 compatibility and core pro?les are upward compatible with
the OpenGL 4.1 compatibility and core pro?les, respectively.
Following are brief descriptions of changes and additions to OpenGL 4.2.
F.1 New Features
New features in OpenGL 4.2, including the extension or extensions if any on which
they were based, include:
 Support for BPTC compressed textures (ARB_texture_compression_-
bptc).
 Allow pixel storage parameters to affect packing and unpacking of com-
pressed textures (ARB_compressed_texture_pixel_storage).
 Shader atomic counters (ARB_shader_atomic_counters).
 Immutable texture images (ARB_texture_storage).
684F.2. DEPRECATIONMODEL 685
 Instanced transformed feedback drawing (ARB_transform_feedback_-
instanced).
 Allow the offset within buffer objects used for instanced rendering to be
speci?ed (ARB_base_instance).
 OpenGL Shading Language built-in functions allowing loads from and
stores to texture images from any shader stage, and application control
over the ordering of image load/store operations relative to other OpenGL
pipeline operations accessing the same memory (ARB_shader_image_-
load_store).
 New OpenGL Shading Language features with no OpenGL API impact
(ARB_conservative_depth and ARB_shading_language_420pack -
see the OpenGL Shading Language Specification for details).
 Queries for sample counts available for a given internal format and usage
(ARB_internalformat_query).
 More restrictive alignment constraints for mapped buffers (ARB_map_-
buffer_alignment).
F.2 Deprecation Model
The following features are newly deprecated by the OpenGL 4.2 core pro?le:
 The query targets NUM_COMPRESSED_TEXTURE_FORMATS and
COMPRESSED_TEXTURE_FORMATS (see section 8.5).
Features deprecated by OpenGL 4.1 remain deprecated, but have not yet been
removed.
F.3 Changed Tokens
New token names are introduced to be used in place of old, less general names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table F.1. Note thatCOPY_READ_BUFFER and
COPY_WRITE_BUFFER continue to be used as buffer targets for e.g. BindBuffer;
the_BINDING forms are used only when querying the buffer object bound to those
targets.
OpenGL 4.6 (Core Pro?le) - February 2, 2019F.4. CHANGELOGFORRELEASEDSPECIFICATIONS 686
New Token Name Old Token Name
COPY_READ_BUFFER_BINDING COPY_READ_BUFFER
COPY_WRITE_BUFFER_BINDING COPY_WRITE_BUFFER
TRANSFORM_FEEDBACK_ACTIVE TRANSFORM_FEEDBACK_BUFFER_ACTIVE
TRANSFORM_FEEDBACK_PAUSED TRANSFORM_FEEDBACK_BUFFER_PAUSED
Table F.1: New token names and the old names they replace.
F.4 Change Log for Released Specifications
Changes in the speci?cation update of January 19, 2012:
 Corrections to ?gure 3.1 (Bug 7997).
 Minor bug?xes and typos in sections 3, 10.3, 11.1, 11.1.1, 11.1.3.5, 4.2,
13.3.3, 14.5.2 (restored description of non-antialiased wide line rendering to
the core pro?le since they are deprecated, but not yet removed), 8.2 (?xed
prototypes for SamplerParameter commands), 15.2.1, 17.3.10 (specify that
multisample buffer is only resolved at this time if the default framebuffer is
bound), 9.2.8 (correct limits on layer for different types of attached textures),
9.4.2, 8.11 (remove redundant description by IsTexture that unbound object
names created by GenTextures are not the names of texture objects), 23
(add GetInteger64v as a supported state query), chapter 5, and tables 23.31,
23.32, 23.55, and 23.72 (Bug 7895).
 Add missing automatic unbinding of previously bound buffer objects for
BindBufferRange and BindBufferBase in section 6.1.1 (Bug 8196).
 More clearly specify interface matching rules for shader inputs and outputs
in section 7.4.1, for cases where both sides of an interface are found in the
same program and where they are in different programs (Bug 7030).
 Clarify in section 11.1.1 that dvec3 and dvec4 vertex shader inputs con-
sume only a single attribute location for the purpose of matching inputs to
generic vertex attributes, but may consume two vectors for the purposes of
determining if too many attribute vectors are used (Bug 7809). Also, add
missing language describing the set of attributes consumed by matrix vertex
attributes, with ?xes to explicitly addressdmat types.
*
 Remove dangling references to nonexistent gl_VerticesOut in sec-
tion 11.2.1.2.3 (Bug 8357).
OpenGL 4.6 (Core Pro?le) - February 2, 2019F.4. CHANGELOGFORRELEASEDSPECIFICATIONS 687
 Fix names of cube map sampler type tokens in table 7.3 (Bug 8303).
 Fix behavior of DeleteTransformFeedbacks in section 13.3.1 to generate
an error if any of the objects being deleted has transform feedback active
(Bug 8323).
 Remove ambiguity in the order of operations and which vertices are ap-
pended by transform feedback when it is resumed in section 13.3.2 (Bug
8202).
 Updated description of errors resulting from specifying texture images of
level 1 or greater which exceed implementation-dependent limits, in sec-
tions 8.5 and 8.17.3 (Bug 8210).
 Remove clamping ofD andD prior to depth texture comparison in sec-
t ref
tion 8.23.1, since it doesn’t re?ect hardware reality (Bug 7975).
 Update description of texture access from shadow samplers in section 15.2.1
to interact with texture swizzle (Bug 7962) and clarify that swizzling is not
performed on the results of incomplete texture lookups (Bug 7917).
 Add buffer clearing to the list of operations affected by scissor rectangle zero
in section 14.9.2 (Bug 8368).
 Remove error (from the core pro?le only) for querying CURRENT_-
VERTEX_ATTRIB for attribute zero with GetVertexAttrib* in section 7.14
(Bug 8352).
 Clarify that the initial state ofSAMPLE_MASK_VALUE is for all bits to be set
in table 23.11 (Bug 8441).
 Add missingPROGRAM_SEPARABLE state to table 23.32 (Bug 8442).
 Numerous minor ?xes to state table type ?elds and formatting (Bugs 8430,
8431).
 Clari?ed that automatic unbinding of deleted objects, as described in sec-
tion 5.1.2, does not affect attachments to unbound container objects the
deleted objects are themselves attached to (Bug 8233).
 Add version in which several extensions were introduced to core GL in sec-
tion K.3 (Bug 8418).
Changes in the speci?cation update of August 22, 2011:
OpenGL 4.6 (Core Pro?le) - February 2, 2019F.5. CREDITSANDACKNOWLEDGEMENTS 688
 More clearly specify interface matching rules for shader inputs and outputs
in section 7.4.1, for cases where both sides of an interface are found in the
same program and where they are in different programs (Bug 7030).
 Clarify in section 11.1.1 that dvec3 and dvec4 vertex shader inputs con-
sume only a single attribute location for the purpose of matching inputs to
generic vertex attributes, but may consume two vectors for the purposes of
determining if too many attribute vectors are used (Bug 7809). Also, add
missing language describing the set of attributes consumed by matrix vertex
attributes, with ?xes to explicitly addressdmat types.
*
Changes in the released speci?cation of August 8, 2011:
 Update name ofMIN_MAP_BUFFER_ALIGNMENT to follow GL conventions
in section 6.3 and table 23.55 (Bug 7825).
 Change query object state description in section 4.2 so the initial state of the
query result available ?ag agrees with the state table (Bug 7823).
 Minor cleanups to atomic counter language in section 7.6 and to atomic
counter token names in tables 23.57, 23.58, 23.60, and 23.61 (Bug 7834).
 Clarify that completeness affects texture lookup and fetch operations in all
shader stages in section 8.17 (Bug 7856).
 Change BindImageTexture parameter name from index to unit and ?x mi-
nor language issues in section 8.26 (Bugs 7744, 7850, 7851).
 Fix typos in section 22.3 (Bug 7843).
 Fix minimum maximums for MAX_FRAGMENT_IMAGE_UNIFORMS and
MAX_COMBINED_IMAGE_UNIFORMS in table 23.65 (Bug 7805).
 Change minimum maximum forMAX_ATOMIC_COUNTER_BUFFER_SIZE to
32 in table 23.64 (Bug 7855).
F.5 Credits and Acknowledgements
OpenGL 4.2 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 4.2, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including speci?c functionality developed in the form of
OpenGL 4.6 (Core Pro?le) - February 2, 2019F.5. CREDITSANDACKNOWLEDGEMENTS 689
new ARB extensions together with OpenGL 4.2. In addition, many people partic-
ipated in developing earlier vendor andEXT extensions on which the OpenGL 4.2
functionality is based in part; those individuals are listed in the respective extension
speci?cations in the OpenGL Extension Registry.
Acorn Pooley, NVIDIA
Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
Benji Bowman, Imagination Technologies
Bill Licea-Kane (Chair, ARB OpenGL Shading Language TSG,ARB_shader_-
atomic_counters)
Bruce Merry, ARM (Detailed speci?cation review,ARB_texture_storage)
Chris Dodd, NVIDIA
Christophe Riccio, Imagination Technologies
Daniel Koch (ARB_internalformat_query)
Eric Werness, NVIDIA (ARB_texture_compression_bptc)
Graham Sellers, AMD (ARB_base_instance, ARB_conservative_depth,
ARB_transform_feedback_instanced)
Greg Roth, NVIDIA
Ian Romanick, Intel (ARB_texture_storage)
Jacob Strom,? Ericsson AB
Jan-Harald Fredriksen (ARB_internalformat_query)
Jeannot Breton, NVIDIA
Jeff Bolz, NVIDIA Corporation (ARB_shader_image_load_store)
Jeremy Sandmel, Apple
John Kessenich, Independent (OpenGL Shading Language Specification Editor,
ARB_shading_language_420pack)
Jon Leech, Independent (OpenGL API Specification Editor)
Lingjun (Frank) Chen, Qualcomm
Mark Callow, HI Corporation
Maurice Ribble, Qualcomm
Nick Haemel, AMD
Pat Brown, NVIDIA Corporation (ARB_shader_image_load_store,ARB_-
shading_language_packing)
Patrick Doane, Blizzard
Pierre Boudier, AMD
Piers Daniell, NVIDIA Corporation (ARB_compressed_texture_pixel_-
storage,ARB_map_buffer_alignment)
Robert Simpson, Qualcomm
Tom Olson, ARM (Chair, Khronos OpenGL ES Working Group)
OpenGL 4.6 (Core Pro?le) - February 2, 2019F.5. CREDITSANDACKNOWLEDGEMENTS 690
The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix G
Version 4.3
OpenGL version 4.3, released on August 6, 2012, is the ?fteenth revision since the
original version 1.0.
Separate versions of the OpenGL 4.3 Specification exist for the core pro?le
and compatibility pro?le described in appendix E, respectively subtitled the “Core
Pro?le” and the “Compatibility Pro?le”. This document describes the Core Pro?le.
An OpenGL 4.3 implementation must be able to create a context supporting the
core pro?le, and may also be able to create a context supporting the compatibility
pro?le.
Material speci?c to the compatibility pro?le speci?cation is marked in a dis-
tinct color to clearly call out differences between the two pro?les.
The OpenGL 4.3 compatibility and core pro?les are upward compatible with
the OpenGL 4.2 compatibility and core pro?les, respectively (see appendix F).
Following are brief descriptions of changes and additions to OpenGL 4.3. De-
scriptions of changes and additions in versions of OpenGL prior to 4.2 are omitted
in this Specification, but may be found in the OpenGL 3.0 Specification (for fea-
tures in versions 1.0 - 3.0, inclusive) and the OpenGL 4.2 Specification (for features
in versions 3.1 - 4.1, inclusive). These Specifications are available in the OpenGL
Registry.
G.1 Restructuring
The Specification has been substantially restructured to introduce high-level con-
cepts and describe objects before their use, and more cleanly split descriptions of
programmable and ?xed-function processing. Chapter and section numbering has
been aligned between the two pro?le Specifications so that a section number will
always refer to the same concept in both pro?les (although that section may be
691G.2. NEWFEATURES 692
empty in the core pro?le).
G.2 New Features
New features in OpenGL 4.3, including the extension or extensions if any on which
they were based, include:
 ARB_arrays_of_arrays (OpenGL Shading Language only)
 ARB_ES3_compatibility
 ARB_clear_buffer_object
 ARB_compute_shader
 ARB_copy_image
 ARB_debug_output
 ARB_explicit_uniform_location
 ARB_fragment_layer_viewport (OpenGL Shading Language only)
 ARB_framebuffer_no_attachments
 ARB_internalformat_query2
 ARB_invalidate_subdata
 ARB_multi_draw_indirect
 ARB_program_interface_query
 ARB_robust_buffer_access_behavior
 ARB_shader_image_size (OpenGL Shading Language only)
 ARB_shader_storage_buffer_object
 ARB_stencil_texturing
 ARB_texture_buffer_range
 ARB_texture_query_levels
 ARB_texture_storage_multisample
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.3. DEPRECATIONMODEL 693
 ARB_texture_view
 ARB_vertex_attrib_binding
 KHR_debug
 AddVERTEX_ATTRIB_ARRAY_LONG query for whether a vertex attribute is
stored as an unconverteddouble (Bug 8272).
 Add queries for #version strings of all OpenGL Shading Language ver-
sions supported by the GL (Bug 7811).
 Increase required number of uniform blocks per program stage from 12 to
14 (Bug 8891).
G.3 Deprecation Model
The following features are deprecated by the OpenGL 4.3 core pro?le.
 Bitmap pack/unpack state for bitmaps - the pixel pack parametersUNPACK_-
LSB_FIRSTPACK_LSB_FIRST and (see sections 8.4.1 and 18.2).
The following features which were previously deprecated have been re-
introduced to the OpenGL 4.3 core pro?le:
 The GetPointerv command (see section 22.2) and the STACK_OVERFLOW
and STACK_UNDERFLOW errors (see table 2.3). These features are used by
the debug functionality in chapter 20.
Other features deprecated by OpenGL 4.2 remain deprecated, but have not yet
been removed.
G.4 Changed Tokens
New token names are introduced to be used in place of old, less general names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table G.1.
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.5. CHANGELOGFORRELEASEDSPECIFICATIONS 694
New Token Name Old Token Name
MAX_COMBINED_SHADER_OUTPUT_- MAX_COMBINED_IMAGE_UNITS_AND_-
RESOURCES FRAGMENT_OUTPUTS
Table G.1: New token names and the old names they replace.
G.5 Change Log for Released Specifications
Changes in the speci?cation update of February 14, 2013:
 Do not perform validity checks on the BindBufferRange size and offset ar-
guments when a zero buffer is speci?ed to unbind a buffer, in section 6.1.1
(Bug 9765).
 Clean up descriptions of BindBufferBase in section 6.1.1 so it is described
without reference to BindBufferRange, and note in section 6.7.1 that a zero
size query result for a buffer binding is a sentinel indicating the entire buffer
is bound (Bug 9513).
 Fix typo in error descriptions in section 6.7 (Bug 9720).
 Update section 6.8 to reference the tables of buffer binding state of differ-
ent types, and move uniform buffer binding state from table 23.35 to new
table 23.49 to match (Bug 9566).
 Clarify that Uniform*d cannot be used to load uniforms with boolean
types in section 7.6.1 (Bug 9345).
 Added double-precision matrix types to the description of uniform buffer
object storage layouts in section 7.6.2.1, and cleaned up description of the
matrix stride and how to query it (Bug 9375).
 Correct off-by-one error for valid range of sampler values in introduction to
section 7.11 (Bug 8905).
 Clarify in section 7.15 that table 23.43 is not part of program object state,
and update the table caption to match (Bug 9781).
 Clarify description of the data argument to TexSubImage* in section 8.6 so
that it may not beNULL, unlike TexImage* (Bug 9750).
 Fix typo in description of TexParameter* in section 8.10 (Bug 9625).
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.5. CHANGELOGFORRELEASEDSPECIFICATIONS 695
 Add a color-renderable column to table 8.12 and modify section 9.4 to de?ne
color-renderable formats with respect to the table, rather than with respect
to base formats. This results in the RGB9_E5 format no longer being color-
renderable, which was an error (Bug 9338).
 Allow vector forms of TexParameter* to be used to set scalar parameters in
section 8.10, reversing an old spec change made in error (vector parameters,
however, still cannot be set with the scalar calls) (Bug 7346).
 Restore missing clamp for D and D (depth texture comparison mode
t ref
parameters) in section 8.23.1 when using a ?xed-point texture (Bug 7975).
 Correct exp to exp terminology and include missing N term when
shared s
describing shared exponent texture color conversion and ?nal conversion in
sections 8.25 and 18.2.8 (Bug 9486).
 Specify that FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER for Get-
FramebufferParameteriv in section 9.2.3 (Bug 9344).
 Added STENCIL_INDEX8 as a required stencil-only renderbuffer format in
sections 9.2.5 and 9.4.3, for compatibility with OpenGL ES 3.0 (Bug 9418).
 Fixes to description of isoline tessellation in section 11.2.2.3 to describe use
of outer tessellation levels in the correct order (Bug 9607).
 Clamp values at speci?cation time for DepthRange* (section 13.8.1) and
ClearDepth (section 17.4.3), to avoid subtle issues when using ?oating-
point depth buffers. However, this change does not reintroduce use of the
clampf andclampd types eliminated in OpenGL 4.2 (Bug 9517).
 Change DrawBuffer error for COLOR_ATTACHMENTm out of range from
INVALID_VALUE to INVALID_OPERATION in section 17.4.1, to match
DrawBuffers and OpenGL ES 3.0 (Bug 8568).
 Modify language describing buffer writes in section 17.4.1 so that fragment
colors are not written only to draw buffers with no color attachment, or with
NONE as the draw buffer, allowing writes to other draw buffers to succeed.
Specify that when only some output variables are written, only the fragment
colors corresponding to unwritten variables are unde?ned (Bug 9494).
 Allow attachment parameters to InvalidateSubFramebuffer in sec-
tion 17.4.4 to includeDEPTH_STENCIL_ATTACHMENT (Bug 9480).
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.5. CHANGELOGFORRELEASEDSPECIFICATIONS 696
 Specify that the BlitFramebuffer mask may be zero in section 18.3.1 (Bug
9748).
 Cleaned up language describing parameters to DebugMessageControl in
section 20.4 to avoid triple negatives (Bug 9392).
 Increase minimum value for MAX_UNIFORM_BUFFER_BINDINGS to 84 in
table 23.63 to account for correct number of bindings/stage (14) (Bug 9424).
Changes in the released Specification of August 6, 2012:
 Restructured as described in section G.1.
 Added new features as described in section G.2.
 Add title image page using the “pipeline metro” diagram.
 Miscellaneous minor typos and ?xes to better match OpenGL ES 3.0 spec
language (Bugs 7885, 7904, 7919).
 Changed “rectangular texture” to “rectangle texture” throughout the spec for
consistency (Bug 9262). Other consistency changes including using “equiv-
alent to” consistently for pseudocode samples de?ning the operation of a
command.
 Many cleanups and additions to error language throughout the spec to add
previously implicit errors explicitly (however, this is still a work in progress).
In particular, added explicit errors for all commands taking program or
shader arguments as described at the start of section 7.1, and for commands
taking shadertype arguments (Bug 9145); and added explicit INVALID_-
VALUE errors for negative values ofsizei andsizeiptr arguments (Bug
9320).
 Cleaned up description of function prototypes from the oldT notation toT
*
orconst T as appropriate for the actual C binding of the corresponding
*
command.
 Added NUM_SHADING_LANGUAGE_VERSIONS and SHADING_-
LANGUAGE_VERSION queries for supported GLSL#version strings in sec-
tions 1.3.1, 1.3.3 and 22.2, and in table 23.56 (see Bug 7811). Still need
enum assignments for these.
 Remove assertion that draw and read framebuffers must be of the same class
in section 2.1 (Bug 9134).
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.5. CHANGELOGFORRELEASEDSPECIFICATIONS 697
 Clarify in the caption to table 2.2 that sync is de?ned as a pointer type in
the C binding (Bug 9140).
 ReintroducedSTACK_OVERFLOW andSTACK_UNDERFLOW errors to the core
pro?le in table 2.3, since they are used by the debug group APIs (Bug 9158).
 Describe new, more complete error summary and typesetting style in sec-
tion 2.3.1. Convert (most) error summaries beginning with section 4.1,
adding implicit error conditions that have not been described with the com-
mands they apply to before. This is a work in progress.
 Clean up query objects in section 4.2 to clarify that TIME_ELAPSED and
TIMESTAMP queries are different type of queries, and remove an inapplicable
error condition forTIMESTAMP queries (Bug 9268).
 Add language to DeleteBuffers in section 6 and BufferData in section 6.2
specifying that these commands cause any existing mappings of a buffer be-
ing operated on in any context to be unmapped, per a rather offhand reference
in section 6.3.1 (Bug 9323).
 Restore COPY_READ_BUFFER and COPY_WRITE_BUFFER as buffer target
names in sections 6.1 and 6.6. The _BINDING aliases are used only when
querying those binding points (Bugs 8475, 9115).
 Bring compute shader language in sync with changes to the extension spec.
In particular, add DISPATCH_INDIRECT_BUFFER binding section 6.1, de-
scribe it in section 10.3.11, update DispatchComputeIndirect to use it in
section 19, add new table 23.52, and update aggregate shader limits in sec-
tion 23.63 (Bug 9130).
 Add create-on-bind behavior for BindBufferRange and BindBufferBase in
section 6.1.1, mirroring BindBuffer (Bug 9216).
 Clarify that offset and alignment constraints for ClearBufferSubData in
section 6.2.1 are based on the total size of a texel of type internalformat
(size of base type times no. of components) (Bug 9211).
 Update errors for ClearBuffer*Data and mention them and Invalidate-
Buffer*Data among the commands that can modify buffer object storage
in sections 6.2.1, 7.6, 7.8, and 7.13 (Bug 9154).
 Clarify that buffer mappings are not affected by whether or not a context is
current in section 6.3.1 (Bug 9323).
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.5. CHANGELOGFORRELEASEDSPECIFICATIONS 698
 Add language in section 6.3.2 specifying that commands which write to (as
well as read from) mapped buffers are also supposed to generate errors (Bug
9115).
 Make InvalidateBuffer*Data generate errors for invalid object handles in
section 6.5 (Bug 9341).
 Merge description of different types of indexed array buffer bindings into
section 6.7.1, and move description of target-speci?c BindBufferRange er-
rors into section 6.1.1 with reference to section 6.7.1 (Bug 9115 and general
cleanup).
 Extend ShaderBinary in section 7.2 to allow support for shader binary for-
mats including all shader types, not just vertex and fragment shaders (Bug
9282).
 Add description of “top-level arrays” to active shader storage block discus-
sion in section 7.3.1 (Bug 9115). This probably needs to migrate back to the
extension as well, along with a few other language changes in this section
which Pat suggested in his PDF review but hasn’t put into the extension yet.
 Clarify error descriptions for UseProgramStages and ActiveShaderPro-
gram (section 7.4), UseProgram (section 7.6.1), and ProgramUniform*
(section 7.6.1) to generate an INVALID_OPERATION error “if program has
not been linked, or was last linked unsucessfully” rather than “if program has
not been successfully linked” (Bug 8640, tracking similar changes to other
commands previously).
 Merge similar descriptions of uniform variable component limits for each
separate shader stage into section 7.6.
 Fix nonexistent token ATOMIC_COUNTER_ARRAY_STRIDE to UNIFORM_-
ARRAY_STRIDE in section 7.7.1 (Bug 9346).
 Removed redundant de?nition of GetSubroutineUniformLocation from
the beginning of section 7.10.
 AddedINVALID_VALUE error in section 7.11 if Uniform1ifvg is used to set
a sampler to a value less than zero or greater than or equal to the value of
MAX_COMBINED_TEXTURE_IMAGE_UNITS, matching the similar error for
setting image uniforms.
 Add VERTEX_ATTRIB_ARRAY_LONG state in section 7.14 and table 23.3
(Bug 8272).
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.5. CHANGELOGFORRELEASEDSPECIFICATIONS 699
 Add all speci?c compressed texture formats to the required format list in
section 8.5.1. Include EAC and ETC2 format in speci?c format language in
table 8.14 and sections 8.6, 8.7, and 8.24 (Bug 9156).
 Add additional INVALID_OPERATION errors depending on odd combina-
tions of read buffer and FBO state for CopyTexImage* and CopyTex-
SubImage* in section 8.6 (Bug 8559).
 Disallow CopyTexImage* between sRGB and linear formats in section 8.6,
and de?ne BlitFramebuffer to linearize sRGB data from the read buffer in
section 18.3.1 (Bug 8560).
 Allow multisample texture targets as arguments to TexParameter* in sec-
tion 8.10, with additional error conditions when attempting to set a disal-
lowed min ?lter or base level parameter value.
 Replace listings of all six cube map face selection targets with references to
tables 8.19 or 9.3, in several places throughout the spec.
 Fix error generated for invalid texture handle passed to TextureView in sec-
tion 8.18 (Bug 9337).
 Tweaked descriptions of transferring vertices in sections 10.3.4 and 10.4 to
more closely match OpenGL ES 3.0 (Bug 8686).
 Restore missing description of DrawElementsInstanced in section 10.4.
 Renamed the formal parameter primcount to instancecount for DrawAr-
raysInstancedBaseInstance, DrawArraysInstanced, DrawElementsIn-
stancedBaseInstance, DrawElementsInstanced, DrawElementsIn-
stancedBaseVertex, and DrawElementsInstancedBaseVertexBase-
Instance (section 10.4), and for DrawTransformFeedbackInstanced
and DrawTransformFeedbackStreamInstanced (section 13.3.3). Used
equivalent terminology in the pseudocode descriptions of DrawEle-
mentsIndirect and DrawArraysIndirect (section 10.4). Renamed
the formal parameter primcount to drawcount for MultiDrawArrays,
MultiDrawArraysIndirect, MultiDrawElements, MultiDrawEle-
mentsIndirect, MultiDrawElementsBaseVertex (section 10.4) (Bug
9230).
 Moved description of GetVertexAttrib* into section 10.5 (Bug 9115).
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.5. CHANGELOGFORRELEASEDSPECIFICATIONS 700
 Specify in section 11.1.1 that special built-in inputs and outputs such asgl_-
VertexID should be enumerated in the PROGRAM_INPUT and PROGRAM_-
OUTPUT interfaces, as well as the legacy function GetActiveAttrib. Add
spec language counting the built-ins gl_VertexID and gl_InstanceID
against the active attribute limit (Bug 9201).
 Swap order of tessellation levels in describing isoline tessellation in sec-
tion 11.2.2.3, to match actual hardware (Bug 9195).
 Remove language about deferred deletion for DeleteTransformFeedbacks
in section 13.3.1 (Bug 8948).
 Add transform feedback-related error for ProgramBinary, matching exist-
ing error for LinkProgram in section 13.3.2 when program is the name of a
program being used by one or more transform feedback objects (Bug 7928).
 Add description ofMAX_COMPUTE_SHARED_MEMORY_SIZE in section 19.1,
lifted from GLSL spec (Bug 9069).
 Add description of the type of the debug callback function, including
platform-dependent calling conventions, in section 20.2.
 Remove inaccurate description of GLSL version string sort order in sec-
tion 22.2. Instead, ensure that the most recent GLSL version corresponding
to the context pro?le is returned ?rst, and other entries have no de?ned or-
dering (Bug 7811).
 Change Z terminology used in state tables to describe enumerated state
n
withn possible values toE throughout, since maintaining then was always
tricky as features were added and the possible values are fully described in
the spec body. This affects hundreds of state table entries as well as adding
a description ofE in table 23.1.
 Move IMPLEMENTATION_COLOR_READ_FORMAT and
IMPLEMENTATION_COLOR_READ_TYPE from table 23.73 to table 23.53
since they are not framebuffer-dependent values, unlike OpenGL ES (Bug
8561).
 Increased minimum values for MAX_VERTEX_UNIFORM_BLOCKS, MAX_-
TESS_CONTROL_UNIFORM_BLOCKS, MAX_TESS_EVALUATION_-
UNIFORM_BLOCKS, MAX_GEOMETRY_UNIFORM_BLOCKS, MAX_-
FRAGMENT_UNIFORM_BLOCKS, and MAX_COMPUTE_UNIFORM_BLOCKS to
14 in tables 23.57, 23.58, 23.59, 23.60, 23.61, and 23.62 respectively, and
ofMAX_COMBINED_UNIFORM_BLOCKS to 70 in table 23.63 (Bug 8891).
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.6. CREDITS 701
 AddedUNPACK_LSB_FIRST andPACK_LSB_FIRST state to the deprecated
features list in section G.3 (Bug 7865).
G.6 Credits
OpenGL 4.3 is the result of the contributions of many people and companies. Mem-
bers of the Khronos OpenGL ARB Working Group during the development of
OpenGL 4.3, including the company that they represented at the time of their con-
tributions, follow.
Some major contributions made by individuals are listed together with their
name, including speci?c functionality developed in the form of new ARB exten-
sions together with OpenGL 4.3. In addition, many people participated in develop-
ing earlier vendor and EXT extensions on which the OpenGL 4.3 functionality is
based in part; those individuals are listed in the respective extension speci?cations
in the OpenGL Registry.
Aaron Plattner, NVIDIA
Acorn Pooley, NVIDIA
Ahmet Oguz Akyuz, AMD
Alex Eddy, Apple Inc
Anton Staaf, Google
Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
Benj Lipchak, Apple
Benjamin Morris, NVIDIA
Bill Licea-Kane (Chair, ARB OpenGL Shading Language TSG)
Brent Wilson, NVIDIA
Bruce Merry, Independent
Chris Marrin, Apple
Chris Niederauer, Apple Inc
Christophe Riccio, AMD (ARB_debug_group, ARB_debug_label, ARB_-
shader_image_size, ARB_texture_query_levels, KHR_debug_-
output)
Dan Omachi, Apple Inc
Daniel Koch, TransGaming Inc. (ARB_internalformat_query2)
Daniel Rakos, AMD
Eric Werness, NVIDIA
Georg Kolling, Imagination Technologies
Graham Sellers, AMD (ARB_multi_draw_indirect, ARB_clear_-
buffer_object, ARB_compute_shader, ARB_copy_image, ARB_-
texture_buffer_range,ARB_texture_storage_multisample)
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.6. CREDITS 702
Greg Roth, NVIDIA
Henri Verbeet, CodeWeavers
Jaakko Konttinen, AMD (ARB_debug_output)
James Jones, NVIDIA
Jan-Harald Fredriksen, ARM
Jason Green, TransGaming
Jean-Franois Roy, Apple
Jeff Bolz, NVIDIA (ARB_invalidate_subdata, ARB_texture_view,
ARB_vertex_attrib_binding)
Joe Kain, NVIDIA
John Kessenich, Independent (OpenGL Shading Language Specification Editor,
ARB_arrays_of_arrays)
Jon Leech, Independent (OpenGL API Specification Editor)
Kenneth Russell, Google (ARB_robustness_isolation)
Kent Miller, Apple
Lingjun (Frank) Chen, Qualcomm
Mark Callow, HI Corporation
Mark Kilgard, NVIDIA (ARB_robustness)
Mark Young, AMD
Mathias Schott, NVIDIA
Matt Collins, Apple
Maurice Ribble, Qualcomm
Michael Gold, NVIDIA (ARB_copy_image)
Michael Morrison, NVIDIA
Pat Brown, NVIDIA (ARB_framebuffer_no_attachments, ARB_-
program_interface_query, ARB_shader_storage_buffer_-
object)
Pierre Boudier, AMD
Piers Daniell, NVIDIA (ARB_ES3_compatibility, ARB_debug_-
output2, ARB_explicit_uniform_location, ARB_fragment_-
layer_viewport, ARB_robust_buffer_access_behavior, ARB_-
stencil_texturing)
Richard Schreyer, Apple
Seth Sowerby, Apple
Thomas Volk, NVIDIA
Tim Johansson, Opera
Vladimir Vukicevic, Mozilla
Yaki Tebeka, Graphic Remedy
Yuan Wang, IMG
OpenGL 4.6 (Core Pro?le) - February 2, 2019G.7. ACKNOWLEDGEMENTS 703
G.7 Acknowledgements
The ARB gratefully acknowledges administrative support by the members of Gold
Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Fredericks,
and Michelle Clark, and technical support from James Riordon, webmaster of
Khronos.org and OpenGL.org.
The “pipeline metro” cover image was created by Dominic Agoro-Ombaka of
Gold Standard Group.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix H
Version 4.4
OpenGL version 4.4, released on July 22, 2013, is the sixteenth revision since the
original version 1.0.
Separate versions of the OpenGL 4.4 Specification exist for the core pro?le
and compatibility pro?le described in appendix E, respectively subtitled the “Core
Pro?le” and the “Compatibility Pro?le”. This document describes the Core Pro?le.
An OpenGL 4.4 implementation must be able to create a context supporting the
core pro?le, and may also be able to create a context supporting the compatibility
pro?le.
Material speci?c to the compatibility pro?le speci?cation is marked in a dis-
tinct color to clearly call out differences between the two pro?les.
The OpenGL 4.4 compatibility and core pro?les are upward compatible with
the OpenGL 4.3 compatibility and core pro?les, respectively (see appendix G).
Following are brief descriptions of changes and additions to OpenGL 4.4. De-
scriptions of changes and additions in versions of OpenGL prior to 4.2 are omitted
in this Specification, but may be found in the OpenGL 3.0 Specification (for fea-
tures in versions 1.0 - 3.0, inclusive) and the OpenGL 4.2 Specification (for features
in versions 3.1 - 4.1, inclusive). These Specifications are available in the OpenGL
Registry.
H.1 New Features
New features in OpenGL 4.4, including the extension or extensions if any on which
they were based, include:
 ARB_buffer_storage
 ARB_clear_texture
704H.2. DEPRECATIONMODEL 705
 ARB_enhanced_layouts
 ARB_multi_bind
 ARB_query_buffer_object
 ARB_texture_mirror_clamp_to_edge
 ARB_texture_stencil8
 ARB_vertex_type_10f_11f_11f_rev
 New implementation-dependent state MAX_VERTEX_ATTRIB_STRIDE,
which constrains the maximum value of stride parameters to vertex array
pointer-setting commands.
H.2 Deprecation Model
No new features are deprecated, and no previously deprecated features are re-
introduced by the OpenGL 4.4 core pro?le.
Features deprecated by OpenGL 4.3 remain deprecated, but have not yet been
removed.
H.3 Change Log for Released Specifications
Changes in the released Specification update of March 19, 2014:
 Fix typos and apply minor non-semantic language changes in several places
to more closely match the OpenGL ES 3.1 Specification.
 Tweak Enable / Disable language for different targets throughout the spec
for more consistency.
 Modify language in section 5.1.2 so that binding-related state is restored to
default values after automatic unbinds (Bugs 10076, 11630).
 Add samplers to the list of object types in section 5.1.3 for which deletion is
delayed until the object is no longer in use, and remove transform feedback
objects since deletion is de?ned to generate an error while they are active
(Bugs 11374, 10079).
 Add atomic counter binding, offset and stride assignments to the values reset
by ProgramBinary in section 7.5 (bug?x from ES spec).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 706
 Move Uniform* errors to section 7.6.1 where the Uniform* commands are
de?ned, from sections 7.11 and 7.12
 Correct typo MAX_ATOMIC_COUNTER_BUFFERS to MAX_COMBINED_-
ATOMIC_COUNTER_BUFFERS in section 7.7, and specify new program in-
terface query for atomic counter buffer data size query in section 7.7.2
 Restrict error for UniformSubroutinesuiv in section 7.10 to the case where
no program stage is active for the shader stage identi?ed by shadertype (Bug
11306).
 Update DeleteSamplers language in section 8.2 to allow for the case where
a sampler is bound to multiple texture units (bug?x from ES spec).
 Fix conversion equation reference for SamplerParameteriv in section 8.2.
Reorganize descriptions of exceptions to default data conversion rules here
and in section 8.10 for TexParameter* (Bug 11185).
 Add error in section 8.2 for calling scalar SamplerParameterfifg en-
try points with non-scalar param tokens, matching TexParameter* (Bug
11186).
 Add error for TexImage3D in section 8.5 when specifying invalid border
or target values with speci?c compressed texture formats, matching Com-
pressedTexImage3D (Bug 11239).
 Update table 8.12 in section 8.5.2 to make all remaining sized color formats
texture-renderable that were not already, since the component size promotion
rules mean there are already required texture formats with the same format
and as least as many bits/component (Bug 11097).
We discussed but did not also make these formats required renderbuffer for-
mats, because doing this might imply a format change when a format sup-
ported at exactly the required component size for textures is only supported
at a larger component size for renderbuffers (e.g. create texture at RGB4,
use as a texture, then use as a renderbuffer and ?nd it has to be converted to
RGB565).
 Change maximum allowed texture size for TexImage3DMultisample in
section 8.8 to the value ofMAX_ARRAY_TEXTURE_LAYERS (Bug 11135).
 Remove explicit OUT_OF_MEMORY errors from TexImage*Multisample in
section 8.8 and RenderbufferStorageMultisample in section 9.2.4. (public
Bug 952).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 707
 Add subsection headings and Errors sections for GetTexParameter* and
GetTexLevelParameter* in section 8.11.
 Change formal parameter names value and data to pname and params,
following the headers and man pages, for GetTexParameter* and Get-
TexLevelParameter* (see section 8.11). (Bug 11523).
 Added per-target maximum level-of-detail values to de?nition of Get-
TexLevelParameter* in section 8.11.3 (Bug 11136)
 Add error for GetTexLevelParameter* in section 8.11 when querying
multisample-speci?c parameters for non-multisample textures (this was im-
ported from the OpenGL ES spec and it’s not certain it should be here).
 De?ne behavior of GetTexLevelParameter* in section 8.11.3 for queries of
multisample state from non-multisampled textures (Bug 11814).
 Change rounding mode for layer numbers of array textures in section 8.14.2
to prefer round-to-nearest-even, while still allowing old spec behavior (Bug
11399).
 Add cube map array texel arrays to the enumerated state in section 8.22, and
remove redundant description of the bound buffer texture object name.
 Add description of DEPTH_STENCIL_TEXTURE_MODE in section 8.22, and
correct its type in table 23.15 (Bug 11770).
 Add section 8.26.1 summarizing image unit binding state (Bug 10076).
 Restructure error condition for FramebufferParameteri in section 9.2.1 to
avoid ambiguity (Bug 11831).
 De?ne GetFramebufferAttachmentParameteriv in section 9.2.3 to return
NONE when querying the object type of depth or stencil attachments, the
default framebuffer is bound, and the corresponding buffer of the default
framebuffer has zero bits (Bug 10908).
 Clean up language describing the GetFramebufferAttachmentParam-
eteriv query for FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER in sec-
tion 9.2.3 (Bug 11102).
 Remove bogus error condition for FramebufferRenderbuffer, and add er-
rors for invalid layer depending on texture type in section 9.2.7 (bug?x from
ES spec).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 708
 Set the vertex attribute array pointer state explicitly in the pseu-
docode for VertexAttrib*Pointer in section 10.3.2, and de?ne queries
of VERTEX_ATTRIB_ARRAY_BUFFER_BINDING and VERTEX_ATTRIB_-
ARRAY_DIVISOR to look up the corresponding state via the vertex attribute
binding in section 10.5 (Bug 11789).
 Rewrite section 10.3.11 to merge language for indirect drawing and indirect
compute dispatch commands (Bug 11601).
 Fix texel fetch limit on layer for array textures in section 11.1.3.2 (Bug
11770).
 Fix typo in section 11.1.3.7 (Bug 11553).
 Relax restrictions on required shader stages in sections 11.2 and 11.3 so that
separable program objects containing tessellation and geometry shaders are
not also required to contain a vertex shader (Bug 11508).
 Modify tessellation primitive generation language in section 11.2.2 to dis-
card patches only when relevant outer tessellation levels are NaNs, but not
for non-relevant levels (Bug 11484).
 Add missing error for invalid pname to GetMultisamplefv in section 14.3.1
(Bug 11134).
 Change error for invalid mode parameters to BlendEquation* in sec-
*
tion 17.3.6.1 toINVALID_ENUM (bug 11354).
 Fix error for invalid blending function arguments in section 17.3.6.2 to
INVALID_ENUM (Bug 11770).
 Add errors for ClearBuffer* in section 17.4.3.1 when the wrong type of
buffer is passed to different forms of the command (Bug 11139).
 Fix table reference in description of ClearBuffer* in section 17.4.3.1
from 17.5 to 17.4 so it’s clear that DRAW_BUFFERi can contain any legal
value and the corresponding buffers will be cleared (Bug 11463).
 Modify caption for table 17.4 in section 17.4.1 so it’s clear table entries refer
only to selected buffers for the draw buffer, and remove redundant descrip-
tion of initial draw buffers state (Bugs 11462, 11463).
 Moved language allowing unde?ned behavior for overlapping copies to the
beginning of section 18.3, extended it to the case of overlapping copies via
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 709
texture views, applied it to all pixel copy operations in the section, and re-
stricted the effects to unde?ned pixel values rather than general unde?ned
behavior (Bug 11355).
 Replace the “Get Value” of LABEL with - for debug labels of objects in
tables 23.3, 23.6, 23.15, 23.18, 23.24, 23.27, 23.30, 23.31, 23.32, 23.44,
23.48, 23.50, and 23.74 (Bug 11131).
 Rewrote descriptions of the vertex binding-speci?c state in table 23.4,
added missing VERTEX_BINDING_DIVISOR and VERTEX_BINDING_-
BUFFER state, and marked all such state as part of the vertex-array attribute
group (in the compatibility pro?le only) (Bug 10736).
 Add missing state for framebuffers with no attachment to tables 23.24
and 23.69 (Bug 11187).
 Add missing COMPUTE_SHADER state to program pipeline objects in ta-
ble 23.31 (Bug 11539).
Changes in the released Specification update of October 18, 2013:
 Add footnote to section 2.3.1 noting that OUT_OF_MEMORY errors are not
explicitly shown in command-speci?c Error sections because all GL com-
mands can potentially generate them. Remove explicitOUT_OF_MEMORY er-
rors from BufferStorage, BufferData, and MapBufferRange in section 6,
and the TexStorage* commands in section 8.19 (public Bug 952).
 Add new section 2.4 de?ning the term rendering commands, and modify
language using this term in sections 7.11, 9.4.4, 10.3.9, 10.9, and 11.1.3.11
to use the new de?nition, sometimes narrowed to drawing commands, or to
rendering commands which invoke shaders (Bug 10403).
 Add footnote to section 2.6.9 specifying that unde?ned behavior results
when mixing non-shared core API framebuffer objects and shared EXT ex-
tension framebuffer objects (Bug 10738).
 Change description of BufferStorage MAP_COHERENT_BIT in section 6.2
to say that changes are “visible to any subsequently issued GL commands”
rather than “immediately visible” (Public Bug 935).
 Remove error for BufferStorage in section 6.2 which did not allow ?ags to
contain MAP_WRITE_BIT while not also containing DYNAMIC_STORAGE_-
BIT (Bug 10561, public Bug 925).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 710
 Rewrite section 6.3.2 describing the effects of mapped buffers on other com-
mands and possible resulting errors or unde?ned behavior (Bug 10684).
 Update GetProgramResourceiv in section 7.3.1 to return one forARRAY_-
SIZE queries of non-arrays (for compatibility with GetActiveUniform) and
zero for explicitly unsized arrays, and describe circumstances in which
queries ofARRAY_SIZE andTOP_LEVEL_ARRAY_SIZE for unknown array
sizes may return zero (Bugs 10641, 10647).
 Allow ActiveShaderProgram and UseProgramStages to accept zero pro-
gram values in section 7.4, to reset the corresponding program pipeline ob-
ject state to its initial value (Public Bug 871).
 Add additional const quali?er to parameter type of uniformNames for
GetUniformIndices in section 7.6 (Bug 10703).
 Fix typo from SHADER_STORAGE_BLOCK to SHADER_STORAGE_BUFFER
for ShaderStorageBlockBinding in section 7.8 (Bug 10795).
 Fix list of supported texture targets for stencil, depth, and depth+stencil for-
mats in section 8.5 to include multisample targets (Bug 10558).
 Move descriptions of required texture and renderbuffer/texture formats into
tables 8.12 and 8.13, and update language in sections 8.5.1, 9.2.5, 9.4,
and 9.4.3 to refer to those tables and to describe required framebuffer for-
mats as color-renderable. Also, merged the no-longer-existent table 9.1 of
renderbuffer-only stencil formats into table 8.13, and modi?ed the de?nition
of stencil-renderable in section 9.4 accordingly (Bug 9338).
 Tag type of stencil ?elds in table 8.13 as ui (Bug 10748).
 Add error for TexImage*DMultisample in section 8.8 when internalformat
is not a valid format (Bug 11018).
 Change type of internalformat argument to TexImage2DMultisample and
TexImage3DMultisample in section 8.8 toenum, since the legacy internal
formats are never accepted by these commands (Bug 10496).
 Note that during computation of scale factors in section 8.14.1, implementa-
tions have chosen to perform clamping of intermediate terms in the sum of
level-of-detail biases differently (Bug 9779).
 Specify how border color values are clamped for compressed texture image
formats in table 8.14 and section 8.14.2 (Bug 9476).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 711
 Specify behavior of GetFramebufferAttachmentParameteriv in sec-
tion 9.2.3 when querying texture attachments which have not yet speci?ed a
texture image or which do not yet have an allocated image store, and ?x the
error generated when querying a combined depth+stencil attachment to ap-
ply to the component type query, rather than the color encoding query (Bugs
9170, 10357).
 Clean up errors for FramebufferTexture*D in section 9.2.8 (Bug 10674).
 Merge rows of table 10.2 for VertexAttrib*Format and VertexAt-
trib*Pointer commands which are otherwise identical (Bug 10692).
 Rewrite description of BindVertexBuffer in section 10.3.2 to clarify that it
may create buffers in the same fashion as BindBuffer (Bug 10693).
 Explicitly specify in section 10.3.2 that the VertexAttrib*Pointer com-
mands may generate any of the errors de?ned by VertexAttrib*Format and
VertexAttribBinding, since the pseudocode invokes those commands (Bug
10631). This was implicit in the previous spec language and has simply been
called out more explicitly for clarity without replicating the errors.
 Add PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED to section 10.3.6
and table 23.53 to allow querying primitive restart support for patch primi-
tives (Bug 10364). Note that some implementations already could not sup-
port this, but had no way to indicate this.
 Drop bogus references to “disabled attributes” in section 10.3.7 (Bug 10695).
 Generate INVALID_VALUE errors consistently for misaligned indirect pa-
rameters to DrawArraysIndirect and DrawElementsIndirect in sec-
tion 10.4, and DispatchComputeIndirect in section 19 (Bug 10385).
 Clarify in sections 11.1.3.5 and 15.2.1 that swizzling during texture lookups
of textures with depth component data is always performed, whether depth
comparision is disabled or enabled (Bug 10702, Public Bug 749).
 Restrict description in section 11.1.3.11 of checks required to be performed
by ValidateProgram to only the errors described in that section (Bug
10650).
 Remove a sentence fragment accidentally left in the description of Vali-
dateProgramPipeline in section 11.1.3.11.
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 712
 Specify in section 14.3.1 that the value ofSAMPLE_BUFFERS is framebuffer-
dependent, likeSAMPLES (Bug 10688).
 Remove redundant language describing depth texture lookups in sec-
tion 15.2.1 and replace with a link to section 11.1.3.5, which also has some
additional bug?xes that were not present here (Bug 10997).
 Move a paragraph in section 15.2.2 to near the end of the section for better
?ow (Bug 10687).
 Restrict language disallowing writing to multiple “classes” of fragment
shader outputs in section 15.2.3 to compatibility pro?le only (Bug 10126).
 Improve language describing unde?ned behavior when different color values
are written to the same multiply-attached color buffer, and move it from
section 17.3.9 to section 17.4.1 (Bug 10983).
 Specify in section 18.3.1 that linearization of sRGB formats during
reads performed by blending and blitting operations is controlled by the
FRAMEBUFFER_SRGB enable (Bug 8560).
 Change the type of FRAMEBUFFER_ATTACHMENT_LAYERED in table 23.25
fromnB toB.
 Restore missing TEXTURE_BUFFER_BINDING query in table 23.74 for the
buffer object bound to the corresponding bind point (Bug 4353, public Bug
844).
Changes in the released Specification of July 22, 2013:
 Added new features as described in section H.1.
 Changed references throughout the spec to the value of SAMPLE_BUFFERS
being “greater than zero” to “one”, since it can only take on values of zero
and one.
 Added introductory subsection 1.4 describing how to ?le bug reports against
the GL and GLSL Specifications in the Khronos public Bugzilla (public bug
379).
 Added a note that queryingQUERY_RESULT_AVAILABLE for a query object
will eventually succed in section 4.2.3 (Bug 9766).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 713
 Add views of an object’s data store to the list of conditions in sections 5
and 5.1.3 under which an object is considered in use for purposes of deter-
mining object lifetimes (Bug 10511).
 Minor clari?cations in sections 5.3.1, 8.21, 7.6.3, 7.7.2, 7.8, 13.1, and 15.2.1
(Bug 10346).
 AddedINVALID_VALUE error for BindBufferRange in section 6.1.1 if off-
set is negative (Bug 9873).
 Add BufferSubData error for immutable storage without dynamic draw ?ag
in section 6.2 (Bug 10326).
 Modi?ed prototypes for vector forms of the commands GetTexParame-
ter* and GetTexLevelParameter* (section 8.11.1), and VertexAttrib4Nub
(section 10.2.1), so that they are passed pointers rather than scalars as sug-
gested by the ’T’ notation (public bug 273).
 Clarify that no speci?c compressed one-dimensional texture formats are sup-
ported by the API, but may be by extensions, in section 8.7 (Bug 10388).
 Restore errors for setting invalid rectangle texture parameters in section 8.10
(Bug 10208).
 Move language constraininglevel andlevel for immutable textures
base max
from section 8.10 to section 8.14.3 (Bug 9342).
 Added alternate mipmap level selection computation in equation 8.14 (Bug
10119).
 Add forward references to pixel packing and PACK_ pixel storage modes
*
from descriptions of texture queries and PixelStore in sections 8.11, 8.4.1,
and 18.4 (Bug 10380).
 Describe wrap mode application forMIRROR_CLAMP_TO_EDGE consistently
with other modes in table 8.20, and use mod math operator instead of
fmod() function since the inputs are described in non-scaled integer co-
ordinates (Bug 10432).
 Use actual VIEW_CLASS_ compatibility class names in table 8.22 instead
*
of abstract class names, and refer to these tokens from the description of
VIEW_COMPATIBILITY_CLASS in section 22.3.2 instead of enumerating
them again (Bug 10518).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 714
 Change completeness condition for stencil index textures and stencil tex-
turing from depth+stencil textures to match other integer textures in sec-
tion 8.17 (Bug 10372).
 Add number of samples to proxy texture state in section 8.22 and specify
that its value is not checked for multisample textures (Bug 10171).
 Add error for querying component type of a combined depth+stencil buffer
with GetFramebufferAttachmentParameteriv in section 9.2.3, and note
that the color encoding for non-color buffers is returned as LINEAR (Bug
9170).
 Add conditions in section 9.4.1 for texture image attachments, making
framebuffer attachment completeness dependent on valid mipmap level and
mipmap completness of the image and including the case where texture im-
age attachment is part of a cubemap texture, which must be mipmap cube
complete (Bug 9689).
 Remove redundant paragraph from section 10.2 (Bug 10311).
 Limit stride parameters to BindVertexBuffer* and the generic ver-
tex array speci?cation commands in section 10.3 to the value of the
new implementation-dependent stateMAX_VERTEX_ATTRIB_STRIDE in ta-
ble 23.55 (Bug 10229).
 Move non-local error descriptions for *Indirect* rendering and dispatch
commands to live with the commands themselves in sections 10.3.11, 10.4,
and 19 (Bug 10385).
 Only allow generated buffer object names in the core pro?le for BindVer-
texBuffer in section 10.3.2 (Bug 10486).
 Added BlitFramebuffer to commands affected by conditional rendering in
section 10.9 (Bug 9562).
 Restore error for BindAttribLocation attribute variable names starting with
the reserved"gl_" pre?x to core pro?le in section 11.1.1 (Bug 10203).
 Clarify that GetTransformFeedbackVarying may be used to query any
transform feedback varying variable in section 11.1.2.1 (Bug 10472).
 Add a non-local error in section 13.3.2 for GL commands that attempt to read
or write to an active and unpaused transform feedback buffer (Bug 10193).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.3. CHANGELOGFORRELEASEDSPECIFICATIONS 715
 Changed type of GetPolygonStipple argument toubyte in section 14.6.2
to match shipping header ?les and be typesafe (Bug 10110).
 Clean up description of GetFragData* in section 15.2.3 (Bug 10127).
 Made default value for ALPHA_TEST_REF ?oating-point in section 17.3.2,
and changed query in table 23.20 to GetFloatv (Bug 10128).
 Strike redundant language describing default/FBO bindings under Draw-
Buffer (see section 17.4.1) and ReadBuffer (section 18.2.1). Bring lan-
guage for the two sections in sync, and restore errors for ReadBuffer corre-
sponding to DrawBuffer (Bug 10172).
 Fix error speci?ed for ColorMaski in section 17.4.2 to specify the correct
formal parameter name, buf, and be restricted to that command (public bug
256).
 Minimize use of generic ClearBuffer* terminology, since Clear-
Buffer*Data behave differently than the similarly named commands in sec-
tion 17.4.3 with respect to conditional rendering and rasterizer discard (Bug
10312).
 Clarify that ClearBuffer* can clear any valid draw buffers in sec-
tion 17.4.3.1, and that the commands have no effect when the selected draw
buffer has the valueNONE (Bug 10537).
 Relax BlitFramebuffer in section 18.3.1 so that format conversion can take
place during multisample blits, since drivers already allow this and some
apps depend on it. Simpli?ed references toSAMPLE_BUFFERS by using the
term “multisampled”. Cleaned up the Errors section and moved errors from
spec body language into it (Bugs 9692, 10219).
 Add const quali?er to userParam argument of DebugMessageCallback
and DEBUGPROC in section 20.2. Specify that unrecognized message IDs
in DebugMessageControl ids array are ignored in section 20.4. Specify
in section 20.9 that GetDebugMessageLog messageLog parameter must be
NULL when bufSize is less than zero, to allow an early out. (Bug 10083).
 Reorganize section 22.3 to group internal format query pnames by the type
of query and sort them, and addCLEAR_TEXTURE pname to match extension
spec.
 Add missing PRIMITIVE_RESTART_FIXED_INDEX to table 23.5 (Bug
10250).
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.4. CREDITS 716
 Clean up state table entries to indicate enumerated types in tables 23.14,
23.18, 23.19, 23.25, and 23.27 (Bug 10251).
 Fixed types of CLIP_DISTANCEi and DEPTH_RANGE in table 23.7 (Bugs
10106, 10107).
 Add missing UNIFORM_BLOCK_NAME_LENGTH state to table 23.36 (Bug
8136).
 Change minimum number of compressed texture formats to 18 in ta-
ble 23.55, comprising the required speci?c formats in table 8.14 (Bug 7235).
H.4 Credits
OpenGL 4.4 is the result of the contributions of many people and companies. Mem-
bers of the Khronos OpenGL ARB Working Group during the development of
OpenGL 4.4, including the company that they represented at the time of their con-
tributions, follow.
Some major contributions made by individuals are listed together with their
name, including speci?c functionality developed in the form of new ARB exten-
sions together with OpenGL 4.4. In addition, many people participated in develop-
ing earlier vendor and EXT extensions on which the OpenGL 4.4 functionality is
based in part; those individuals are listed in the respective extension speci?cations
in the OpenGL Registry.
Alon Or-bach, Samsung
Aras Pranckevicius, Unity3D
Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
Benj Lipchak, Apple
Benji Bowman, Imagination Technologies
Bill Licea-Kane, AMD
Brent Insko, Intel
Bruce Merry, Independent
Christoph Kubisch, NVIDIA
Christophe Riccio, AMD
Daniel Koch, NVIDIA (GL_ARB_clear_texture, GL_ARB_texture_-
mirror_clamp_to_edge,GL_ARB_vertex_type_10f_11f_11f_rev)
Daniel Rakos, AMD (GL_ARB_query_buffer_object)
Graham Connor, Imagination Technologies
Graham Sellers, AMD (GL_ARB_buffer_storage)
Ian Romanick, Intel
OpenGL 4.6 (Core Pro?le) - February 2, 2019H.5. ACKNOWLEDGEMENTS 717
James Helferty, NVIDIA
James Jones, NVIDIA
Jeff Bolz, NVIDIA (GL_ARB_texture_stencil8)
John Kessenich, Independent (OpenGL Shading Language Specification Editor,
GL_ARB_enhanced_layouts)
Jon Leech, Independent (OpenGL API Specification Editor)
Jonathan Putsman, Imagination Technologies
Karol Gasinski, Intel
Larry Seiler, Intel
Lingjun (Frank) Chen, Qualcomm
Mark Callow, Artspark
Nick Penwarden, Epic Games
Pat Brown, NVIDIA (GL_ARB_multi_bind)
Pierre Boudier, AMD
Piers Daniell, NVIDIA
Rob Barris, NVIDIA
Robert Simpson, Qualcomm
Slawomir Grajewski, Intel
Tim Foley, Intel
Tom Olson, ARM
H.5 Acknowledgements
The ARB gratefully acknowledges administrative support by the members of Gold
Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Fredericks,
and Michelle Clark, and technical support from James Riordon, webmaster of
Khronos.org and OpenGL.org.
The “pipeline metro” cover image was created by Dominic Agoro-Ombaka of
Gold Standard Group.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix I
Version 4.5
OpenGL version 4.5, released on August 11, 2014, is the seventeenth revision since
the original version 1.0.
Separate versions of the OpenGL 4.5 Specification exist for the core pro?le
and compatibility pro?le described in appendix E, respectively subtitled the “Core
Pro?le” and the “Compatibility Pro?le”. This document describes the Core Pro?le.
An OpenGL 4.5 implementation must be able to create a context supporting the
core pro?le, and may also be able to create a context supporting the compatibility
pro?le.
Material speci?c to the compatibility pro?le speci?cation is marked in a dis-
tinct color to clearly call out differences between the two pro?les.
The OpenGL 4.5 compatibility and core pro?les are upward compatible with
the OpenGL 4.4 compatibility and core pro?les, respectively (see appendix H).
Following are brief descriptions of changes and additions to OpenGL 4.5. De-
scriptions of changes and additions in versions of OpenGL prior to 4.2 are omitted
in this Specification, but may be found in the OpenGL 3.0 Specification (for fea-
tures in versions 1.0 - 3.0, inclusive) and the OpenGL 4.2 Specification (for features
in versions 3.1 - 4.1, inclusive). These Specifications are available in the OpenGL
Registry.
I.1 New Features
New features in OpenGL 4.5, including the extension or extensions if any on which
they were based, include:
 GL_ARB_clip_control
 GL_ARB_cull_distance
718I.2. DEPRECATIONMODEL 719
 GL_ARB_ES3_1_compatibility
 GL_ARB_conditional_render_inverted
 GL_KHR_context_flush_control
 GL_ARB_derivative_control (OpenGL Shading Language Only)
 GL_ARB_direct_state_access
 GL_ARB_get_texture_sub_image
 GL_KHR_robustness
 GL_ARB_shader_texture_image_samples (OpenGL Shading Lan-
guage Only)
 GL_ARB_texture_barrier
I.2 Deprecation Model
No new features are deprecated, and no previously deprecated features are re-
introduced by the OpenGL 4.5 core pro?le.
Features deprecated by OpenGL 4.4 remain deprecated, but have not yet been
removed.
I.3 Change Log for Released Specifications
Changes in the released Specification update of June 29, 2017
 Updated document copyright to new standard Khronos speci?cation copy-
right.
 Specify in section 2.3.1 that detection of errors based on the value of param-
eters is always performed prior to any state-based validation (Bug 11046).
 Clarify that program object state queries in section 7.14 return the state
presently in effect, which may be different than most recently set state (Bug
9702).
 Clarify in section 7.14 that there is always an info log for shader, program,
and program pipeline objects, even if it is empty; and that the strings returned
by GetShaderInfoLog, GetProgramInfoLog and GetProgramPipeline-
InfoLog are always null-terminated (Bug 16110).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 720
 Note that the implementation-dependent maximum texture dimensions are
independent in each image dimension, and that implementations may fail
to create textures of the maximum sizes due to resource exhaustion, in sec-
tion 8.5.3 (Bug 12249).
 Adjust the level-of-detail computation of f(x;y) in section 8.14.1 to con-
sider other vectors when computing scale factors (Bug 16179).
 Clean up level-of-detail computation in equation 8.14 section 8.14.3 to relax
computation to match the Vulkan speci?cation (Bug 16233).
 Specify in section 8.14.4 that GenerateMipmap has no effect when the base
mipmap level is unde?ned (Bug 11147).
 Add a description in section 9.2.3
of the case when querying Get*FramebufferAttachmentParameteriv for
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE returnsNONE, and the default
framebuffer attachment is not allocated (Bug 16189).
 Add an error to FramebufferTexture*D and *FramebufferTextureLayer
in section 9.2.8 when attempting to attach a non-existent level of an im-
mutable texture, and make the language in these sections closer to OpenGL
ES (Bugs 15946,16214).
 Add clari?cation that one of the error conditions for *DrawBuffers in sec-
tion 17.4.1 applies only to the default framebuffer (Bug 16153).
 Change the initial QUERY_RESULT_AVAILABLE state for query objects to
TRUE in table 23.44, consistent with other changes made in Public Bug 1213
(Bug 16089).
 Update the extension summaries in appendix K.3.3 to re?ect all currently
published ARB extensions.
Changes in the released Specification update of October 24, 2016
 Add language to GetProgramResourceiv in section 7.3.1.1 specifying the
returned block index when the interface block is declared as an array of block
instances, and clarify the de?nition of active uniform blocks in section 7.6
(Bug 11938).
 Remove required clamping of texture border colors in section 8.14.2 and
make out-of-range values unde?ned, since not all hardware supports this
(Bug 14442).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 721
 Add missing error for VertexAttrib*Pointer in section 10.3.2 of the core
pro?le when no vertex array object is bound (Bug 10694).
 Add validation errors in section 11.1.3.11 for multiple program objects ex-
ceeding any of theCOMBINED resource limits, not just shader storage blocks
(Bug 8834).
 Attempt to rotate landscape-format state table pages when being displayed -
this is dependent on the PDF reader (Bug 11976).
Changes in the released Specification update of July 7, 2016
 Specify that queries returning unsigned integers will clamp negative state
values in section 2.2.1 (Bug 14444).
 Clean up error language around reuse of query objects in section 4.2 to make
clear that occlusion query objects created with targets ANY_SAMPLES_-
PASSED orANY_SAMPLES_PASSED_CONSERVATIVE may be speci?ed and
reused with either of those query targets (Bug 13342).
 Use consistent phrasing of “has/has been linked successfully” to describe
the link status of programs where relevant in the descriptions of conditions
for UseProgram in section 7.3, GetProgramResourceLocation* in sec-
tion 7.3.1.1, UseProgramStages and ActiveShaderProgram in section 7.4,
GetProgramBinary in section 7.5, ProgramUniform* in section 7.6.1,
GetActiveAttrib in section 11.1.1, and GetFragDataLocation and Get-
FragDataIndex in section 15.2.3.
This replaces a variety of previous usages including the rather wordy “has
not been linked, or was linked unsuccessfully” (Bug 8640).
 Clarify shader interface matching rules in section 7.4.1 so that there is no
match in the case where name, type and quali?cation match, but one variable
has alocation quali?er and the other does not (Bug 13613).
 Fixed name of formal parameter of SamplerParameter*v in section 8.2 to
params (Bug 14158).
 Relax error that prevented CompressedTex*SubImage3D from accepting
TEXTURE_CUBE_MAP andTEXTURE_CUBE_MAP_ARRAY in section 8.7 (Bug
14366).
 Simplify error language for TexParameter* and TextureParameter* in
section 8.10 (Bug 15457).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 722
 Fix name of formal parameter target to GetnTexImage in section 8.11.4.
 Specify that the COLOR_ATTACHMENTm tokens are de?ned for m in
the range [0; 31] in section 9.2, and specify that INVALID_OPERATION
errors are generated for valid COLOR_ATTACHMENTm tokens where m
is outside the range of valid color attachments for the commands
Get*FramebufferAttachmentParameteriv in section 9.2.3, *Framebuf-
ferRenderbuffer in section 9.2.7, *FramebufferTexture* in section 9.2.8,
*DrawBuffers in section 17.4.1, and InvalidateSubFramebuffer and In-
validateNamedFramebufferSubData in section 17.4.4 (Bug 13858).
 Add missing validation error for the target argument of BindRenderbuffer
in section 9.2.4 (Bug 14283).
 Add missing constraint for two-dimensional multisample array textures on
the level argument of *FramebufferTextureLayer in section 9.2.8 (Bug
14189).
 Rewrite layer validation errors for *FramebufferTextureLayer in sec-
tion 9.2.8 to break out validation by texture dimensionality and specify the
correct constraint for cube map array textures, matching the OpenGL ES
speci?cation.
 Remove description of component layout quali?ers affecting values as-
signed to attribute variables of matrix type in section 11.1.1 (Bug 15326).
 Remove description of OpenGL Shading Language as not supporting multi-
dimensional arrays from sections 11.2.1.2 and 11.2.3.3 (Bug 13824).
 Specify in section 11.3.1 that the mode parameter used for validating geom-
etry shaders depends on whether or not a tessellation evaluation shader is
active (Bug 14141).
 Remove clause from section 13.3.2 specifying an error for ResumeTrans-
formFeedback if the active program object has been relinked since trans-
form feedback became active for the current transform feedback object (Bug
15414).
 Cleanup the description of fragment coordinate w in section 15.2.2 (Bug
f
5434).
 Update the description of gl_SampleMaskIn in section 15.2.2 and gl_-
SampleMask in section 15.2.3 to refer to the maximum number of sam-
ples supported for any renderable internal format, and make corresponding
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 723
changes to the de?nitions of theMAX_ SAMPLES queries in table 23.69 (Bug
*
15792, based on ES bug 15122).
 Fix work group size limit error for DispatchCompute in section 19 (Bug
15069).
 Cleanup introduction to section 23, ?x type ofSYNC_FLAGS in table 23.50,
and addCONTEXT_PROFILE_MASK in table 23.56 (Bug 5581).
 Rewrite appendix D to refer to the Khronos Data Format Specification for
the de?nition of formats (Bug 15255).
Changes in the released Specification update of May 28, 2015
 Fix minor typos found during OpenGL ES spec updates.
 Add language to section 4.1.2 tightening the behavior of SYNC_FLUSH_-
COMMANDS_BIT to only guarantee that commands are ?ushed up to and in-
cluding the FenceSync command (Bug 11525).
 Change description ofMAP_COHERENT_BIT for buffer storage in section 6.2
so that barriers with CLIENT_MAPPED_BUFFER_BARRIER_BIT does not
need to make CPU writes visible to the GPU in this case without an explicit
?ush (Bug 13578).
 Add language for arrays of arrays to the generation of active resource lists in
section 7.3.1 (Bug 13004).
 Add language in sections 7.3.1, 7.3.1.1, and 11.1.2.1 allowing program in-
terface queries to distinguish between entire arrays and array elements for
transform feedback resources (Bug 12787).
 Specify thatshared andstd140 layout uniform blocks and their members
are always active in section 7.6 (Bug 10182).
 Clarify the interaction of multisample write masks, shader side effects, and
early per-fragment tests. Update the description of rasterization at the start
of chapter 14 and in ?gure 14.1, and add language in sections 7.13.1 and
14.9. Move pixel ownership, scissor, and multisample fragment operations
from section 17.3 into sections 14.9.1 and 14.9.2, note that stencil test, depth
test, and occlusion query operations may be performed prior to fragment
shading if requeseted by the shader, and update ?gure 17.1 to match. Move
description of the application of gl_SampleMask from section 14.9.3 to
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 724
section 15.2.3. Split alpha to coverage from multisample fragment oper-
ations, leaving the former in section 17.3.1. Update section references in
table 23.11 (Bug 12936).
 Strike INVALID_ENUM error for invalid packed depth-stencil format/type
combinations in section 8.4.4; it is covered by the generic special interpre-
tation language in section 8.4.4.2. Also change the error for invalid integer-
?oat format/type mismatches toINVALID_OPERATION in section 8.4.4 (Bug
11167).
 Add missing error conditions in section 8.5 when specifying texture images
with speci?c compressed internal formats and there’s a texture dimensional-
ity and/or target mismatch with the format (Bug 11239).
 Added a de?nition of the effective internal format corresponding to base
formats in section 8.5 (without going into detail on how it is determined,
unlike the OpenGL ES Specification), and modi?ed the descriptions of for-
mat matching for TextureView in section 8.18 and CopyImageSubData in
section 18.3.2 to use the effective internal format where appropriate (Bug
13111).
 Fix error for invalid target to GetTexSubImage* in section 8.6 to generate
INVALID_ENUM instead ofINVALID_VALUE (Bug 13563).
 Add errors to *Tex*SubImage3D (section 8.6 and to GetTexture*Image
and GetCompressedTextureImage (section 8.11.4) in the cases where
the target or effective target of the texture is TEXTURE_CUBE_MAP or
TEXTURE_CUBE_MAP_ARRAY, and the texture is not cube complete or cube
array complete, respectively (Bug 13223).
 De?ne initial state for sampler objects min ?lter and wrap modes in ta-
ble 23.18, instead of deferring it to inapplicable language describing these
parameters for texture objects as dependent on the texture type. Add a foot-
note noting this for CreateSamplers in section 8.2 (Bug 13499).
 Add missing language from ARB_gpu_program5 describing comp argu-
ment to textureGather , and textureGatherOffsets commands in
*
section 8.14.2. This language should have been included in the OpenGL 4.0
Specification, but was left out by mistake (Bug 5910).
 Specify that the values returned for RGBA texture sampling and fetches
from incomplete textures are in ?oating-point format, in sections 8.14.2
and 11.1.3.5 (Bug 13525).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 725
 Drop redundant bullet point in the list of texture incompleteness conditions
at the end of section 8.17 (Bug 12791).
 Fix typo for DEPTH_STENCIL_TEXTURE_MODE (was improperly shown as
DEPTH_TEXTURE_STENCIL_MODE in section 8.22) (Bug 13590).
 Restore the initial value of internal format for buffer textures in the compati-
bility pro?le toLUMINANCE8 in section 8.22 and table 23.16, ?xing an error
introduced in earlier GL specs (Bug 10185).
 Restore cube map arrays, which were accidentally removed, to the list
of framebuffer attachment completeness conditions in section 9.4.1 (Bug
11201).
 Rewrite the beginning of section 11.1.3.2 to clarify which operations are and
are not performed duringtexelFetch operations (Bug 13833).
 Allow errors resulting from user-de?ned tessellation control inputs and out-
puts, and tessellation evaluation inputs that are not speci?ed to be arrays
exactly gl_MaxPatchVertices long to be detected at compile time, as
well as link time in sections 11.2.1.2, 11.2.1.2.3 and 11.2.3.3 (Bug 12185).
 Clarify in section 14.3.1 that querying SAMPLE_POSITION returns a shad-
ing sample location, not a rasterization or coverage sample location (Bug
13484).
 Align language withGL_OES_sample_shading in section 14.3.1.1.
 Rearrange description of gl_SampleMaskIn in section 15.2.2 following
variables whose use can kick off per-sample shading, and mention that (by
symmetry withGL_OES_sample_variables).
 Add explicit errors list for GetPointerv and GetString in section 22.2.
 Fix description ofMAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS in
table 23.58 to re?ect that it is the maximum for all outputs, not per-patch
outputs (Bug 13765).
Changes in the released Specification update of February 2, 2015
 Remove reference to nonexistent ARRAY_SIZE language in the discussion
of array trimming for active variables in section 7.3.1 (Bug 13445).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 726
 Remove unimplementable TEXTURE_BINDING query from description of
BindTexture in section 8.1, section 22.5, and table 23.13 (Bug 13278). Also
removed in GL_ARB_direct_state_access speci?cation and the spec-
?le and headers in the Registry.
Changes in the released Specification update of October 30, 2014
 Restore language describing non-sequentiality of resource locations for con-
secutive active array elements in section 7.3.1 (Bug 12318).
 Restore description ofMAX_UNIFORM_BLOCK_SIZE in section 7.6.2, which
was lost in the restructuring and program interface query language intro-
duced in OpenGL 4.3, but change behavior so that exceeding the limit will
cause link failure, compared to may cause link failure in the 4.2 language
(Bug 12897).
 Add NEAREST_MIPMAP_NEAREST to the allowed ?lter modes for
STENCIL_INDEX textures in section 8.17 (Bug 12791).
 Modify behavior of primitive restart in section 10.3.6 to only apply to
*DrawElements* commands for both forms of primitive restart, matching
shipping drivers (Bug 12893).
 Rearrange descriptions of DrawArraysOneInstance, DrawElementsOne-
Instance, and the actual DrawElements* commands in section 10.4 to use
the term “vertex ID” when referring to the actual element index of an ele-
ment transferred to the GL, and make clear that the vertex ID does include
the basevertex value passed to the DrawElements*BaseVertex commands
(Bug 12756).
 Add description of conditions for which multisample texel fetch operations
are unde?ned in section 11.1.3.3 (Bug 12255).
 Modify the end of section 13.7.1 to remove language requiring that integer
outputs be quali?ed as flat, since fragment shader inputs now control as
described in the OpenGL Shading Language Specification (Bug 12623).
 In the description of the source of the derived point size when program point
size mode is enabled in section 14.4, remove the unreachable case where a
tessellation evaluation shader is active, but no tessellation control shader or
geometry shader is active (Bug 12865).
 Add missing error for invalid target argument to InvalidateSubFrame-
buffer in section 17.4.4 (Bug 12727).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 727
 Restore description of TEXTURE_BUFFER_OFFSET_ALIGNMENT in ta-
ble 23.55, UNIFORM_BUFFER_OFFSET_ALIGNMENT in table 23.63, and
SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT in table 23.64 to refer
to them as minimum require alignments, while the footnote in the caption
continues to note that the numeric limits are the maximum allowed values
(Bug 11962).
 Increase the minimum values forMAX_GEOMETRY_UNIFORM_COMPONENTS
and MAX_COMPUTE_UNIFORM_COMPONENTS from 512 to 1024 in ta-
bles 23.60 and 23.62, respectively. This makes the minimums consistent
across all shader stages (Bug 12731).
Changes in the released Specification update of September 19, 2014
 Clarify description of the initial state of query objects for CreateQueries
and BeginQueryIndexed in section 4.2 (Public Bug 1213).
 Add DSA-style GetQueryBufferObject* queries along with GetQueryOb-
ject* in section 4.2.3 (Public Bug 1214).
 Add missing MapNamedBufferRange to description ofMAP_COHERENT_-
BIT in section 6.2 (Public Bug 1208).
 Modify description of active resource list enumeration in section 7.3.1 to
treat only arrays of aggregate types as top-level arrays, and clarify how this
applies to GetProgramResourceiv queries TOP_LEVEL_ARRAY_SIZE and
TOP_LEVEL_ARRAY_STRIDE (Bug 11753).
 Clarify behavior of rendering to multiple framebuffer object attachments of
different sizes in section 9.2 (Bug 10403).
 Add FRONT and BACK as valid attachment names for
Get*FramebufferAttachmentParameteriv in section 9.2.3 (Bug 12695).
Changes in the released Specification of August 11, 2014:
 Added new features as described in section I.1.
 Cleanup many bugs and typos (public Bug 1186).
 Clean up reference to texture borders in the core pro?le, where borders must
always be zero width, simplifying equations (Bug 10507).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 728
 Replace all uses of “texel array” and “image array” with “texture image” or
“image” as appropriate, to avoid confusion with array texture types.
 Use “max.”, “min.”, and “no.” consistently throughout state tables instead of
“maximum”, “minimum”, and “number”.
 Make description of WebGL in section 1.3.5 consistent with the OpenGL ES
3.1 Specification.
 Change required size ofboolean from “1 or more” bits to exactly 8 bits in
table 2.2, matching OpenGL ES 3.1 (Bug 11847).
 Clarify in equations 2.3 and 2.4 that either truncation or rounding are ac-
ceptable when converting from ?oating-point to normalized ?xed-point (Bug
9976).
 Simplify and generalize language about object and name lifetimes in sec-
tion 5.1.3 to make clear that an active query object behaves like an object
attachment (Bug 12161).
 Add missing validation error for invalid target parameters to MapBuffer-
Range in section 6.3.
 Simplify language in section 6.3.2 to remove confusing reference to “invalid
reads, writes, or state changes” to mapped buffer objects (Bug 12300).
 Modify error condition for invalid buffer binding target arguments to Copy-
BufferSubData in section 6.6 to INVALID_ENUM instead of INVALID_-
VALUE.
 Make LinkProgram fail with an empty program object (one with no shaders
attached) in the core pro?le only, in section 7.3 (Bug 12215).
 Fix error condition for UseProgram in section 7.3 (Bug 12281).
 Fix description of LINK_STATUS for GetProgramiv in section 7.14 (Bug
9698).
 Change the variable representing compressed texture block size toblocksize
in section 8.7, to avoid confusion with the texture border width b used in
s
many other places.
 Clarify that ?lter state is ignored for multisample texture access in sec-
tions 8.8 and 11.1.3.3 (Bug 12171).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 729
 IncludeMIRROR_CLAMP_TO_EDGE in the wrap modes not allowed for rect-
angle texture targets in the description of TexParameter* in section 8.10
(public Bug 1186).
 Make the mini?cation vs. magni?cation switch-over point always zero in
sections 8.14.3 and 8.15 (Bug 9997).
 Strike irrelevant clause from description of error condition for numlayers
argument to TextureView in section 8.18 (Bug 11891).
 Add an error for TextureView in section 8.18 if the computed number of
levels or layers for the new texture view is not positive (Bug 12256).
 Update errors for TexStorage*DMultisample in section 8.19 to include an
appropriate subset of the generic errors for Tex*Storage*D commands de-
?ned in section 8.19, and remove redundant errors from the latter commands
(Bug 11937).
 Allow GetFramebufferParameteriv and GetNamedFramebufferParam-
eteriv in section 9.2.3 to be used to query the framebuffer-dependent state in
table 23.73, including queries for the default framebuffers (Bug 12360).
 Add missing error for invalid attachment arguments of GetFramebufferAt-
tachmentParameteriv and GetNamedFramebufferAttachmentParame-
teriv in section 9.2.3.
 Fix error condition for GetFramebufferAttachmentParameteriv in sec-
tion 9.2.3 (Bug 12180).
 Moved description of SAMPLE_BUFFERS and SAMPLE_BUFFERS from sec-
tion 9.4.2 to new section 9.2.3.1, and add a comment about the effective
value of these parameters for framebuffer objects other than the currently
bound draw framebuffer. Change references to these parameters accordingly
in sections 8.6, 14.3.1, 18.2.2, and 18.3.1 (Bug 12360).
 Add missing cube map array textures to list of layered texture types for
FramebufferTexture in section 9.2.8 (Bug 12336).
 Restore missing error condition for CheckFramebufferStatus target argu-
ment in section 9.4.2.
 Clarify in section 10.4 that DrawArrays transfers no elements when count
is zero (Bug 10015).
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.3. CHANGELOGFORRELEASEDSPECIFICATIONS 730
 Specify the values ofgl_VertexID in the descriptions of drawing pseudo-
commands DrawArraysOneInstance and DrawElementsOneInstance in
section 10.4 (Bug 12202).
 Removecount from the list of parameters validated in the pseudocode for
MultiDrawElements in section 10.4, since it’s an array, not a value (Bug
7004).
 Clarify that MultiDrawArraysIndirect and MultiDrawElementsIndirect
in section 10.4 share the same errors as the comparable non-MultiDraw*
commands, and throughout the spec, clarify relevant pseudocode examples
with “(assuming no errors are generated)” (Bug 12351).
 Add description of ELEMENT_ARRAY_BUFFER_BINDING. to section 10.5
(Bug 11042).
 Fix list of required state in section 10.6 and table 23.4 (Bug 10283).
 Clarify description of BindAttribLocation in section 11.1.1 (Bug 12186).
 Make validation fail in section 11.1.3.11 when an empty program pipeline
object (one with no code for any shader stage) is current (Bug 12176).
 Add language for robust buffer access in section 11.1.3.12 expanding the
de?nition of what can be returned from out-of-bounds shader reads within a
buffer object (Bugs 10826, 12104).
 Modify descriptions of tessellation in sections 11.2.2, 11.2.2.1, and 11.2.2.2
to clarify that tessellation may produce multiple vertices with the samegl_-
TessCoord values under some conditions (Bug 11979).
 Fixed DebugMessageInsert in section 20.5 so error for invalid severity
arguments is INVALID_ENUM, matching ARB_debug_output, instead of
INVALID_VALUE.
 Change title of section 22.2 to more accurately describe the contents (Bug
12352).
 Change query commands for buffer storage state in table 23.6 to GetBuffer-
Parameteriv (Bug 12307).
 Change the description column for TEXTURE_BUFFER_OFFSET_-
ALIGNMENT in table 23.55, UNIFORM_BUFFER_OFFSET_ALIGNMENT in
table 23.63, and SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT in
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.4. CREDITS 731
table 23.64 to refer to them as maximum, not minimum, values, consistently
with the footnote in the caption (Bug 11962).
 Clean up caption for table 23.73 to accurately describe which FBO binding
is used for different queries (Bug 12360).
I.4 Credits
OpenGL 4.5 is the result of the contributions of many people and companies. Mem-
bers of the Khronos OpenGL ARB Working Group during the development of
OpenGL 4.5, including the company that they represented at the time of their con-
tributions, follow.
Some major contributions made by individuals are listed together with their
name, including speci?c functionality developed in the form of new ARB exten-
sions together with OpenGL 4.5. In addition, many people participated in develop-
ing earlier vendor and EXT extensions on which the OpenGL 4.5 functionality is
based in part; those individuals are listed in the respective extension speci?cations
in the OpenGL Registry.
Acorn Pooley, NVIDIA
Alex Corscadden, VMware
Anton Staaf, Google
Aras Pranckevicius, Unity
Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
Bill Licea-Kane, Qualcomm
Brian Paul, VMware Inc. (GL_ARB_conditional_render_inverted,GL_-
ARB_cull_distance,GL_ARB_get_texture_sub_image)
Bruce Merry, ARM
Chris Marrin, Apple
Christoph Kubisch, NVIDIA
Christophe Riccio, Unity (GL_ARB_direct_state_access)
Daniel Koch, NVIDIA
Daniel Rakos, AMD
Dominik Witczak, Samsung Electronics (reference pages)
Evan Hart, NVIDIA
Graham Sellers, AMD (GL_ARB_direct_state_access)
Greg Roth, NVIDIA
Ian Romanick, Intel
Jaroslaw Lipowski (extensive proofreading in public bug 1186)
Jason Mitchell, Valve
OpenGL 4.6 (Core Pro?le) - February 2, 2019I.5. ACKNOWLEDGEMENTS 732
Jeannot Breton, NVIDIA
Jeff Bolz, NVIDIA (GL_ARB_texture_barrier)
Jesse Hall, Google
John Kessenich, Independent (OpenGL Shading Language Specification Editor,
GL_ARB_derivative_control)
John McDonald, NVIDIA
Jon Leech, Independent (OpenGL API Specification Editor, reference pages)
Kenneth Russell, Google
Kent Miller, Apple
Lingjun (Frank) Chen, Qualcomm
Mark Callow, ArtSpark
Mark Kilgard, NVIDIA (GL_ARB_clip_control,GL_ARB_robustness)
Mathias Schott, NVIDIA (GL_ARB_shader_texture_image_samples)
Nick Penwarden, Epic Games
Pat Brown, NVIDIA
Patrick Doane, Blizzard
Piers Daniell, NVIDIA (GL_ARB_shader_texture_image_samples, GL_-
ARB_ES3_1_compatibility)
Robert Simpson, Qualcomm
Simon Bennett, VMware
Stefan Dsinger, CodeWeavers
Tim Foley, Intel
Timo Suoranta, Broadcom
Timothy Lottes, Epic Games
Tom Olson, ARM
Tristan Lorach, NVIDIA
Vladimir Vukicevic, Mozilla
I.5 Acknowledgements
The ARB gratefully acknowledges administrative support by the members of Gold
Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Fredericks,
and Michelle Clark, and technical support from James Riordon, webmaster of
Khronos.org and OpenGL.org.
The “pipeline metro” cover image was created by Dominic Agoro-Ombaka of
Gold Standard Group.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix J
Version 4.6
OpenGL version 4.6, released on July 31, 2017, is the eighteenth revision since the
original version 1.0.
Separate versions of the OpenGL 4.6 Specification exist for the core pro?le
and compatibility pro?le described in appendix E, respectively subtitled the “Core
Pro?le” and the “Compatibility Pro?le”. This document describes the Core Pro?le.
An OpenGL 4.6 implementation must be able to create a context supporting the
core pro?le, and may also be able to create a context supporting the compatibility
pro?le.
Material speci?c to the compatibility pro?le speci?cation is marked in a dis-
tinct color to clearly call out differences between the two pro?les.
The OpenGL 4.6 compatibility and core pro?les are upward compatible with
the OpenGL 4.5 compatibility and core pro?les, respectively (see appendix I).
Following are brief descriptions of changes and additions to OpenGL 4.6. De-
scriptions of changes and additions in versions of OpenGL prior to 4.2 are omitted
in this Specification, but may be found in the OpenGL 3.0 Specification (for fea-
tures in versions 1.0 - 3.0, inclusive) and the OpenGL 4.2 Specification (for features
in versions 3.1 - 4.1, inclusive). These Specifications are available in the OpenGL
Registry.
J.1 New Features
New features in OpenGL 4.6, including the extension or extensions if any on which
they were based, include:
 GL_ARB_indirect_parameters
 GL_ARB_pipeline_statistics_query
733J.2. DEPRECATIONMODEL 734
 GL_ARB_polygon_offset_clamp
 GL_KHR_no_error
 GL_ARB_shader_atomic_counter_ops (OpenGL Shading Language
Only)
 GL_ARB_shader_draw_parameters
 GL_ARB_shader_group_vote (OpenGL Shading Language Only)
 GL_ARB_gl_spirv
 GL_ARB_spirv_extensions
 GL_ARB_texture_filter_anisotropic
 GL_ARB_transform_feedback_overflow_query
J.2 Deprecation Model
No new features are deprecated, and no previously deprecated features are re-
introduced by the OpenGL 4.6 core pro?le.
Features deprecated by OpenGL 4.5 remain deprecated, but have not yet been
removed.
J.3 Change Log Descriptions
In the change logs below, a comment like (github #16) refers to a public Github
issue on the https://github.com/KhronosGroup/OpenGL-API/ repository; (Public
Bug 1432) refers to a public Bugzilla issue at https://www.khronos.org/bugzilla;
(gitlab #40) refers to a private issue on Khronos’ internal server; and (Bug 16315)
refers to a private Bugzilla issue on Khronos’ internal server.
J.4 Change Log for Released Specifications
Changes in the released Specification of February 2, 2019
 Fix minor a/an grammar issues (gitlab #101).
 Fix “builtin”! “built-in” in a few places.
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.4. CHANGELOGFORRELEASEDSPECIFICATIONS 735
 Use the term “workgroup” consistently instead of “work group” (internal
issue #87 - just a typo, so not marked everywhere the change was done).
 Use explicit errors for negative sizei parameters everywhere for consis-
tency, even though there’s a generic error described in section 2.3.1 (gitlab
#52).
 Modify description of conversion behavior for normalized ?oating-point val-
ues in sections 2.3.5.1 and 8.5 so that they are not clamped on upload (Bug
13802).
 Clarify enumeration of block members for arrays of uniform and shader stor-
age buffer objects in section 7.3.1.1 (gitlab #94).
 Clarify shader interface matching in section 7.4.1 so that the built-in inter-
face blocks between vertex shaders and downstream shaders match (Bug
16124).
 Generate an INVALID_OPERATION error for GetProgramBinary in sec-
tion 7.5 if there are no de?ned binary formats (Bug 16155).
 Clean up de?nition of which uniform blocks count against combined limits
in section 7.6.2 (gitlab #69).
 Make clari?cations on uniform and shader storage buffer object layout re-
quirements in section 7.6.2.3 (gitlab #92).
 AddTEXTURE_CUBE_MAP orTEXTURE_CUBE_MAP_ARRAY as valid targets
for CompressedTexImage3D in section 8.7 (Bug 14713)
 Update the texture level-of-detail equation to better approximate ellipse ma-
jor and minor axes for anisotropic sampling in section 8.14, and use the same
terminology as the isotropic sampling case (gitlab #5).
Clarify language in section 9.2.3 about valid GetFramebufferAttachment-
Parameteriv queries when the value of FRAMEBUFFER_ATTACHMENT_-
OBJECT_TYPE isNONE (Bug 16198).
 Specify in section 11.1.3.4 that textureSize returns unde?ned values
when the texture is incomplete (Bug 11750).
 Add a footnote to section 11.1.3.11 clarifying that unlike OpenGL ES,
OpenGL does not require validation to detect mismatched interfaces between
shader stages (Bug 15331).
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.4. CHANGELOGFORRELEASEDSPECIFICATIONS 736
 Modi?ed BeginTransformFeedback language about simultaneous use of
buffers for transform feedback and other operations in section 13.3.2 to en-
sure this behavior is unde?ned (gitlab #83).
 Specify std430 as a base layout for compute shader uniform storage re-
quirements in section 19.1 (github #40).
Changes in the released Specification of May 14, 2018
 Clarify unde?ned GL behavior with no current context in section 2.1 (Bug
11522).
 Add a footnote to the description of Flush in section 2.3.3 explaining histor-
ical reasons for its inconsistent behavior (Bug 13916).
 Note in section 2.6.6 that texture objects contain a data store. Change the
feedback loop language in section 9.3 to refer to the data store rather than
the texture object, and include texture views as ways to create feedback loops
(Bug 11934).
 Drop now-irrelevant language in section 6.1 saying that the GL may make
different choices about storage location and layout based on the initial bind-
ing (github #23).
 Clarify for Clear*BufferSubData in section 6.2.1 that there are no compat-
ibility restrictions between the format and type of the speci?ed clear color,
and the internal format to be stored in the buffer (Bug 16232).
 Clarify error for glSpecializeShader in section 7.2.1, and add a new error if
shader types mismatch (github #16).
 Add descriptions of COMPATIBLE_SUBROUTINES and
NUM_COMPATIBLE_SUBROUTINES to the GetProgramResourceiv queries
described in section 7.3.1.1 (gitlab #40).
 Specify that only a single integer is written for several resources already de-
scribed as queriable with GetProgramResourceiv in section 7.3.1.1 (github
#35).
 Clarify in section 7.4.1 that output blocks that match in all ways except their
name are not guaranteed to match (Bug 15338).
 RequireBinding for uniform and shader storage blocks in section 7.4.2 and
add whitelist for accepted storage classes in section C.4 (github #5, gitlab
#55)
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.4. CHANGELOGFORRELEASEDSPECIFICATIONS 737
 Specify in section 7.7.1 that the value of UNIFORM_ARRAY_STRIDE) for
atomic_uint arrays is always 4 (gitlab #31).
 Added description of storage block activeness in section 7.8, based on that
of uniform blocks (Bug 13745, gitlab #63).
 Add new section 7.9 de?ning invocation groups, as used in the OpenGL
Shading Language Specification (github #15).
 Add MultiDraw*IndirectCount and PARAMETER_BUFFER to the list of
commands whose buffer bindings can be affected byCOMMAND_BARRIER_-
BIT in the discussion of MemoryBarrier in section 7.13.2 (github #17).
 Use the term “work group size” consistently in section 7.14 and chapter 19,
instead of a mix of similar terms usually starting with “local” (Bug 11723).
 Remove error in section 8.6 for the *TexSubImage3D commands when tar-
get is TEXTURE_CUBE_MAP_ARRAY, and the target image is not cube ar-
ray complete. This was inappropriately added and should only exist for the
*TextureSubImage3D commands (Bug 13223).
 Fix typo (missing comma) in prototype for TextureParameterI* in sec-
tion 8.10 (Public Bug 1432).
 Drop reference in section 8.14.1 to the no-longer-used mini?cation switch-
over valuec and replace with 0:0 (github #34).
 Specify in section 8.14.4 that mimap generation has no effect when any
level dimension is zero (gitlab #72).
base
 Add a requirement to the Generate*Mipmap commands in section 8.14.4
that any synchronization required before performing mipmap reduction will
be done within the commands themselves (Public Bug 1429).
 Add error for Tex*Storage3D in section 8.19 when target is TEXTURE_-
CUBE_MAP_ARRAY and depth is not a multiple of 6 (Public Bug 1439).
 Clarify meaning of FULL_SUPPORT for FRAMEBUFFER_RENDERABLE and
FRAMEBUFFER_RENDERABLE_LAYERED in section 9.4.3 (Public Bug 689).
 Modify the description of indirect commands in buffer objects in sec-
tion 10.3.11 to say that indirect parameters are sourced from the indirect
buffer in the core pro?le, and may be sourced from it in the compatibility
pro?le (Public Bug 1082).
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.4. CHANGELOGFORRELEASEDSPECIFICATIONS 738
 Remove assertions that OpenGL Shading Language does not support multi-
dimensional arrays in sections 11.2.1.2.3 and 11.3.4.4 (gitlab #62).
 Specify that interpolation of vertex outputs is controlled by fragment shader
input quali?ers at the beginning of section 11.1.3.10 (github #10).
 Move de?nition of upstream shader for geometry shaders from sec-
tion 11.3.4.4 to section 11.3.3 (Bug 14158).
 Use new terminology for the “last active vertex processing stage” and “when
a vertex processing stage is active”, rather than referring to “vertex shader
outputs” and “when a vertex shader is active”, respectively. This allows the
same language to apply to outputs from the shading pipeline coming from
any of vertex, tessellation evaluation, or geometry shaders. These changes
are made in a new section 13.2 and in sections 13.3, 13.3.2, 13.6, 13.7,
13.7.1, and 14.4 (github #9).
 Add a footnote to the description of BindTransformFeedback in sec-
tion 13.3.1 explaining that the generic bind point should not be affected
by this command, and move TRANSFORM_FEEDBACK_BUFFER_BINDING
generic binding state from the transform feedback object state table 23.48 to
the context transformation state table 23.7 (gitlab #66).
 Clarify near the end of section 13.3.2 that a buffer object must be bound for
transform feedback only if the buffer is active (gitlab #38).
 Remove duplicate de?nition of “fragment” near the beginning of section 14
(Public Bug 1388).
 Ensure discussion of polygon vertex lighting in section 14.6.4 appears in the
compatibility pro?le (github #18).
 Simplify description of per-sample shading in section 15.2.2 and clarify the
requirements on the interaction betweengl_SampleMaskIn and MinSam-
pleShading (gitlab #45).
 Clarify occlusion query description in section 17.3.5 to refer to fragments
that are not discarded by earlier stages, rather than fragments that pass the
depth test (github #19).
 Don’t require that textures passed to CopyImageSubData in section 18.3.2
be mipmap complete, by ignoring format-based completeness rules (Bug
16224).
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.4. CHANGELOGFORRELEASEDSPECIFICATIONS 739
 Fix error for DispatchComputeIndirect in section 19 to refer to
DISPATCH_INDIRECT_BUFFER instead ofDRAW_INDIRECT_BUFFER (git-
lab #41).
 Clarify comparison of internal format queries to GetTexLevelParameter*
in section 22.3.2, so that internal formats not supported by that command are
still valid queries (gitlab #65).
 Specify
in section C.4 that OpImageQuerySizeLod and OpImageQueryLevels
only work withSampled images (gitlab #73).
 Fix typo in table D.2 (Public Bug 1920).
Changes in the released Specification of July 30, 2017:
 Added new features as described in section J.1.
 Update cover image to OpenGL 4.6 (gitlab #16).
 Numerous minor typographical cleanups (gitlab #25), and use “level-of-
detail” consistently, replacing occasional usage of “level of detail”. These
are not marked in color.
 Direct bug reports to API and GLSL Github repositories, instead of Bugzilla,
in section 1.4 (gitlab #2).
 Add SPIR-V to the Related APIs in section 1.3.4, and refer to this section
from the SPIR-V Execution Environment appendix in section C (gitlab #2).
 Added clarifying language to section 2.3.1 specifying when INVALID_-
OPERATION errors are generated vs. INVALID_ENUM (gitlab #7).
 Change reporting ofOUT_OF_MEMORY errors in section 2.3.1.1 (gitlab #14).
 Add the pipeline statistics query targets to those for which the index parame-
ter of BeginQueryIndexed and EndQueryIndexed in section 4.2.2, and of
GetQueryIndexediv in section 4.2.3, must be zero (gitlab #26).
 Add new subsections 4.2.1 and 4.2.2, with existing content. Refer to the table
of query object targets in section 4.2.1 for error purposes in BeginQueryIn-
dexed and related commands in the descriptions of CreateQueries, Begin-
QueryIndexed, EndQueryIndexed, and GetQueryIndexediv (gitlab #18).
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.4. CHANGELOGFORRELEASEDSPECIFICATIONS 740
 Fix reference to theBuiltIn decoration (not variable) in section 7.4.2 (git-
lab #32).
 Minor cleanup of SPIR-V interface language in section 7.4.2 and table C.6,
and clarifyOpTypeRuntimeArray restriction in section C.4 (gitlab #20).
 ClarifyRECTANGLE_TEXTURE and compressed texture interactions in errors
for *Tex*SubImage2D in section 8.6, CompressedTexImage2D in sec-
tion 8.7, and Tex*Storage2D in section 8.19 (gitlab #10).
 Change errors for invalid effective targets of TextureBufferRange in sec-
tion 8.9, TextureParameter* in section 8.10, GetTextureParameter* in
section 8.11.2, GetTextureLevelParameter* in section 8.11.3, and Get-
TextureImage in section 8.11.4 from INVALID_VALUE to INVALID_-
OPERATION (gitlab #22).
 Change some errors for GetTextureSubImage in section 8.18 and Inval-
idateTexSubImage in section 8.20 from INVALID_VALUE to INVALID_-
OPERATION (gitlab #17).
 Tweak language for TextureStorage1D errors in section 8.19 to update gen-
erated error for the wrong effective target (gitlab #8).
 Change level limit for *FramebufferTexture*D and *FramebufferTex-
tureLayer in section 9.2.8 from the value of TEXTURE_IMMUTABLE_-
LEVELS to that of TEXTURE_VIEW_NUM_LEVELS, to account for texture
views (gitlab #19).
 Remove incorrectly-applied language forgl_DrawID that had been applied
to DrawArraysInstancedBaseInstance in section 10.4 (gitlab #21).
 AddTEXTURE_MAX_ANISOTROPY parameter to sampler state in table 23.18,
as well as texture object state (gitlab #15).
 Change required state for QUERY_COUNTER_BITS in table 23.69 and
CURRENT_QUERY in table 23.74 from 18E to nE to avoid having
to track the total number of otherwise unrelated pieces of queryable state
(gitlab #11).
 Refer to the tables in section C instead of saying “above” or “below”, since
these tables are ?oats that may shift their position in the document as other
material is added and removed, and clean up related language in section C.6
(gitlab #2).
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.5. CREDITS 741
J.5 Credits
OpenGL 4.6 is the result of the contributions of many people and companies. Mem-
bers of the Khronos OpenGL ARB Working Group during the development of
OpenGL 4.6, including the company that they represented at the time of their con-
tributions, follow.
Some major contributions made by individuals are listed together with their
name, including speci?c functionality developed in the form of new ARB exten-
sions together with OpenGL 4.6. In addition, many people participated in develop-
ing earlier vendor and EXT extensions on which the OpenGL 4.6 functionality is
based in part; those individuals are listed in the respective extension speci?cations
in the OpenGL Registry.
Brian Paul, VMware (ARB_pipeline_statistics_query,
ARB_transform_feedback_overflow_query)
Christophe Riccio, OpenGL Garden / Unity
Daniel Kartch, NVIDIA
Daniel Koch, NVIDIA (ARB_gl_spirv,ARB_spirv_extensions)
Daniel Rakos, AMD (ARB_shader_atomic_counter_ops)
David Blythe, SGI
Dominik Witczak, AMD
Eric Lengyel, Terathon Software
Graham Sellers, AMD (ARB_indirect_parameters,ARB_shader_draw_-
parameters)
James Jones, NVIDIA
Jan-Harald Fredriksen, ARM
John Kessenich, Google (ARB_gl_spirv)
Jon Leech, Independent (OpenGL API Specification Editor)
Mark Kilgard, NVIDIA (EXT_texture_filter_anisotropic on which the
ARB functionality was based)
Maurice Ribble, Qualcomm (KHR_no_error)
Pat Brown, NVIDIA (ARB_shader_group_vote)
Piers Daniell, NVIDIA (Chair, Khronos OpenGL Working Group; ARB_-
polygon_offset_clamp,ARB_texture_filter_anisotropic)
Steve Hill, Broadcom
Tobias Hector, Imagination Technologies
Walt Donovan, NVIDIA
OpenGL 4.6 (Core Pro?le) - February 2, 2019J.6. ACKNOWLEDGEMENTS 742
J.6 Acknowledgements
The ARB gratefully acknowledges technical support by James Riordon, webmaster
of Khronos.org and OpenGL.org.
The “pipeline metro” cover image was created by Dominic Agoro-Ombaka.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Appendix K
OpenGL Registry, Header Files,
and ARB Extensions
K.1 OpenGL Registry
Many extensions to the OpenGL API have been de?ned by vendors, groups of
vendors, and the OpenGL ARB. In order not to compromise the readability of
the OpenGL Specification, such extensions are not integrated into the core lan-
guage; instead, they are made available online in the OpenGL Registry, together
with extensions to window system binding APIs, such as GLX and WGL, and with
speci?cations for OpenGL, GLX, and related APIs.
Extensions are documented as changes to a particular version of the Speci?ca-
tion. The Registry is available on the World Wide Web at URL
http://www.opengl.org/registry/
K.2 Header Files
Historically, C and C++ source code calling OpenGL was to#include a single
header ?le, <GL/gl.h>. In addition to the core OpenGL API, the APIs for all
extensions provided by an implementation were de?ned in this header.
When platforms became common where the OpenGL SDK (library and header
?les) were not necessarily obtained from the same source as the OpenGL driver,
such as Microsoft Windows and Linux, <GL/gl.h> could not always be kept
in sync with new core API versions and extensions supported by drivers. At this
time the OpenGL ARB de?ned a new header, <GL/glext.h>, which could be
obtained directly from the OpenGL Registry (see section K.1). The combination
743K.3. ARBANDKHRONOSEXTENSIONS 744
of <GL/gl.h> and <GL/glext.h> always de?nes all APIs for all pro?les of
the latest OpenGL version, as well as for all extensions de?ned in the Registry.
<GL/glcorearb.h> de?nes APIs for the core pro?le of OpenGL, together
with ARB extensions compatible with the core pro?le. It does not include APIs for
features only in the compatibility pro?le or for other extensions.
There is currently no Khronos-supported mechanism for using vendor exten-
sions together with <GL/glcorearb.h>, due to lack of demand and lack of
knowledge on which vendor extensions are compatible with the core pro?le. In
the future, this may be addressed by a hypothetical header<GL/glcoreext.h>
which would de?ne APIs for additional EXT and vendor extensions compatible
with the core pro?le, but not de?ned in<GL/glcorearb.h>. Most older exten-
sions are not compatible with the core pro?le.
Applications using the compatibility pro?le (see appendix E) should
#include the traditional<GL/gl.h> and<GL/glext.h> headers.
Applications using the core pro?le, and which do not need to use vendor ex-
tensions, may instead#include the<GL/glcorearb.h> header.
By using <GL/glcorearb.h>, instead of the legacy <GL/gl.h> and
<GL/glext.h>, newly developed applications are given increased protection
against accidentally using a legacy feature that has been removed from the core
pro?le, and against using a less portable EXT or vendor extension. This can assist
in developing applications on a GL implementation that supports the compatibility
pro?le when the application is also intended to run on other platforms supporting
only the core pro?le.
Developers should always be able to download <GL/glcorearb.h> from
the Registry, with this headers replacing, or being used in place of older versions
that may be provided by a platform SDK.
K.3 ARB and Khronos Extensions
OpenGL extensions that have been approved by the Khronos OpenGL Architec-
tural Review Board Working Group (ARB), or jointly approved by the ARB and the
Khronos OpenGL ES Working Group (KHR), are summarized in this section. ARB
and KHR extensions are not required to be supported by a conformant OpenGL im-
plementation, but are expected to be widely available; they de?ne functionality that
is likely to move into the required feature set in a future revision of the speci?ca-
tion.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 745
K.3.1 Naming Conventions
To distinguish ARB and KHR extensions from core OpenGL features and from
vendor-speci?c extensions, the following naming conventions are used:
 A unique name string of the form ”GL_ARB_name” or ”GL_KHR_name” is
associated with each extension. If the extension is supported by an imple-
mentation, this string will be among the EXTENSIONS strings returned by
GetStringi, as described in section 22.2.
 All functions de?ned by the extension will have names of the form Func-
tionARB orFunctionKHR, respectively.
 All enumerants de?ned by the extension will have names of the form
NAME_ARB. orNAME_KHR, respectively.
 In addition to OpenGL extensions, there are also ARB extensions to the
related GLX and WGL APIs. Such extensions have name strings pre?xed by
"GLX_" and"WGL_" respectively. Not all GLX and WGL ARB extensions
are described here, but all such extensions are included in the registry.
K.3.2 Promoting Extensions to Core Features
Extensions can be promoted to required core features in later revisions of OpenGL.
When this occurs, the extension speci?cations are merged into the core speci?ca-
tion. Functions and enumerants that are part of such promoted extensions will have
the ARB, KHR, EXT, or vendor af?x removed.
Implementations of such later revisions should continue to export the name
strings of promoted extensions in theEXTENSIONS strings and continue to support
the af?xed versions of functions and enumerants as a transition aid.
For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond, see the corresponding version of the OpenGL speci?cation, or the de-
scriptions of that version in version-speci?c appendices to later versions of the
speci?cation.
K.3.3 Extension Summaries
This section describes each ARB and KHR extension brie?y. In most cases, the
functionality of these extensions also was added to a version of the OpenGL Speci-
?cation, and in these cases only the extension string is described, together with the
corresponding OpenGL version.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 746
K.3.3.1 Multitexture
The name string for multitexture isGL_ARB_multitexture. It was promoted to
a core feature in OpenGL 1.3.
K.3.3.2 Transpose Matrix
The name string for transpose matrix is GL_ARB_transpose_matrix. It was
promoted to a core feature in OpenGL 1.3.
K.3.3.3 Multisample
The name string for multisample isGL_ARB_multisample. It was promoted to a
core feature in OpenGL 1.3.
K.3.3.4 Texture Add Environment Mode
The name string for texture add mode is GL_ARB_texture_env_add. It was
promoted to a core feature in OpenGL 1.3.
K.3.3.5 Cube Map Textures
The name string for cube mapping is GL_ARB_texture_cube_map. It was pro-
moted to a core feature in OpenGL 1.3.
K.3.3.6 Compressed Textures
The name string for compressed textures isGL_ARB_texture_compression. It
was promoted to a core feature in OpenGL 1.3.
K.3.3.7 Texture Border Clamp
The name string for texture border clamp isGL_ARB_texture_border_clamp.
It was promoted to a core feature in OpenGL 1.3.
K.3.3.8 Point Parameters
The name string for point parameters is GL_ARB_point_parameters. It was
promoted to a core features in OpenGL 1.4.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 747
K.3.3.9 Vertex Blend
Vertex blending replaces the single model-view transformation with multiple ver-
tex units. Each unit has its own transform matrix and an associated current weight.
Vertices are transformed by all the enabled units, scaled by their respective weights,
and summed to create the eye-space vertex. Normals are similarly transformed by
the inverse transpose of the model-view matrices.
The name string for vertex blend isGL_ARB_vertex_blend.
K.3.3.10 Matrix Palette
Matrix palette extends vertex blending to include a palette of model-view matrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
The name string for matrix palette isGL_ARB_matrix_palette.
K.3.3.11 Texture Combine Environment Mode
The name string for texture combine mode isGL_ARB_texture_env_combine.
It was promoted to a core feature in OpenGL 1.3.
K.3.3.12 Texture Crossbar Environment Mode
The name string for texture crossbar is GL_ARB_texture_env_crossbar. It
was promoted to a core features in OpenGL 1.4.
K.3.3.13 Texture Dot3 Environment Mode
The name string for DOT3 is GL_ARB_texture_env_dot3. It was promoted to
a core feature in OpenGL 1.3.
K.3.3.14 Texture Mirrored Repeat
The name string for texture mirrored repeat is GL_ARB_texture_mirrored_-
repeat. It was promoted to a core feature in OpenGL 1.4.
K.3.3.15 Depth Texture
The name string for depth texture is GL_ARB_depth_texture. It was promoted
to a core feature in OpenGL 1.4.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 748
K.3.3.16 Shadow
The name string for shadow isGL_ARB_shadow. It was promoted to a core feature
in OpenGL 1.4.
K.3.3.17 Shadow Ambient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value speci?ed by the TEXTURE_COMPARE_FAIL_VALUE_ARB texture
parameter to be returned when the texture comparison fails. This may be used for
ambient lighting of shadowed fragments and other advanced lighting effects.
The name string for shadow ambient isGL_ARB_shadow_ambient.
K.3.3.18 Window Raster Position
The name string for window raster position isGL_ARB_window_pos. It was pro-
moted to a core feature in OpenGL 1.4.
K.3.3.19 Low-Level Vertex Programming
Application-de?ned vertex programs may be speci?ed in a new low-level program-
ming language, replacing the standard ?xed-function vertex, transformation, light-
ing, and texture coordinate generation pipeline. Vertex programs enable many new
effects and are an important ?rst step towards future graphics pipelines that will be
fully programmable in an unrestricted, high-level shading language.
The name string for low-level vertex programming is GL_ARB_vertex_-
program.
K.3.3.20 Low-Level Fragment Programming
Application-de?ned fragment programs may be speci?ed in the same low-level lan-
guage asGL_ARB_vertex_program, replacing the standard ?xed-function vertex
texturing, fog, and color sum operations.
The name string for low-level fragment programming is GL_ARB_-
fragment_program.
K.3.3.21 Buffer Objects
The name string for buffer objects is GL_ARB_vertex_buffer_object. It was
promoted to a core feature in OpenGL 1.5.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 749
K.3.3.22 Occlusion Queries
The name string for occlusion queries is GL_ARB_occlusion_query. It was
promoted to a core feature in OpenGL 1.5.
K.3.3.23 Shader Objects
The name string for shader objects is GL_ARB_shader_objects. It was pro-
moted to a core feature in OpenGL 2.0.
K.3.3.24 High-Level Vertex Programming
The name string for high-level vertex programming isGL_ARB_vertex_shader.
It was promoted to a core feature in OpenGL 2.0.
K.3.3.25 High-Level Fragment Programming
The name string for high-level fragment programming is GL_ARB_fragment_-
shader. It was promoted to a core feature in OpenGL 2.0.
K.3.3.26 OpenGL Shading Language
The name string for the OpenGL Shading Language is GL_ARB_shading_-
language_100. The presence of this extension string indicates that programs
written in version 1 of the Shading Language are accepted by OpenGL. It was
promoted to a core feature in OpenGL 2.0.
K.3.3.27 Non-Power-Of-Two Textures
The name string for non-power-of-two textures is GL_ARB_texture_non_-
power_of_two. It was promoted to a core feature in OpenGL 2.0.
K.3.3.28 Point Sprites
The name string for point sprites isGL_ARB_point_sprite. It was promoted to
a core feature in OpenGL 2.0.
K.3.3.29 Fragment Program Shadow
Fragment program shadow extends low-level fragment programs de?ned with
GL_ARB_fragment_program to add shadow 1D, 2D, and 3D texture targets, and
remove the interaction withGL_ARB_shadow.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 750
The name string for fragment program shadow is GL_ARB_fragment_-
program_shadow.
K.3.3.30 Multiple Render Targets
The name string for multiple render targets is GL_ARB_draw_buffers. It was
promoted to a core feature in OpenGL 2.0.
K.3.3.31 Rectangle Textures
Rectangle textures de?ne a new texture target TEXTURE_RECTANGLE_ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangle tex-
tures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are also useful for shadow maps and window-space texturing. These
textures are accessed by dimension-dependent (aka non-normalized) texture coor-
dinates.
Rectangle textures are a restricted version of non-power-of-two textures. The
differences are that rectangle textures are supported only for 2D; they require a new
texture target; and the new target uses non-normalized texture coordinates.
The name string for texture rectangles is GL_ARB_texture_rectangle. It
was promoted to a core feature in OpenGL 3.1.
K.3.3.32 Floating-Point Color Buffers
Floating-point color buffers can represent values outside the normal [0; 1] range
of colors in the ?xed-function OpenGL pipeline. This group of related exten-
sions enables controlling clamping of vertex colors, fragment colors throughout the
pipeline, and pixel data read back to client memory, and also includes WGL and
GLX extensions for creating framebuffers with ?oating-point color components
(referred to in GLX as framebuffer con?gurations, and in WGL as pixel formats).
The name strings for ?oating-point color buffers are GL_ARB_color_-
buffer_float, GLX_ARB_fbconfig_float, and WGL_ARB_pixel_-
format_float. GL_ARB_color_buffer_float was promoted to a core
feature in OpenGL 3.0.
K.3.3.33 Half-Precision Floating-Point
This extension de?nes the representation of a 16-bit ?oating-point data format, and
a correspondingtype argument which may be used to specify and read back pixel
and texture images stored in this format in client memory. Half-precision ?oats are
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 751
smaller than full precision ?oats, but provide a larger dynamic range than similarly
sized (short) data types.
The name string for half-precision ?oating-point is GL_ARB_half_float_-
pixel. It was promoted to a core feature in OpenGL 3.0.
K.3.3.34 Floating-Point Textures
Floating-point textures stored in both 32- and 16-bit formats may be de?ned using
new internalformat arguments to commands which specify and read back texture
images.
The name string for ?oating-point textures is GL_ARB_texture_float. It
was promoted to a core feature in OpenGL 3.0.
K.3.3.35 Pixel Buffer Objects
The buffer object interface is expanded by adding two new binding targets for
buffer objects, the pixel pack and unpack buffers. This permits buffer objects to be
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formance compared to data in client memory.
The name string for pixel buffer objects isGL_ARB_pixel_buffer_object.
It was promoted to a core feature in OpenGL 2.1.
K.3.3.36 Floating-Point Depth Buffers
The name string for ?oating-point depth buffers is GL_ARB_depth_buffer_-
float. This extension is equivalent to new core functionality introduced in
OpenGL 3.0, based on the earlierGL_NV_depth_buffer_float extension, and
is provided to enable this functionality in older drivers.
K.3.3.37 Instanced Rendering
The name string for instanced rendering is GL_ARB_draw_instanced. It was
promoted to a core feature in OpenGL 3.1.
K.3.3.38 Framebuffer Objects
The name string for framebuffer objects isGL_ARB_framebuffer_object. This
extension is equivalent to new core functionality introduced in OpenGL 3.0, based
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 752
on the earlier GL_EXT_framebuffer_object, GL_EXT_framebuffer_-
multisample, and GL_EXT_framebuffer_blit extensions, and is provided
to enable this functionality in older drivers.
K.3.3.39 sRGB Framebuffers
The name string for sRGB framebuffers is GL_ARB_framebuffer_sRGB. It was
promoted to a core feature in OpenGL 3.0.
To create sRGB format surfaces for use on display devices, an additional pixel
format (con?g) attribute is required in the window system integration layer. The
name strings for the GLX and WGL sRGB pixel format interfaces areGLX_ARB_-
framebuffer_sRGB andWGL_ARB_framebuffer_sRGB respectively.
K.3.3.40 Geometry Shaders
This extension de?nes a new shader type called a geometry shader. Geometry
shaders are run after vertices are transformed, but prior to the remaining ?xed-
function vertex processing, and may generate new vertices for, or remove vertices
from the primitive assembly process.
The name string for geometry shaders is GL_ARB_geometry_shader4. It
was promoted to a core feature in OpenGL 3.2.
K.3.3.41 Half-Precision Vertex Data
The name string for half-precision vertex data isGL_ARB_half_float_vertex.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlierGL_NV_half_float extension, and is provided to enable this
functionality in older drivers.
K.3.3.42 Instanced Rendering
This instanced rendering interface is a less-capable form of GL_ARB_draw_-
instanced which can be supported on older hardware.
The name string for instanced rendering is GL_ARB_instanced_arrays. It
was promoted to a core feature in OpenGL 3.3.
K.3.3.43 Flexible Buffer Mapping
The name string for ?exible buffer mapping is GL_ARB_map_buffer_range.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 753
based on the earlier GL_APPLE_flush_buffer_range extension, and is pro-
vided to enable this functionality in older drivers.
K.3.3.44 Texture Buffer Objects
The name string for texture buffer objects is GL_ARB_texture_buffer_-
object. It was promoted to a core feature in OpenGL 3.1.
K.3.3.45 RGTC Texture Compression Formats
The name string for RGTC texture compression formats is GL_ARB_texture_-
compression_rgtc. This extension is equivalent to new core functionality intro-
duced in OpenGL 3.0, based on the earlier GL_EXT_texture_compression_-
rgtc extension, and is provided to enable this functionality in older drivers.
It was promoted to a core feature in OpenGL 3.0.
K.3.3.46 One- and Two-Component Texture Formats
The name string for one- and two-component texture formats is GL_ARB_-
texture_rg. It was promoted to a core feature in OpenGL 3.0. This extension is
equivalent to new core functionality introduced in OpenGL 3.0, and is provided to
enable this functionality in older drivers.
K.3.3.47 Vertex Array Objects
The name string for vertex array objects is GL_ARB_vertex_array_object.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_APPLE_vertex_array_object extension, and is pro-
vided to enable this functionality in older drivers.
It was promoted to a core feature in OpenGL 3.0.
K.3.3.48 Versioned Context Creation
Starting with OpenGL 3.0, a new context creation interface is required in the win-
dow system integration layer. This interface speci?es the context version required
as well as other attributes of the context.
The name strings for the GLX and WGL context creation interfaces areGLX_-
ARB_create_context andWGL_ARB_create_context respectively.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 754
K.3.3.49 Uniform Buffer Objects
The name string for uniform buffer objects is GL_ARB_uniform_buffer_-
object. This extension is equivalent to new core functionality introduced in
OpenGL 3.1 and is provided to enable this functionality in older drivers.
K.3.3.50 Restoration of features removed from OpenGL 3.0
OpenGL 3.1 removes a large number of features that were marked deprecated in
OpenGL 3.0. GL implementations needing to maintain these features to support
existing applications may do so, following the deprecation model, by exporting
an extension string indicating those features are present. Applications written for
OpenGL 3.1 should not depend on any of the features corresponding to this exten-
sion, since they will not be available on all platforms with 3.1 implementations.
The name string for restoration of features deprecated by OpenGL 3.0 isGL_-
ARB_compatibility.
The pro?le terminology introduced with OpenGL 3.2 eliminates the necessity
for evolving this extension. Instead, interactions between features removed by
OpenGL 3.1 and new features introduced in later OpenGL versions are de?ned by
the compatibility pro?le corresponding to those versions.
K.3.3.51 Fast Buffer-to-Buffer Copies
The name string for fast buffer-to-buffer copies is GL_ARB_copy_buffer. This
extension is equivalent to new core functionality introduced in OpenGL 3.1 and is
provided to enable this functionality in older drivers.
K.3.3.52 Shader Texture Level-of-Detail Control
The name string for shader texture level-of-detail control is GL_ARB_shader_-
texture_lod. This extension is equivalent to new core functions introduced in
OpenGL Shading Language 1.30 and is provided to enable this functionality in
older versions of the shading language.
K.3.3.53 Depth Clamp Control
The name string for depth clamp control is GL_ARB_depth_clamp. This exten-
sion is equivalent to new core functionality introduced in OpenGL 3.2 and is pro-
vided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 755
K.3.3.54 Base Vertex Offset Drawing Commands
The name string for base vertex offset drawing commands is GL_ARB_draw_-
elements_base_vertex. This extension is equivalent to new core functionality
introduced in OpenGL 3.2 and is provided to enable this functionality in older
drivers.
K.3.3.55 Fragment Coordinate Convention Control
The name string for fragment coordinate convention control is GL_ARB_-
fragment_coord_conventions. This extension is equivalent to new core func-
tionality introduced in OpenGL 3.2 and is provided to enable this functionality in
older drivers.
K.3.3.56 Provoking Vertex Control
The name string for provoking vertex control is GL_ARB_provoking_vertex.
This extension is equivalent to new core functionality introduced in OpenGL 3.2
and is provided to enable this functionality in older drivers.
K.3.3.57 Seamless Cube Maps
The name string for seamless cube maps isGL_ARB_seamless_cube_map. This
extension is equivalent to new core functionality introduced in OpenGL 3.2 and is
provided to enable this functionality in older drivers.
K.3.3.58 Fence Sync Objects
The name string for fence sync objects isGL_ARB_sync. This extension is equiva-
lent to new core functionality introduced in OpenGL 3.2 and is provided to enable
this functionality in older drivers.
K.3.3.59 Multisample Textures
The name string for multisample textures is GL_ARB_texture_multisample.
This extension is equivalent to new core functionality introduced in OpenGL 3.2
and is provided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 756
K.3.3.60 BGRA Attribute Component Ordering
The name string for BGRA attribute component ordering is GL_ARB_vertex_-
array_bgra. This extension is equivalent to new core functionality introduced in
OpenGL 3.2 and is provided to enable this functionality in older drivers.
K.3.3.61 Per-Buffer Blend Control
The blending interface is extended to specify blend equation and blend function on
a per-draw-buffer basis.
The name string for per-buffer blend control is GL_ARB_draw_buffers_-
blend. It was promoted to a core feature in OpenGL 4.0.
K.3.3.62 Sample Shading Control
Sample shading control adds the ability to request that an implementation use a
minimum number of unique sets of fragment computation inputs when multisam-
pling a pixel.
The name string for sample shading control isGL_ARB_sample_shading. It
was promoted to a core feature in OpenGL 4.0.
K.3.3.63 Cube Map Array Textures
A cube map array texture is a two-dimensional array texture that may contain many
cube map layers. Each cube map layer is a unique cube map image set.
The name string for cube map array textures is GL_ARB_texture_cube_-
map_array. It was promoted to a core feature in OpenGL 4.0.
K.3.3.64 Texture Gather
Texture gather adds a new set of texture functions (textureGather) to the
OpenGL Shading Language that determine the 22 footprint used for linear ?lter-
ing in a texture lookup, and return a vector consisting of the ?rst component from
each of the four texels in the footprint.
The name string for texture gather isGL_ARB_texture_gather. It was pro-
moted to a core feature in OpenGL 4.0.
K.3.3.65 Texture Level-Of-Detail Queries
Texture level-of-detail queries adds a new set of fragment shader texture functions
(textureLOD) to the OpenGL Shading Language that return the results of au-
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 757
tomatic level-of-detail computations that would be performed if a texture lookup
were to be done.
The name string for texture level-of-detail queries is GL_ARB_texture_-
query_lod.
K.3.3.66 Pro?led Context Creation
Starting with OpenGL 3.2, API pro?les are de?ned. Pro?led context creation ex-
tends the versioned context creation interface to specify a pro?le which must be
implemented by the context.
The name strings for the GLX and WGL pro?led context creation interfaces
areGLX_ARB_create_context_profile andWGL_ARB_create_context_-
profile respectively.
K.3.3.67 Shading Language Include
Shading language include adds support for#include directives to shaders, and
a named string API for de?ning the text corresponding to#include pathnames.
The name string for shading language include is GL_ARB_shading_-
language_include.
K.3.3.68 BPTC texture compression
BPTC texture compression provides new block compressed speci?c texture for-
mats which can improve quality in images with sharp edges and strong chromi-
nance transitions, and support high dynamic range ?oating-point formats.
The name string for BPTC texture compression is GL_ARB_texture_-
compression_bptc.
K.3.3.69 Extended Blend Functions
The name string for extended blend functions is GL_ARB_blend_func_-
extended. This extension is equivalent to new core functionality introduced in
OpenGL 3.3, and is provided to enable this functionality in older drivers.
K.3.3.70 Explicit Attribute Location
The name string for explicit attribute location is GL_ARB_explicit_attrib_-
location. This extension is equivalent to new core functionality introduced in
OpenGL 3.3 and is provided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 758
K.3.3.71 Boolean Occlusion Queries
The name string for boolean occlusion queries is GL_ARB_occlusion_query2.
This extension is equivalent to new core functionality introduced in OpenGL 3.3
and is provided to enable this functionality in older drivers.
K.3.3.72 Sampler Objects
The name string for sampler objects is GL_ARB_sampler_objects. This ex-
tension is equivalent to new core functionality introduced in OpenGL 3.3 and is
provided to enable this functionality in older drivers.
K.3.3.73 Shader Bit Encoding
The name string for shader bit encoding is GL_ARB_shader_bit_encoding.
This extension is equivalent to new core functionality introduced in OpenGL 3.3
and is provided to enable this functionality in older drivers.
K.3.3.74 RGB10A2 Integer Textures
The name string for RGB10A2 integer textures is GL_ARB_texture_rgb10_-
a2ui. This extension is equivalent to new core functionality introduced in OpenGL
3.3 and is provided to enable this functionality in older drivers.
K.3.3.75 Texture Swizzle
The name string for texture swizzle is GL_ARB_texture_swizzle. This ex-
tension is equivalent to new core functionality introduced in OpenGL 3.3 and is
provided to enable this functionality in older drivers.
K.3.3.76 Timer Queries
The name string for timer queries is GL_ARB_timer_query. This extension is
equivalent to new core functionality introduced in OpenGL 3.3 and is provided to
enable this functionality in older drivers.
K.3.3.77 Packed 2.10.10.10 Vertex Formats
The name string for packed 2.10.10.10 vertex formats is GL_ARB_vertex_-
type_2_10_10_10_rev. This extension is equivalent to new core functional-
ity introduced in OpenGL 3.3 and is provided to enable this functionality in older
drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 759
K.3.3.78 Draw Indirect
The name string for draw indirect isGL_ARB_draw_indirect. This extension is
equivalent to new core functionality introduced in OpenGL 4.0 and is provided to
enable this functionality in older drivers.
K.3.3.79 GPU Shader5 Miscellaneous Functionality
The name string for GPU shader5 miscellaneous functionality is GL_ARB_gpu_-
shader5. This extension is equivalent to new core functionality introduced in
OpenGL 4.0 and is provided to enable this functionality in older drivers.
K.3.3.80 Double-Precision Floating-Point Shader Support
The name string for double-precision ?oating-point shader support is GL_ARB_-
gpu_shader_fp64. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.0 and is provided to enable this functionality in older drivers.
K.3.3.81 Shader Subroutines
The name string for shader subroutines is GL_ARB_shader_subroutine. This
extension is equivalent to new core functionality introduced in OpenGL 4.0 and is
provided to enable this functionality in older drivers.
K.3.3.82 Tessellation Shaders
The name string for tessellation shaders is GL_ARB_tessellation_shader.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.
K.3.3.83 RGB32 Texture Buffer Objects
The name string for RGB32 texture buffer objects is GL_ARB_texture_-
buffer_object_rgb32. This extension is equivalent to new core functional-
ity introduced in OpenGL 4.0 and is provided to enable this functionality in older
drivers.
K.3.3.84 Transform Feedback 2
The name string for transform feedback 2 is GL_ARB_transform_feedback2.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 760
K.3.3.85 Transform Feedback 3
The name string for transform feedback 3 is GL_ARB_transform_feedback3.
This extension is equivalent to new core functionality introduced in OpenGL 4.0
and is provided to enable this functionality in older drivers.
K.3.3.86 OpenGL ES 2.0 Compatibility
The name string for OpenGL ES 2.0 compatibility is GL_ARB_ES2_-
compatibility. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.1 and is provided to enable this functionality in older drivers.
K.3.3.87 Program Binary Support
The name string for program binary support isGL_ARB_get_program_binary.
This extension is equivalent to new core functionality introduced in OpenGL 4.1
and is provided to enable this functionality in older drivers.
K.3.3.88 Separate Shader Objects
The name string for separate shader objects is GL_ARB_separate_shader_-
objects. This extension is equivalent to new core functionality introduced in
OpenGL 4.1 and is provided to enable this functionality in older drivers.
K.3.3.89 Shader Precision Restrictions
The name string for shader precision restritions isGL_ARB_shader_precision.
This extension is equivalent to new core functionality introduced in OpenGL 4.1
and is provided to enable this functionality in older drivers.
K.3.3.90 Double Precision Vertex Shader Inputs
The name string for double precision vertex shader inputs is GL_ARB_vertex_-
attrib_64bit. This extension is equivalent to new core functionality introduced
in OpenGL 4.1 and is provided to enable this functionality in older drivers.
K.3.3.91 Viewport Arrays
The name string for viewport arrays is GL_ARB_viewport_array. This exten-
sion is equivalent to new core functionality introduced in OpenGL 4.1 and is pro-
vided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 761
K.3.3.92 Robust Context Creation
Robust context creation allows creating an OpenGL context supporting robust
buffer access behavior and a speci?ed graphics reset noti?cation behavior exposed
through theGL_ARB_robustness extension (see section K.3.3.95).
The name strings for GLX and WGL robust context creation are GLX_-
ARB_create_context_robustness and WGL_ARB_create_context_-
robustness, respectively.
K.3.3.93 OpenCL Event Sharing
OpenCL event sharing allows creating OpenGL sync objects linked to OpenCL
event objects, potentially improving ef?ciency of sharing images and buffers be-
tween the two APIs.
The name string for OpenCL event sharing isGL_ARB_cl_event.
K.3.3.94 Debug Output Noti?cation
Debug output noti?cation enables GL to inform the application when various
events occur that may be useful during development and debugging.
The name string for debug output noti?cation isGL_ARB_debug_output.
K.3.3.95 Context Robustness
Context robustness provides “safe” APIs that limit data written to application
memory to a speci?ed length, provides a mechanism to learn about graphics re-
sets affecting the context, and de?nes guarantee that out-of-bounds buffer object
accesses will have deterministic behavior precluding instability or termination.
Some of these behaviors are controlled at context creation time via the companion
GLX_ARB_create_context_robustness or WGL_ARB_create_context_-
robustness extensions (see section K.3.3.92).
The name string for context robustness isGL_ARB_robustness.
K.3.3.96 Shader Stencil Export
Sharder stencil export enables shaders to generate a stencil reference value, allow-
ing stencil testing to be performed against per-shader-invocation values.
The name string for shader stencil export is GL_ARB_shader_stencil_-
export.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 762
K.3.3.97 Base Instanced Rendering
The name string for base instanced rendering is GL_ARB_base_instance. This
extension is equivalent to new core functionality introduced in OpenGL 4.2 and is
provided to enable this functionality in older drivers.
K.3.3.98 OpenGL Shading Language 4.20 Feature Pack
The name string for the OpenGL Shading Language 4.20 feature pack is GL_-
ARB_shading_language_420pack. This extension is equivalent to new core
functionality introduced in OpenGL 4.2 and is provided to enable this functionality
in older drivers.
K.3.3.99 Instanced Transform Feedback
The name string for instanced transform feedback is GL_ARB_transform_-
feedback_instanced. This extension is equivalent to new core functionality
introduced in OpenGL 4.2 and is provided to enable this functionality in older
drivers.
K.3.3.100 Compressed Texture Pixel Storage
The name string for compressed texture pixel storage isGL_ARB_compressed_-
texture_pixel_storage. This extension is equivalent to new core functional-
ity introduced in OpenGL 4.2 and is provided to enable this functionality in older
drivers.
K.3.3.101 Conservative Depth
The name string for conservative depth isGL_ARB_conservative_depth. This
extension is equivalent to new core functionality introduced in OpenGL 4.2 and is
provided to enable this functionality in older drivers.
K.3.3.102 Internal Format Query
The name string for internal format query isGL_ARB_internalformat_query.
This extension is equivalent to new core functionality introduced in OpenGL 4.2
and is provided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 763
K.3.3.103 Map Buffer Alignment
The name string for map buffer alignment isGL_ARB_map_buffer_alignment.
This extension is equivalent to new core functionality introduced in OpenGL 4.2
and is provided to enable this functionality in older drivers.
K.3.3.104 Shader Atomic Counters
The name string for shader atomic counters is GL_ARB_shader_atomic_-
counters. This extension is equivalent to new core functionality introduced in
OpenGL 4.2 and is provided to enable this functionality in older drivers.
K.3.3.105 Shader Image Load/Store
The name string for shader image load/store isGL_ARB_shader_image_load_-
store. This extension is equivalent to new core functionality introduced in
OpenGL 4.2 and is provided to enable this functionality in older drivers.
K.3.3.106 Shading Language Packing
The name string for shading language packing is GL_ARB_shading_-
language_packing. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.2 and is provided to enable this functionality in older drivers.
K.3.3.107 Texture Storage
The name string for texture storage is GL_ARB_texture_storage. This exten-
sion is equivalent to new core functionality introduced in OpenGL 4.2 and is pro-
vided to enable this functionality in older drivers.
K.3.3.108 ASTC Texture Compression
The name string for ASTC texture compression is GL_KHR_texture_-
compression_astc_ldr. This extension is equivalent to new core functionality
introduced in OpenGL 4.3, and is provided to enable this functionality in older
drivers.
K.3.3.109 Debug Contexts
This KHR extension de?nes debugging features and combines the functionality of
GL_ARB_debug_output, GL_ARB_debug_output2, GL_ARB_debug_group,
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 764
and GL_ARB_debug_label. It is intended primarily to bring this debug func-
tionality to OpenGL ES implementations.
The name string for debug contexts isGL_KHR_debug.
K.3.3.110 Shader Array of Arrays
The name string for shader array of arrays isGL_ARB_arrays_of_arrays. This
extension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.
K.3.3.111 Clear Buffer Object
The name string for clear buffer object isGL_ARB_clear_buffer_object. This
extension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.
K.3.3.112 Compute Shaders
The name string for compute shaders is GL_ARB_compute_shader. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.
K.3.3.113 Copy Image
The name string for copy image isGL_ARB_copy_image. This extension is equiv-
alent to new core functionality introduced in OpenGL 4.3, and is provided to enable
this functionality in older drivers.
K.3.3.114 Texture Views
The name string for texture views is GL_ARB_texture_view. This extension is
equivalent to new core functionality introduced in OpenGL 4.3, and is provided to
enable this functionality in older drivers.
K.3.3.115 Vertex Attribute Binding
The name string for vertex attribute binding is GL_ARB_vertex_attrib_-
binding. This extension is equivalent to new core functionality introduced in
OpenGL 4.3, and is provided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 765
K.3.3.116 Robustness Isolation
The name string for robustness isolation is GL_ARB_robustness_isolation.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.
K.3.3.117 OpenGL ES 3.0 Compatibility
The name string for OpenGL ES 3.0 compatibility is GL_ARB_ES3_-
compatibility. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.
K.3.3.118 Shader Explicit Uniform Location
The name string for shader explicit uniform location is GL_ARB_explicit_-
uniform_location. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.
K.3.3.119 Fragment Layer Viewport
The name string for fragment layer viewport is GL_ARB_fragment_layer_-
viewport. This extension is equivalent to new core functionality introduced in
OpenGL 4.3, and is provided to enable this functionality in older drivers.
K.3.3.120 Binding a Framebuffer Without Attachments
The name string for binding a framebuffer without attachments is GL_ARB_-
framebuffer_no_attachments. This extension is equivalent to new core func-
tionality introduced in OpenGL 4.3, and is provided to enable this functionality in
older drivers.
K.3.3.121 Extended Internal Format Query
The name string for extended internal format query is GL_ARB_-
internalformat_query2. This extension is equivalent to new core func-
tionality introduced in OpenGL 4.3, and is provided to enable this functionality in
older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 766
K.3.3.122 Invalidate SubData
The name string for invalidate subdata is GL_ARB_invalidate_subdata. This
extension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.
K.3.3.123 Multi Draw Indirect
The name string for multi draw indirect is GL_ARB_multi_draw_indirect.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.
K.3.3.124 Program Interface Queries
The name string for program interface queries is GL_ARB_program_-
interface_query. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.
K.3.3.125 Robust Buffer Access Behavior
The name string for robust buffer access behavior isGL_ARB_robust_buffer_-
access_behavior. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.3, and is provided to enable this functionality in older drivers.
K.3.3.126 Shader Image Size Query
The name string for shader image size query is GL_ARB_shader_image_size.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.
K.3.3.127 Shader Storage in Buffer Objects
The name string for shader storage in buffer objects is GL_ARB_shader_-
storage_buffer_object. This extension is equivalent to new core function-
ality introduced in OpenGL 4.3, and is provided to enable this functionality in
older drivers.
K.3.3.128 Stencil Texturing
The name string for stencil texturing isGL_ARB_stencil_texturing. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.3, and is
provided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 767
K.3.3.129 Texture Buffer Range
The name string for texture buffer range is GL_ARB_texture_buffer_range.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.
K.3.3.130 Texture Query Levels
The name string for texture query levels is GL_ARB_texture_query_levels.
This extension is equivalent to new core functionality introduced in OpenGL 4.3,
and is provided to enable this functionality in older drivers.
K.3.3.131 Texture Storage Multisample
The name string for texture storage multisample is GL_ARB_texture_-
storage_multisample. This extension is equivalent to new core functionality
introduced in OpenGL 4.3, and is provided to enable this functionality in older
drivers.
K.3.3.132 Robustness Application Isolation Context Creation
These extensions allow creation of OpenGL contexts which support robustness
isolation through OpenGL 4.3 or the equivalent functionality in the GL_ARB_-
robustness_isolation extension (see K.3.3.116), and may also de?ne addi-
tional constraints around how OpenGL context reset noti?cation affects other con-
texts in the share group, or other applications on the system. There are equivalent
sets of extensions for both GLX and WGL window-system binding layers.
The name strings for GLX robustness application isolation context cre-
ation are GLX_ARB_robustness_application_isolation and GLX_ARB_-
robustness_share_group_isolation.
The name strings for WGL robustness application isolation context cre-
ation are WGL_ARB_robustness_application_isolation and WGL_ARB_-
robustness_share_group_isolation.
K.3.3.133 Buffer Storage
The name string for buffer storage isGL_ARB_buffer_storage. This extension
is equivalent to new core functionality introduced in OpenGL 4.4, and is provided
to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 768
K.3.3.134 Clear Texture
The name string for clear texture is GL_ARB_clear_texture. This extension is
equivalent to new core functionality introduced in OpenGL 4.4, and is provided to
enable this functionality in older drivers.
K.3.3.135 Enhanced Layouts
The name string for enhanced layouts isGL_ARB_enhanced_layouts. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.4, and is
provided to enable this functionality in older drivers.
K.3.3.136 Multiple Bind
The name string for multiple bind is GL_ARB_multi_bind. This extension is
equivalent to new core functionality introduced in OpenGL 4.4, and is provided to
enable this functionality in older drivers.
K.3.3.137 Query Buffer Object
The name string for query buffer object is GL_ARB_query_buffer_object.
This extension is equivalent to new core functionality introduced in OpenGL 4.4,
and is provided to enable this functionality in older drivers.
K.3.3.138 Texture Mirror Clamp To Edge
The name string for texture mirror clamp to edge isGL_ARB_texture_mirror_-
clamp_to_edge. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.4, and is provided to enable this functionality in older drivers.
K.3.3.139 Texture Stencil8
The name string for texture stencil8 is GL_ARB_texture_stencil8. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.4, and is
provided to enable this functionality in older drivers.
K.3.3.140 Vertex Type 10f 11f 11f
The name string for vertex type 10f 11f 11f is GL_ARB_vertex_type_10f_-
11f_11f_rev. This extension is equivalent to new core functionality introduced
in OpenGL 4.4, and is provided to enable this functionality in older drivers.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 769
K.3.3.141 Bindless Textures
Bindless textures allows access to texture objects in shaders without ?rst binding
each texture to one of a limited number of texture image units.
The name string for bindless textures isGL_ARB_bindless_texture.
K.3.3.142 Compute Variable Group Size
Compute variable groups size allows writing generic compute shaders that operate
on workgroups with arbitrary dimensions.
The name string for compute variable group size is GL_ARB_compute_-
variable_group_size.
K.3.3.143 Indirect Parameters
Indirect parameters allows buffer objects to store drawing parameters for some
drawing commands, and introduces new drawing commands that source some of
their parameters from buffers.
The name string for indirect parameters isGL_ARB_indirect_parameters.
K.3.3.144 Seamless Cubemap per Texture
This allows providing a per-texture setting for enabling seamless sampling from
cube maps.
The name string for seamless cubemap per texture is GL_ARB_seamless_-
cubemap_per_texture.
K.3.3.145 Shader Draw Parameters
This adds two new built-in variables to the OpenGL Shading Language containing
values passed in the basevertex and baseinstance parameters of drawinng com-
mands, and an index of the draw command being processed by MultiDraw* com-
mands.
The name string for shader draw parameters is GL_ARB_shader_draw_-
parameters.
K.3.3.146 Shader Group Vote
Shader group vote provides new built-in functions to compute the composite of
a set of boolean conditions across a group of shader invocations. These compos-
ite results may be used to execute shaders more ef?ciently on a single-instruction
multiple-data (SIMD) processor.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 770
The name string for shader group vote isGL_ARB_shader_group_vote.
K.3.3.147 Sparse Textures
This extension allows the separation of the graphics processor’s address space
(reservation) from the requirement that all textures must be physically backed
(commitment). This exposes a limited form of virtualization for textures. Use
cases include sparse (or partially resident) textures, texture paging, on-demand and
delayed loading of texture assets and application controlled level-of-detail.
The name string for sparse textures isGL_ARB_sparse_texture.
K.3.3.148 OpenGL ES 3.1 Compatibility
This extension adds supported for features of OpenGL ES 3.1 that are missing from
OpenGL 4.5.
The name string for OpenGL ES 3.1 compatibility is GL_ARB_ES3_1_-
compatibility. This extension is equivalent to new core functionality intro-
duced in OpenGL 4.5, and is provided to enable this functionality in older drivers.
K.3.3.149 Clip Control
This extension provides additional clip control modes to con?gure how clip space
is mapped to window space.
The name string for clip control is GL_ARB_clip_control. This extension
is equivalent to new core functionality introduced in OpenGL 4.5, and is provided
to enable this functionality in older drivers.
K.3.3.150 Inverted Conditional Rendering
This extension adds new modes to BeginConditionalRender which invert the con-
dition used to determine whether to draw or not.
The name string for inverted conditional rendering is GL_ARB_-
conditional_render_inverted. This extension is equivalent to new
core functionality introduced in OpenGL 4.5, and is provided to enable this
functionality in older drivers.
K.3.3.151 Cull Distance Shader Output
This extension adds a new OpenGL Shading Languagegl_CullDistance shader
output, similar togl_ClipDistance, but used for whole primitive culling.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 771
The name string for cull distance shader output isGL_ARB_cull_distance.
This extension is equivalent to new core functionality introduced in OpenGL 4.5,
and is provided to enable this functionality in older drivers.
K.3.3.152 Derivative Computation Granularity
This extension provides control over the spacial granularity at which the underlying
implementation computes derivatives.
The name string for derivative computation granularity is GL_ARB_-
derivative_control. This extension is equivalent to new core functionality
introduced in OpenGL 4.5, and is provided to enable this functionality in older
drivers.
K.3.3.153 Direct State Access
This extension allows state for most objects to be queried and modi?ed without the
object needing to be bound to a context.
The name string for direct state access is GL_ARB_direct_state_access.
This extension is equivalent to new core functionality introduced in OpenGL 4.5,
and is provided to enable this functionality in older drivers.
K.3.3.154 Texture Subregion Readback
This extension adds commands allowing readback of subregions of texture images.
The name string for texture subregion readback is GL_ARB_get_texture_-
sub_image. This extension is equivalent to new core functionality introduced in
OpenGL 4.5, and is provided to enable this functionality in older drivers.
K.3.3.155 Shading Language Texture Sample Queries
This extension provides OpenGL Shading Language built-in functions allowing
shaders to query the number of samples of a texture.
The name string for shading language texture sample queries is GL_ARB_-
shader_texture_image_samples. This extension is equivalent to new core
functionality introduced in OpenGL 4.5, and is provided to enable this functionality
in older drivers.
K.3.3.156 Texture Barriers
This extension relaxes the restrictions on rendering to a currently bound texture
and provides a mechanism to avoid read-after-write hazards.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 772
The name string for texture barriers isGL_ARB_texture_barrier. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.5, and is
provided to enable this functionality in older drivers.
K.3.3.157 Context Flush Control
This extension allows querying the context ?ush behavior. There are associated
EGL, GLX and WGL extensions which add new context creation parameters al-
lowing speci?cation of the desired behavior when a context is made non-current,
as well as opting out of the implicit ?ush behavior of unextended OpenGL.
The name string for context ?ush control is GL_KHR_context_flush_-
control. This extension is equivalent to new core functionality introduced in
OpenGL 4.5, and is provided to enable this functionality in older drivers.
K.3.3.158 Robust Buffer Access Behavior
This extension speci?es the behavior of out-of-bounds buffer and array accesses.
The name string for robust buffer access behavior is GL_KHR_robust_-
buffer_access_behavior.
K.3.3.159 Context Robustness
This extension adds APIs for safe access to application buffers by the GL imple-
mentation; mechanisms to learn about how graphics hardware resets affect the GL
context; speci?cation of behavior of GL commands after a graphics reset; and guar-
antees that out-of-bounds buffer object accesses by the GPU will have deterministic
behavior.
The name string for context robustness is GL_KHR_robustness. This ex-
tension is equivalent to new core functionality introduced in OpenGL 4.5, and is
provided to enable this functionality in older drivers.
K.3.3.160 Pipelin Statistics Queries
This extension introduces new query types that allow applications to get statistics
information about different parts of the pipeline:
The name string for pipeline statistics queries is GL_ARB_pipeline_-
statistics_query.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 773
K.3.3.161 Sparse Buffers
This extension adds a mechanism to decouple the virtual and physical storage re-
quirements of buffer objects, and allows an application to create partially popu-
lated buffers that would over-subscribe available graphics memory if made fully
resident.
The name string for sparse buffers isGL_ARB_sparse_buffer.
K.3.3.162 Transform Feedback Over?ow Queries
This extension adds new query types which can be used to detect over?ow of trans-
form feedback buffers, and are accepted by conditional rendering commands.
The name string for transform feedback over?ow queries is GL_ARB_-
transform_feedback_overflow_query.
K.3.3.163 Advanced Blend Equations
These extensions add a number of “advanced” blend equations. A base extension
provides the new equations, but guarantees de?ned results only if each sample is
touched no more than once in any single rendering pass, and de?nes a command
to indicate pass boundaries. A layered extension guarantees that blending is done
coherently and in API primitive order.
The name strings for advanced blend equations are GL_KHR_blend_-
equation_advanced andGL_KHR_blend_equation_advanced_coherent.
K.3.3.164 Unde?ned Error Behavior
This extension causes the GL implementation to have unde?ned behavior in any
situation that would otherwise cause a GL error to be generated, allowing increased
performance and decreased power usage for error-free applications. The extension
is only supported for contexts created using associated EGL, GLX and WGL ex-
tensions which add corresponding new context creation parameters.
The name string for unde?ned error behavior isGL_KHR_no_error.
K.3.3.165 OpenGL ES 3.2 Compatibility
This extension adds supported for features of OpenGL ES 3.2 that are missing from
OpenGL 4.5.
The name string for OpenGL ES 3.2 compatibility is GL_ARB_ES3_2_-
compatibility.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 774
K.3.3.166 Fragment Shader Interlock
This extension provides new OpenGL Shading Language built-in functions that
are used to delimit critical sections of fragment shader code. For pairs of shader
invocations with “overlapping” coverage in a given pixel, the GL implementation
will guarantee that the critical section of the fragment shader will be executed for
only one fragment at a time.
The name string for fragment shader interlock is GL_ARB_fragment_-
shader_interlock.
K.3.3.167 64-bit Integer Shader Operations
This extension adds support for 64-bit integer data types to OpenGL Shading Lan-
guage shaders, as well as related packing, conversion, relational, and mahtematical
functions.
The name string for 64-bit integer shader operations is GL_ARB_gpu_-
shader_int64.
K.3.3.168 Parallel Shader Compilation
This extension provides a mechanism to allow compilation of OpenGL Shading
Language shaders in multiple separate CPU threads, limit the number of threads to
be used, and query if compilation is complete.
The name string for parallel shader compilation is GL_ARB_parallel_-
shader_compile.
K.3.3.169 Post Depth Coverage
This extension allows the fragment shader to control whether values in gl_-
SampleMaskIn[] re?ect coverage after application of the early depth and stencil
tests.
The name string for post depth coverage isGL_ARB_post_depth_coverage.
K.3.3.170 Explicit Sample Locations
This extension allows an application to modify the locations of samples within a
pixel used in multisample rasterization, and to specify different sample locations
for each pixel in a group of adjacent pixels
The name string for explicit sample locations is GL_ARB_sample_-
locations.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 775
K.3.3.171 Shader Atomic Counter Operations
This extension extends the list of OpenGL Shading Language built-in functions
that can operate on atomic counters.
The name string for shader atomic counter operations is GL_ARB_shader_-
atomic_counter_ops.
K.3.3.172 Shader Ballot
This extension provides the ability for a group of invocations which execute in
lockstep to do limited forms of cross-invocation communication via a group broad-
cast of a invocation value, or broadcast of a bitarray representing a predicate value
from each invocation in the group.
The name string for shader ballot isGL_ARB_shader_ballot.
K.3.3.173 Shader Clock
This extension exposes a 64-bit monotonically incrementing shader counter which
may be used to derive local timing information within a single shader invocation.
The name string for shader clock isGL_ARB_shader_clock.
K.3.3.174 Shader Viewport Layer Array
This extension allows thegl_Layer andgl_ViewportIndex outputs to be writ-
ten directly from the vertex shader with no geometry shader present.
The name string for shader viewport layer array is GL_ARB_shader_-
viewport_layer_array.
K.3.3.175 Sparse Texture 2
This extension adds additional shader functions and behaviors for use of sparse
textures.
The name string for sparse texture 2 isGL_ARB_sparse_texture2.
K.3.3.176 Sparse Texture Clamp
This extension adds additional shader texture lookup functions that specify a mini-
mum level-of-detail to use for lookups where the level-of-detail is computed auto-
matically.
The name string for sparse texture clampGL_ARB_sparse_texture_clamp.
OpenGL 4.6 (Core Pro?le) - February 2, 2019K.3. ARBANDKHRONOSEXTENSIONS 776
K.3.3.177 Texture Filter Minmax
This extension provides a new texture and sampler parameter which allows appli-
cations to produce a ?ltered texel value by computing a component-wise minimum
or maximum of the texels that would normally be averaged.
The name string for texture ?lter minmax is GL_ARB_texture_filter_-
minmax.
K.3.3.178 ASTC Sliced 3D Texture Compression
This extension supports slice-based 3D textures using the ASTC LDR pro?le, in
the same fashion as the ASTC HDR pro?le when using theGL_KHR_texture_-
compression_astc_ldr extension.
The name string for astc sliced 3d texture compression isGL_KHR_texture_-
compression_astc_sliced_3d.
K.3.3.179 SPIR-V Shaders
This extension allows a SPIR-V module to be speci?ed for use in a shader stage,
rather than using OpenGL Shading Language, and modi?es OpenGL Shading Lan-
guage to be usable as a source language for creating SPIR-V modules, outside of
the GL runtime.
The name string for SPIR-V shaders isGL_ARB_gl_spirv.
K.3.3.180 Create Context Unde?ned Error
These extensions allow the creation of an OpenGL or OpenGL ES context that
doesn’t generate errors, and has unde?ned behavior on errors. They are paired
withGL_KHR_no_error.
The name strings for create context no error are GLX_ARB_create_-
context_no_error andWGL_ARB_create_context_no_error.
There is a similarEGL_KHR_create_context_no_error extension for cre-
ating contexts through EGL, located in the EGL Registry.
OpenGL 4.6 (Core Pro?le) - February 2, 2019Index
#version, 4, 5, 568, 693, 696 ACTIVE VARIABLES, 111, 112, 139,
140, 623
Accum, 682
ActiveShaderProgram, 125, 141, 698,
ACCUM BUFFER BIT, 682
710, 721
ACTIVE ATOMIC COUNTER -
ActiveTexture, 157, 179, 181
BUFFERS, 169, 621
ALIASED LINE WIDTH RANGE,
ACTIVE ATTRIBUTE MAX -
636
LENGTH, 167, 615
ALL ATTRIB BITS, 683
ACTIVE ATTRIBUTES, 167, 615
ALL BARRIER BITS, 164, 166
ACTIVE PROGRAM, 170, 613
ALL SHADER BITS, 124
ACTIVE RESOURCES, 107, 108, 622
ALPHA, 240, 286, 490, 511, 596, 598,
ACTIVE SUBROUTINE MAX -
607, 681
LENGTH, 175, 620
ALPHA BITS, 682
ACTIVE SUBROUTINE UNIFORM -
ALPHA TEST, 682
LOCATIONS, 154, 156, 157,
ALPHA TEST REF, 715
174, 175, 620
AlphaFunc, 682
ACTIVE SUBROUTINE UNIFORM -
ALREADY SIGNALED, 38
MAX LENGTH, 175, 620
ALWAYS, 240, 289, 504, 505, 602
ACTIVE SUBROUTINE UNI-
AND, 515
FORMS, 175, 620
AND INVERTED, 515
ACTIVE SUBROUTINES, 154, 155,
AND REVERSE, 515
157, 175, 620
Antialiasing, 476
ACTIVE TEXTURE, 179, 183, 242,
ANY SAMPLES PASSED, 42, 45, 48,
601
381–383, 505, 506, 721
ACTIVE UNIFORM BLOCK -
ANY SAMPLES PASSED CONSER-
MAX NAME LENGTH, 168,
VATIVE, 42, 45, 48, 381–383,
617
505, 506, 721
ACTIVE UNIFORM BLOCKS, 168,
ARB arrays of arrays, 692, 702
617
ARB base instance, 685, 689
ACTIVE UNIFORM MAX LENGTH,
ARB buffer storage, 704
168, 615
ARB clear buffer object, 692, 701
ACTIVE UNIFORMS, 168, 615
ARB clear texture, 704
777INDEX 778
ARB compressed texture pixel stor- ARB shader image load store, 685,
age, 684, 689 689
ARB compute shader, 692, 701 ARB shader image size, 692, 701
ARB conservative depth, 685, 689 ARB shader storage buffer object,
ARB copy image, 692, 701, 702 692, 702
ARB debug group, 701 ARB shading language 420pack, 685,
ARB debug label, 701 689
ARB debug output, 692, 702, 730 ARB shading language packing, 689
ARB debug output2, 702 ARB spirv extensions, 741
ARB enhanced layouts, 705 ARB stencil texturing, 692, 702
ARB ES3 compatibility, 692, 702 ARB texture buffer range, 692, 701
ARB explicit uniform location, 692, ARB texture compression bptc, 684,
702 689
ARB fragment layer viewport, 692, ARB texture ?lter anisotropic, 741
702 ARB texture mirror clamp to edge,
ARB framebuffer no attachments, 692, 705
702 ARB texture query levels, 692, 701
ARB gl spirv, 741 ARB texture stencil8, 705
ARB gpu program5, 724 ARB texture storage, 684, 689
ARB indirect parameters, 741 ARB texture storage multisample, 692,
ARB internalformat query, 685, 689 701
ARB internalformat query2, 692, 701 ARB texture view, 693, 702
ARB invalidate subdata, 692, 702 ARB transform feedback instanced,
ARB map buffer alignment, 685, 689 685, 689
ARB multi bind, 705 ARB transform feedback over?ow -
ARB multi draw indirect, 692, 701 query, 741
ARB pipeline statistics query, 741 ARB vertex attrib binding, 693, 702
ARB polygon offset clamp, 741 ARB vertex type 10f 11f 11f rev, 705
ARB program interface query, 692, AreTexturesResident, 682
702 ARRAY BUFFER, 61, 358, 359, 364
ARB query buffer object, 705 ARRAY BUFFER BINDING, 364,
ARB robust buffer access behavior, 587
692, 702 ARRAY SIZE, 106, 111, 112, 136, 137,
ARB robustness, 702 388, 396, 623, 710, 725
ARB robustness isolation, 702 ARRAY STRIDE, 111, 113, 137, 623
ARB shader atomic counter ops, 741 ArrayStride, 147, 148
ARB shader atomic counters, 684, 689 ATOMIC COUNTER BARRIER BIT,
ARB shader draw parameters, 741 163, 165
ARB shader group vote, 741 ATOMIC -
COUNTER BUFFER, 61, 62,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 779
102, 106, 108–112, 138, 151 atomic uint, 119, 150, 737
ATOMIC COUNTER BUFFER AC- AtomicCounter, 667, 668
TIVE ATOMIC COUNTER - atomicCounter, 662
INDICES, 140, 621 atomicCounterDecrement, 662
ATOMIC COUNTER BUFFER AC- atomicCounterIncrement, 662
TIVE ATOMIC COUN- AtomicCounterMemory, 668
TERS, 140, 621 AtomicStorage, 672
ATOMIC COUNTER - AtomicStorageOps, 672
BUFFER BINDING, 85, 140, ATTACHED SHADERS, 167, 170, 614
621, 628 AttachShader, 95
ATOMIC COUNTER BUFFER - ATTRIB STACK DEPTH, 683
DATA SIZE, 140, 621
BACK, 310, 478, 503, 507, 517–522,
ATOMIC COUNTER BUFFER IN-
530, 592, 681, 727
DEX, 111, 113, 137, 623
BACK LEFT, 310, 518, 519, 527
ATOMIC COUNTER BUFFER REF-
BACK RIGHT, 310, 518, 519, 527
ERENCED BY COMPUTE -
barrier, 415
SHADER, 140, 621
BaseInstance, 671
ATOMIC COUNTER BUFFER REF-
BaseVertex, 671
ERENCED BY FRAG-
Begin, 679
MENT SHADER, 140, 621
BeginConditionalRender, 381, 382,
ATOMIC COUNTER BUFFER REF-
383, 770
ERENCED BY GEOME-
BeginQuery, 43, 46, 51, 383, 409, 429,
TRY SHADER, 140, 621
439, 457, 498, 505, 548
ATOMIC COUNTER BUFFER REF-
BeginQueryIndexed, 43, 45, 46, 47,
ERENCED BY TESS CON-
451, 452, 727, 739
TROL SHADER, 140, 621
BeginTransformFeedback, 445, 445–
ATOMIC COUNTER BUFFER REF-
449, 736
ERENCED BY TESS EVAL-
BGR, 194, 534, 536
UATION SHADER, 140
BGR INTEGER, 194
ATOMIC COUNTER BUFFER REF-
BGRA, 194, 197, 202, 354, 355, 358,
ERENCED BY TESS EVA-
363, 534
LUTION SHADER, 621
BGRA INTEGER, 194, 197
ATOMIC COUNTER BUFFER REF-
BindAttribLocation, 131, 387, 387, 714,
ERENCED -
730
BY VERTEX SHADER, 140,
BindBuffer, 28, 59, 60, 62, 239, 355,
621
364, 685, 697, 711
ATOMIC COUNTER BUFFER SIZE,
BindBufferBase, 62, 63, 64, 84, 447,
85, 628
449, 686, 694, 697
ATOMIC COUNTER BUFFER -
BindBufferRange, 54, 62, 63, 64, 84,
START, 85, 628
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 780
149, 151, 153, 447–449, 686, BlendEquationi, 507, 507
694, 697, 698, 713 BlendEquationSeparate, 507, 507
BindBuffersBase, 63, 64 BlendEquationSeparatei, 507, 507
BindBuffersRange, 64, 64, 65 BlendFunc, 509, 510
BindFragDataLocation, 131, 495, 495, BlendFunci, 510, 510
496 BlendFuncSeparate, 509, 510
BindFragDataLocationIndexed, 494, BlendFuncSeparatei, 510, 510
496, 512 BlitFramebuffer, 26, 327, 529, 538, 538,
BindFramebuffer, 302, 303, 305, 331 539, 541, 696, 699, 714, 715
BindImageTexture, 54, 291, 292, 293, BlitNamedFramebuffer, 538, 538, 541
299, 572, 576, 688 Block, 147
BindImageTextures, 292, 292 BLOCK INDEX, 111, 113, 137, 623
Binding, 129, 736 BLUE, 194, 240, 286, 490, 534, 536,
binding, 152 596, 598, 607
BindProgramPipeline, 99, 123, 123– BLUE BITS, 682
125, 157, 170, 407, 449 BLUE INTEGER, 194
BindRenderbuffer, 313, 314, 315, 722 BOOL, 116
BindSampler, 28, 184, 184, 186, 187 bool, 116, 145
BindSamplers, 185, 185 BOOL VEC2, 116
BindTexture, 157, 179, 180, 180, 181, BOOL VEC3, 116
183, 288, 726 BOOL VEC4, 116
BindTextures, 181, 181 boolean, 143, 694
BindTextureUnit, 182 BUFFER, 557
BindTransformFeedback, 443, 444, 738 BUFFER ACCESS, 61, 68, 75, 588
BindVertexArray, 351, 351, 352 BUFFER ACCESS FLAGS, 61, 68, 75,
BindVertexBuffer, 355, 355–357, 364, 78, 588
711, 714 BUFFER BINDING, 111, 113, 139,
BindVertexBuffers, 356, 356, 357 140, 623
BITMAP, 681 BUFFER DATA SIZE, 111, 113, 139,
Bitmap, 681 140, 151, 623
BLEND, 507, 513, 514, 603 BUFFER IMMUTABLE STORAGE,
BLEND COLOR, 603 61, 68, 70, 71, 588
BLEND DST ALPHA, 603 BUFFER MAP LENGTH, 61, 68, 75,
BLEND DST RGB, 603 78, 588
BLEND EQUATION ALPHA, 603 BUFFER MAP OFFSET, 61, 68, 75,
BLEND EQUATION RGB, 603 78, 588
BLEND SRC ALPHA, 603 BUFFER MAP POINTER, 61, 68, 75,
BLEND SRC RGB, 603 78, 82, 83, 588
BlendColor, 509, 512 BUFFER MAPPED, 61, 68, 75, 78, 588
BlendEquation, 507, 507 BUFFER SIZE, 61, 68, 71–73, 76, 80,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 781
83, 153, 236, 588 ClampColor, 535, 680
BUFFER STORAGE FLAGS, 61, 68, CLEAR, 515
71, 73, 74, 588 Clear, 26, 336, 464, 523, 524–526, 682
BUFFER UPDATE BARRIER BIT, CLEAR BUFFER, 571
163 CLEAR TEXTURE, 571, 715
BUFFER USAGE, 61, 68, 74, 588 ClearAccum, 682
BUFFER VARIABLE, 103, 111, 112, ClearBufferfif uigv, 524
114 ClearBufferData, 72, 576
BufferBlock, 147, 148, 668 ClearBuffer?, 525, 526
BufferData, 56, 65, 68, 68–70, 78, 697, ClearBufferfv, 525, 526
709 ClearBufferiv, 525, 526
BufferStorage, 65, 65, 67–70, 709 ClearBufferSubData, 66, 71, 71, 72,
BufferSubData, 56, 66, 70, 70, 161, 576, 697
164, 713 ClearBufferuiv, 526
BuiltIn, 128, 740 ClearColor, 523, 525
bvec2, 116, 142 ClearDepth, 523, 525, 695
bvec3, 116 ClearDepthf, 523
bvec4, 116 ClearNamedBufferData, 72, 72
BYTE, 193, 298, 299, 353, 537, 538 ClearNamedBufferSubData, 71, 71
ClearNamedFramebuffer, 524
callback, 552
ClearNamedFramebuffer?, 525, 526
CallList, 683
ClearNamedFramebufferfv, 526
CallLists, 683
ClearNamedFramebufferiv, 526
CAVEAT SUPPORT, 570
ClearNamedFramebufferuiv, 526
CCW, 168, 477, 592, 619
ClearStencil, 524, 525
ccw, 418
ClearTexImage, 285
Centroid, 668
ClearTexImageSubData, 71
centroid, 489
ClearTexSubImage, 283, 284, 285
centroid in, 489
CLIENT ALL ATTRIB BITS, 683
CheckFramebufferStatus, 331, 332,
CLIENT ATTRIB STACK DEPTH,
332, 729
683
CheckNamedFramebufferStatus, 332,
CLIENT MAPPED BUFFER BAR-
332
RIER BIT, 67, 163, 723
CLAMP, 681
CLIENT STORAGE BIT, 67
CLAMP FRAGMENT COLOR, 680
ClientActiveTexture, 679
CLAMP READ COLOR, 535, 590
ClientWaitSync, 36, 37, 38, 38–40, 55
CLAMP TO BORDER, 241, 254, 261
CLIP DEPTH MODE, 589
CLAMP TO EDGE, 240, 241, 254,
CLIP DISTANCEi, 589
261, 286, 539
CLIP DISTANCE0, 455
CLAMP VERTEX COLOR, 680
CLIP ORIGIN, 589
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 782
ClipControl, 453 COMPRESSED RED RGTC1, 212,
ClipDistance, 671, 672 274, 544, 675
CLIPPING INPUT PRIMITIVES, 43, COMPRESSED RG, 212
48, 457 COMPRESSED RG11 EAC, 212, 676
CLIPPING OUTPUT PRIMITIVES, COMPRESSED RG RGTC2, 212,
43, 48, 457 274, 544, 675
ClipPlane, 680 COMPRESSED RGB, 212
coherent, 164 COMPRESSED RGB8 ETC2, 212,
COLOR, 218, 524, 526, 527 676
COLOR ATTACHMENTm, 722 COMPRESSED RGB8 -
COLOR ATTACHMENT0, 304, 521, PUNCHTHROUGH AL-
530 PHA1 ETC2, 212, 676
COLOR BUFFER BIT, 523, 526, 539– COMPRESSED RGB -
541 BPTC SIGNED FLOAT, 212,
COLOR CLEAR VALUE, 604 274, 544, 675
COLOR COMPONENTS, 573 COMPRESSED RGB BPTC UN-
COLOR ENCODING, 573 SIGNED FLOAT, 212, 274,
COLOR INDEX, 679 544, 675
COLOR LOGIC OP, 514, 603 COMPRESSED RGBA, 212
COLOR MATERIAL, 680 COMPRESSED RGBA8 ETC2 EAC,
COLOR RENDERABLE, 573 212, 676
COLOR SUM, 682 COMPRESSED RGBA BPTC UN-
COLOR WRITEMASK, 522, 604 ORM, 212, 274, 544, 675
ColorMask, 521, 521–523 COMPRESSED SIGNED R11 EAC,
ColorMaski, 521, 521, 522, 715 212, 676
ColorMaterial, 680 COMPRESSED SIGNED -
ColorPointer, 679 RED RGTC1, 212, 274, 544,
COMMAND BARRIER BIT, 162, 737 675
COMPARE REF TO TEXTURE, 240, COMPRESSED SIGNED RG11 EAC,
288 212, 676
COMPATIBLE SUBROUTINES, 111, COMPRESSED SIGNED RG -
120, 156, 620, 623, 736 RGTC2, 212, 274, 544, 675
COMPILE STATUS, 90, 92, 101, 166, COMPRESSED SRGB, 212, 290
167, 612 COMPRESSED SRGB8 ALPHA8 -
CompileShader, 90, 90, 91 ETC2 EAC, 212, 290, 676
Component, 128, 129, 390, 495, 497 COMPRESSED SRGB8 ETC2, 212,
component, 114, 126, 385, 390, 495, 290, 676
722 COMPRESSED SRGB8 -
COMPRESSED R11 EAC, 212, 676 PUNCHTHROUGH AL-
COMPRESSED RED, 212 PHA1 ETC2, 212, 290, 676
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 783
COMPRESSED SRGB ALPHA, 212, 567
290 CONTEXT FLAG FORWARD COM-
COMPRESSED SRGB ALPHA - PATIBLE BIT, 567
BPTC UNORM, 212, 274, CONTEXT FLAG NO ERROR BIT,
290, 544, 675 568
COMPRESSED TEXTURE FOR- CONTEXT FLAG ROBUST AC-
MATS, 206, 637, 679, 685 CESS BIT, 568
CompressedTexImage1D, 215, 226, CONTEXT FLAGS, 549, 567, 568, 638
228–231, 576 CONTEXT LOST, 16–18, 20
CompressedTexImage2D, 226, 228– CONTEXT PROFILE MASK, 567,
231, 576 638, 723
CompressedTexImage3D, 226, 228– CONTEXT RELEASE BEHAVIOR,
231, 251, 576, 706, 735 568, 635
CompressedTexSubImage*D, 232 CONTEXT RELEASE BEHAVIOR -
CompressedTexSubImage1D, 230 FLUSH, 568
CompressedTexSubImage2D, 231 COPY, 515, 603
CompressedTexSubImage3D, 231, 252 COPY INVERTED, 515
CompressedTextureSubImage*D, 232 COPY READ BUFFER, 61, 81, 685,
CompressedTextureSubImage1D, 231 686, 697
CompressedTextureSubImage2D, 231 COPY READ BUFFER BINDING,
CompressedTextureSubImage3D, 231 656, 686
COMPUTE SHADER, 89, 155, 546, COPY WRITE BUFFER, 61, 81, 685,
613, 709 686, 697
COMPUTE SHADER BIT, 124 COPY WRITE BUFFER BINDING,
COMPUTE SHADER INVOCA- 656, 686
TIONS, 43, 48, 548 CopyBufferSubData, 66, 80, 81, 728
COMPUTE SUBROUTINE, 103, 155 CopyImageSubData, 206, 542, 542–
COMPUTE SUBROUTINE UNI- 544, 724, 738
FORM, 103, 108, 111, 120, CopyNamedBufferSubData, 80, 81
155 CopyPixels, 218, 682
COMPUTE TEXTURE, 571 CopyTexImage, 284, 682
COMPUTE WORK GROUP SIZE, CopyTexImage1D, 219, 220, 221, 266,
169, 547, 614 576
CONDITION SATISFIED, 38 CopyTexImage2D, 218, 219–221, 266,
CONSTANT ALPHA, 511 576
CONSTANT COLOR, 511 CopyTexSubImage1D, 220, 222
CONTEXT COMPATIBILITY PRO- CopyTexSubImage2D, 220, 222
FILE BIT, 567 CopyTexSubImage3D, 220, 222
CONTEXT CORE PROFILE BIT, 567 CopyTextureSubImage1D, 221, 222
CONTEXT FLAG DEBUG BIT, 549, CopyTextureSubImage2D, 221, 222
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 784
CopyTextureSubImage3D, 221, 222, DEBUG SEVERITY HIGH, 551
223 DEBUG SEVERITY LOW, 551, 552
CreateBuffers, 28, 59, 59, 355, 356 DEBUG SEVERITY MEDIUM, 551
CreateFramebuffers, 303, 303 DEBUG SEVERITY NOTIFICA-
CreateProgram, 28, 94 TION, 551, 556
CreateProgramPipelines, 123, 123 DEBUG SOURCE API, 17, 550, 571
CreateQueries, 44, 44, 45, 47, 51, 727, DEBUG SOURCE APPLICATION,
739 550, 555, 556
CreateRenderbuffers, 314, 314 DEBUG SOURCE OTHER, 550
CreateSamplers, 184, 184, 724 DEBUG SOURCE SHADER COM-
CreateShader, 88, 89 PILER, 550
CreateShaderProgramv, 100, 100, 101 DEBUG SOURCE THIRD PARTY,
CreateTextures, 28, 182, 182, 243 550, 555, 556
CreateTransformFeedbacks, 444, 444 DEBUG SOURCE WINDOW SYS-
CreateVertexArrays, 28, 352, 352 TEM, 550
CULL FACE, 478, 592 DEBUG TYPE DEPRECATED BE-
CULL FACE MODE, 592 HAVIOR, 551
CullDistance, 671, 672 DEBUG TYPE ERROR, 17, 551
CullFace, 477, 478, 478, 482 DEBUG TYPE MARKER, 551
CURRENT PROGRAM, 614 DEBUG TYPE OTHER, 551
CURRENT QUERY, 47, 48, 656, 740 DEBUG TYPE PERFORMANCE,
CURRENT VERTEX ATTRIB, 379, 551, 571
625, 687 DEBUG TYPE POP GROUP, 551, 556
CW, 168, 477 DEBUG TYPE PORTABILITY, 551
cw, 418 DEBUG TYPE PUSH GROUP, 551,
556
DEBUG CALLBACK FUNCTION,
DEBUG TYPE UNDEFINED BE-
553, 559, 566, 649
HAVIOR, 551
DEBUG CALLBACK USER -
DebugMessageCallback, 552, 553, 559,
PARAM, 559, 566, 649
715
DEBUG GROUP STACK DEPTH,
DebugMessageControl, 552, 554, 696,
649
715
DEBUG LOGGED MESSAGES, 553,
DebugMessageInsert, 555, 555, 730
649
DECR, 504
DEBUG NEXT LOGGED MES-
DECR WRAP, 504
SAGE LENGTH, 553, 649
DELETE STATUS, 91, 166, 167, 612,
DEBUG OUTPUT, 405, 549, 553–555,
614
649
DeleteBuffers, 28, 54, 60, 62, 63, 65,
DEBUG OUTPUT SYNCHRONOUS,
356, 697
558, 559, 649
DeleteFramebuffers, 303, 305
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 785
DeleteLists, 683 534
DeleteProgram, 100, 100 DEPTH STENCIL ATTACHMENT,
DeleteProgramPipelines, 122, 123–125, 310, 313, 319, 320, 326, 695
170, 408 DEPTH STENCIL -
DeleteQueries, 44, 45, 52 TEXTURE MODE, 240, 269,
DeleteRenderbuffers, 54, 314, 315, 331 270, 286, 288, 402, 597, 707,
DeleteSamplers, 185, 187, 706 725
DeleteShader, 91, 91 DEPTH TEST, 504, 602
DeleteSync, 37, 38, 41 DEPTH TEXTURE MODE, 681
DeleteTextures, 54, 183, 292, 331 DEPTH WRITEMASK, 604
DeleteTransformFeedbacks, 443, 444, DepthFunc, 505
687, 700 DepthMask, 522, 523
DeleteVertexArrays, 351, 351, 352 DepthRange, 15, 459, 459
DEPTH, 218, 310, 525–527, 598, 607 DepthRangeArrayv, 459, 459
Depth, 667 DepthRangef, 459
DEPTH24 STENCIL8, 211 DepthRangeIndexed, 459, 459
DEPTH32F STENCIL8, 211 DerivativeControl, 672
DEPTH ATTACHMENT, 304, 320, DetachShader, 95
329 Device, 667
DEPTH BITS, 682 dFdx, 563
DEPTH BUFFER BIT, 523, 526, 539, dFdy, 563
541 Disable, 254, 361, 455, 464, 467–469,
DEPTH CLAMP, 455, 589 471, 477, 478, 485, 486, 501,
DEPTH CLEAR VALUE, 604 503, 504, 507, 514, 549, 558,
DEPTH COMPONENT, 194, 205, 211, 680–682, 705
215, 240, 247, 248, 284–286, DisableClientState, 679
288, 328, 401, 402, 532–534, Disablei, 485, 506, 507
597 DisableVertexArrayAttrib, 359, 359
DEPTH COMPONENT16, 211 DisableVertexAttribArray, 359, 359,
DEPTH COMPONENT24, 211 379
DEPTH COMPONENT32, 211 DISPATCH INDIRECT BUFFER, 61,
DEPTH COMPONENT32F, 211 162, 365, 547, 548, 697, 739
DEPTH COMPONENTS, 574 DISPATCH INDIRECT BUFFER -
DEPTH FUNC, 602 BINDING, 634
DEPTH RANGE, 589, 716 DispatchCompute, 546, 547, 723
DEPTH RENDERABLE, 574 DispatchComputeIndirect, 162, 365,
DEPTH STENCIL, 194, 197, 202–205, 547, 697, 711, 739
211, 215, 218, 247, 248, 269, DITHER, 514, 603
270, 284, 285, 288, 319, 326, dmatC, 145
328, 401, 402, 525, 526, 533, dmatCxR, 145
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 786
dmat*, 686, 688 DRAW INDIRECT BUFFER BIND-
dmat2, 116, 386 ING, 587
dmat2x3, 116, 386, 389 DrawArrays, 338, 340, 351, 361, 364,
dmat2x4, 116, 386, 389 366, 367, 368, 404, 729
dmat3, 116, 142, 386, 389 DrawArraysIndirect, 365, 367, 368,
dmat3x2, 116, 386 369, 699, 711
dmat3x4, 116, 386, 389 DrawArraysInstanced, 367, 368, 450,
dmat4, 116, 386, 389 699
dmat4x2, 116, 386 DrawArraysInstancedBaseInstance,
dmat4x3, 116, 386, 389 366, 367, 372, 699, 740
do, 415 DrawArraysOneInstance, 365, 366, 730
DONT CARE, 554, 563, 633 DrawBuffer, 515, 516, 517, 517, 518,
DOUBLE, 116, 353 520, 523, 526, 695, 715
double, 116, 127, 145, 386, 459, 693 DrawBuffers, 516, 518, 519, 520, 695
DOUBLE MAT2, 116 DrawElements, 159, 351, 361, 364, 371,
DOUBLE MAT2x3, 116 372, 373
DOUBLE MAT2x4, 116 DrawElementsBaseVertex, 364, 374,
DOUBLE MAT3, 116 377
DOUBLE MAT3x2, 116 DrawElementsIndirect, 365, 374, 375,
DOUBLE MAT3x4, 116 376, 699, 711
DOUBLE MAT4, 116 DrawElementsInstanced, 364, 372, 372,
DOUBLE MAT4x2, 116 699
DOUBLE MAT4x3, 116 DrawElementsInstancedBaseInstance,
DOUBLE VEC2, 116 372, 372, 699
DOUBLE VEC3, 116 DrawElementsInstancedBaseVertex,
DOUBLE VEC4, 116 364, 374, 699
DOUBLEBUFFER, 308, 655 DrawElementsInstancedBaseVertexBaseInstance,
DRAW BUFFER, 521 374, 699
DRAW BUFFERi, 606 DrawElementsOneInstance, 370, 370,
DRAW BUFFER0, 521 371, 374, 730
DRAW FRAMEBUFFER, 302, 303, DrawIndex, 671
305–309, 312, 319–322, 332, DrawParameters, 672
517, 519, 526, 527, 538, 605, DrawPixels, 681
695 DrawRangeElements, 364, 373, 374,
DRAW FRAMEBUFFER BINDING, 636
265, 306, 334, 605 DrawRangeElementsBaseVertex, 364,
DRAW INDIRECT, 369, 375 374, 374
DRAW INDIRECT BUFFER, 61, 162, DrawTransformFeedback, 450, 451
365, 368, 375, 739 DrawTransformFeedbackInstanced,
450, 450, 699
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 787
DrawTransformFeedbackStream, 450, EndQuery, 47, 51, 505, 506
451 EndQueryIndexed, 46, 46, 739
DrawTransformFeedbackStreamInstanced,EndStreamPrimitive, 434, 439
450, 450, 451, 699 EndTransformFeedback, 56, 57, 445,
DST ALPHA, 511 445, 449, 451
DST COLOR, 511 EQUAL, 168, 240, 289, 504, 505, 619
dvec2, 116, 386 equal spacing, 416, 424
dvec3, 116, 386, 389, 686, 688 EQUIV, 515
dvec4, 116, 385, 386, 389, 686, 688 ExecutionMode, 94
DYNAMIC COPY, 61, 69 exp(x), 673
DYNAMIC DRAW, 61, 68, 69 exp2(x), 673
DYNAMIC READ, 61, 69 exp2(y * log2(x)), 673
DYNAMIC STORAGE BIT, 66, 68, EXT texture ?lter anisotropic, 741
69, 71, 709 EXTENSIONS, 568, 569, 638, 683, 745
early fragment tests, 498 FALSE, 14, 15, 41, 45, 47, 49, 60, 61,
EdgeFlagPointer, 679 68, 70, 78, 89–92, 94, 96, 99–
EGL KHR create context no error, 101, 122, 131, 141, 142, 166,
776 167, 169, 175, 176, 183, 188,
ELEMENT ARRAY BARRIER BIT, 189, 286, 291–293, 295, 306,
162 312, 315, 325, 348, 352, 354,
ELEMENT AR- 355, 362, 379, 381, 382, 406,
RAY BUFFER, 61, 162, 364, 443, 464, 482, 487, 506, 532,
380 535, 549, 554, 558, 573, 574,
ELEMENT ARRAY BUFFER BIND- 576, 578, 579, 585, 587–589,
ING, 378, 380, 586, 730 591–593, 597, 599, 602, 603,
EmitStreamVertex, 434 606, 607, 610–614, 619, 621,
Enable, 254, 361, 455, 464, 467–469, 625–627, 630, 649, 656
471, 477, 478, 485, 486, 501, false, 492
503, 504, 507, 514, 549, 558, FASTEST, 563
565, 680–682, 705 FeedbackBuffer, 682
EnableClientState, 679 FenceSync, 28, 36, 36, 37, 40, 56, 67,
Enablei, 485, 506, 507 723
EnableVertexArrayAttrib, 359, 359 FILL, 480, 482, 483, 592, 664
EnableVertexAttribArray, 351, 359, FILTER, 571
359, 379 Finish, 21, 21, 36, 56, 67, 664
End, 679 FIRST VERTEX CONVENTION,
EndConditionalRender, 381, 382, 383 438, 453
EndList, 683 FIXED, 353
EndPrimitive, 336, 434, 439 FIXED ONLY, 535, 544, 590
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 788
Flat, 668 652
?at, 433, 453, 726 FRAGMENT SHADER, 89, 155, 172,
FLOAT, 115, 193, 245, 295, 298, 311, 173, 613
353, 381, 535–537, 576, 585 FRAGMENT SHADER BIT, 124
?oat, 115, 127, 145, 386 FRAGMENT SHADER DERIVA-
Float64, 672 TIVE HINT, 563, 633
FLOAT 32 UNSIGNED INT - FRAGMENT SHADER INVOCA-
24 8 REV, 192, 193, 195, 197, TIONS, 43, 48, 498
201, 533, 537, 538 FRAGMENT SUBROUTINE, 103,
FLOAT MAT2, 116 155
FLOAT MAT2x3, 116 FRAGMENT SUBROUTINE UNI-
FLOAT MAT2x4, 116 FORM, 103, 108, 111, 120,
FLOAT MAT3, 116 155
FLOAT MAT3x2, 116 FRAGMENT TEXTURE, 571
FLOAT MAT3x4, 116 FRAMEBUFFER, 303, 306–309, 312,
FLOAT MAT4, 116 319–322, 332, 526, 527, 557,
FLOAT MAT4x2, 116 695
FLOAT MAT4x3, 116 FRAMEBUFFER ATTACHMENT x -
FLOAT VEC2, 115 SIZE, 607
FLOAT VEC3, 115 FRAMEBUFFER ATTACHMENT -
FLOAT VEC4, 116 ALPHA SIZE, 311
Flush, 20, 20, 21, 40, 664, 736 FRAMEBUFFER ATTACHMENT -
FlushMappedBufferRange, 56, 74, 75, BLUE SIZE, 311
77, 77 FRAMEBUFFER ATTACHMENT -
FlushMappedNamedBufferRange, 77, COLOR ENCODING,
77, 78 219, 311, 508, 513, 514, 539,
fma(), 673 607
FOG, 682 FRAMEBUFFER ATTACHMENT -
Fog, 682 COMPONENT TYPE, 311,
FOG HINT, 683 607
FogCoordPointer, 679 FRAMEBUFFER ATTACHMENT -
for, 415 DEPTH SIZE, 311
FRACTIONAL EVEN, 168 FRAMEBUFFER ATTACHMENT -
fractional even spacing, 416 GREEN SIZE, 311
FRACTIONAL ODD, 168 FRAMEBUFFER ATTACH-
fractional odd spacing, 416, 418 MENT LAYERED, 312, 325,
FragCoord, 671 607, 712
FragDepth, 671 FRAMEBUFFER ATTACHMENT -
FRAGMENT INTERPO- OBJECT NAME, 310–312,
LATION OFFSET BITS, 489, 319, 325, 329, 607
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 789
FRAMEBUFFER ATTACH- MISSING ATTACHMENT,
MENT OBJECT TYPE, 310– 330
312, 319, 325, 329, 334, 607, FRAMEBUFFER INCOMPLETE -
720, 735 MULTISAMPLE, 330, 331
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER RENDERABLE,
RED SIZE, 311 333, 571, 737
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER RENDERABLE -
STENCIL SIZE, 311 LAYERED, 333, 571, 737
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER SRGB,
TEXTURE - 508, 513, 514, 539, 573, 603,
CUBE MAP FACE, 312, 325, 712
607 FRAMEBUFFER UNDEFINED, 330
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER UNSUPPORTED,
TEXTURE LAYER, 312, 325, 330, 332
335, 607, 707 FramebufferParameteri, 306, 306–308,
FRAMEBUFFER ATTACHMENT - 707
TEXTURE LEVEL, 265, 312, FramebufferRenderbuffer, 319, 319,
325, 607 320, 331, 707
FRAMEBUFFER BARRIER BIT, 163, FramebufferTexture, 54, 321, 321, 323,
165 324, 729
FRAMEBUFFER BINDING, 306 FramebufferTexture1D, 322, 323
FRAMEBUFFER BLEND, 571 FramebufferTexture2D, 322, 323
FRAMEBUFFER COMPLETE, 332 FramebufferTexture3D, 322, 323
FRAMEBUFFER DEFAULT, 310 FramebufferTextureLayer, 323
FRAMEBUFFER DEFAULT FIXED - FRONT, 310, 478, 503, 507, 517, 518,
SAMPLE LOCATIONS, 306– 520–522, 530, 681, 727
308, 606 FRONT AND BACK, 478, 480, 503,
FRAMEBUFFER DEFAULT - 507, 518, 520–522, 530
HEIGHT, 306–308, 330, 606 FRONT FACE, 592
FRAMEBUFFER DEFAULT LAY- FRONT LEFT, 310, 518, 519, 527
ERS, 306–308, 606 FRONT RIGHT, 310, 518, 519, 527
FRAMEBUFFER DEFAULT SAM- FrontFace, 477, 477, 492, 680
PLES, 306–308, 606 FrontFacing, 671
FRAMEBUFFER DEFAULT WIDTH, Frustum, 679
306–308, 330, 606 FULL SUPPORT, 333, 571, 737
FRAMEBUFFER INCOMPLETE AT- FUNC ADD, 509, 512, 603
TACHMENT, 330 FUNC REVERSE SUBTRACT, 509
FRAMEBUFFER INCOMPLETE - FUNC SUBTRACT, 509
LAYER TARGETS, 331 Function, 667
FRAMEBUFFER INCOMPLETE - fwidth, 563
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 790
GenBuffers, 28, 59, 59, 60, 62, 63, 355, GeometryStreams, 672
356 GEQUAL, 240, 289, 504, 505
GENERATE MIPMAP, 682 GET TEXTURE IMAGE FORMAT,
GENERATE MIPMAP HINT, 683 574
GenerateMipmap, 267, 267, 268, 720 GET TEXTURE IMAGE TYPE, 574
GenerateTextureMipmap, 267, 267, 268 GetActiveAtomicCounterBufferiv, 138,
GenFramebuffers, 302, 303, 305, 305 140, 621
GenLists, 683 GetActiveAttrib, 388, 388, 615, 700,
GenProgramPipelines, 122, 122–125, 721
170, 407, 408 GetActiveSubroutineName, 155, 620
GenQueries, 43, 43–45, 52 GetActiveSubroutineUniformiv, 156,
GenRenderbuffers, 313, 314, 315, 315 156, 620
GenSamplers, 184, 184–188 GetActiveSubroutineUniformName,
GenTextures, 180, 180, 181, 183, 275, 156, 620
686 GetActiveUniform, 136, 142, 615, 710
GenTransformFeedbacks, 442, 442–444 GetActiveUniformBlockiv, 138, 139,
GenVertexArrays, 350, 350, 351 618, 619
Geometry, 672 GetActiveUniformBlockName, 137
GEOMETRY INPUT TYPE, 168, 169, GetActiveUniformName, 135
431, 616 GetActiveUniformsiv, 136, 137, 617,
GEOMETRY OUTPUT TYPE, 168, 618, 621
169, 432, 616 GetAttachedShaders, 170, 614
GEOMETRY SHADER, 89, 155, 430, GetAttribLocation, 387, 389, 615
613 GetBooleani v, 522, 565, 604, 627
GEOMETRY SHADER BIT, 124 GetBooleanv, 14, 362, 522, 564, 580,
GEOMETRY SHADER - 593, 604, 610, 611, 630, 635,
INVOCATIONS, 43, 48, 168, 637, 655
169, 439, 616 GetBufferParameteri64v, 81, 588
GEOMETRY SHADER - GetBufferParameteriv, 81, 588, 730
PRIMITIVES EMITTED, 43, GetBufferPointerv, 83, 83, 588
48, 439 GetBufferSubData, 82, 82, 588
GEOMETRY SUBROUTINE, 103, GetCompressedTexImage,
155 229–232, 246, 251, 251, 252,
GEOMETRY SUBROUTINE UNI- 532, 563
FORM, 103, 108, 111, 120, GetCompressedTexSubImage, 253
155 GetCompressedTextureImage, 251, 251
GEOMETRY TEXTURE, 571 GetCompressedTextureSubImage, 252
GEOMETRY VERTICES OUT, 168, GetDebugMessageLog, 553, 559, 559,
169, 432, 436, 616 560, 715
GeometryPointSize, 672 GetDoublei v, 565, 589
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 791
GetDoublev, 15, 564 GetNamedBufferSubData, 82, 82, 83
GetError, 16, 16, 18, 20, 656 GetNamedFramebufferAttachmentParameteriv,
GetFloati v, 565, 589 309, 309, 312, 729
GetFloatv, 11, 15, 461, 468, 564, 584, GetNamedFramebufferParameteriv,
591–593, 603, 604, 635, 636, 308, 308, 309, 313, 729
652, 715 GetNamedRenderbufferParameteriv,
GetFragDataIndex, 497, 721 318, 318
GetFragDataLocation, 497, 721 GetnCompressedTexImage, 251, 251
GetFramebufferAttachmentParameteriv, GetnTexImage, 246, 247, 248, 251, 722
309, 309, 312, 607, 707, 711, GetnUniformdv, 173
714, 729, 735 GetnUniformfv, 173
GetFramebufferParameteriv, 308, 308, GetnUniformiv, 174
309, 313, 606, 695, 729 GetnUniformuiv, 174
GetGraphicsResetStatus, 19, 19, 20 GetObjectLabel, 560, 561, 585, 588,
GetInteger, 569 597, 600, 606, 609, 612–614,
GetInteger64i v, 84, 565, 580, 586, 626, 630
628–631 GetObjectPtrLabel, 561, 632
GetInteger64v, 15, 39, 51, 371, 564, GetPointerv, 559, 566, 649, 693, 725
635, 646, 651, 686 GetPolygonStipple, 715
GetIntegeri v, 84, 487, 513, 547, 565, GetProgramBinary, 130, 131, 132, 614,
580, 581, 586, 593, 602, 603, 721, 735
627–631, 644 GetProgramInfoLog, 98, 131, 171, 171,
GetIntegeriv, 656 614, 719
GetIntegerv, 15, 19, 51, 133, 144, 149– GetProgramInterfaceiv, 107, 110, 622
152, 179, 185, 206, 306, 313, GetProgramiv, 96, 130, 131, 167, 167,
314, 373, 380, 438, 454, 510, 170, 171, 406, 411, 431, 432,
513, 519, 521, 530, 532, 547, 436, 547, 614–617, 619, 621,
564, 567, 568, 580, 581, 584, 728
586, 587, 589–592, 594, 595, GetProgramPipelineInfoLog, 171, 171,
601–606, 608, 610, 611, 614, 719
628, 629, 631, 633–652, 654– GetProgramPipelineiv, 169, 171, 407,
656 613
GetInternalformati64v, 569, 577 GetProgramPiplineInfoLog, 613
GetInternalformativ, 235, 316, 333, 569, GetProgramResourceIndex, 108
653 GetProgramResourceiv, 110, 111, 112,
GetMultisamplefv, 399, 466, 467, 655, 137, 139, 140, 145, 151, 496,
708 623, 624, 710, 720, 727, 736
GetNamedBufferParameteri64v, 82 GetProgramResourceLocation, 120,
GetNamedBufferParameteriv, 81 120, 121
GetNamedBufferPointerv, 83, 83 GetProgramResourceLocationIndex,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 792
120, 120, 121 GetTexParameteriv, 288, 596, 597
GetProgramResourceName, 109 GetTextureImage, 246, 247–251, 740
GetProgramStageiv, 175, 620 GetTextureLevelParameter, 244
GetQueryBufferObjecti64v, 49 GetTextureLevelParameter*, 246
GetQueryBufferObjectiv, 49 GetTextureParameter, 243
GetQueryBufferObjectui64v, 49 GetTextureParameter*, 244
GetQueryBufferObjectuiv, 49 GetTextureParameterI, 243
GetQueryIndexediv, 47, 739 GetTextureParameteriv, 596
GetQueryiv, 49, 651, 656 GetTextureSubImage, 249, 252, 253,
GetQueryObjecti64v, 49 740
GetQueryObjectiv, 49, 626 GetTransformFeedback*, 581
GetQueryObjectui64v, 49 GetTransformFeedbacki64 v, 580, 581
GetQueryObjectuiv, 20, 49, 626 GetTransformFeedbacki v, 580, 581
GetRenderbufferParameteriv, 318, 318, GetTransformFeedbackiv, 580, 581
334, 609 GetTransformFeedbackVarying, 395,
GetSamplerParameter, 188 396, 616, 714
GetSamplerParameterfv, 600 GetUniform, 615
GetSamplerParameterIfi uigv, 188 GetUniformBlockIndex, 137
GetSamplerParameterIiv, 188 GetUniformdv, 173
GetSamplerParameterIuiv, 14, 188 GetUniformfv, 173
GetSamplerParameteriv, 600 GetUniformIndices, 136, 710
GetShaderInfoLog, 90, 171, 171, 612, GetUniformiv, 173
719 GetUniformLocation, 135, 158, 615
GetShaderiv, 90, 91, 166, 171, 172, 612 GetUniformSubroutineuiv, 174
GetShaderPrecisionFormat, 91, 172 GetUniformuiv, 173
GetShaderSource, 172, 612 GetVertexArrayIndexed64iv, 378, 378
GetString, 566, 567, 638, 683, 725 GetVertexArrayIndexediv, 378, 378
GetStringi, 568, 638, 745 GetVertexArrayiv, 377
GetSubroutineIndex, 155 GetVertexAttribdv, 379, 379
GetSubroutineUniformLocation, 156, GetVertexAttribfv, 379, 379, 625
698 GetVertexAttribIiv, 379, 379
GetSynciv, 20, 37, 41, 41, 632 GetVertexAttribIuiv, 379, 380
GetTexImage, 163, 246, 248, 249, 251, GetVertexAttribiv, 379, 379, 585, 586
288, 295, 298, 532, 574, 595 GetVertexAttribLdv, 379, 380
GetTexLevelParameter, 244 GetVertexAttribPointerv, 380, 585
GetTexLevelParameteriv, 598, 599 gl , 107
GetTexParameter, 243, 276, 297, 334, GL APPLE ?ush buffer range, 753
574 GL APPLE vertex array object, 753
GetTexParameterfv, 288, 596, 597 GL ARB arrays of arrays, 764
GetTexParameterI, 243 GL ARB base instance, 762
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 793
GL ARB bindless texture, 769 GL ARB enhanced layouts, 768
GL ARB blend func extended, 757 GL ARB ES2 compatibility, 760
GL ARB buffer storage, 716 GL ARB ES3 1 compatibility, 719,
GL ARB buffer storage, 767 732, 770
GL ARB cl event, 761 GL ARB ES3 2 compatibility, 773
GL ARB clear buffer object, 764 GL ARB ES3 compatibility, 765
GL ARB clear texture, 716 GL ARB explicit attrib location, 757
GL ARB clear texture, 768 GL ARB explicit uniform location,
GL ARB clip control, 718, 732, 770 765
GL ARB color buffer ?oat, 750 GL ARB fragment coord conventions,
GL ARB compatibility, 678, 754 755
GL ARB compressed texture pixel - GL ARB fragment layer viewport, 765
storage, 762 GL ARB fragment program, 748, 749
GL ARB compute shader, 764 GL ARB fragment program shadow,
GL ARB compute variable group size, 750
769 GL ARB fragment shader, 749
GL ARB conditional render inverted, GL ARB fragment shader interlock,
719, 731, 770 774
GL ARB conservative depth, 762 GL ARB framebuffer no attachments,
GL ARB copy buffer, 754 765
GL ARB copy image, 764 GL ARB framebuffer object, 31, 751
GL ARB cull distance, 718, 731, 771 GL ARB framebuffer sRGB, 752
GL ARB debug group, 763 GL ARB geometry shader4, 752
GL ARB debug label, 764 GL ARB get program binary, 760
GL ARB debug output, 761, 763 GL ARB get texture sub image, 719,
GL ARB debug output2, 763 731, 771
GL ARB depth buffer ?oat, 751 GL ARB gl spirv, 734, 776
GL ARB depth clamp, 754 GL ARB gpu shader5, 759
GL ARB depth texture, 747 GL ARB gpu shader fp64, 759
GL ARB derivative control, 719, 732, GL ARB gpu shader int64, 774
771 GL ARB half ?oat pixel, 751
GL ARB direct state access, 719, 726, GL ARB half ?oat vertex, 752
731, 771 GL ARB indirect parameters, 733
GL ARB draw buffers, 750 GL ARB indirect parameters, 769
GL ARB draw buffers blend, 756 GL ARB instanced arrays, 752
GL ARB draw elements base vertex, GL ARB internalformat query, 762
755 GL ARB internalformat query2, 765
GL ARB draw indirect, 759 GL ARB invalidate subdata, 766
GL ARB draw instanced, 751, 752 GL ARB map buffer alignment, 763
GL ARB enhanced layouts, 717 GL ARB map buffer range, 752
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 794
GL ARB matrix palette, 747 GL ARB shader image load store, 763
GL ARB multi bind, 717 GL ARB shader image size, 766
GL ARB multi draw indirect, 766 GL ARB shader objects, 749
GL ARB multi bind, 768 GL ARB shader precision, 760
GL ARB multisample, 746 GL ARB shader stencil export, 761
GL ARB multitexture, 746 GL ARB shader storage buffer object,
GL ARB occlusion query, 749 766
GL ARB occlusion query2, 758 GL ARB shader subroutine, 759
GL ARB parallel shader compile, 774 GL ARB shader tex-
GL ARB pipeline statistics query, 733, ture image samples, 719, 732,
772 771
GL ARB pixel buffer object, 751 GL ARB shader texture lod, 754
GL ARB point parameters, 746 GL ARB shader viewport layer array,
GL ARB point sprite, 749 775
GL ARB polygon offset clamp, 734 GL ARB shader draw parameters, 769
GL ARB post depth coverage, 774 GL ARB shader group vote, 770
GL ARB program interface query, 766 GL ARB shading language 100, 749
GL ARB provoking vertex, 755 GL ARB shading language 420pack,
GL ARB query buffer object, 716 762
GL ARB query buffer object, 768 GL ARB shading language include,
GL ARB robust buffer access behav- 757
ior, 766 GL ARB shading language packing,
GL ARB robustness, 732, 761 763
GL ARB robustness isolation, 765, GL ARB shadow, 748, 749
767 GL ARB shadow ambient, 748
GL ARB sample locations, 774 GL ARB sparse buffer, 773
GL ARB sample shading, 756 GL ARB sparse texture2, 775
GL ARB sampler objects, 758 GL ARB sparse texture clamp, 775
GL ARB seamless cube map, 755 GL ARB sparse texture, 770
GL ARB seamless cubemap per tex- GL ARB spirv extensions, 734
ture, 769 GL ARB stencil texturing, 766
GL ARB separate shader objects, 760 GL ARB sync, 755
GL ARB shader atomic counter ops, GL ARB tessellation shader, 759
734, 775 GL ARB texture barrier, 719, 732, 772
GL ARB shader atomic counters, 763 GL ARB texture border clamp, 746
GL ARB shader ballot, 775 GL ARB texture buffer object, 753
GL ARB shader bit encoding, 758 GL ARB texture buffer object rgb32,
GL ARB shader clock, 775 759
GL ARB shader draw parameters, 734 GL ARB texture buffer range, 767
GL ARB shader group vote, 734 GL ARB texture compression, 746
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 795
GL ARB texture compression bptc, feedback over?ow query, 734,
757 773
GL ARB texture compression rgtc, GL ARB transpose matrix, 746
753 GL ARB uniform buffer object, 754
GL ARB texture cube map, 746 GL ARB vertex array bgra, 756
GL ARB texture cube map array, 756 GL ARB vertex array object, 753
GL ARB texture env add, 746 GL ARB vertex attrib 64bit, 760
GL ARB texture env combine, 747 GL ARB vertex attrib binding, 764
GL ARB texture env crossbar, 747 GL ARB vertex blend, 747
GL ARB texture env dot3, 747 GL ARB vertex buffer object, 748
GL ARB texture ?lter anisotropic, 734 GL ARB vertex program, 748
GL ARB texture ?lter minmax, 776 GL ARB vertex shader, 749
GL ARB texture ?oat, 751 GL ARB vertex type 10f 11f 11f rev,
GL ARB texture gather, 756 716
GL ARB texture mirror clamp to - GL ARB vertex type 2 10 10 10 rev,
edge, 716 758
GL ARB texture mirrored repeat, 747 GL ARB vertex type 10f 11f 11f rev,
GL ARB texture multisample, 755 768
GL ARB texture non power of two, GL ARB viewport array, 760
749 GL ARB window pos, 748
GL ARB texture query levels, 767 GL ARB name, 745
GL ARB texture query lod, 757 gl BackColor, 680
GL ARB texture rectangle, 750 gl BackSecondaryColor, 680
GL ARB texture rg, 753 gl BaseInstance, 388, 404
GL ARB texture rgb10 a2ui, 758 gl BaseVertex, 388, 404
GL ARB texture stencil8, 717 gl ClipDistance, 405, 412, 413, 427,
GL ARB texture storage, 763 429, 437, 770
GL ARB texture storage multisample, gl ClipDistance[], 126, 435, 454
767 gl CullDistance, 405, 412, 413, 427,
GL ARB texture swizzle, 758 429, 437, 454, 770
GL ARB texture view, 764 gl CullDistance[], 126, 435, 454
GL ARB texture mirror clamp to - gl DrawID, 368, 369, 373, 376, 377,
edge, 768 388, 404, 740
GL ARB texture stencil8, 768 GL EXT framebuffer blit, 752
GL ARB timer query, 758 GL EXT framebuffer multisample,
GL ARB transform feedback2, 759 752
GL ARB transform feedback3, 760 GL EXT framebuffer object, 31, 752
GL ARB transform feedback in- GL EXT texture compression rgtc,
stanced, 762 753
GL ARB transform - gl FragCoord, 491
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 796
gl FragCoord.z, 659 429, 435, 436, 457, 665
gl FragDepth, 493, 494, 659 gl PrimitiveID, 412, 427, 437, 492
gl FrontFacing, 492 gl PrimitiveIDIn, 435
gl in, 412, 427 gl SampleID, 492, 493
gl in[], 435 gl SampleMask, 493, 494, 722, 723
gl InstanceID, 366, 371, 388, 404, 700 gl SampleMaskIn, 493, 722, 725, 738
gl InvocationID, 411, 412, 414, 434 gl SampleMaskIn[], 774
GL KHR blend equation advanced, gl SamplePosition, 492, 493
773 gl SkipComponents, 448
GL KHR blend equation advanced co- gl SkipComponents1, 106, 109, 114,
herent, 773 115, 393
GL KHR context ?ush control, 719, gl SkipComponents2, 106, 109, 114,
772 115, 393
GL KHR debug, 764 gl SkipComponents3, 106, 109, 114,
GL KHR no error, 734, 773, 776 115, 393
GL KHR robust buffer access behav- gl SkipComponents4, 106, 109, 114,
ior, 772 115, 393
GL KHR robustness, 719, 772 gl TessCoord, 417, 427, 662, 730
GL KHR texture compression astc ldr, gl TessLevelInner, 413, 414, 428
763, 776 gl TessLevelInner[1], 428
GL KHR texture compression astc - gl TessLevelOuter, 413, 414, 428
sliced 3d, 776 gl TessLevelOuter[2], 428
GL KHR name, 745 gl TessLevelOuter[3], 428
gl Layer, 336, 437, 438, 636, 775 gl VertexID, 366, 370, 388, 404, 492,
gl MaxPatchVertices, 412, 413, 427, 700, 730
428 gl VerticesOut, 686
gl NextBuffer, 106, 109, 114, 115, 393 gl ViewportIndex, 437, 438, 458, 636,
gl NumSamples, 492 775
gl NumWorkGroups, 546 gl MaxPatchVertices, 725
GL NV depth buffer ?oat, 751 glBlitFramebuffer, 17
GL NV half ?oat, 752 GlobalInvocationId, 671
GL OES sample shading, 725 GLSLPacked, 147
GL OES sample variables, 725 GLSLShared, 147
gl out, 413 glSpecializeShader, 736
gl PatchVerticesIn, 412, 427 GLX ARB create context, 549, 753
gl PerVertex, 125, 127, 128 GLX ARB create context no error,
gl PointCoord, 470 776
gl PointSize, 125, 127, 405, 412, 413, GLX ARB create context pro?le, 678,
427, 429, 435, 437, 468 757
gl Position, 391, 405, 412, 413, 427, GLX ARB create context robustness,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 797
761 image2DRect, 118
GLX ARB fbcon?g ?oat, 750 image3D, 118
GLX ARB framebuffer sRGB, 752 IMAGE 1D, 118
GLX ARB robustness application iso- IMAGE 1D ARRAY, 118
lation, 767 IMAGE 2D, 118
GLX ARB robustness share group - IMAGE 2D ARRAY, 118
isolation, 767 IMAGE 2D MULTISAMPLE, 118
GREATER, 240, 289, 504, 505 IMAGE 2D MULTISAMPLE AR-
GREEN, 194, 240, 286, 490, 534, 536, RAY, 118
596, 598, 607 IMAGE 2D RECT, 118
GREEN BITS, 682 IMAGE 3D, 118
GREEN INTEGER, 194 IMAGE BINDING ACCESS, 627
GUILTY CONTEXT RESET, 19 IMAGE BINDING FORMAT, 627
IMAGE BINDING LAYER, 627
HALF FLOAT, 193, 298, 353, 535–537
IMAGE BINDING LAYERED, 627
HelperInvocation, 671
IMAGE BINDING LEVEL, 627
HIGH FLOAT, 172
IMAGE BINDING NAME, 627
HIGH INT, 172
IMAGE BUFFER, 118
Hint, 562, 683
IMAGE CLASS 10 10 10 2, 574
IMAGE CLASS 11 11 10, 574
if, 102, 415
IMAGE CLASS 1 X 16, 574
iimage1D, 118
IMAGE CLASS 1 X 32, 574
iimage1DArray, 119
IMAGE CLASS 1 X 8, 574
iimage2D, 118
IMAGE CLASS 2 X 16, 574
iimage2DArray, 119
IMAGE CLASS 2 X 32, 574
iimage2DMS, 119
IMAGE CLASS 2 X 8, 574
iimage2DMSArray, 119
IMAGE CLASS 4 X 16, 574
iimage2DRect, 118
IMAGE CLASS 4 X 32, 574
iimage3D, 118
IMAGE CLASS 4 X 8, 574
iimageBuffer, 119
IMAGE COMPATIBILITY CLASS,
iimageCube, 118
574
iimageCubeArray, 119
IMAGE CUBE, 118
Image, 667
IMAGE CUBE MAP ARRAY, 118
Image1D, 672
IMAGE FORMAT COMPATIBIL-
image1D, 118
ITY BY CLASS, 297, 574
image1DArray, 118
IMAGE FORMAT COMPATIBIL-
image2D, 118
ITY BY SIZE, 297, 574
image2DArray, 118
IMAGE FORMAT COMPATI-
image2DMS, 118
BILITY TYPE, 243, 297, 574,
image2DMSArray, 118
597
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 798
IMAGE PIXEL FORMAT, 575 119
IMAGE PIXEL TYPE, 575 INT IMAGE 2D MULTISAMPLE -
IMAGE TEXEL SIZE, 575 ARRAY, 119
ImageBuffer, 672 INT IMAGE 2D RECT, 118
imageBuffer, 118 INT IMAGE 3D, 118
imageCube, 118 INT IMAGE BUFFER, 119
ImageCubeArray, 672 INT IMAGE CUBE, 118
imageCubeArray, 118 INT IMAGE CUBE MAP ARRAY,
ImageGatherExtended, 672 119
ImageMSArray, 672 INT SAMPLER 1D, 117
ImageQuery, 672 INT SAMPLER 1D ARRAY, 117
ImageRect, 672 INT SAMPLER 2D, 117
IMPLEMENTATION COLOR - INT SAMPLER 2D ARRAY, 117
READ FORMAT, 308, 334, INT SAMPLER 2D MULTISAMPLE,
532, 655, 700 117
IMPLEMENTATION COLOR - INT SAMPLER 2D MULTISAM-
READ TYPE, 308, 334, 532, PLE ARRAY, 117
655, 700 INT SAMPLER 2D RECT, 117
in, 428 INT SAMPLER 3D, 117
INCR, 504 INT SAMPLER BUFFER, 117
INCR WRAP, 504 INT SAMPLER CUBE, 117
Index, 495, 497 INT SAMPLER CUBE MAP AR-
index, 495 RAY, 117
IndexPointer, 679 INT VEC2, 116
INFO LOG LENGTH, 166, 167, 170, INT VEC3, 116
171, 612–614 INT VEC4, 116
InitNames, 682 INTENSITY, 681
INNOCENT CONTEXT RESET, 19 INTERLEAVED ATTRIBS, 168, 177,
Input, 128, 390, 667, 668 392–394, 616
InstanceId, 671 InterleavedArrays, 679
INT, 116, 193, 245, 295, 298, 311, 353, INTERNALFORMAT ALPHA SIZE,
537, 538, 576 575
int, 116, 127, 145, 386 INTERNALFORMAT ALPHA TYPE,
INT 2 10 10 10 REV, 348, 353, 355, 575
362 INTERNALFORMAT BLUE SIZE,
INT IMAGE 1D, 118 575
INT IMAGE 1D ARRAY, 119 INTERNALFORMAT BLUE TYPE,
INT IMAGE 2D, 118 575
INT IMAGE 2D ARRAY, 119 INTERNALFORMAT DEPTH SIZE,
INT IMAGE 2D MULTISAMPLE, 575
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 799
INTERNALFORMAT DEPTH TYPE, 724, 728, 730, 739
575 INVALID FRAMEBUFFER OPERA-
INTERNALFORMAT GREEN SIZE, TION, 18, 219, 225, 333, 533,
575 541
INTERNALFORMAT GREEN TYPE, INVALID INDEX, 106, 109, 174
575 INVALID OPERATION, 17, 18, 45,
INTERNALFORMAT PREFERRED, 46, 50–52, 62, 63, 65, 67, 70–
575 72, 75–83, 90–95, 97, 99, 100,
INTERNALFORMAT RED SIZE, 575 108–110, 120, 121, 123–125,
INTERNALFORMAT RED TYPE, 130, 132, 142, 144, 149, 153,
575 157, 158, 167, 169, 170, 172,
INTERNALFORMAT SHARED - 174, 175, 180, 182, 185–188,
SIZE, 575 190, 192, 195, 205, 215, 219,
INTERNALFORMAT STENCIL - 224–228, 230, 232, 233, 235,
SIZE, 575 236, 241, 242, 244, 246, 248–
INTERNALFORMAT STENCIL - 253, 268, 272, 275, 277, 279–
TYPE, 575 285, 293, 303, 304, 307, 309,
INTERNALFORMAT SUPPORTED, 312–314, 316, 318, 320, 321,
569, 576 323, 324, 332, 351, 352, 354–
interpolateAtCentroid, 489 361, 366, 368, 370, 371, 375,
interpolateAtOffset, 489, 652 376, 378, 380, 382, 383, 387–
interpolateAtSample, 489 389, 393, 405–408, 410, 430,
InterpolationFunction, 672 431, 438, 443–451, 495, 497,
INVALID ENUM, 17, 18, 37, 41, 44– 512, 517, 520, 525, 527, 530–
46, 48, 50, 51, 62, 63, 65, 70, 534, 536, 541, 543, 544, 547,
72, 75, 77, 78, 81–83, 89, 92, 548, 554, 581, 678–680, 695,
100, 101, 108–110, 120, 121, 698, 699, 722, 724, 735, 739,
132, 157, 167, 169, 170, 173– 740
175, 179, 180, 187–189, 214, INVALID VALUE, 17, 18, 37–39, 41,
215, 219, 225, 227, 230, 232– 44–46, 48, 50, 59, 60, 63, 65,
236, 241, 242, 244, 246, 248, 67, 70–72, 76, 78, 80, 81, 83,
268, 277, 278, 280, 281, 288, 84, 90–92, 94, 95, 97, 98, 100,
303, 307, 309, 312–314, 316, 101, 108–110, 120–125, 130,
318, 320–323, 332, 347, 349, 132, 142, 144, 149, 153, 157,
354, 355, 366, 371, 378, 380, 164, 166, 167, 169–172, 174,
383, 393, 418, 444, 445, 454, 175, 180, 182–187, 189, 214,
467, 469, 477, 478, 508, 510, 215, 219, 225, 227, 228, 232,
517, 520, 526, 527, 531, 533, 234–236, 242, 246, 248–250,
541, 543, 554–557, 561, 563, 252, 253, 272, 275, 277, 282–
565–567, 569, 580, 581, 708, 284, 292, 293, 303, 305, 307,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 800
314–317, 321, 323, 324, 347, isamplerCubeArray, 117
349, 351, 352, 354–361, 366, IsBuffer, 60, 60
368–371, 373, 375–378, 380, IsEnabled, 485, 513, 565, 565, 582, 587,
383, 387–389, 393, 407, 443, 589, 591–593, 602, 603, 625,
444, 447, 451, 459–461, 467, 649, 656
469, 471, 484, 485, 487, 495, IsEnabledi, 485, 507, 513, 566, 566,
507, 508, 510, 515, 520, 522, 602, 603
523, 526, 527, 531, 541, 543, IsFramebuffer, 305, 306
544, 547, 548, 554–558, 560, IsList, 683
561, 565, 566, 569, 580, 581, ISOLINES, 168
678, 680, 682, 695, 696, 698, isolines, 415, 416, 424, 427
711, 713, 724, 728, 730, 740 IsProgram, 100, 100
InvalidateBufferData, 80 IsProgramPipeline, 122, 122
InvalidateBufferSubData, 80, 80 IsQuery, 47, 47
InvalidateFramebuffer, 527 IsRenderbuffer, 315, 315
InvalidateNamedFramebufferData, 527, IsSampler, 184, 187, 188
528 IsShader, 91, 91
InvalidateNamedFramebufferSubData, IsSync, 41, 41
526, 722 IsTexture, 183, 183, 686
InvalidateSubFramebuffer, 526, 527, IsTransformFeedback, 443, 443
695, 722, 726 IsVertexArray, 352, 352
InvalidateTexImage, 283 ivec2, 116, 386
InvalidateTexSubImage, 282, 282, 283, ivec3, 116, 386
740 ivec4, 116, 295, 386
inversesqrt(), 673
KEEP, 504, 602
INVERT, 504, 515
KHR debug, 693
Invocation, 667
KHR debug output, 701
InvocationId, 671
KHR no error, 741
IS PER PATCH, 111, 113, 623
IS ROW MAJOR, 111, 113, 137, 623
LAST VERTEX CONVENTION, 438,
isampler1D, 117
453, 590
isampler1DArray, 117
Layer, 671
isampler2D, 117
LAYER PROVOKING VERTEX, 438,
isampler2DArray, 117
636
isampler2DMS, 117
Layered images, 308
isampler2DMSArray, 117
layout, 106, 107, 114, 126, 127, 144,
isampler2DRect, 117
146, 147, 149, 151, 152, 169,
isampler3D, 117
295–297, 385, 386, 391–395,
isamplerBuffer, 117
410, 413, 415, 416, 418, 421,
isamplerCube, 117
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 801
424, 431–433, 492, 495, 496, LoadName, 682
498, 547, 722 LoadTransposeMatrix, 679
LEFT, 507, 517, 518, 520, 521, 530 LocalInvocationId, 671
LEQUAL, 240, 286, 289, 504, 505, 597, LocalInvocationIndex, 671
600 LocalSize, 669
LESS, 240, 289, 504, 505, 602 LOCATION, 111, 113, 121, 496, 623
LIGHTING, 680 Location, 128, 129, 384, 390, 495, 497
LINE, 480, 482, 592 location, 107, 126, 127, 384, 390, 495,
LINE LOOP, 340, 431, 438, 446 721
LINE SMOOTH, 471, 476, 591 LOCATION COMPONENT, 112, 114,
LINE SMOOTH HINT, 563, 633 496, 623
LINE STIPPLE, 680 LOCATION INDEX, 112, 114, 121,
LINE STRIP, 168, 340, 431, 432, 438, 496, 623
446 log(), 673
LINE STRIP ADJACENCY, 344, 431, log2(), 673
438 LOGIC OP MODE, 603
LINE WIDTH, 591 Logical, 667
LINEAR, 219, 240, 242, 254, 261, 264– LogicOp, 514, 515
267, 269, 270, 286, 311, 398, LOSE CONTEXT ON RESET, 20
539, 541, 571, 573, 596, 600, LOW FLOAT, 172
714 LOW INT, 172
LINEAR MIPMAP LINEAR, 240, LOWER LEFT, 454, 456, 458, 469,
265, 267 470, 477, 589
LINEAR MIPMAP NEAREST, 240, LUMINANCE, 681
265, 266 LUMINANCE8, 725
LINES, 168, 340, 431, 438, 445, 446 LUMINANCE ALPHA, 681
lines, 431
main, 415
LINES ADJACENCY, 168, 342, 431,
MAJOR VERSION, 567, 638
438
MANUAL GENERATE MIPMAP,
lines adjacency, 431
571
LineStipple, 680
MAP COHERENT BIT, 66, 67, 74, 76,
LineWidth, 471, 678, 680
709, 723, 727
LINK STATUS, 96, 131, 167, 614, 728
MAP FLUSH EXPLICIT BIT, 74, 76–
LinkProgram, 93, 96, 97–99, 103, 106,
78
126, 131, 132, 149, 158, 167,
MAP INVALIDATE BUFFER BIT,
387, 394, 405, 436, 449, 496,
74, 76
700, 728
MAP INVALIDATE RANGE BIT, 74,
ListBase, 683
76
LoadIdentity, 679
LoadMatrix, 679
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 802
MAP PERSISTENT BIT, 66, 67, 71– MAX ATTRIB STACK DEPTH, 683
73, 76, 77, 79–81, 83 MAX CLIENT ATTRIB STACK -
MAP READ BIT, 66–69, 73–77 DEPTH, 683
MAP UNSYNCHRONIZED BIT, 75, MAX CLIP DISTANCES, 454, 635
76 MAX COLOR ATTACHMENTS, 302,
MAP WRITE BIT, 66–69, 73, 75–77, 313, 320, 321, 323, 333, 518,
709 527, 531, 652
MAP COHERENT BIT, 74 MAX COLOR TEXTURE SAM-
MapBuffer, 62, 71, 72, 76, 77, 80, 450 PLES, 578, 651
MapBufferRange, 66, 71, 72, 73, 73, 75, MAX COMBINED ATOMIC -
77, 80, 709, 728 COUNTER BUFFERS, 150,
MapNamedBuffer, 76, 77 406, 646, 706
MapNamedBufferRange, 66, 73, 73, 75, MAX COMBINED ATOMIC COUN-
77, 727 TERS, 403, 406, 646
matC, 145 MAX COMBINED CLIP AND -
matCxR, 145 CULL DISTANCES, 454, 635
mat2, 116, 386 MAX COMBINED COMPUTE UNI-
mat2x3, 116, 386 FORM COMPONENTS, 134,
mat2x4, 116, 386 644
mat3, 116, 386 MAX COMBINED DIMENSIONS,
mat3x2, 116, 386 576
mat3x4, 116, 386 MAX COMBINED FRAGMENT -
mat4, 116, 386 UNIFORM COMPONENTS,
mat4x2, 116, 386 134, 648
mat4x3, 116, 386 MAX COMBINED GEOMETRY -
Matrix, 672 UNIFORM COMPONENTS,
MATRIX STRIDE, 111, 114, 137, 145, 134, 648
623 MAX COMBINED IMAGE UNI-
MatrixMode, 679 FORMS, 403, 406, 647, 688
MatrixStride, 147, 148 MAX COMBINED IMAGE UNITS -
MAX, 509 AND FRAGMENT OUT-
MAX 3D TEXTURE SIZE, 213, 245, PUTS, 694
322–324, 635 MAX COMBINED SHADER OUT-
MAX ARRAY TEXTURE LAYERS, PUT RESOURCES, 299, 406,
214, 235, 324, 635, 706 647, 694
MAX ATOMIC COUNTER - MAX COMBINED SHADER STOR-
BUFFER BINDINGS, 85, AGE BLOCKS, 152, 404,
151, 646 406, 646
MAX ATOMIC COUNTER - MAX COMBINED TESS CON-
BUFFER SIZE, 646, 688 TROL UNI-
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 803
FORM COMPONENTS, 134, MAX CULL DISTANCES, 454, 635
648 MAX DEBUG GROUP STACK -
MAX COMBINED TESS EVALUA- DEPTH, 556, 650
TION UNI- MAX DEBUG LOGGED MES-
FORM COMPONENTS, 134, SAGES, 553, 650
648 MAX DEBUG MESSAGE LENGTH,
MAX COMBINED TEXTURE IM- 552, 555, 556, 650
AGE UNITS, 142, 179, 185, MAX DEPTH, 577
401, 406, 645, 698 MAX DEPTH TEXTURE SAMPLES,
MAX COMBINED UNIFORM - 578, 651
BLOCKS, 144, 406, 645, 700 MAX DRAW BUFFERS, 495, 496,
MAX COMBINED VERTEX UNI- 507, 508, 510, 519, 520, 522,
FORM COMPONENTS, 134, 526, 652
648 MAX DUAL SOURCE -
MAX COMPUTE ATOMIC - DRAW BUFFERS, 495, 496,
COUNTER BUFFERS, 150, 510, 512, 652
644 MAX ELEMENT INDEX, 371, 635
MAX COMPUTE ATOMIC COUN- MAX ELEMENTS INDICES, 373,
TERS, 403, 644 636
MAX COMPUTE IMAGE UNI- MAX ELEMENTS VERTICES, 373,
FORMS, 403, 644 636
MAX COMPUTE SHADER STOR- MAX FRAGMENT ATOMIC -
AGE BLOCKS, 152, 404, 644 COUNTER BUFFERS, 150,
MAX COMPUTE SHARED MEM- 643
ORY SIZE, 548, 644, 700 MAX FRAGMENT ATOMIC COUN-
MAX COMPUTE TEXTURE IM- TERS, 403, 643
AGE UNITS, 401, 644 MAX FRAGMENT IMAGE UNI-
MAX COMPUTE UNIFORM - FORMS, 403, 647, 688
BLOCKS, 144, 644, 700 MAX FRAGMENT -
MAX COMPUTE UNI- INPUT COMPONENTS, 493,
FORM COMPONENTS, 133, 643
644, 727 MAX FRAGMENT INTERPOLA-
MAX COMPUTE WORK GROUP - TION OFFSET, 489, 652
COUNT, 547, 644 MAX FRAGMENT SHADER STOR-
MAX COMPUTE WORK GROUP - AGE BLOCKS, 152, 404, 643
INVOCATIONS, 547, 644 MAX FRAGMENT UNIFORM -
MAX COMPUTE WORK GROUP - BLOCKS, 144, 643, 700
SIZE, 547, 644 MAX FRAGMENT UNI-
MAX CUBE MAP TEXTURE SIZE, FORM COMPONENTS, 133,
214, 245, 275, 322, 324, 635 643
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 804
MAX FRAGMENT UNIFORM VEC- MAX IMAGE SAMPLES, 294, 647
TORS, 133, 643 MAX IMAGE UNITS, 142, 158, 290,
MAX FRAME- 292, 647
BUFFER HEIGHT, 307, 329, MAX INTEGER SAMPLES, 317, 578,
651 651
MAX FRAMEBUFFER LAYERS, MAX LABEL LENGTH, 558, 650
307, 329, 651 MAX LAYERS, 577
MAX FRAMEBUFFER SAMPLES, MAX NAME LENGTH, 107, 108,
307, 329, 651 110, 622
MAX FRAMEBUFFER WIDTH, 307, MAX NUM ACTIVE VARIABLES,
329, 651 107, 108, 622
MAX GEOMETRY ATOMIC - MAX NUM COMPATIBLE SUB-
COUNTER BUFFERS, 150, ROUTINES, 108, 622
642 MAX PATCH VERTICES, 347, 640
MAX GEOMETRY ATOMIC COUN- MAX PROGRAM TEXEL OFFSET,
TERS, 403, 642 258, 645
MAX GEOMETRY IMAGE UNI- MAX PROGRAM TEXTURE -
FORMS, 403, 647 GATHER OFFSET, 258, 264,
MAX GEOMETRY - 643
INPUT COMPONENTS, 436, MAX RECTANGLE TEXTURE -
642 SIZE, 214, 637
MAX GEOMETRY OUTPUT COM- MAX RENDERBUFFER SIZE, 317,
PONENTS, 437, 642 635
MAX GEOMETRY OUTPUT VER- MAX SAMPLE MASK WORDS,
TICES, 436, 642 487, 651
MAX GEOMETRY SHADER INVO- MAX SAMPLES, 317, 579, 651
CATIONS, 642 MAX SERVER WAIT TIMEOUT, 39,
MAX GEOMETRY SHADER STOR- 651
AGE BLOCKS, 152, 404, 642 MAX SHADER STORAGE -
MAX GEOMETRY TEXTURE IM- BLOCK SIZE, 152, 646
AGE UNITS, 400, 642 MAX SHADER STORAGE -
MAX GEOMETRY TOTAL OUT- BUFFER BINDINGS, 85,
PUT COMPONENTS, 436, 153, 646
642 MAX SUBROUTINE UNIFORM -
MAX GEOMETRY UNIFORM - LOCATIONS, 154, 645
BLOCKS, 144, 642, 700 MAX SUBROUTINES, 154, 645
MAX GEOMETRY UNI- MAX TESS CONTROL ATOMIC -
FORM COMPONENTS, 133, COUNTER BUFFERS, 150,
642, 727 640
MAX HEIGHT, 577 MAX TESS CONTROL ATOMIC -
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 805
COUNTERS, 402, 640 641
MAX TESS CONTROL IMAGE - MAX TESS EVALUATION UNI-
UNIFORMS, 403, 647 FORM BLOCKS, 144, 641,
MAX TESS CONTROL - 700
INPUT COMPONENTS, 413, MAX TESS EVALUATION UNI-
640 FORM COMPONENTS, 133,
MAX TESS CONTROL OUTPUT - 641
COMPONENTS, 414, 640 MAX TESS GEN LEVEL, 416, 640
MAX TESS CONTROL SHADER - MAX TESS PATCH COMPONENTS,
STORAGE BLOCKS, 152, 414, 428, 640
404, 640 MAX TEXTURE BUFFER SIZE,
MAX TESS CONTROL TEXTURE - 237, 637
IMAGE UNITS, 400, 640 MAX TEXTURE COORDS, 682
MAX TESS CONTROL TOTAL - MAX TEXTURE IMAGE UNITS,
OUTPUT COMPONENTS, 401, 643
414, 640, 725 MAX TEXTURE LOD BIAS, 257,
MAX TESS CONTROL UNIFORM - 635
BLOCKS, 144, 640, 700 MAX TEXTURE MAX -
MAX TESS CONTROL UNI- ANISOTROPY, 255, 256, 635
FORM COMPONENTS, 133, MAX TEXTURE SIZE, 214, 235, 245,
640 322, 324, 635
MAX TESS EVALUATION - MAX TEXTURE UNITS, 682
ATOMIC COUNTER - MAX TRANSFORM FEEDBACK -
BUFFERS, 150, 641 BUFFERS, 85, 393, 654
MAX TESS EVALUATION - MAX TRANSFORM FEEDBACK -
ATOMIC COUNTERS, 403, INTERLEAVED COMPO-
641 NENTS, 394, 395, 654
MAX TESS EVALUATION IMAGE - MAX TRANSFORM FEEDBACK -
UNIFORMS, 403, 647 SEPARATE ATTRIBS, 393,
MAX TESS EVALUATION - 654
INPUT COMPONENTS, 428, MAX TRANSFORM FEEDBACK -
641 SEPARATE COMPONENTS,
MAX TESS EVALUATION OUT- 394, 654
PUT COMPONENTS, 429, MAX UNIFORM BLOCK SIZE, 144,
641 645, 726
MAX TESS EVALUATION - MAX UNIFORM BUFFER BIND-
SHADER STORAGE - INGS, 85, 149, 645, 696
BLOCKS, 152, 404, 641 MAX UNIFORM LOCATIONS, 135,
MAX TESS EVALUATION TEX- 645
TURE IMAGE UNITS, 400, MAX VARYING COMPONENTS,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 806
391, 645, 679 MAX WIDTH, 577
MAX VARYING FLOATS, 679 MEDIUM FLOAT, 172
MAX VARYING VECTORS, 391, 645 MEDIUM INT, 172
MAX VERTEX ATOMIC - Memory Semantics, 668
COUNTER BUFFERS, 150, MemoryBarrier, 67, 161, 164–166, 737
639 memoryBarrier, 160, 161, 165
MAX VERTEX ATOMIC COUN- MemoryBarrierByRegion, 165, 166
TERS, 402, 639 MIN, 509
MAX VERTEX ATTRIB BINDINGS, MIN/MAG, 571
356–358, 360, 380, 637 MIN FRAGMENT INTERPOLA-
MAX VERTEX ATTRIB RELA- TION OFFSET, 489, 652
TIVE OFFSET, 355, 637 MIN MAP BUFFER ALIGNMENT,
MAX VERTEX ATTRIB - 74, 77, 637, 688
STRIDE, 356, 357, 359, 637, MIN PROGRAM TEXEL OFFSET,
705, 714 258, 645
MAX VERTEX ATTRIBS, 347, 349, MIN PROGRAM TEXTURE -
350, 354, 358, 359, 361, 378, GATHER OFFSET, 258, 264,
380, 387–389, 639 643
MAX VERTEX IMAGE UNIFORMS, MIN SAMPLE SHADING VALUE,
403, 647 468, 593
MAX VERTEX OUTPUT COMPO- MINOR VERSION, 567, 638
NENTS, 391, 413, 415, 429, MinSampleShading, 468, 738
436, 437, 493, 639 MIPMAP, 578
MAX VERTEX SHADER STOR- MIRROR CLAMP TO EDGE, 185,
AGE BLOCKS, 152, 404, 639 241, 242, 261, 713, 729
MAX VERTEX STREAMS, 42, 45, MIRRORED REPEAT, 185, 241, 242,
46, 48, 451, 642 261
MAX VERTEX TEXTURE IMAGE - MultiDrawArrays, 368, 699
UNITS, 400, 639 MultiDrawArraysIndirect, 365, 368,
MAX VERTEX UNIFORM - 369, 370, 699, 730
BLOCKS, 144, 639, 700 MultiDrawArraysIndirectCount, 369
MAX VERTEX UNI- MultiDrawElements, 364, 372, 699, 730
FORM COMPONENTS, 133, MultiDrawElementsBaseVertex, 364,
639 377, 699
MAX VERTEX UNIFORM VEC- MultiDrawElementsIndirect, 365, 375,
TORS, 133, 639 376, 699, 730
MAX VIEWPORT DIMS, 461, 528, MultiDrawElementsIndirectCount, 376
636 MULTISAMPLE, 467, 468, 471, 476,
MAX VIEWPORTS, 458–460, 485, 482, 486, 489, 501, 515, 516,
486, 636 593
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 807
MultiViewport, 672 NO ERROR, 16, 18, 19
MultMatrix, 680 NO RESET NOTIFICATION, 19
MultTransposeMatrix, 680 NONE, 106, 225, 240, 245, 286–288,
310–312, 325, 329, 396, 401,
Name, 94
402, 501, 512, 515, 517–521,
NAME LENGTH, 112, 114, 137, 139,
524, 526, 530–533, 568, 570,
624
573–576, 578–580, 596–598,
NamedBufferData, 68, 68–70
600, 607, 626, 695, 707, 715,
NamedBufferStorage, 65, 65, 67, 68
720, 735
NamedBufferSubData, 70, 70
NOOP, 515
NamedFramebufferDrawBuffer, 517,
NoPerspective, 668
517
noperspective, 456
NamedFramebufferDrawBuffers, 519,
NOR, 515
519, 520
NORMALIZE, 680
NamedFramebufferParameteri, 306,
NormalPointer, 679
306, 307
NOTEQUAL, 240, 289, 504, 505
NamedFramebufferReadBuffer, 529,
NULL, 552, 557, 560, 585, 588, 649
529, 530
NUM ACTIVE VARIABLES, 111,
NamedFramebufferRenderbuffer, 319,
112, 114, 139, 140, 624
319, 320
NUM COMPATIBLE SUBROU-
NamedFramebufferTexture, 321, 321,
TINES, 111, 120, 156, 620,
323, 324
624, 736
NamedFramebufferTextureLayer, 323
NUM COMPRESSED TEX-
NamedRenderbufferStorage, 317
TURE FORMATS, 206, 637,
NamedRenderbufferStorageMultisample,
679, 685
316, 316
NUM EXTENSIONS, 568, 638
NAND, 515
NUM PROGRAM BINARY FOR-
NEAREST, 240, 242, 254, 260, 264–
MATS, 130, 131, 637
267, 269, 270, 288, 398, 539,
NUM SAMPLE COUNTS, 578, 653
541, 571
NUM SHADER BINARY FOR-
NEAREST MIPMAP -
MATS, 87, 92, 637
LINEAR, 240, 265, 267, 286,
NUM SHADING LANGUAGE VER-
600
SIONS, 568, 638, 696
NEAREST MIPMAP NEAREST, 240,
NUM SPIR V EXTENSIONS, 569,
265, 266, 270, 288, 571, 726
638
NEGATIVE ONE TO ONE, 454, 456,
NumWorkgroups, 671
458, 589
NEVER, 240, 289, 504, 505 OBJECT TYPE, 37, 41, 632
NewList, 683 ObjectLabel, 557, 558, 560
NICEST, 563 ObjectPtrLabel, 558
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 808
OFFSET, 112, 114, 137, 624 OpTypeInt, 498
Offset, 147, 148, 391, 395, 668 OpTypeRuntimeArray, 668, 740
ONE, 240, 490, 509, 511, 512, 603 OpTypeStruct, 668
ONE MINUS CONSTANT ALPHA, OR, 515
511 OR INVERTED, 515
ONE MINUS CONSTANT COLOR, OR REVERSE, 515
511 Ortho, 680
ONE MINUS DST ALPHA, 511 out, 414
ONE MINUS DST COLOR, 511 OUT OF MEMORY, 16–19, 706, 709,
ONE MINUS SRC1 ALPHA, 510, 511 739
ONE MINUS SRC1 COLOR, 510, Output, 128, 497, 667
511
PACK ALIGNMENT, 532, 611
ONE MINUS SRC ALPHA, 511
PACK COMPRESSED BLOCK -
ONE MINUS SRC COLOR, 511
DEPTH, 251, 252, 532, 611
Op*Name, 105
PACK COMPRESSED BLOCK -
OpCapability, 666, 672
HEIGHT, 251, 252, 532, 611
OpEntryPoint, 94, 128, 390, 497
PACK COMPRESSED BLOCK SIZE,
OpFAdd, 673
251, 532, 611
OpFDiv, 673
PACK COMPRESSED BLOCK -
OpFMul, 673
WIDTH, 251, 252, 532, 611
OpFOrdEqual, 673
PACK IMAGE HEIGHT, 247, 251,
OpFOrdGreaterThan, 673
532, 611
OpFOrdGreaterThanEqual, 673
PACK LSB FIRST, 532, 611, 679, 693,
OpFOrdLessThan, 673
701
OpFOrdLessThanEqual, 673
PACK ROW LENGTH, 251, 532, 611
OpFSub, 673
PACK SKIP IMAGES, 247, 251, 532,
OpFUnordEqual, 673
611
OpFUnordGreaterThan, 673
PACK SKIP PIXELS, 251, 532, 611
OpFUnordGreaterThanEqual, 673
PACK SKIP ROWS, 251, 532, 611
OpFUnordLessThan, 673
PACK SWAP BYTES, 532, 611
OpFUnordLessThanEqual, 673
PARAMETER BUFFER, 61, 162, 369,
OpImageQueryLevels, 667, 739
370, 376, 377, 737
OpImageQuerySizeLod, 667, 739
PARAMETER BUFFER BINDING,
OpMemberName, 105
587
OpName, 105
PassThrough, 682
OpSampledImage, 667
Patch, 668
OpSMod, 670
patch, 113, 410
OpSRem, 670
patch in, 428
OpTypeFloat, 498
patch out, 414
OpTypeImage, 667
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 809
PATCH DE- 446, 480
FAULT INNER LEVEL, 416, points, 431, 434
418, 584 PointSize, 469, 671
PATCH DEFAULT OUTER LEVEL, POLYGON, 681
416, 418, 584 POLYGON MODE, 592
PATCH VERTICES, 346, 347, 584 POLYGON OFFSET CLAMP, 482,
PATCHES, 346, 362, 410, 635 592
PatchParameterfv, 416 POLYGON OFFSET FACTOR, 592
PatchParameteri, 346, 426 POLYGON OFFSET FILL, 482, 592
PatchVertices, 671 POLYGON OFFSET LINE, 482, 592
PauseTransformFeedback, 445, 446 POLYGON OFFSET POINT, 482, 592
PERSPECTIVE CORRECTION - POLYGON OFFSET UNITS, 592
HINT, 683 POLYGON SMOOTH, 477, 482, 592
PIXEL BUFFER BARRIER BIT, 162 POLYGON SMOOTH HINT, 563, 633
PIXEL PACK BUFFER, 61, 162, 190, POLYGON STIPPLE, 681
531 PolygonMode, 480, 480, 482, 483, 681
PIXEL PACK BUFFER BINDING, PolygonOffset, 481, 481
247, 536, 611 PolygonOffsetClamp, 480, 481
PIXEL UNPACK BUFFER, 61, 162, PolygonStipple, 681
190 PopAttrib, 683
PIXEL UNPACK BUFFER BIND- PopClientAttrib, 683
ING, 192, 226, 610 PopDebugGroup, 556, 556
PixelStore, 189, 532, 544, 713 PopMatrix, 680
PixelStore*, 189 PopName, 682
PixelZoom, 681 Position, 671
POINT, 480, 482, 592 pow(x,y), 673
POINT FADE THRESHOLD SIZE, PRIMITIVE RESTART, 361, 362, 587
469, 591 PRIMITIVE RESTART FIXED IN-
point mode, 418 DEX, 362, 587, 715
POINT SIZE, 591 PRIMITIVE RESTART FOR -
POINT SIZE GRANULARITY, 636 PATCHES SUPPORTED,
POINT SIZE RANGE, 636 362, 635, 711
POINT SMOOTH, 680 PRIMITIVE RESTART INDEX, 587
POINT SMOOTH HINT, 683 PrimitiveId, 671
POINT SPRITE, 680 PrimitiveRestartIndex, 361, 362
POINT SPRITE COORD ORIGIN, PRIMITIVES GENERATED, 42, 45,
469, 470, 591 46, 48, 451
PointCoord, 671 PRIMITIVES SUBMITTED, 42, 48,
PointParameter, 469 383
POINTS, 168, 340, 431, 432, 438, 445, PrioritizeTextures, 682
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 810
Private, 667 SAMPLE, 205, 234, 244, 280,
PROGRAM, 557 281, 287
PROGRAM BINARY FORMATS, PROXY TEXTURE 2D MULTISAM-
131, 637 PLE ARRAY, 205, 234, 244,
PROGRAM BINARY LENGTH, 130, 281, 287
131, 614 PROXY TEXTURE 3D, 203, 244, 279,
PROGRAM BINARY RE- 280, 287
TRIEVABLE HINT, 99, 100, PROXY TEXTURE CUBE MAP, 205,
132, 169, 614 216, 244, 278, 287
PROGRAM INPUT, 102, 106, 111, PROXY TEXTURE CUBE -
112, 120, 388, 389, 700 MAP ARRAY, 203, 205, 214,
PROGRAM OUTPUT, 103, 106, 111, 244, 279, 280, 287
112, 120, 496, 497, 700 PROXY TEXTURE RECTANGLE,
PROGRAM PIPELINE, 557 205, 215, 227, 232, 244, 278,
PROGRAM PIPELINE BINDING, 287
614 PushAttrib, 683
PROGRAM POINT SIZE, 435, 469, PushClientAttrib, 683
625 PushDebugGroup, 555, 556
PROGRAM SEPARABLE, 99–101, PushMatrix, 680
124, 169, 406, 614, 687 PushName, 682
ProgramBinary, 98, 99, 130, 131, 132,
QUAD STRIP, 681
167, 449, 700, 705
QUADS, 168, 619, 681
ProgramParameteri, 99, 132
quads, 415, 416, 418, 421, 427
ProgramUniform, 143
QUERY, 557
ProgramUniformf1234gui, 143
QUERY BUFFER, 61, 163
ProgramUniformf1234guiv, 143
QUERY BUFFER BARRIER BIT,
ProgramUniformMatrixf234g, 143
163
ProgramUniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3g,
QUERY BUFFER BINDING, 656
143
QUERY BY REGION NO WAIT,
PROVOKING VERTEX, 438, 590
382, 383
ProvokingVertex, 438, 452
QUERY BY REGION NO WAIT IN-
PROXY TEXTURE 1D, 205, 216, 244,
VERTED, 382, 383
277, 287
QUERY BY REGION WAIT, 382, 383
PROXY TEXTURE 1D ARRAY, 205,
QUERY BY REGION WAIT IN-
215, 244, 278, 279, 287
VERTED, 382, 383
PROXY TEXTURE 2D, 205, 215, 244,
QUERY COUNTER BITS, 48, 49,
278, 287
651, 740
PROXY TEXTURE 2D ARRAY, 203,
QUERY NO WAIT, 382, 383
205, 244, 279, 280, 287
PROXY TEXTURE 2D MULTI-
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 811
QUERY NO WAIT INVERTED, 382, r8ui, 296
383 RASTERIZER DISCARD, 333, 457,
QUERY RESULT, 44, 45, 49, 50, 626 464, 591
QUERY RESULT - READ BUFFER, 530, 606
AVAILABLE, 20, 44, 45, 49, READ FRAMEBUFFER, 302, 303,
50, 626, 712, 720 305–309, 312, 319–322, 332,
QUERY RESULT NO WAIT, 50 526, 527, 529, 538, 605
QUERY TARGET, 50, 626 READ FRAMEBUFFER BINDING,
QUERY WAIT, 382, 383 219, 225, 306, 334, 531, 533,
QUERY WAIT INVERTED, 382, 383 534, 605
QueryCounter, 43, 51, 51 READ ONLY, 61, 75–77, 291, 292, 627
READ PIXELS, 571
R11F G11F B10F, 207, 209, 274, 296,
READ PIXELS FORMAT, 578
298
READ PIXELS TYPE, 578
r11f g11f b10f, 296
READ WRITE, 61, 68, 75, 77, 291–
R16, 208, 237, 274, 297, 299
293, 588
r16, 297
ReadBuffer, 518, 529, 529, 715
R16 SNORM, 208, 274, 297, 299
ReadnPixels, 531, 531
r16 snorm, 297
ReadPixels, 162, 188, 189, 196, 218,
R16F, 209, 237, 274, 296, 298
247, 333, 336, 450, 529, 530,
r16f, 296
531, 531–534, 536, 538, 578,
R16I, 209, 237, 274, 296, 298
681
r16i, 296
RECTANGLE TEXTURE, 740
R16UI, 209, 237, 274, 296, 298
RED, 194, 205, 208, 209, 212, 240, 249,
r16ui, 296
253, 286, 298, 299, 328, 490,
R32F, 209, 237, 274, 296, 298
491, 534, 536, 596, 598, 607
r32f, 296
RED BITS, 682
R32I, 209, 237, 274, 296, 298
RED INTEGER, 194, 298
r32i, 296
REFERENCED BY COMPUTE -
R32UI, 209, 237, 274, 296, 298
SHADER, 112, 115, 139, 140,
r32ui, 296
624
R3 G3 B2, 208
REFERENCED BY FRAGMENT -
R8, 208, 237, 274, 286, 292, 297, 299,
SHADER, 112, 115, 139, 140,
598, 627
624
r8, 297
REFERENCED BY GEOMETRY -
R8 SNORM, 208, 274, 297, 299
SHADER, 112, 115, 139, 140,
r8 snorm, 297
624
R8I, 209, 237, 274, 296, 298
REFERENCED BY TESS CON-
r8i, 296
TROL SHADER, 112, 115,
R8UI, 209, 237, 274, 296, 298
139, 140, 624
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 812
REFERENCED BY TESS EVAL- REPLACE, 504
UATION SHADER, 112, 115, RESCALE NORMAL, 680
139, 140, 624 RESET NOTIFICATION STRATEGY,
REFERENCED - 19, 656
BY VERTEX SHADER, 112, ResumeTransformFeedback, 445, 445,
115, 139, 140, 624 446, 449, 722
Relaxed, 668 RG, 194, 205, 208–210, 212, 249, 298,
ReleaseShaderCompiler, 90, 90 299, 328, 491, 534, 536
RENDERBUFFER, 310, 311, 313–316, RG16, 208, 237, 274, 296, 299
318–320, 334, 542, 543, 557, rg16, 296
570, 578, 579, 608 RG16 SNORM, 208, 274, 297, 299
RENDERBUFFER ALPHA SIZE, rg16 snorm, 297
318, 609 RG16F, 209, 238, 274, 296, 298
RENDERBUFFER BINDING, 314, rg16f, 296
608 RG16I, 210, 238, 274, 296, 298
RENDERBUFFER BLUE SIZE, 318, rg16i, 296
609 RG16UI, 210, 238, 274, 296, 298
RENDERBUFFER DEPTH SIZE, rg16ui, 296
318, 609 RG32F, 209, 238, 274, 296, 298, 544
RENDERBUFFER GREEN SIZE, rg32f, 296
318, 609 RG32I, 210, 238, 274, 296, 298, 544
RENDERBUFFER HEIGHT, 316, 318, rg32i, 296
609 RG32UI, 210, 238, 274, 296, 298, 544
RENDERBUFFER INTERNAL FOR- rg32ui, 296
MAT, 316, 318, 609 RG8, 208, 237, 274, 296, 299
RENDERBUFFER RED SIZE, 318, rg8, 296
609 RG8 SNORM, 208, 274, 297, 299
RENDERBUFFER SAMPLES, 313, rg8 snorm, 297
316, 318, 330, 609 RG8I, 210, 238, 274, 296, 298
RENDERBUFFER STENCIL SIZE, rg8i, 296
318, 609 RG8UI, 210, 238, 274, 296, 298
RENDERBUFFER WIDTH, 316, 318, rg8ui, 296
609 RG INTEGER, 194, 298
RenderbufferStorage, 317, 576 RGB, 194, 197, 202, 205, 208–210,
RenderbufferStorage*, 331 212, 249, 298, 328, 491, 511,
RenderbufferStorageMultisample, 306, 534–536
315, 316, 576, 706 RGB10, 209
RENDERER, 566, 567, 638 RGB10 A2, 209, 274, 296, 299
RenderMode, 682 rgb10 a2, 296
REPEAT, 185, 240–242, 261, 286, 600 RGB10 A2UI, 209, 274, 296, 298
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 813
rgb10 a2ui, 296 RGBA32I, 210, 238, 274, 296, 298, 544
RGB12, 209 rgba32i, 296
RGB16, 209, 274 RGBA32UI, 210, 238, 274, 296, 298,
RGB16 SNORM, 209, 274 544
RGB16F, 209, 274 rgba32ui, 296
RGB16I, 210, 274 RGBA4, 209
RGB16UI, 210, 274 RGBA8, 209, 238, 274, 296, 299
RGB32F, 209, 238, 274 rgba8, 296
RGB32I, 210, 238, 274 RGBA8 SNORM, 209, 274, 297, 299
RGB32UI, 210, 238, 274 rgba8 snorm, 297
RGB4, 208, 706 RGBA8I, 210, 238, 274, 296, 298
RGB5, 208 rgba8i, 296
RGB565, 208, 706 RGBA8UI, 210, 238, 274, 296, 298
RGB5 A1, 209 rgba8ui, 296
RGB8, 208, 274 RGBA INTEGER, 194, 197, 295, 298
RGB8 SNORM, 209, 274 RIGHT, 507, 517, 518, 520, 521, 530
RGB8I, 210, 274 Rotate, 680
RGB8UI, 210, 274
Sample, 668
RGB9 E5, 207, 209, 274, 290, 535, 695
sample, 489, 493
RGB INTEGER, 194, 197
sample in, 467, 489
RGBA, 194, 197, 202, 205, 209, 210,
SAMPLE ALPHA TO COVERAGE,
212, 249, 284–286, 295, 298,
501, 593
299, 328, 491, 534, 598, 609,
SAMPLE ALPHA TO ONE, 501, 503,
681
593
RGBA12, 209
SAMPLE BUFFERS, 160, 219, 226,
RGBA16, 209, 238, 274, 296, 299, 544
308, 309, 313, 466, 471, 476,
rgba16, 296
482, 486, 501, 505, 515, 516,
RGBA16 SNORM, 209, 274, 297, 299,
523, 531, 533, 540, 655, 712,
544
715, 729
rgba16 snorm, 297
SAMPLE COVERAGE, 486, 493, 593
RGBA16F, 209, 238, 274, 296, 298, 544
SAMPLE COVERAGE INVERT, 486,
rgba16f, 296
487, 593
RGBA16I, 210, 238, 274, 296, 298, 544
SAMPLE COVERAGE VALUE, 486,
rgba16i, 296
487, 593
RGBA16UI, 210, 238, 274, 296, 298,
SAMPLE MASK, 486, 493, 593
544
SAMPLE MASK VALUE, 15, 486,
rgba16ui, 296
487, 593, 687
RGBA2, 209
SAMPLE POSITION, 309, 466, 467,
RGBA32F, 209, 238, 274, 296, 298, 544
655, 725
rgba32f, 296
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 814
SAMPLE SHADING, 468, 593 SAMPLER 2D MULTISAMPLE AR-
SampleCoverage, 487 RAY, 117
Sampled, 667, 739 SAMPLER 2D RECT, 117
Sampled Type, 667 SAMPLER 2D RECT SHADOW, 117
Sampled1D, 672 SAMPLER 2D SHADOW, 117
SampledBuffer, 672 SAMPLER 3D, 117
SampledCubeArray, 672 SAMPLER BINDING, 185, 581, 595
SampledImageArrayDynamicIndexing, SAMPLER BUFFER, 117
672 SAMPLER CUBE, 117
SampledRect, 672 SAMPLER CUBE MAP ARRAY, 117
SampleId, 671 SAMPLER CUBE MAP ARRAY -
SampleMask, 671 SHADOW, 117
SampleMaski, 487 SAMPLER CUBE SHADOW, 117
SamplePosition, 671 SampleRateShading, 672
SAMPLER, 557 samplerBuffer, 117
sampler*, 157 samplerCube, 117
sampler*Shadow, 401 samplerCubeArray, 117
sampler1D, 117 samplerCubeArrayShadow, 117
sampler1DArray, 117 samplerCubeShadow, 117
sampler1DArrayShadow, 117 SamplerParameter, 186
sampler1DShadow, 117 SamplerParameterIfi uigv, 186
sampler2D, 117, 157 SamplerParameterIiv, 186
sampler2DArray, 117 SamplerParameterIuiv, 186
sampler2DArrayShadow, 117 SamplerParameteriv, 187, 706
sampler2DMS, 117 SAMPLES, 235, 308, 309, 313, 466–
sampler2DMSArray, 117 468, 506, 540, 541, 578, 653,
sampler2DRect, 117 655, 712
sampler2DRectShadow, 117 SAMPLES PASSED, 42, 45, 48, 381–
sampler2DShadow, 117 383, 505
sampler3D, 117 Scale, 680
SAMPLER 1D, 117 Scissor, 484, 485
SAMPLER 1D ARRAY, 117 SCISSOR BOX, 602
SAMPLER 1D ARRAY SHADOW, SCISSOR TEST, 485, 486, 602
117 ScissorArrayv, 484, 484, 485
SAMPLER 1D SHADOW, 117 ScissorIndexed, 484, 485
SAMPLER 2D, 117 ScissorIndexedv, 484, 485
SAMPLER 2D ARRAY, 117 Scope, 667
SAMPLER 2D ARRAY SHADOW, SecondaryColorPointer, 679
117 SelectBuffer, 682
SAMPLER 2D MULTISAMPLE, 117 SEPARATE ATTRIBS, 168, 392–394
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 815
SET, 515 566–569, 638, 696
ShadeModel, 680 shared, 133, 548, 723
SHADER, 557 SHORT, 193, 298, 299, 353, 537, 538
Shader, 672 SIGNALED, 20, 37, 41
SHADER BI- SIGNED NORMALIZED, 245, 311,
NARY FORMAT SPIR V, 92, 576
93 SIMULTANEOUS TEXTURE AND -
SHADER BINARY FORMATS, 92, DEPTH TEST, 572
637 SIMULTANEOUS TEXTURE AND -
SHADER COMPILER, 87, 637 DEPTH WRITE, 572
SHADER IMAGE ACCESS BAR- SIMULTANEOUS TEXTURE AND -
RIER BIT, 162, 165 STENCIL TEST, 572
SHADER IMAGE ATOMIC, 572 SIMULTANEOUS TEXTURE AND -
SHADER IMAGE LOAD, 572 STENCIL WRITE, 572
SHADER IMAGE STORE, 572 SMOOTH LINE WIDTH GRANU-
SHADER SOURCE LENGTH, 166, LARITY, 636
167, 172, 612 SMOOTH LINE WIDTH RANGE,
SHADER STORAGE BARRIER BIT, 636
163, 165 SpecializeShader, 92, 93
SHADER STOR- SPIR V BINARY, 89, 90, 92, 94, 97,
AGE BLOCK, 104, 108, 111, 105, 166, 167, 612
112 SPIR V EXTENSIONS, 569, 638
SHADER STORAGE BUFFER, 61, sqrt(), 673
62, 152, 153, 710 SRC1 ALPHA, 510–512
SHADER STORAGE BUFFER - SRC1 COLOR, 510–512
BINDING, 85, 629 SRC ALPHA, 511, 512
SHADER STORAGE BUFFER OFF- SRC ALPHA SATURATE, 511
SET ALIGNMENT, 85, 646, SRC COLOR, 511, 512
727, 730 SRGB, 219, 290, 311, 508, 513, 514,
SHADER STORAGE BUFFER SIZE, 540, 573
85, 629 SRGB8, 209, 274, 290
SHADER STORAGE BUFFER - SRGB8 ALPHA8, 209, 274, 290
START, 85, 629 SRGB ALPHA, 290
SHADER TYPE, 166, 167, 175, 612 SRGB READ, 572
ShaderBinary, 89, 91, 92, 93, 166, 666, SRGB WRITE, 573
698 STACK OVERFLOW, 18, 556, 693,
ShaderSource, 89, 89, 90, 92, 172 697
ShaderStorageBlockBinding, 153, 153, STACK UNDERFLOW, 18, 556, 693,
710 697
SHADING LANGUAGE VERSION, STATIC COPY, 61, 69
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 816
STATIC DRAW, 61, 69, 588 StencilFuncSeparate, 503, 503, 504
STATIC READ, 61, 69 StencilMask, 522, 522, 523, 664
std140, 133, 146, 147, 152, 723 StencilMaskSeparate, 522, 522, 523
std430, 147, 151, 152, 548, 736 StencilOp, 503, 503, 504
STENCIL, 310, 525–527, 598, 607 StencilOpSeparate, 503, 503, 504
STENCIL ATTACHMENT, 304, 320, STEREO, 308, 655
330 Storage Class, 667
STENCIL BACK FAIL, 602 StorageBufferArrayDynamicIndexing,
STENCIL BACK FUNC, 602 672
STENCIL BACK PASS DEPTH - StorageImageArrayDynamicIndexing,
FAIL, 602 672
STENCIL BACK PASS DEPTH - StorageImageExtendedFormats, 672
PASS, 602 StorageImageMultisample, 672
STENCIL BACK REF, 602 StorageImageWriteWithoutFormat, 672
STENCIL BACK VALUE MASK, 602 STREAM COPY, 61, 69
STENCIL BACK WRITEMASK, 604 STREAM DRAW, 61, 69
STENCIL BITS, 682 STREAM READ, 61, 69
STENCIL - Subgroup, 667
BUFFER BIT, 523, 526, 539, SubgroupVoteKHR, 672
541 SUBPIXEL BITS, 635
STENCIL CLEAR VALUE, 604 switch, 415
STENCIL COMPONENTS, 579 SYNC CONDITION, 37, 41, 632
STENCIL FAIL, 602 SYNC FENCE, 37, 41, 632
STENCIL FUNC, 602 SYNC FLAGS, 37, 41, 632, 723
STENCIL INDEX, 194, 205, 211, 215, SYNC FLUSH COMMANDS BIT,
218, 240, 247, 248, 269, 270, 20, 38–40, 723
284, 285, 288, 328, 402, 533, SYNC GPU COMMANDS COM-
534, 726 PLETE, 37, 41, 67, 632
STENCIL INDEX1, 211 SYNC STATUS, 20, 37, 41, 632
STENCIL INDEX16, 211
TESS CONTROL OUTPUT VER-
STENCIL INDEX4, 211
TICES, 168, 169, 411, 619
STENCIL INDEX8, 211, 695
TESS CONTROL SHADER, 89, 155,
STENCIL PASS DEPTH FAIL, 602
411, 613
STENCIL PASS DEPTH PASS, 602
TESS CONTROL SHADER BIT, 124
STENCIL REF, 602
TESS CONTROL SHADER -
STENCIL RENDERABLE, 579
PATCHES, 43, 48, 429
STENCIL TEST, 503, 602
TESS CONTROL SUBROUTINE,
STENCIL VALUE MASK, 602
103, 155
STENCIL WRITEMASK, 15, 604
StencilFunc, 503, 503, 504, 664
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 817
TESS CONTROL SUBROU- TexImage3D, 203, 204, 211, 213–216,
TINE UNIFORM, 103, 108, 218, 226, 230, 247, 266, 284,
111, 120, 155 287, 576, 706
TESS CONTROL TEXTURE, 573 TexImage3DMultisample, 234, 234,
TESS EVALUATION SHADER, 89, 235, 281, 287, 576, 706, 710
155, 426, 613 TexParameter, 56, 179, 187, 239, 682
TESS EVALUATION SHADER BIT, TexParameter*, 706
124 TexParameterI, 239
TESS EVALUATION SHADER IN- TexParameterIiv, 239
VOCATIONS, 43, 48, 429 TexParameterIuiv, 239
TESS EVALUATION SUBROUTINE, TexParameteriv, 239
103, 155 TexStorage, 284
TESS EVALUATION SUBROU- TexStorage1D, 277, 277, 576
TINE UNIFORM, 103, 108, TexStorage2D, 277, 278, 279, 576
111, 120, 155 TexStorage2DMultisample, 280, 280,
TESS EVALUATION TEXTURE, 573 281, 576
TESS GEN MODE, 168, 169, 619 TexStorage3D, 279, 279, 280, 576
TESS GEN POINT MODE, 169, 619 TexStorage3DMultisample, 281, 281,
TESS GEN SPACING, 168, 169, 619 576
TESS GEN VERTEX ORDER, 168, TexSubImage, 162
169, 619 TexSubImage1D, 220, 222
TessCoord, 671 TexSubImage2D, 220, 221, 222, 272
Tessellation, 672 TexSubImage3D, 220, 222–224, 250,
TessellationPointSize, 672 282, 283, 285, 298
TessLevelInner, 671 TEXTURE, 310, 311, 325, 334, 557
TessLevelOuter, 671 TEXTURE0, 179, 181, 601
TexBuffer, 236, 576 TEXTURE x SIZE, 598
TexBufferRange, 235, 235, 236 TEXTURE x TYPE, 598
TexCoordPointer, 679 TEXTURE xD, 595
texelFetch, 397, 398, 725 TEXTURE 1D, 180, 205, 216, 220,
TexEnv, 682 222, 239, 243, 244, 247, 248,
TexImage, 179, 221, 284 250, 267, 273, 275, 277, 294,
TexImage*D, 188, 190, 227 323, 570, 682
TexImage1D, 211, 216, 216, 218, 220, TEXTURE 1D ARRAY, 180, 205, 215,
226, 230, 266, 287, 576 218, 219, 222, 239, 243, 244,
TexImage2D, 211, 214, 215, 215, 216, 247, 248, 250, 267, 273, 276,
218, 221, 226, 230, 266, 287, 278, 279, 294, 570, 594, 595,
295, 576 682
TexImage2DMultisample, 233, 234, TEXTURE 2D, 157, 180, 205, 215,
281, 287, 306, 576, 710 218, 219, 222, 239, 243, 244,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 818
247, 248, 250, 267, 273, 275, ARRAY, 581, 594
278, 294, 323, 570, 682 TEXTURE BINDING RECTANGLE,
TEXTURE 2D ARRAY, 180, 203, 205, 581, 594
215, 222, 230, 233, 239, 243, TEXTURE BLUE SIZE, 245
244, 247, 248, 267, 273, 275, TEXTURE BLUE TYPE, 245
276, 279, 280, 294, 570, 594, TEXTURE BORDER COLOR,
595, 682 186–188, 239, 240, 242, 243,
TEXTURE 2D MULTISAMPLE, 180, 261, 286, 596, 600
205, 234, 239, 242–245, 273, TEXTURE BUFFER, 61, 180, 235,
275, 280, 281, 283, 294, 322, 236, 238, 239, 244, 245, 273,
323, 570, 578, 579, 594 283, 294, 542, 543, 570, 594
TEXTURE 2D MULTISAMPLE AR- TEXTURE BUFFER BINDING, 656,
RAY, 180, 205, 234, 239, 242– 712
245, 273, 276, 281–283, 294, TEXTURE BUFFER DATA STORE -
570, 578, 579, 594 BINDING, 599
TEXTURE 3D, 180, 203, 222, 239, TEXTURE BUFFER OFFSET, 599
243–245, 247, 248, 267, 273, TEXTURE BUFFER OFF-
275, 279, 280, 287, 294, 322, SET ALIGNMENT, 236, 637,
323, 570, 682 727, 730
TEXTURE ALPHA SIZE, 245 TEXTURE BUFFER SIZE, 599
TEXTURE ALPHA TYPE, 245 TEXTURE COMPARE FAIL -
TEXTURE BASE LEVEL, 240–242, VALUE ARB, 748
255, 271, 286, 596 TEXTURE COMPARE FUNC, 240,
TEXTURE BINDING xD, 594 286, 288, 597, 600
TEXTURE BINDING 1D, 581 TEXTURE COMPARE MODE,
TEXTURE BINDING 1D ARRAY, 240, 286, 288, 401, 402, 597,
581, 594 600
TEXTURE BINDING 2D, 581 TEXTURE COMPONENTS, 681
TEXTURE BINDING 2D ARRAY, TEXTURE COMPRESSED, 579, 599
581, 594 TEXTURE COMPRESSED BLOCK -
TEXTURE BINDING 2D MULTI- HEIGHT, 579
SAMPLE, 581, 594 TEXTURE COMPRESSED BLOCK -
TEXTURE BINDING 2D MULTI- SIZE, 579
SAMPLE ARRAY, 581, 594 TEXTURE COMPRESSED BLOCK -
TEXTURE BINDING 3D, 581 WIDTH, 579
TEXTURE BINDING BUFFER, 581, TEXTURE COMPRESSED -
594 IMAGE SIZE, 229, 231, 246,
TEXTURE BINDING CUBE MAP, 251, 599
581, 594 TEXTURE COMPRESSION HINT,
TEXTURE BINDING CUBE MAP - 563, 633
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 819
TEXTURE CUBE MAP, 180, 205, 598
216, 222, 225, 230, 233, 239, TEXTURE GATHER, 573
243, 245, 247, 248, 250, 251, TEXTURE GATHER SHADOW, 573
267, 268, 272, 273, 275, 276, TEXTURE GREEN SIZE, 245
278, 294, 570, 594, 682, 721, TEXTURE GREEN TYPE, 245
724, 735 TEXTURE HEIGHT, 224, 229, 231–
TEXTURE CUBE MAP ARRAY, 180, 234, 246, 598
203, 205, 213, 214, 216, 222, TEXTURE IMAGE FORMAT, 579
225, 230, 233, 239, 243–245, TEXTURE IMAGE TYPE, 580
247, 248, 250, 251, 267, 268, TEXTURE IMMUTABLE FORMAT,
272, 273, 275, 276, 279, 280, 235, 243, 272, 275, 276, 286,
294, 570, 594, 595, 721, 724, 597
735, 737 TEXTURE IMMUTABLE LEVELS,
TEXTURE CUBE MAP NEGA- 243, 266, 272, 276, 286, 597,
TIVE X, 254, 337, 595 740
TEXTURE CUBE MAP NEGA- TEXTURE INTERNAL FORMAT,
TIVE Y, 254, 337, 595 229, 231, 232, 234, 246, 598,
TEXTURE CUBE MAP NEGA- 681
TIVE Z, 254, 337, 595 TEXTURE LOD BIAS, 240, 257, 596,
TEXTURE CUBE MAP POS- 600, 682
ITIVE X, 245, 254, 292, 337, TEXTURE MAG FILTER, 240, 268,
595 269, 286, 288, 596, 600
TEXTURE CUBE - TEXTURE MAX ANISOTROPHY,
MAP POSITIVE Y, 254, 337, 256
595 TEXTURE MAX ANISOTROPY, 240,
TEXTURE CUBE - 242, 255, 256, 597, 600, 740
MAP POSITIVE Z, 254, 337, TEXTURE -
595 MAX LEVEL, 240–242, 255,
TEXTURE CUBE MAP SEAMLESS, 271, 286, 596
254, 656 TEXTURE MAX LOD, 240, 241, 255,
TEXTURE DEPTH, 229, 231, 232, 286, 596, 600
246, 598 TEXTURE MIN FILTER, 184, 240,
TEXTURE DEPTH SIZE, 245 242, 260, 261, 265, 269, 270,
TEXTURE DEPTH TYPE, 245 286, 288, 596, 600
TEXTURE ENV, 682 TEXTURE MIN LOD, 240, 241, 255,
TEXTURE FETCH BARRIER BIT, 286, 596, 600
162, 165 TEXTURE PRIORITY, 682
TEXTURE FILTER CONTROL, 682 TEXTURE RECTANGLE, 180, 205,
TEXTURE FIXED SAMPLE - 215, 218, 219, 222, 225–227,
LOCATIONS, 234, 246, 330, 232, 239, 242–245, 247, 248,
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 820
250, 273, 275, 278, 279, 283, TEXTURE WRAP T, 185, 241, 242,
294, 322, 323, 570, 594, 595 261, 596, 600, 681
TEXTURE RECTANGLE ARB, 750 TextureBarrier, 327, 327
TEXTURE RED SIZE, 245 TextureBuffer, 236
TEXTURE RED TYPE, 245 TextureBufferRange, 235, 235, 236, 740
TEXTURE SAMPLES, 234, 246, 313, textureGather, 258, 263, 264, 643, 756
330, 598 textureGather*, 724
TEXTURE SHADOW, 573 textureGatherOffset, 264
TEXTURE SHARED SIZE, 245, 598 textureGatherOffsets, 264, 724
TEXTURE STENCIL SIZE, 245 textureLOD, 756
TEXTURE SWIZZLE A, 240, 286, TextureParameter, 239
490, 596 TextureParameter*, 241
TEXTURE SWIZZLE B, 240, 286, TextureParameterI, 239
490, 596 textureQueryLevels, 400
TEXTURE SWIZZLE G, 240, 286, textureSize, 399, 735
490, 596 TextureStorage*, 277
TEXTURE SWIZZLE R, 240, 286, TextureStorage1D, 277, 277, 740
490, 596 TextureStorage2D, 278, 279
TEXTURE SWIZZLE RGBA, 187, TextureStorage2DMultisample, 280,
240, 242 281
TEXTURE TARGET, 221, 243, 249, TextureStorage3D, 279, 280
251, 252, 596 TextureStorage3DMultisample, 281,
TEXTURE UPDATE BARRIER BIT, 281
163 TextureSubImage1D, 221, 222
TEXTURE VIEW, 573 TextureSubImage2D, 220, 221, 222
TEXTURE VIEW MIN LAYER, 243, TextureSubImage3D, 220, 222, 223
272, 286, 597 TextureView, 206, 241, 271, 273, 274,
TEXTURE VIEW MIN LEVEL, 243, 573, 576, 699, 724, 729
272, 286, 597 TIME ELAPSED, 42, 48, 51, 697
TEXTURE VIEW NUM LAYERS, TIMEOUT EXPIRED, 38
243, 272, 275, 276, 286, 597 TIMEOUT IGNORED, 39
TEXTURE VIEW NUM LEVELS, TIMESTAMP, 42, 44–48, 51, 52, 697
243, 272, 275, 276, 286, 322, TOP LEVEL ARRAY SIZE, 112, 115,
324, 597, 740 624, 710, 727
TEXTURE WIDTH, 224, 229, 231– TOP LEVEL ARRAY STRIDE, 112,
234, 246, 598 115, 624, 727
TEXTURE WRAP R, 185, 241, 261, TRANSFORM FEEDBACK, 443, 444,
596, 600, 681 557
TEXTURE WRAP S, 185, 240, 242, TRANSFORM FEEDBACK ACTIVE,
261, 596, 600, 681 581, 630, 686
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 821
TRANSFORM FEEDBACK BAR- TRANSFORM FEEDBACK VARY-
RIER BIT, 163 ING MAX LENGTH, 168,
TRANSFORM FEEDBACK BIND- 616
ING, 589 TRANSFORM FEED-
TRANSFORM FEED- BACK VARYINGS, 168, 396,
BACK BUFFER, 61, 62, 103, 616
106, 108–112, 395, 446, 447, TransformFeedback, 672
449 TransformFeedbackBufferBase, 446,
TRANSFORM FEEDBACK - 447
BUFFER ACTIVE, 686 TransformFeedbackBufferRange, 446,
TRANSFORM FEEDBACK - 447
BUFFER BINDING, 85, 443, TransformFeedbackVarying, 396
581, 589, 630, 738 TransformFeedbackVaryings, 103, 106,
TRANSFORM FEEDBACK - 109, 114, 392, 393–396
BUFFER INDEX, 112, 115 Translate, 680
TRANSFORM FEEDBACK - TRIANGLE FAN, 342, 347, 432, 438,
BUFFER MODE, 168, 616 446
TRANSFORM FEEDBACK - TRIANGLE STRIP, 168, 341, 347,
BUFFER PAUSED, 686 432, 438, 446, 458, 616
TRANSFORM FEEDBACK - TRIANGLE STRIP -
BUFFER SIZE, 85, 581, 630 ADJACENCY, 345, 347, 432,
TRANSFORM FEED- 438
BACK BUFFER START, 85, TRIANGLES, 168, 342, 347, 432, 438,
581, 630 445, 446, 616
TRANSFORM FEEDBACK - triangles, 415, 416, 418, 419, 432
BUFFER STRIDE, 112, 115 TRIANGLES ADJACENCY, 168, 344,
TRANSFORM FEEDBACK OVER- 347, 432, 438
FLOW, 42, 48, 381–383, 452 triangles adjacency, 432
TRANSFORM FEEDBACK - TRUE, 14, 15, 20, 41, 44, 47, 49, 50, 60,
PAUSED, 581, 630, 686 61, 68, 70, 71, 75, 78, 87, 90–
TRANSFORM FEEDBACK - 92, 94, 96, 99–101, 105, 122,
PRIMITIVES WRITTEN, 42, 131, 132, 142, 166, 167, 169,
45, 46, 48, 448, 452 183, 188, 189, 234, 235, 272,
TRANSFORM FEEDBACK - 275, 276, 291–293, 295, 306,
STREAM OVERFLOW, 42, 312, 315, 325, 330, 348, 352,
45, 46, 48, 382, 383, 452 354, 362, 379, 382, 406, 443,
TRANSFORM - 486, 487, 506, 521, 532, 535,
FEEDBACK VARYING, 103, 549, 554, 573, 574, 576, 578,
106, 109, 111, 112, 114, 395, 579, 588, 593, 598, 603, 604,
396 626, 637, 649, 680, 720
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 822
true, 492 UNIFORM BLOCK ACTIVE UNI-
TYPE, 106, 112, 115, 136, 137, 388, FORMS, 139, 618
396, 624 UNIFORM BLOCK BINDING, 139,
618
uimage1D, 119
UNIFORM BLOCK DATA SIZE, 139,
uimage1DArray, 119
149, 618
uimage2D, 119
UNIFORM BLOCK INDEX, 137, 617
uimage2DArray, 119
UNIFORM BLOCK NAME -
uimage2DMS, 119
LENGTH, 139, 618, 716
uimage2DMSArray, 119
UNIFORM BLOCK REFERENCED -
uimage2DRect, 119
BY COMPUTE SHADER,
uimage3D, 119
139, 619
uimageBuffer, 119
UNIFORM BLOCK REFERENCED -
uimageCube, 119
BY FRAGMENT SHADER,
uimageCubeArray, 119
139, 619
uint, 116, 127, 145, 150, 386
UNIFORM BLOCK REFERENCED -
UNDEFINED VERTEX, 438
BY GEOMETRY SHADER,
UNIFORM, 102, 106, 111, 112, 114,
139, 619
120, 135–137
UNIFORM BLOCK REFERENCED -
Uniform, 11, 147, 148, 667, 668
BY TESS CONTROL -
Uniform1f, 11
SHADER, 139, 618
Uniform1i, 11
UNIFORM BLOCK REFERENCED -
Uniform2f, 11
BY TESS EVALUATION -
Uniform2i, 11
SHADER, 139
Uniform3f, 11
UNIFORM BLOCK REFERENCED -
Uniform3i, 11
BY TESS EVALUTION -
Uniform4f, 11, 12
SHADER, 618
Uniform4ffvg, 142
UNIFORM BLOCK REFERENCED -
Uniform4i, 12
BY VERTEX SHADER, 139,
UNIFORM ARRAY -
618
STRIDE, 137, 146, 150, 618,
UNIFORM BUFFER, 61, 62, 149
698, 737
UNIFORM BUFFER BINDING, 85,
UNIFORM ATOMIC COUNTER -
631
BUFFER INDEX, 137, 621
UNIFORM BUFFER OFFSET -
UNIFORM BARRIER BIT, 162, 165
ALIGNMENT, 85, 645, 727,
UNIFORM BLOCK, 102, 108, 111,
730
112, 137, 138
UNIFORM BUFFER SIZE, 85, 631
UNIFORM BLOCK ACTIVE UNI-
UNIFORM BUFFER START, 85, 631
FORM INDICES, 139, 618
UNIFORM IS ROW MAJOR, 137,
618
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 823
UNIFORM MATRIX STRIDE, 137, 216, 227–229, 610
618 UNPACK SKIP PIXELS, 189, 195,
UNIFORM NAME LENGTH, 137, 227–229, 610
617, 620 UNPACK SKIP ROWS, 189, 195,
UNIFORM OFFSET, 137, 617 227–229, 610
UNIFORM SIZE, 137, 617, 620 UNPACK SWAP BYTES, 189, 192,
UNIFORM TYPE, 137, 617 194, 610
Uniformf1234gfifd uig, 141 UNSIGNALED, 37, 41, 632
Uniformf1234gfifd uigv, 141 UNSIGNED BYTE, 193, 298, 299,
UniformBlockBinding, 149, 149 353, 355, 362, 370, 371, 537,
UniformBufferArrayDynamicIndexing, 538
672 UNSIGNED BYTE 2 3 3 REV, 193,
UniformConstant, 667 197, 198, 537
UniformMatrix2x4fv, 142 UNSIGNED BYTE 3 3 2, 193, 197,
UniformMatrix3dv, 142 198, 537
UniformMatrixf234g, 141 UNSIGNED INT, 116, 193, 245, 295,
UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3g, 298, 311, 353, 362, 370, 371,
141 537, 538, 576
UniformSubroutinesuiv, 156, 706 UNSIGNED INT 10 10 10 2, 193,
UNKNOWN CONTEXT RESET, 19 197, 200, 537
UnmapBuffer, 56, 60, 67, 69, 75, 78, 78, UNSIGNED INT 10F 11F 11F REV,
79 193, 197, 200, 202, 298, 348,
UnmapNamedBuffer, 78, 78, 79 349, 353–355, 363, 535, 537
UNPACK ALIGNMENT, 189, 195, UNSIGNED INT 24 8, 193, 197, 200,
204, 229, 610 533, 537, 538
UNPACK COMPRESSED BLOCK - UNSIGNED INT 2 10 10 10 REV,
DEPTH, 189, 227, 610 193, 197, 200, 298, 299, 348,
UNPACK COMPRESSED BLOCK - 353, 355, 362, 537
HEIGHT, 189, 227, 610 UNSIGNED INT 5 9 9 9 REV,
UNPACK COMPRESSED BLOCK - 193, 197, 200, 202, 208, 535,
SIZE, 189, 227, 610 537
UNPACK COMPRESSED BLOCK - UNSIGNED INT 8 8 8 8, 193, 197,
WIDTH, 189, 227, 610 200, 537
UNPACK IMAGE HEIGHT, 189, 204, UNSIGNED INT 8 8 8 8 REV, 193,
227, 229, 610 197, 200, 537
UNPACK LSB FIRST, 189, 610, 679, UNSIGNED INT ATOMIC -
693, 701 COUNTER, 119
UNPACK ROW LENGTH, 189, 195, UNSIGNED INT IMAGE 1D, 119
204, 227, 229, 610 UNSIGNED INT IMAGE 1D AR-
UNPACK SKIP IMAGES, 189, 204, RAY, 119
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 824
UNSIGNED INT IMAGE 2D, 119 UNSIGNED SHORT, 193, 298, 299,
UNSIGNED INT IMAGE 2D AR- 353, 362, 370, 371, 537, 538
RAY, 119 UNSIGNED SHORT 1 5 5 5 REV,
UNSIGNED INT IMAGE 2D MUL- 193, 197, 199, 537
TISAMPLE, 119 UNSIGNED SHORT 4 4 4 4, 193,
UNSIGNED INT IMAGE 2D MUL- 197, 199, 537
TISAMPLE ARRAY, 119 UNSIGNED SHORT 4 4 4 4 REV,
UNSIGNED INT IMAGE 2D RECT, 193, 197, 199, 537
119 UNSIGNED SHORT 5 5 5 1, 193,
UNSIGNED INT IMAGE 3D, 119 197, 199, 537
UNSIGNED INT IMAGE BUFFER, UNSIGNED SHORT 5 6 5, 193, 197,
119 199, 537
UNSIGNED INT IMAGE CUBE, 119 UNSIGNED SHORT 5 6 5 REV, 193,
UNSIGNED INT IMAGE CUBE - 197, 199, 537
MAP ARRAY, 119 UPPER LEFT, 454, 458, 469, 470, 477,
UNSIGNED INT SAMPLER 1D, 117 591
UNSIGNED INT SAMPLER 1D AR- usampler1D, 117
RAY, 118 usampler1DArray, 118
UNSIGNED INT SAMPLER 2D, 118 usampler2D, 118
UNSIGNED INT SAMPLER 2D AR- usampler2DArray, 118
RAY, 118 usampler2DMS, 118
UNSIGNED INT SAMPLER 2D - usampler2DMSArray, 118
MULTISAMPLE, 118 usampler2DRect, 118
UNSIGNED INT SAMPLER 2D - usampler3D, 118
MULTISAMPLE ARRAY, usamplerBuffer, 118
118 usamplerCube, 118
UNSIGNED INT SAMPLER 2D - usamplerCubeArray, 118
RECT, 118 UseProgram, 98, 98, 99, 123, 141, 157,
UNSIGNED INT SAMPLER 3D, 118 406, 407, 449, 698, 721, 728
UNSIGNED INT SAMPLER - UseProgramStages, 99, 123, 124, 157,
BUFFER, 118 169, 406, 449, 698, 710, 721
UNSIGNED INT SAMPLER CUBE, uvec2, 116, 386
118 uvec3, 116, 386
UNSIGNED INT SAMPLER CUBE - uvec4, 116, 295, 386
MAP ARRAY, 118
VALIDATE STATUS, 167, 170, 406,
UNSIGNED INT VEC2, 116
407, 613, 614
UNSIGNED INT VEC3, 116
ValidateProgram, 167, 406, 407, 711
UNSIGNED INT VEC4, 116
ValidateProgramPipeline, 170, 407, 711
UNSIGNED NORMALIZED, 245,
vec2, 115, 386
311, 576
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 825
vec3, 115, 386 586, 709
vec4, 116, 142, 146, 147, 295, 386 VERTEX BINDING DIVISOR, 379,
VENDOR, 566, 567, 638 586, 709
VERSION, 566, 567, 638 VERTEX BINDING OFFSET, 378,
VERTEX ARRAY, 557 586
VERTEX ARRAY BINDING, 353, VERTEX BINDING STRIDE, 358,
378, 379, 587 586
VERTEX ATTRIB ARRAY BAR- VERTEX PROGRAM TWO SIDE,
RIER BIT, 162 680
VERTEX ATTRIB ARRAY BUFFER, VERTEX SHADER, 89, 155, 172, 173,
162 613
VERTEX ATTRIB ARRAY - VERTEX SHADER BIT, 124
BUFFER BINDING, 364, VERTEX SHADER INVOCATIONS,
379, 586, 708 42, 48, 409
VERTEX ATTRIB - VERTEX SUBROUTINE, 103, 155
ARRAY DIVISOR, 378, 379, VERTEX SUBROUTINE UNIFORM,
585, 708 103, 108, 111, 120, 155
VERTEX ATTRIB ARRAY EN- VERTEX TEXTURE, 573
ABLED, 378, 379, 585 VertexArrayAttribBinding, 357, 357,
VERTEX ATTRIB - 358
ARRAY INTEGER, 378, 379, VertexArrayAttribFormat, 353
585 VertexArrayAttribIFormat, 353
VERTEX ATTRIB ARRAY LONG, VertexArrayAttribLFormat, 353
378, 379, 585, 693, 698 VertexArrayBindingDivisor, 360, 360
VERTEX ATTRIB ARRAY NOR- VertexArrayElementBuffer, 352
MALIZED, 378, 379, 585 VertexArrayVertexBuffer, 355, 355, 356
VERTEX ATTRIB - VertexArrayVertexBuffers, 356, 356,
ARRAY POINTER, 358, 380, 357
585 VertexAttrib, 348, 382
VERTEX ATTRIB ARRAY SIZE, VertexAttrib4, 348
378, 379, 585 VertexAttrib4N, 348
VERTEX ATTRIB ARRAY STRIDE, VertexAttrib4Nub, 348, 713
358, 378, 379, 585 VertexAttribBinding, 357, 357, 359,
VERTEX ATTRIB ARRAY TYPE, 364
378, 379, 585 VertexAttribDivisor, 360, 366, 367, 370
VERTEX ATTRIB BINDING, 379, VertexAttribFormat, 353, 354
586 VertexAttribI, 348
VERTEX ATTRIB RELATIVE OFF- VertexAttribI1i, 386
SET, 378, 379, 586 VertexAttribI1ui, 386
VERTEX BINDING BUFFER, 379, VertexAttribI2i, 386
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 826
VertexAttribI2ui, 386 VIEW CLASS RGTC2 RG, 274
VertexAttribI3i, 386 VIEW COMPATIBILITY CLASS,
VertexAttribI3ui, 386 580, 713
VertexAttribI4, 348 VIEWPORT, 589
VertexAttribI4i, 386 Viewport, 460, 460
VertexAttribI4ui, 386 VIEWPORT BOUNDS RANGE, 461,
VertexAttribIFormat, 353, 354, 355 636
VertexAttribIPointer, 358, 379 VIEWPORT INDEX -
VertexAttribL1d, 386 PROVOKING VERTEX, 438,
VertexAttribL2d, 386 636
VertexAttribL3d, 386 VIEWPORT SUBPIXEL BITS, 461,
VertexAttribL3dv, 385 636
VertexAttribL4d, 386 ViewportArrayv, 460, 460
VertexAttribLf1234gd, 348 ViewportIndex, 671
VertexAttribLf1234gdv, 348 ViewportIndexedf, 460, 460
VertexAttribLFormat, 353, 354, 355 ViewportIndexedfv, 460, 460
VertexAttribLPointer, 358, 385
WAIT FAILED, 38
VertexAttribP1ui, 348
WaitSync, 36–38, 39, 39, 40, 55, 56,
VertexAttribP2ui, 348
651
VertexAttribP3ui, 348
WGL ARB create context, 549, 753
VertexAttribP4ui, 348, 349
WGL ARB create context no error,
VertexAttribP4uiv, 349
776
VertexAttribPointer, 351, 358, 364, 379,
WGL ARB create context pro?le, 678,
680
757
VertexBindingDivisor, 360, 360
WGL ARB create context robustness,
VertexId, 671
761
VertexPointer, 679
WGL ARB framebuffer sRGB, 752
vertices, 410
WGL ARB pixel format ?oat, 750
VERTICES SUBMITTED, 42, 48, 383
WGL ARB robustness application iso-
VIEW CLASS 128 BITS, 274
lation, 767
VIEW CLASS 16 BITS, 274
WGL ARB robustness share group -
VIEW CLASS 24 BITS, 274
isolation, 767
VIEW CLASS 32 BITS, 274
while, 415
VIEW CLASS 48 BITS, 274
Width, 498
VIEW CLASS 64 BITS, 274
Workgroup, 667
VIEW CLASS 8 BITS, 274
WorkgroupId, 671
VIEW CLASS 96 BITS, 274
WorkgroupSize, 669, 671
VIEW CLASS BPTC FLOAT, 274
WRITE ONLY, 61, 75, 77, 291
VIEW CLASS BPTC UNORM, 274
VIEW CLASS RGTC1 RED, 274
OpenGL 4.6 (Core Pro?le) - February 2, 2019INDEX 827
Xfb, 391, 395, 668
xfb buffer, 391, 392, 395
xfb offset, 114, 391, 392, 395
xfb stride, 391, 392, 394, 395
XfbBuffer, 391, 395, 668
XfbStride, 391, 668
XOR, 515
ZERO, 240, 490, 504, 509, 511, 513,
603
ZERO TO ONE, 454, 458
OpenGL 4.6 (Core Pro?le) - February 2, 2019