R
The OpenGL Graphics System:
A Specification
(Version 3.0 - September 23, 2008)
Mark Segal
Kurt Akeley
Editor (version 1.1): Chris Frazier
Editor (versions 1.2-3.0): Jon Leech
Editor (version 2.0): Pat BrownCopyrightc 2006-2008 The Khronos Group Inc. All Rights Reserved.
This speci?cation is protected by copyright laws and contains material proprietary
to the Khronos Group, Inc. It or any components may not be reproduced, repub-
lished, distributed, transmitted, displayed, broadcast or otherwise exploited in any
manner without the express prior written permission of Khronos Group. You may
use this speci?cation for implementing the functionality therein, without altering or
removing any trademark, copyright or other notice from the speci?cation, but the
receipt or possession of this speci?cation does not convey any rights to reproduce,
disclose, or distribute its contents, or to manufacture, use, or sell anything that it
may describe, in whole or in part.
Khronos Group grants express permission to any current Promoter, Contributor
or Adopter member of Khronos to copy and redistribute UNMODIFIED versions
of this speci?cation in any fashion, provided that NO CHARGE is made for the
speci?cation and the latest available update of the speci?cation for any version
of the API is used whenever possible. Such distributed speci?cation may be re-
formatted AS LONG AS the contents of the speci?cation are not changed in any
way. The speci?cation may be incorporated into a product that is sold as long as
such product includes signi?cant independent work developed by the seller. A link
to the current version of this speci?cation on the Khronos Group web-site should
be included whenever possible with speci?cation distributions.
Khronos Group makes no, and expressly disclaims any, representations or war-
ranties, express or implied, regarding this speci?cation, including, without limita-
tion, any implied warranties of merchantability or ?tness for a particular purpose
or non-infringement of any intellectual property. Khronos Group makes no, and
expressly disclaims any, warranties, express or implied, regarding the correctness,
accuracy, completeness, timeliness, and reliability of the speci?cation. Under no
circumstances will the Khronos Group, or any of its Promoters, Contributors or
Members or their respective partners, of?cers, directors, employees, agents or rep-
resentatives be liable for any damages, whether direct, indirect, special or conse-
quential damages for lost revenues, lost pro?ts, or otherwise, arising from or in
connection with these materials.
Khronos is a trademark of The Khronos Group Inc. OpenGL is a registered trade-
mark, and OpenGL ES is a trademark, of Silicon Graphics, Inc.Contents
1 Introduction 1
1.1 Formatting of Optional Features . . . . . . . . . . . . . . . . . . 1
1.2 What is the OpenGL Graphics System? . . . . . . . . . . . . . . 1
1.3 Programmer’s View of OpenGL . . . . . . . . . . . . . . . . . . 2
1.4 Implementor’s View of OpenGL . . . . . . . . . . . . . . . . . . 2
1.5 Our View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.6 The Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . 3
1.7 Companion Documents . . . . . . . . . . . . . . . . . . . . . . . 3
1.7.1 OpenGL Shading Language . . . . . . . . . . . . . . . . 3
1.7.2 Window System Bindings . . . . . . . . . . . . . . . . . 3
2 OpenGL Operation 5
2.1 OpenGL Fundamentals . . . . . . . . . . . . . . . . . . . . . . . 5
2.1.1 Floating-Point Computation . . . . . . . . . . . . . . . . 7
2.1.2 16-Bit Floating-Point Numbers . . . . . . . . . . . . . . 8
2.1.3 Unsigned 11-Bit Floating-Point Numbers . . . . . . . . . 9
2.1.4 Unsigned 10-Bit Floating-Point Numbers . . . . . . . . . 9
2.2 GL State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.2.1 Shared Object State . . . . . . . . . . . . . . . . . . . . . 11
2.3 GL Command Syntax . . . . . . . . . . . . . . . . . . . . . . . . 11
2.4 Basic GL Operation . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.5 GL Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.6 Begin/End Paradigm . . . . . . . . . . . . . . . . . . . . . . . . 16
2.6.1 Begin and End . . . . . . . . . . . . . . . . . . . . . . . 19
2.6.2 Polygon Edges . . . . . . . . . . . . . . . . . . . . . . . 23
2.6.3 GL Commands within Begin/End . . . . . . . . . . . . . 24
2.7 Vertex Specification . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.8 Vertex Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.9 Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
iCONTENTS ii
2.9.1 Mapping and Unmapping Buffer Data . . . . . . . . . . . 42
2.9.2 Vertex Arrays in Buffer Objects . . . . . . . . . . . . . . 46
2.9.3 Array Indices in Buffer Objects . . . . . . . . . . . . . . 47
2.9.4 Buffer Object State . . . . . . . . . . . . . . . . . . . . . 47
2.10 Vertex Array Objects . . . . . . . . . . . . . . . . . . . . . . . . 48
2.11 Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.12 Coordinate Transformations . . . . . . . . . . . . . . . . . . . . 49
2.12.1 Controlling the Viewport . . . . . . . . . . . . . . . . . . 51
2.12.2 Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.12.3 Normal Transformation . . . . . . . . . . . . . . . . . . . 57
2.12.4 Generating Texture Coordinates . . . . . . . . . . . . . . 59
2.13 Asynchronous Queries . . . . . . . . . . . . . . . . . . . . . . . 61
2.14 Conditional Rendering . . . . . . . . . . . . . . . . . . . . . . . 63
2.15 Transform Feedback . . . . . . . . . . . . . . . . . . . . . . . . 64
2.16 Primitive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . 67
2.17 Clipping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
2.18 Current Raster Position . . . . . . . . . . . . . . . . . . . . . . . 70
2.19 Colors and Coloring . . . . . . . . . . . . . . . . . . . . . . . . . 73
2.19.1 Lighting . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
2.19.2 Lighting Parameter Specification . . . . . . . . . . . . . . 80
2.19.3 ColorMaterial . . . . . . . . . . . . . . . . . . . . . . . 84
2.19.4 Lighting State . . . . . . . . . . . . . . . . . . . . . . . . 84
2.19.5 Color Index Lighting . . . . . . . . . . . . . . . . . . . . 85
2.19.6 Clamping or Masking . . . . . . . . . . . . . . . . . . . 86
2.19.7 Flatshading . . . . . . . . . . . . . . . . . . . . . . . . . 86
2.19.8 Color and Associated Data Clipping . . . . . . . . . . . . 87
2.19.9 Final Color Processing . . . . . . . . . . . . . . . . . . . 88
2.20 Vertex Shaders . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
2.20.1 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . 89
2.20.2 Program Objects . . . . . . . . . . . . . . . . . . . . . . 90
2.20.3 Shader Variables . . . . . . . . . . . . . . . . . . . . . . 92
2.20.4 Shader Execution . . . . . . . . . . . . . . . . . . . . . . 104
2.20.5 Required State . . . . . . . . . . . . . . . . . . . . . . . 110
3 Rasterization 112
3.1 Discarding Primitives Before Rasterization . . . . . . . . . . . . 114
3.2 Invariance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
3.3 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
3.3.1 Multisampling . . . . . . . . . . . . . . . . . . . . . . . 115
3.4 Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
Version 3.0 (September 23, 2008)CONTENTS iii
3.4.1 Basic Point Rasterization . . . . . . . . . . . . . . . . . . 119
3.4.2 Point Rasterization State . . . . . . . . . . . . . . . . . . 123
3.4.3 Point Multisample Rasterization . . . . . . . . . . . . . . 123
3.5 Line Segments . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
3.5.1 Basic Line Segment Rasterization . . . . . . . . . . . . . 124
3.5.2 Other Line Segment Features . . . . . . . . . . . . . . . . 126
3.5.3 Line Rasterization State . . . . . . . . . . . . . . . . . . 129
3.5.4 Line Multisample Rasterization . . . . . . . . . . . . . . 129
3.6 Polygons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
3.6.1 Basic Polygon Rasterization . . . . . . . . . . . . . . . . 130
3.6.2 Stippling . . . . . . . . . . . . . . . . . . . . . . . . . . 132
3.6.3 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . 133
3.6.4 Options Controlling Polygon Rasterization . . . . . . . . 133
3.6.5 Depth Offset . . . . . . . . . . . . . . . . . . . . . . . . 134
3.6.6 Polygon Multisample Rasterization . . . . . . . . . . . . 135
3.6.7 Polygon Rasterization State . . . . . . . . . . . . . . . . 136
3.7 Pixel Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
3.7.1 Pixel Storage Modes and Pixel Buffer Objects . . . . . . . 136
3.7.2 The Imaging Subset . . . . . . . . . . . . . . . . . . . . 138
3.7.3 Pixel Transfer Modes . . . . . . . . . . . . . . . . . . . . 138
3.7.4 Rasterization of Pixel Rectangles . . . . . . . . . . . . . 149
3.7.5 Pixel Transfer Operations . . . . . . . . . . . . . . . . . 163
3.7.6 Pixel Rectangle Multisample Rasterization . . . . . . . . 173
3.8 Bitmaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
3.9 Texturing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
3.9.1 Texture Image Specification . . . . . . . . . . . . . . . . 177
3.9.2 Alternate Texture Image Specification Commands . . . . 192
3.9.3 Compressed Texture Images . . . . . . . . . . . . . . . . 197
3.9.4 Texture Parameters . . . . . . . . . . . . . . . . . . . . . 201
3.9.5 Depth Component Textures . . . . . . . . . . . . . . . . 203
3.9.6 Cube Map Texture Selection . . . . . . . . . . . . . . . . 203
3.9.7 Texture Minification . . . . . . . . . . . . . . . . . . . . 204
3.9.8 Texture Magnification . . . . . . . . . . . . . . . . . . . 213
3.9.9 Combined Depth/Stencil Textures . . . . . . . . . . . . . 213
3.9.10 Texture Completeness . . . . . . . . . . . . . . . . . . . 213
3.9.11 Texture State and Proxy State . . . . . . . . . . . . . . . 215
3.9.12 Texture Objects . . . . . . . . . . . . . . . . . . . . . . . 216
3.9.13 Texture Environments and Texture Functions . . . . . . . 219
3.9.14 Texture Comparison Modes . . . . . . . . . . . . . . . . 222
3.9.15 sRGB Texture Color Conversion . . . . . . . . . . . . . . 225
Version 3.0 (September 23, 2008)CONTENTS iv
3.9.16 Shared Exponent Texture Color Conversion . . . . . . . . 227
3.9.17 Texture Application . . . . . . . . . . . . . . . . . . . . . 227
3.10 Color Sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
3.11 Fog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
3.12 Fragment Shaders . . . . . . . . . . . . . . . . . . . . . . . . . . 231
3.12.1 Shader Variables . . . . . . . . . . . . . . . . . . . . . . 232
3.12.2 Shader Execution . . . . . . . . . . . . . . . . . . . . . . 233
3.13 Antialiasing Application . . . . . . . . . . . . . . . . . . . . . . 237
3.14 Multisample Point Fade . . . . . . . . . . . . . . . . . . . . . . . 237
4 Per-Fragment Operations and the Framebuffer 239
4.1 Per-Fragment Operations . . . . . . . . . . . . . . . . . . . . . . 241
4.1.1 Pixel Ownership Test . . . . . . . . . . . . . . . . . . . . 241
4.1.2 Scissor Test . . . . . . . . . . . . . . . . . . . . . . . . . 242
4.1.3 Multisample Fragment Operations . . . . . . . . . . . . . 242
4.1.4 Alpha Test . . . . . . . . . . . . . . . . . . . . . . . . . 243
4.1.5 Stencil Test . . . . . . . . . . . . . . . . . . . . . . . . . 244
4.1.6 Depth Buffer Test . . . . . . . . . . . . . . . . . . . . . . 246
4.1.7 Occlusion Queries . . . . . . . . . . . . . . . . . . . . . 246
4.1.8 Blending . . . . . . . . . . . . . . . . . . . . . . . . . . 247
4.1.9 sRGB Conversion . . . . . . . . . . . . . . . . . . . . . 252
4.1.10 Dithering . . . . . . . . . . . . . . . . . . . . . . . . . . 252
4.1.11 Logical Operation . . . . . . . . . . . . . . . . . . . . . 253
4.1.12 Additional Multisample Fragment Operations . . . . . . . 254
4.2 Whole Framebuffer Operations . . . . . . . . . . . . . . . . . . . 255
4.2.1 Selecting a Buffer for Writing . . . . . . . . . . . . . . . 255
4.2.2 Fine Control of Buffer Updates . . . . . . . . . . . . . . 260
4.2.3 Clearing the Buffers . . . . . . . . . . . . . . . . . . . . 261
4.2.4 The Accumulation Buffer . . . . . . . . . . . . . . . . . 264
4.3 Drawing, Reading, and Copying Pixels . . . . . . . . . . . . . . . 266
4.3.1 Writing to the Stencil or Depth/Stencil Buffers . . . . . . 266
4.3.2 Reading Pixels . . . . . . . . . . . . . . . . . . . . . . . 266
4.3.3 Copying Pixels . . . . . . . . . . . . . . . . . . . . . . . 274
4.3.4 Pixel Draw/Read State . . . . . . . . . . . . . . . . . . . 278
4.4 Framebuffer Objects . . . . . . . . . . . . . . . . . . . . . . . . 278
4.4.1 Binding and Managing Framebuffer Objects . . . . . . . . 279
4.4.2 Attaching Images to Framebuffer Objects . . . . . . . . . 282
4.4.3 Rendering When an Image of a Bound Texture Object is
Also Attached to the Framebuffer . . . . . . . . . . . . . 289
4.4.4 Framebuffer Completeness . . . . . . . . . . . . . . . . . 290
Version 3.0 (September 23, 2008)CONTENTS v
4.4.5 Effects of Framebuffer State on Framebuffer Dependent
Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
4.4.6 Mapping between Pixel and Element in Attached Image . 296
5 Special Functions 297
5.1 Evaluators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
5.2 Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
5.3 Feedback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
5.4 Display Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
5.5 Commands Not Usable In Display Lists . . . . . . . . . . . . . . 311
5.6 Flush and Finish . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
5.7 Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
6 State and State Requests 315
6.1 Querying GL State . . . . . . . . . . . . . . . . . . . . . . . . . 315
6.1.1 Simple Queries . . . . . . . . . . . . . . . . . . . . . . . 315
6.1.2 Data Conversions . . . . . . . . . . . . . . . . . . . . . . 316
6.1.3 Enumerated Queries . . . . . . . . . . . . . . . . . . . . 317
6.1.4 Texture Queries . . . . . . . . . . . . . . . . . . . . . . . 320
6.1.5 Stipple Query . . . . . . . . . . . . . . . . . . . . . . . . 323
6.1.6 Color Matrix Query . . . . . . . . . . . . . . . . . . . . . 323
6.1.7 Color Table Query . . . . . . . . . . . . . . . . . . . . . 323
6.1.8 Convolution Query . . . . . . . . . . . . . . . . . . . . . 324
6.1.9 Histogram Query . . . . . . . . . . . . . . . . . . . . . . 325
6.1.10 Minmax Query . . . . . . . . . . . . . . . . . . . . . . . 326
6.1.11 Pointer and String Queries . . . . . . . . . . . . . . . . . 327
6.1.12 Asynchronous Queries . . . . . . . . . . . . . . . . . . . 328
6.1.13 Buffer Object Queries . . . . . . . . . . . . . . . . . . . 330
6.1.14 Vertex Array Object Queries . . . . . . . . . . . . . . . . 331
6.1.15 Shader and Program Queries . . . . . . . . . . . . . . . . 331
6.1.16 Framebuffer Object Queries . . . . . . . . . . . . . . . . 336
6.1.17 Renderbuffer Object Queries . . . . . . . . . . . . . . . . 338
6.1.18 Saving and Restoring State . . . . . . . . . . . . . . . . . 339
6.2 State Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
A Invariance 393
A.1 Repeatability . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
A.2 Multi-pass Algorithms . . . . . . . . . . . . . . . . . . . . . . . 394
A.3 Invariance Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
A.4 What All This Means . . . . . . . . . . . . . . . . . . . . . . . . 396
Version 3.0 (September 23, 2008)CONTENTS vi
B Corollaries 397
C Compressed Texture Image Formats 400
C.1 RGTC Compressed Texture Image Formats . . . . . . . . . . . . 400
C.1.1 FormatCOMPRESSED RED RGTC1 . . . . . . . . . . . . . 401
C.1.2 FormatCOMPRESSED SIGNED RED RGTC1 . . . . . . . . 402
C.1.3 FormatCOMPRESSED RG RGTC2 . . . . . . . . . . . . . . 403
C.1.4 FormatCOMPRESSED SIGNED RG RGTC2 . . . . . . . . . 403
D Shared Objects and Multiple Contexts 404
D.1 Object Deletion Behavior . . . . . . . . . . . . . . . . . . . . . . 404
E The Deprecation Model 405
E.1 Pro?les and Deprecated Features of OpenGL 3.0 . . . . . . . . . 405
F Version 1.1 411
F.1 Vertex Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
F.2 Polygon Offset . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
F.3 Logical Operation . . . . . . . . . . . . . . . . . . . . . . . . . . 412
F.4 Texture Image Formats . . . . . . . . . . . . . . . . . . . . . . . 412
F.5 Texture Replace Environment . . . . . . . . . . . . . . . . . . . . 412
F.6 Texture Proxies . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
F.7 Copy Texture and Subtexture . . . . . . . . . . . . . . . . . . . . 413
F.8 Texture Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
F.9 Other Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
F.10 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 414
G Version 1.2 416
G.1 Three-Dimensional Texturing . . . . . . . . . . . . . . . . . . . . 416
G.2 BGRA Pixel Formats . . . . . . . . . . . . . . . . . . . . . . . . 416
G.3 Packed Pixel Formats . . . . . . . . . . . . . . . . . . . . . . . . 417
G.4 Normal Rescaling . . . . . . . . . . . . . . . . . . . . . . . . . . 417
G.5 Separate Specular Color . . . . . . . . . . . . . . . . . . . . . . 417
G.6 Texture Coordinate Edge Clamping . . . . . . . . . . . . . . . . 417
G.7 Texture Level of Detail Control . . . . . . . . . . . . . . . . . . . 418
G.8 Vertex Array Draw Element Range . . . . . . . . . . . . . . . . . 418
G.9 Imaging Subset . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
G.9.1 Color Tables . . . . . . . . . . . . . . . . . . . . . . . . 418
G.9.2 Convolution . . . . . . . . . . . . . . . . . . . . . . . . . 419
G.9.3 Color Matrix . . . . . . . . . . . . . . . . . . . . . . . . 419
Version 3.0 (September 23, 2008)CONTENTS vii
G.9.4 Pixel Pipeline Statistics . . . . . . . . . . . . . . . . . . . 420
G.9.5 Constant Blend Color . . . . . . . . . . . . . . . . . . . . 420
G.9.6 New Blending Equations . . . . . . . . . . . . . . . . . . 420
G.10 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 420
H Version 1.2.1 424
I Version 1.3 425
I.1 Compressed Textures . . . . . . . . . . . . . . . . . . . . . . . . 425
I.2 Cube Map Textures . . . . . . . . . . . . . . . . . . . . . . . . . 425
I.3 Multisample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
I.4 Multitexture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
I.5 Texture Add Environment Mode . . . . . . . . . . . . . . . . . . 427
I.6 Texture Combine Environment Mode . . . . . . . . . . . . . . . 427
I.7 Texture Dot3 Environment Mode . . . . . . . . . . . . . . . . . . 427
I.8 Texture Border Clamp . . . . . . . . . . . . . . . . . . . . . . . 427
I.9 Transpose Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . 428
I.10 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 428
J Version 1.4 433
J.1 Automatic Mipmap Generation . . . . . . . . . . . . . . . . . . . 433
J.2 Blend Squaring . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
J.3 Changes to the Imaging Subset . . . . . . . . . . . . . . . . . . . 434
J.4 Depth Textures and Shadows . . . . . . . . . . . . . . . . . . . . 434
J.5 Fog Coordinate . . . . . . . . . . . . . . . . . . . . . . . . . . . 434
J.6 Multiple Draw Arrays . . . . . . . . . . . . . . . . . . . . . . . . 434
J.7 Point Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . 435
J.8 Secondary Color . . . . . . . . . . . . . . . . . . . . . . . . . . 435
J.9 Separate Blend Functions . . . . . . . . . . . . . . . . . . . . . . 435
J.10 Stencil Wrap . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
J.11 Texture Crossbar Environment Mode . . . . . . . . . . . . . . . . 435
J.12 Texture LOD Bias . . . . . . . . . . . . . . . . . . . . . . . . . . 436
J.13 Texture Mirrored Repeat . . . . . . . . . . . . . . . . . . . . . . 436
J.14 Window Raster Position . . . . . . . . . . . . . . . . . . . . . . 436
J.15 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 436
K Version 1.5 439
K.1 Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
K.2 Occlusion Queries . . . . . . . . . . . . . . . . . . . . . . . . . . 440
K.3 Shadow Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 440
Version 3.0 (September 23, 2008)CONTENTS viii
K.4 Changed Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
K.5 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 440
L Version 2.0 445
L.1 Programmable Shading . . . . . . . . . . . . . . . . . . . . . . . 445
L.1.1 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . 445
L.1.2 Shader Programs . . . . . . . . . . . . . . . . . . . . . . 445
L.1.3 OpenGL Shading Language . . . . . . . . . . . . . . . . 446
L.1.4 Changes To Shader APIs . . . . . . . . . . . . . . . . . . 446
L.2 Multiple Render Targets . . . . . . . . . . . . . . . . . . . . . . 446
L.3 Non-Power-Of-Two Textures . . . . . . . . . . . . . . . . . . . . 446
L.4 Point Sprites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
L.5 Separate Blend Equation . . . . . . . . . . . . . . . . . . . . . . 447
L.6 Separate Stencil . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
L.7 Other Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
L.8 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 449
M Version 2.1 451
M.1 OpenGL Shading Language . . . . . . . . . . . . . . . . . . . . 451
M.2 Non-Square Matrices . . . . . . . . . . . . . . . . . . . . . . . . 451
M.3 Pixel Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . . . 451
M.4 sRGB Textures . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
M.5 Other Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
M.6 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 454
N Version 3.0 457
N.1 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
N.2 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 458
N.3 Changed Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . 459
N.4 Change Log . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459
N.5 Credits and Acknowledgements . . . . . . . . . . . . . . . . . . 461
O ARB Extensions 464
O.1 Naming Conventions . . . . . . . . . . . . . . . . . . . . . . . . 464
O.2 Promoting Extensions to Core Features . . . . . . . . . . . . . . 465
O.3 Multitexture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
O.4 Transpose Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . 465
O.5 Multisample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
O.6 Texture Add Environment Mode . . . . . . . . . . . . . . . . . . 466
O.7 Cube Map Textures . . . . . . . . . . . . . . . . . . . . . . . . . 466
Version 3.0 (September 23, 2008)CONTENTS ix
O.8 Compressed Textures . . . . . . . . . . . . . . . . . . . . . . . . 466
O.9 Texture Border Clamp . . . . . . . . . . . . . . . . . . . . . . . 466
O.10 Point Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . 466
O.11 Vertex Blend . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466
O.12 Matrix Palette . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
O.13 Texture Combine Environment Mode . . . . . . . . . . . . . . . 467
O.14 Texture Crossbar Environment Mode . . . . . . . . . . . . . . . . 467
O.15 Texture Dot3 Environment Mode . . . . . . . . . . . . . . . . . . 467
O.16 Texture Mirrored Repeat . . . . . . . . . . . . . . . . . . . . . . 467
O.17 Depth Texture . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
O.18 Shadow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
O.19 Shadow Ambient . . . . . . . . . . . . . . . . . . . . . . . . . . 468
O.20 Window Raster Position . . . . . . . . . . . . . . . . . . . . . . 468
O.21 Low-Level Vertex Programming . . . . . . . . . . . . . . . . . . 468
O.22 Low-Level Fragment Programming . . . . . . . . . . . . . . . . 468
O.23 Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
O.24 Occlusion Queries . . . . . . . . . . . . . . . . . . . . . . . . . . 469
O.25 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
O.26 High-Level Vertex Programming . . . . . . . . . . . . . . . . . . 469
O.27 High-Level Fragment Programming . . . . . . . . . . . . . . . . 469
O.28 OpenGL Shading Language . . . . . . . . . . . . . . . . . . . . 469
O.29 Non-Power-Of-Two Textures . . . . . . . . . . . . . . . . . . . . 469
O.30 Point Sprites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470
O.31 Fragment Program Shadow . . . . . . . . . . . . . . . . . . . . . 470
O.32 Multiple Render Targets . . . . . . . . . . . . . . . . . . . . . . 470
O.33 Rectangular Textures . . . . . . . . . . . . . . . . . . . . . . . . 470
O.34 Floating-Point Color Buffers . . . . . . . . . . . . . . . . . . . . 470
O.35 Half-Precision Floating Point . . . . . . . . . . . . . . . . . . . . 471
O.36 Floating-Point Textures . . . . . . . . . . . . . . . . . . . . . . . 471
O.37 Pixel Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . . . 471
Index 472
Version 3.0 (September 23, 2008)List of Figures
2.1 Block diagram of the GL. . . . . . . . . . . . . . . . . . . . . . . 13
2.2 Creation of a processed vertex from a transformed vertex and cur-
rent values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3 Primitive assembly and processing. . . . . . . . . . . . . . . . . . 19
2.4 Triangle strips, fans, and independent triangles. . . . . . . . . . . 21
2.5 Quadrilateral strips and independent quadrilaterals. . . . . . . . . 22
2.6 Vertex transformation sequence. . . . . . . . . . . . . . . . . . . 50
2.7 Current raster position. . . . . . . . . . . . . . . . . . . . . . . . 71
2.8 Processing of RGBA colors. . . . . . . . . . . . . . . . . . . . . 73
2.9 Processing of color indices. . . . . . . . . . . . . . . . . . . . . . 73
2.10 ColorMaterial operation. . . . . . . . . . . . . . . . . . . . . . . 84
3.1 Rasterization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
3.2 Rasterization of non-antialiased wide points. . . . . . . . . . . . . 119
3.3 Rasterization of antialiased wide points. . . . . . . . . . . . . . . 119
3.4 Visualization of Bresenham’s algorithm. . . . . . . . . . . . . . . 124
3.5 Rasterization of non-antialiased wide lines. . . . . . . . . . . . . 127
3.6 The region used in rasterizing an antialiased line segment. . . . . 128
3.7 Operation of DrawPixels. . . . . . . . . . . . . . . . . . . . . . 149
3.8 Selecting a subimage from an image . . . . . . . . . . . . . . . . 154
3.9 A bitmap and its associated parameters. . . . . . . . . . . . . . . 174
3.10 A texture image and the coordinates used to access it. . . . . . . . 190
3.11 Multitexture pipeline. . . . . . . . . . . . . . . . . . . . . . . . . 228
4.1 Per-fragment operations. . . . . . . . . . . . . . . . . . . . . . . 241
4.2 Operation of ReadPixels. . . . . . . . . . . . . . . . . . . . . . . 266
4.3 Operation of CopyPixels. . . . . . . . . . . . . . . . . . . . . . . 274
5.1 Map Evaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
5.2 Feedback syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . 308
xList of Tables
2.1 GL command suf?xes . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2 GL data types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.3 Summary of GL errors . . . . . . . . . . . . . . . . . . . . . . . 17
2.4 Vertex array sizes (values per vertex) and data types . . . . . . . . 30
2.5 Variables that direct the execution of InterleavedArrays. . . . . . 37
2.6 Buffer object parameters and their values. . . . . . . . . . . . . . 39
2.7 Buffer object initial state. . . . . . . . . . . . . . . . . . . . . . . 41
2.8 Buffer object state set by MapBufferRange. . . . . . . . . . . . 44
2.9 Transform feedback modes . . . . . . . . . . . . . . . . . . . . . 65
2.10 Component conversions . . . . . . . . . . . . . . . . . . . . . . . 75
2.11 Summary of lighting parameters. . . . . . . . . . . . . . . . . . . 77
2.12 Correspondence of lighting parameter symbols to names. . . . . . 82
2.13 Polygon ?atshading color selection. . . . . . . . . . . . . . . . . 87
3.1 PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . . 137
3.2 PixelTransfer parameters. . . . . . . . . . . . . . . . . . . . . . 139
3.3 PixelMap parameters. . . . . . . . . . . . . . . . . . . . . . . . 140
3.4 Color table names. . . . . . . . . . . . . . . . . . . . . . . . . . 141
3.5 DrawPixels and ReadPixels types. . . . . . . . . . . . . . . . . . 152
3.6 DrawPixels and ReadPixels formats. . . . . . . . . . . . . . . . 153
3.7 Swap Bytes bit ordering. . . . . . . . . . . . . . . . . . . . . . . 154
3.8 Packed pixel formats. . . . . . . . . . . . . . . . . . . . . . . . . 156
3.9 UNSIGNED BYTE formats. Bit numbers are indicated for each com-
ponent. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
3.10 UNSIGNED SHORT formats . . . . . . . . . . . . . . . . . . . . . 158
3.11 UNSIGNED INT formats . . . . . . . . . . . . . . . . . . . . . . . 159
3.12 Packed pixel ?eld assignments. . . . . . . . . . . . . . . . . . . . 160
3.13 Color table lookup. . . . . . . . . . . . . . . . . . . . . . . . . . 166
3.14 Computation of ?ltered color components. . . . . . . . . . . . . . 167
xiLISTOFTABLES xii
3.15 Conversion from RGBA, depth, and stencil pixel components to
internal texture, table, or ?lter components. . . . . . . . . . . . . 179
3.16 Sized internal color formats. . . . . . . . . . . . . . . . . . . . . 184
3.18 Sized internal depth and stencil formats. . . . . . . . . . . . . . . 185
3.17 Sized internal luminance and intensity formats. . . . . . . . . . . 185
3.19 Generic and speci?c compressed internal formats. . . . . . . . . . 186
3.20 Texture parameters and their values. . . . . . . . . . . . . . . . . 202
3.21 Selection of cube map images. . . . . . . . . . . . . . . . . . . . 203
3.22 Texel location wrap mode application. . . . . . . . . . . . . . . . 207
3.23 Correspondence of ?ltered texture components to texture source
components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
3.24 Texture functionsREPLACE,MODULATE, andDECAL . . . . . . . . 221
3.25 Texture functionsBLEND andADD. . . . . . . . . . . . . . . . . . 222
3.26 COMBINE texture functions. . . . . . . . . . . . . . . . . . . . . . 223
3.27 Arguments forCOMBINE RGB functions. . . . . . . . . . . . . . . 224
3.28 Arguments forCOMBINE ALPHA functions. . . . . . . . . . . . . 224
3.29 Depth texture comparison functions. . . . . . . . . . . . . . . . . 226
4.1 RGB and Alpha blend equations. . . . . . . . . . . . . . . . . . . 250
4.2 Blending functions. . . . . . . . . . . . . . . . . . . . . . . . . . 251
4.3 Arguments to LogicOp and their corresponding operations. . . . . 254
4.4 Buffer selection for the default framebuffer . . . . . . . . . . . . 257
4.5 Buffer selection for a framebuffer object . . . . . . . . . . . . . . 257
4.6 DrawBuffers buffer selection for the default framebuffer . . . . . 258
4.7 PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . . 268
4.8 ReadPixels index masks. . . . . . . . . . . . . . . . . . . . . . . 272
4.9 ReadPixels GL data types and reversed component conversion for-
mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
4.10 Effective ReadPixels format forDEPTH STENCIL CopyPixels op-
eration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
4.11 Correspondence of renderbuffer sized to base internal formats. . . 284
4.12 Framebuffer attachment points. . . . . . . . . . . . . . . . . . . . 286
5.1 Values speci?ed by the target to Map1. . . . . . . . . . . . . . . 298
5.2 Correspondence of feedback type to number of values per vertex. . 307
5.3 Hint targets and descriptions . . . . . . . . . . . . . . . . . . . . 314
6.1 Texture, table, and ?lter return values. . . . . . . . . . . . . . . . 322
6.2 Attribute groups . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
6.3 State Variable Types . . . . . . . . . . . . . . . . . . . . . . . . . 342
Version 3.0 (September 23, 2008)LISTOFTABLES xiii
6.4 GL Internal begin-end state variables (inaccessible) . . . . . . . . 344
6.5 Current Values and Associated Data . . . . . . . . . . . . . . . . 345
6.6 Vertex Array Object State . . . . . . . . . . . . . . . . . . . . . . 346
6.7 Vertex Array Object State (cont.) . . . . . . . . . . . . . . . . . . 347
6.8 Vertex Array Object State (cont.) . . . . . . . . . . . . . . . . . . 348
6.9 Vertex Array Object State (cont.) . . . . . . . . . . . . . . . . . . 349
6.10 Vertex Array Data (not in Vertex Array objects) . . . . . . . . . . 350
6.11 Buffer Object State . . . . . . . . . . . . . . . . . . . . . . . . . 351
6.12 Transformation state . . . . . . . . . . . . . . . . . . . . . . . . 352
6.13 Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353
6.14 Lighting (see also table 2.11 for defaults) . . . . . . . . . . . . . 354
6.15 Lighting (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
6.16 Rasterization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 356
6.17 Rasterization (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . 357
6.18 Multisampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 358
6.19 Textures (state per texture unit and binding point) . . . . . . . . . 359
6.20 Textures (state per texture object) . . . . . . . . . . . . . . . . . . 360
6.21 Textures (state per texture image) . . . . . . . . . . . . . . . . . . 361
6.22 Texture Environment and Generation . . . . . . . . . . . . . . . . 362
6.23 Texture Environment and Generation (cont.) . . . . . . . . . . . . 363
6.24 Pixel Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 364
6.25 Pixel Operations (cont.) . . . . . . . . . . . . . . . . . . . . . . . 365
6.26 Framebuffer Control . . . . . . . . . . . . . . . . . . . . . . . . 366
6.27 Framebuffer (state per target binding point) . . . . . . . . . . . . 367
6.28 Framebuffer (state per framebuffer object) . . . . . . . . . . . . . 368
6.29 Framebuffer (state per attachment point) . . . . . . . . . . . . . . 369
6.30 Renderbuffer (state per target and binding point) . . . . . . . . . . 370
6.31 Renderbuffer (state per renderbuffer object) . . . . . . . . . . . . 371
6.32 Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
6.33 Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
6.34 Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374
6.35 Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
6.36 Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376
6.37 Pixels (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377
6.38 Evaluators (GetMap takes a map name) . . . . . . . . . . . . . . 378
6.39 Shader Object State . . . . . . . . . . . . . . . . . . . . . . . . . 379
6.40 Program Object State . . . . . . . . . . . . . . . . . . . . . . . . 380
6.41 Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 381
6.42 Vertex Shader State . . . . . . . . . . . . . . . . . . . . . . . . . 382
6.43 Query Object State . . . . . . . . . . . . . . . . . . . . . . . . . 383
Version 3.0 (September 23, 2008)LISTOFTABLES xiv
6.44 Transform Feedback State . . . . . . . . . . . . . . . . . . . . . 384
6.45 Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
6.46 Implementation Dependent Values . . . . . . . . . . . . . . . . . 386
6.47 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 387
6.48 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 388
6.49 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 389
6.50 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 390
6.51 Framebuffer Dependent Values . . . . . . . . . . . . . . . . . . . 391
6.52 Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . 392
K.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 441
N.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 459
Version 3.0 (September 23, 2008)Chapter 1
Introduction
This document describes the OpenGL graphics system: what it is, how it acts, and
what is required to implement it. We assume that the reader has at least a rudi-
mentary understanding of computer graphics. This means familiarity with the es-
sentials of computer graphics algorithms as well as familiarity with basic graphics
hardware and associated terms.
1.1 Formatting of Optional Features
Starting with version 1.2 of OpenGL, some features in the speci?cation are consid-
ered optional; an OpenGL implementation may or may not choose to provide them
(see section 3.7.2).
Portions of the speci?cation which are optional are so described where the
optional features are ?rst de?ned (see section 3.7.2). State table entries which are
optional are typeset against a gray background .
1.2 What is the OpenGL Graphics System?
OpenGL (for “Open Graphics Library”) is a software interface to graphics hard-
ware. The interface consists of a set of several hundred procedures and functions
that allow a programmer to specify the objects and operations involved in produc-
ing high-quality graphical images, speci?cally color images of three-dimensional
objects.
Most of OpenGL requires that the graphics hardware contain a framebuffer.
Many OpenGL calls pertain to drawing objects such as points, lines, polygons, and
bitmaps, but the way that some of this drawing occurs (such as when antialiasing
11.3. PROGRAMMER’SVIEWOFOPENGL 2
or texturing is enabled) relies on the existence of a framebuffer. Further, some of
OpenGL is speci?cally concerned with framebuffer manipulation.
1.3 Programmer’s View of OpenGL
To the programmer, OpenGL is a set of commands that allow the speci?cation of
geometric objects in two or three dimensions, together with commands that control
how these objects are rendered into the framebuffer. For the most part, OpenGL
provides an immediate-mode interface, meaning that specifying an object causes it
to be drawn.
A typical program that uses OpenGL begins with calls to open a window into
the framebuffer into which the program will draw. Then, calls are made to allocate
a GL context and associate it with the window. Once a GL context is allocated,
the programmer is free to issue OpenGL commands. Some calls are used to draw
simple geometric objects (i.e. points, line segments, and polygons), while others
affect the rendering of these primitives including how they are lit or colored and
how they are mapped from the user’s two- or three-dimensional model space to
the two-dimensional screen. There are also calls to effect direct control of the
framebuffer, such as reading and writing pixels.
1.4 Implementor’s View of OpenGL
To the implementor, OpenGL is a set of commands that affect the operation of
graphics hardware. If the hardware consists only of an addressable framebuffer,
then OpenGL must be implemented almost entirely on the host CPU. More typi-
cally, the graphics hardware may comprise varying degrees of graphics accelera-
tion, from a raster subsystem capable of rendering two-dimensional lines and poly-
gons to sophisticated ?oating-point processors capable of transforming and com-
puting on geometric data. The OpenGL implementor’s task is to provide the CPU
software interface while dividing the work for each OpenGL command between
the CPU and the graphics hardware. This division must be tailored to the available
graphics hardware to obtain optimum performance in carrying out OpenGL calls.
OpenGL maintains a considerable amount of state information. This state con-
trols how objects are drawn into the framebuffer. Some of this state is directly
available to the user: he or she can make calls to obtain its value. Some of it, how-
ever, is visible only by the effect it has on what is drawn. One of the main goals of
this speci?cation is to make OpenGL state information explicit, to elucidate how it
changes, and to indicate what its effects are.
Version 3.0 (September 23, 2008)1.5. OURVIEW 3
1.5 Our View
We view OpenGL as a pipeline having some programmable stages and some state-
driven stages that control a set of speci?c drawing operations. This model should
engender a speci?cation that satis?es the needs of both programmers and imple-
mentors. It does not, however, necessarily provide a model for implementation. An
implementation must produce results conforming to those produced by the speci-
?ed methods, but there may be ways to carry out a particular computation that are
more ef?cient than the one speci?ed.
1.6 The Deprecation Model
GL features marked as deprecated in one version of the speci?cation are expected
to be removed in a future version, allowing applications time to transition away
from use of deprecated features. The deprecation model is described in more detail,
together with a summary of the commands and state deprecated from this version
of the API, in appendix E.
1.7 Companion Documents
1.7.1 OpenGL Shading Language
This speci?cation should be read together with a companion document titled The
OpenGL Shading Language. The latter document (referred to as the OpenGL Shad-
ing Language Specification hereafter) de?nes the syntax and semantics of the pro-
gramming language used to write vertex and fragment shaders (see sections 2.20
and 3.12). These sections may include references to concepts and terms (such as
shading language variable types) de?ned in the companion document.
OpenGL 3.0 implementations are guaranteed to support at least versions 1.10,
1.20, and 1.30 of the shading language, although versions 1.10 and 1.20 are dep-
recated in a forward-compatible context. The actual version supported may be
queried as described in section 6.1.11.
1.7.2 Window System Bindings
OpenGL requires a companion API to create and manage graphics contexts, win-
dows to render into, and other resources beyond the scope of this Specification.
There are several such APIs supporting different operating and window systems.
OpenGL Graphics with the X Window System, also called the “GLX Speci?ca-
tion”, describes the GLX API for use of OpenGL in the X Window System. It is
Version 3.0 (September 23, 2008)1.7. COMPANIONDOCUMENTS 4
primarily directed at Linux and Unix systems, but GLX implementations also exist
for Microsoft Windows, MacOS X, and some other platforms where X is avail-
able. The GLX Specification is available in the OpenGL Extension Registry (see
appendix O).
The WGL API supports use of OpenGL with Microsoft Windows. WGL is
documented in Microsoft’s MSDN system, although no full speci?cation exists.
Several APIs exist supporting use of OpenGL with Quartz, the MacOS X win-
dow system, including CGL, AGL, and NSGLView. These APIs are documented
on Apple’s developer website.
The Khronos Native Platform Graphics Interface or “EGL Specification” de-
scribes the EGL API for use of OpenGL ES on mobile and embedded devices.
EGL implementations may be available supporting OpenGL as well. The EGL
Specification is available in the Khronos Extension Registry at URL
http://www.khronos.org/registry/egl
Version 3.0 (September 23, 2008)Chapter 2
OpenGL Operation
2.1 OpenGL Fundamentals
OpenGL (henceforth, the “GL”) is concerned only with rendering into a frame-
buffer (and reading values stored in that framebuffer). There is no support for
other peripherals sometimes associated with graphics hardware, such as mice and
keyboards. Programmers must rely on other mechanisms to obtain user input.
The GL draws primitives subject to a number of selectable modes and shader
programs. Each primitive is a point, line segment, polygon, or pixel rectangle.
Each mode may be changed independently; the setting of one does not affect the
settings of others (although many modes may interact to determine what eventually
ends up in the framebuffer). Modes are set, primitives speci?ed, and other GL
operations described by sending commands in the form of function or procedure
calls.
Primitives are de?ned by a group of one or more vertices. A vertex de?nes a
point, an endpoint of an edge, or a corner of a polygon where two edges meet. Data
(consisting of positional coordinates, colors, normals, and texture coordinates) are
associated with a vertex and each vertex is processed independently, in order, and
in the same way. The only exception to this rule is if the group of vertices must
be clipped so that the indicated primitive ?ts within a speci?ed region; in this
case vertex data may be modi?ed and new vertices created. The type of clipping
depends on which primitive the group of vertices represents.
Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all
52.1. OPENGLFUNDAMENTALS 6
previously invoked GL commands, except where explicitly speci?ed otherwise. In
general, the effects of a GL command on either GL modes or the framebuffer must
be complete before any subsequent command can have any such effects.
In the GL, data binding occurs on call. This means that data passed to a com-
mand are interpreted when that command is received. Even if the command re-
quires a pointer to data, those data are interpreted when the call is made, and any
subsequent changes to the data have no effect on the GL (unless the same pointer
is used in a subsequent command).
The GL provides direct control over the fundamental operations of 3D and
2D graphics. This includes speci?cation of such parameters as vertex and frag-
ment shaders, transformation matrices, lighting equation coef?cients, antialiasing
methods, and pixel update operators. It does not provide a means for describing
or modeling complex geometric objects. Another way to describe this situation is
to say that the GL provides mechanisms to describe how complex geometric ob-
jects are to be rendered rather than mechanisms to describe the complex objects
themselves.
The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer as the client. In this sense, the GL is “network-transparent.” A server
may maintain a number of GL contexts, each of which is an encapsulation of cur-
rent GL state. A client may choose to connect to any one of these contexts. Issuing
GL commands when the program is not connected to a context results in unde?ned
behavior.
The GL interacts with two classes of framebuffers: window system-provided
and application-created. There is at most one window system-provided frame-
buffer at any time, referred to as the default framebuffer. Application-created
framebuffers, referred to as framebuffer objects, may be created as desired. These
two types of framebuffer are distinguished primarily by the interface for con?gur-
ing and managing their state.
The effects of GL commands on the default framebuffer are ultimately con-
trolled by the window system, which allocates framebuffer resources, determines
which portions of the default framebuffer the GL may access at any given time, and
communicates to the GL how those portions are structured. Therefore, there are
no GL commands to initialize a GL context or con?gure the default framebuffer.
Similarly, display of framebuffer contents on a physical display device (including
the transformation of individual framebuffer values by such techniques as gamma
correction) is not addressed by the GL.
Allocation and con?guration of the default framebuffer occurs outside of the
GL in conjunction with the window system, using companion APIs such as GLX,
Version 3.0 (September 23, 2008)2.1. OPENGLFUNDAMENTALS 7
WGL, and CGL for GL implementations running on the X Window System, Mi-
crosoft Windows, and MacOS X respectively.
Allocation and initialization of GL contexts is also done using these companion
APIs. GL contexts can typically be associated with different default framebuffers,
and some context state is determined at the time this association is performed.
It is possible to use a GL context without a default framebuffer, in which case
a framebuffer object must be used to perform all rendering. This is useful for
applications neeting to perform offscreen rendering.
The GL is designed to be run on a range of graphics platforms with varying
graphics capabilities and performance. To accommodate this variety, we specify
ideal behavior instead of actual behavior for certain GL operations. In cases where
deviation from the ideal is allowed, we also specify the rules that an implemen-
tation must obey if it is to approximate the ideal behavior usefully. This allowed
variation in GL behavior implies that two distinct GL implementations may not
agree pixel for pixel when presented with the same input even when run on identi-
cal framebuffer con?gurations.
Finally, command names, constants, and types are pre?xed in the GL (by gl,
GL , andGL, respectively inC) to reduce name clashes with other packages. The
pre?xes are omitted in this document for clarity.
2.1.1 Floating-Point Computation
The GL must perform a number of ?oating-point operations during the course of
its operation. In some cases, the representation and/or precision of such oper-
ations is de?ned or limited; by the OpenGL Shading Language Specification for
operations in shaders, and in some cases implicitly limited by the speci?ed format
of vertex, texture, or renderbuffer data consumed by the GL. Otherwise, the rep-
resentation of such ?oating-point numbers, and the details of how operations on
them are performed, is not speci?ed. We require simply that numbers’ ?oating-
point parts contain enough bits and that their exponent ?elds are large enough so
that individual results of ?oating-point operations are accurate to about 1 part in
5
10 . The maximum representable magnitude of a ?oating-point number used to
32
represent positional, normal, or texture coordinates must be at least 2 ; the max-
10
imum representable magnitude for colors must be at least 2 . The maximum
32
representable magnitude for all other ?oating-point values must be at least 2 .
x 0 = 0x = 0 for any non-in?nite and non-NaN x. 1x = x 1 = x.
0
x + 0 = 0 +x =x. 0 = 1. (Occasionally further requirements will be speci?ed.)
Most single-precision ?oating-point formats meet these requirements.
The special values Inf and Inf encode values with magnitudes too large to
be represented; the special value NaN encodes “Not A Number” values resulting
Version 3.0 (September 23, 2008)2.1. OPENGLFUNDAMENTALS 8
1
from unde?ned arithmetic operations such as . Implementations are permitted,
0
but not required, to support Inf s and NaN s in their ?oating-point computations.
Any representable ?oating-point value is legal as input to a GL command that
requires ?oating-point data. The result of providing a value that is not a ?oating-
point number to such a command is unspeci?ed, but must not lead to GL interrup-
tion or termination. In IEEE arithmetic, for example, providing a negative zero or a
denormalized number to a GL command yields predictable results, while providing
a NaN or an in?nity yields unspeci?ed results.
Some calculations require division. In such cases (including implied divisions
required by vector normalizations), a division by zero produces an unspeci?ed re-
sult but must not lead to GL interruption or termination.
2.1.2 16-Bit Floating-Point Numbers
A 16-bit ?oating-point number has a 1-bit sign (S), a 5-bit exponent (E), and a
10-bit mantissa (M). The valueV of a 16-bit ?oating-point number is determined
by the following:
8
S
>
( 1)  0:0; E = 0;M = 0
>
>
>
S
>  14 M
>( 1)  2  ; E = 0;M =6 0
10
<
2
  
S
E 15 M
V = ( 1)  2  1 + ; 0<E < 31
10
2
>
>
S
>
>( 1)  Inf; E = 31;M = 0
>
>
:
NaN; E = 31;M =6 0
If the ?oating-point number is interpreted as an unsigned 16-bit integerN, then
 
N mod 65536
S =
32768
 
N mod 32768
E =
1024
M =N mod 1024:
Any representable 16-bit ?oating-point value is legal as input to a GL command
that accepts 16-bit ?oating-point data. The result of providing a value that is not a
?oating-point number (such as Inf or NaN ) to such a command is unspeci?ed, but
must not lead to GL interruption or termination. Providing a denormalized number
or negative zero to GL must yield predictable results.
Version 3.0 (September 23, 2008)2.1. OPENGLFUNDAMENTALS 9
2.1.3 Unsigned 11-Bit Floating-Point Numbers
An unsigned 11-bit ?oating-point number has no sign bit, a 5-bit exponent (E), and
a 6-bit mantissa (M). The valueV of an unsigned 11-bit ?oating-point number is
determined by the following:
8
>0:0; E = 0;M = 0
>
>
>
 14 M
>
>2  ; E = 0;M =6 0
< 64
  
M
E 15
V =
2  1 + ; 0<E < 31
64
>
>
>
>Inf; E = 31;M = 0
>
>
:
NaN; E = 31;M =6 0
If the ?oating-point number is interpreted as an unsigned 11-bit integerN, then
 
N
E =
64
M =N mod 64:
When a ?oating-point value is converted to an unsigned 11-bit ?oating-point
representation, ?nite values are rounded to the closest representable ?nite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, ?nite posi-
tive values greater than 65024 (the maximum ?nite representable unsigned 11-bit
?oating-point value) are converted to 65024. Additionally: negative in?nity is con-
verted to zero; positive in?nity is converted to positive in?nity; and both positive
and negative NaN are converted to positive NaN .
Any representable unsigned 11-bit ?oating-point value is legal as input to a
GL command that accepts 11-bit ?oating-point data. The result of providing a
value that is not a ?oating-point number (such as Inf or NaN ) to such a command
is unspeci?ed, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.
2.1.4 Unsigned 10-Bit Floating-Point Numbers
An unsigned 10-bit ?oating-point number has no sign bit, a 5-bit exponent (E), and
a 5-bit mantissa (M). The valueV of an unsigned 10-bit ?oating-point number is
determined by the following:
Version 3.0 (September 23, 2008)2.2. GLSTATE 10
8
>
0:0; E = 0;M = 0
>
>
>
 14 M
>
>2  ; E = 0;M =6 0
<
32
  
E 15 M
V = 2  1 + ; 0<E < 31
32
>
>
>
Inf; E = 31;M = 0
>
>
>
:
NaN; E = 31;M6= 0
If the ?oating-point number is interpreted as an unsigned 10-bit integerN, then
 
N
E =
32
M =N mod 32:
When a ?oating-point value is converted to an unsigned 10-bit ?oating-point
representation, ?nite values are rounded to the closest representable ?nite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, ?nite posi-
tive values greater than 64512 (the maximum ?nite representable unsigned 10-bit
?oating-point value) are converted to 64512. Additionally: negative in?nity is con-
verted to zero; positive in?nity is converted to positive in?nity; and both positive
and negative NaN are converted to positive NaN .
Any representable unsigned 10-bit ?oating-point value is legal as input to a
GL command that accepts 10-bit ?oating-point data. The result of providing a
value that is not a ?oating-point number (such as Inf or NaN ) to such a command
is unspeci?ed, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.
2.2 GL State
The GL maintains considerable state. This document enumerates each state vari-
able and describes how each variable can be changed. For purposes of discussion,
state variables are categorized somewhat arbitrarily by their function. Although we
describe the operations that the GL performs on the framebuffer, the framebuffer
is not a part of GL state.
We distinguish two types of state. The ?rst type of state, called GL server
state, resides in the GL server. The majority of GL state falls into this category.
The second type of state, called GL client state, resides in the GL client. Unless
otherwise speci?ed, all state referred to in this document is GL server state; GL
client state is speci?cally identi?ed. Each instance of a GL context implies one
Version 3.0 (September 23, 2008)2.3. GLCOMMANDSYNTAX 11
complete set of GL server state; each connection from a client to a server implies
a set of both GL client state and GL server state.
While an implementation of the GL may be hardware dependent, this discus-
sion is independent of the speci?c hardware on which a GL is implemented. We are
therefore concerned with the state of graphics hardware only when it corresponds
precisely to GL state.
2.2.1 Shared Object State
It is possible for groups of contexts to share certain state. Enabling such sharing
between contexts is done through window system binding APIs such as those de-
scribed in section 1.7.2. These APIs are responsible for creation and management
of contexts, and not discussed further here. More detailed discussion of the behav-
ior of shared objects is included in appendix D. Except as de?ned in this appendix,
all state in a context is speci?c to that context only.
2.3 GL Command Syntax
GL commands are functions or procedures. Various groups of commands perform
the same operation but differ in how arguments are supplied to them. To conve-
niently accommodate this variation, we adopt a notation for describing commands
and their arguments.
GL commands are formed from a name followed, depending on the particular
command, by up to 4 characters. The ?rst character indicates the number of values
of the indicated type that must be presented to the command. The second character
or character pair indicates the speci?c type of the arguments: 8-bit integer, 16-bit
integer, 32-bit integer, single-precision ?oating-point, or double-precision ?oating-
point. The ?nal character, if present, is v, indicating that the command takes a
pointer to an array (a vector) of values rather than a series of individual arguments.
Two speci?c examples come from the Vertex command:
void Vertex3f(float x,float y,float z );
and
void Vertex2sv(short v[2] );
These examples show the ANSIC declarations for these commands. In general,
1
a command declaration has the form
1
The declarations shown in this document apply to ANSI C. Languages such as C++ and Ada
that allow passing of argument type information admit simpler declarations and fewer entry points.
Version 3.0 (September 23, 2008)2.3. GLCOMMANDSYNTAX 12
Letter CorrespondingGL Type
b byte
s short
i int
f float
d double
ub ubyte
us ushort
ui uint
Table 2.1: Correspondence of command suf?x letters to GL argument types. Refer
to table 2.2 for de?nitions of the GL types.
rtype Namef1234gf b s i f d ub us uigfvg
( [args ,] T arg1 ,::: , T argN [, args] );
rtype is the return type of the function. The braces (fg) enclose a series of char-
acters (or character pairs) of which one is selected.  indicates no character. The
arguments enclosed in brackets ([args ,] and [, args]) may or may not be present.
TheN arguments arg1 through argN have type T, which corresponds to one of the
type letters or letter pairs as indicated in table 2.1 (if there are no letters, then the
arguments’ type is given explicitly). If the ?nal character is not v, thenN is given
by the digit 1, 2, 3, or 4 (if there is no digit, then the number of arguments is ?xed).
If the ?nal character is v, then only arg1 is present and it is an array ofN values
of the indicated type. Finally, we indicate anunsigned type by the shorthand of
prepending au to the beginning of the type name (so that, for instance,unsigned
char is abbreviateduchar).
For example,
void Normal3ffdg(T arg );
indicates the two declarations
void Normal3f(float arg1,float arg2,float arg3 );
void Normal3d(double arg1,double arg2,double arg3 );
while
void Normal3ffdgv(T arg );
Version 3.0 (September 23, 2008)2.4. BASICGLOPERATION 13
means the two declarations
void Normal3fv(float arg[3] );
void Normal3dv(double arg[3] );
Arguments whose type is ?xed (i.e. not indicated by a suf?x on the command)
are of one of the GL data types summarized in table 2.2, or pointers to one of these
types.
2.4 Basic GL Operation
Figure 2.1 shows a schematic diagram of the GL. Commands enter the GL on the
left. Some commands specify geometric objects to be drawn while others control
how the objects are handled by the various stages. Most commands may be ac-
cumulated in a display list for processing by the GL at a later time. Otherwise,
commands are effectively sent through a processing pipeline.
The ?rst stage provides an ef?cient means for approximating curve and sur-
face geometry by evaluating polynomial functions of input values. The next stage
operates on geometric primitives described by vertices: points, line segments, and
polygons. In this stage vertices are transformed and lit, and primitives are clipped
to a viewing volume in preparation for the next stage, rasterization. The rasterizer
produces a series of framebuffer addresses and values using a two-dimensional de-
scription of a point, line segment, or polygon. Each fragment so produced is fed
to the next stage that performs operations on individual fragments before they ?-
nally alter the framebuffer. These operations include conditional updates into the
framebuffer based on incoming and previously stored depth values (to effect depth
buffering), blending of incoming fragment colors with stored colors, as well as
masking and other logical operations on fragment values.
Finally, there is a way to bypass the vertex processing portion of the pipeline to
send a block of fragments directly to the individual fragment operations, eventually
causing a block of pixels to be written to the framebuffer; values may also be read
back from the framebuffer or copied from one portion of the framebuffer to another.
These transfers may include some type of decoding or encoding.
This ordering is meant only as a tool for describing the GL, not as a strict rule
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL. Objects such as curved surfaces, for instance, may
be transformed before they are converted to polygons.
Version 3.0 (September 23, 2008)2.4. BASICGLOPERATION 14
GL Type Minimum Description
Bit Width
boolean 1 Boolean
byte 8 Signed 2’s complement binary integer
ubyte 8 Unsigned binary integer
char 8 Characters making up strings
short 16 Signed 2’s complement binary integer
ushort 16 Unsigned binary integer
int 32 Signed 2’s complement binary integer
uint 32 Unsigned binary integer
sizei 32 Non-negative binary integer size
enum 32 Enumerated binary integer value
intptr ptrbits Signed 2’s complement binary integer
sizeiptr ptrbits Non-negative binary integer size
bitfield 32 Bit ?eld
half 16 Half-precision ?oating-point value
encoded in an unsigned scalar
float 32 Floating-point value
clampf 32 Floating-point value clamped to [0; 1]
double 64 Floating-point value
clampd 64 Floating-point value clamped to [0; 1]
time 64 Unsigned binary representing an ab-
solute absolute or relative time inter-
val. Precision is nanoseconds but ac-
curacy is implementation-dependent.
Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to the C type int. An implementation may use more bits than the
number indicated in the table to represent a GL type. Correct interpretation of
integer values outside the minimum range is not required, however.
ptrbits is the number of bits required to represent a pointer type; in other words,
typesintptr andsizeiptr must be suf?ciently large as to store any address.
Version 3.0 (September 23, 2008)2.5. GLERRORS 15
Display
  List
Per?Vertex
Per?
Operations
Rasteriz?
Evaluator Fragment Framebuffer
Primitive ation
Operations
Assembly
Texture
Memory
Pixel
Operations
Figure 2.1. Block diagram of the GL.
2.5 GL Errors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
mance of an error-free program.
The command
enum GetError(void );
is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a ?ag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
the code is returned and the ?ag is cleared, so that a further error will again record
its code. If a call to GetError returnsNO ERROR, then there has been no detectable
error since the last call to GetError (or since the GL was initialized).
To allow for distributed implementations, there may be several ?ag-code pairs.
In this case, after a call to GetError returns a value other than NO ERROR each
subsequent call returns the non-zero code of a distinct ?ag-code pair (in unspeci?ed
order), until all non-NO ERROR codes have been returned. When there are no more
non-NO ERROR error codes, all ?ags are reset. This scheme requires some positive
number of pairs of a ?ag bit and an integer. The initial state of all ?ags is cleared
and the initial value of all codes isNO ERROR.
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 16
Table 2.3 summarizes GL errors. Currently, when an error ?ag is set, results of
GL operation are unde?ned only if OUT OF MEMORY has occurred. In other cases,
the command generating the error is ignored so that it has no effect on GL state or
framebuffer contents. If the generating command returns a value, it returns zero. If
the generating command modi?es values through a pointer argument, no change is
made to these values. These error semantics apply only to GL errors, not to system
errors such as memory access errors. This behavior is the current behavior; the
action of the GL in the presence of errors is subject to change.
Several error generation conditions are implicit in the description of every GL
command:
 If a command that requires an enumerated value is passed a symbolic con-
stant that is not one of those speci?ed as allowable for that command, the
error INVALID ENUM is generated. This is the case even if the argument is
a pointer to a symbolic constant, if the value pointed to is not allowable for
the given command.
 If a negative number is provided where an argument of type sizei or
sizeiptr is speci?ed, the errorINVALID VALUE is generated.
 If memory is exhausted as a side effect of the execution of a command, the
errorOUT OF MEMORY may be generated.
Otherwise, errors are generated only for conditions that are explicitly described in
this speci?cation.
2.6 Begin/End Paradigm
In the GL, most geometric objects are drawn by enclosing a series of coordinate
sets that specify vertices and optionally normals, texture coordinates, and colors
between Begin/End pairs. There are ten geometric objects that are drawn this
way: points, line segments, line segment loops, separated line segments, polygons,
triangle strips, triangle fans, separated triangles, quadrilateral strips, and separated
quadrilaterals.
Each vertex is speci?ed with two, three, or four coordinates. In addition, a
current normal, multiple current texture coordinate sets, multiple current generic
vertex attributes, current color, current secondary color, and current fog coor-
dinate may be used in processing each vertex. Normals are used by the GL in
lighting calculations; the current normal is a three-dimensional vector that may be
set by sending three coordinates that specify it. Texture coordinates determine how
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 17
Error Description Offending com-
mand ignored?
INVALID ENUM enum argument out of range Yes
INVALID VALUE Numeric argument out of range Yes
INVALID OPERATION Operation illegal in current state Yes
INVALID FRAMEBUFFER OPERATION Framebuffer object is not com- Yes
plete
STACK OVERFLOW Command would cause a stack Yes
over?ow
STACK UNDERFLOW Command would cause a stack Yes
under?ow
OUT OF MEMORY Not enough memory left to exe- Unknown
cute command
TABLE TOO LARGE The speci?ed table is too large Yes
Table 2.3: Summary of GL errors
a texture image is mapped onto a primitive. Multiple sets of texture coordinates
may be used to specify how multiple texture images are mapped onto a primitive.
The number of texture units supported is implementation dependent but must be
at least two. The number of texture units supported can be queried with the state
MAX TEXTURE UNITS. Generic vertex attributes can be accessed from within ver-
tex shaders (section 2.20) and used to compute values for consumption by later
processing stages.
Primary and secondary colors are associated with each vertex (see sec-
tion 3.10). These associated colors are either based on the current color and current
secondary color or produced by lighting, depending on whether or not lighting is
enabled. Texture and fog coordinates are similarly associated with each vertex.
Multiple sets of texture coordinates may be associated with a vertex. Figure 2.2
summarizes the association of auxiliary data with a transformed vertex to produce
a processed vertex.
The current values are part of GL state. Vertices and normals are transformed,
colors may be affected or replaced by lighting, and texture coordinates are trans-
formed and possibly affected by a texture coordinate generation function. The
processing indicated for each current value is applied for each vertex that is sent to
the GL.
The methods by which vertices, normals, texture coordinates, fog coordinate,
generic attributes, and colors are sent to the GL, as well as how normals are trans-
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 18
Vertex
Coordinates In
vertex / normal
Transformed
transformation
Coordinates
Current
Normal
Processed
Vertex
Out
Current
lighting
Associated
Colors & 
Data
Materials
(Colors, Edge Flag,
Fog and Texture
Coordinates)
Current
Edge Flag & 
Fog Coord
Current
texture
Texture texgen
matrix 0
Coord Set 0
Current
texture
Texture texgen
matrix 1
Coord Set 1
Current
texture
Texture texgen
matrix 2
Coord Set 2
Current
texture
Texture texgen
matrix 3
Coord Set 3
Figure 2.2. Association of current values with a vertex. The heavy lined boxes rep-
resent GL state. Four texture units are shown; however, multitexturing may support
a different number of units depending on the implementation.
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 19
Point culling;
Line Segment
Point,
 or Polygon
Coordinates
Line Segment, or
Clipping
Processed
Polygon Rasterization
Vertices
Associated
(Primitive)
Data
Color
Assembly
Processing
Begin/End
State
Figure 2.3. Primitive assembly and processing.
formed and how vertices are mapped to the two-dimensional screen, are discussed
later.
Before colors have been assigned to a vertex, the state required by a vertex
is the vertex’s coordinates, the current normal, the current edge ?ag (see sec-
tion 2.6.2), the current material properties (see section 2.19.2), the current fog co-
ordinate, the multiple generic vertex attribute sets, and the multiple current texture
coordinate sets. Because color assignment is done vertex-by-vertex, a processed
vertex comprises the vertex’s coordinates, its edge ?ag, its fog coordinate, its as-
signed colors, and its multiple texture coordinate sets.
Figure 2.3 shows the sequence of operations that builds a primitive (point, line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it
is clipped to a viewing volume. This may alter the primitive by altering vertex
coordinates, texture coordinates, and colors. In the case of line and polygon prim-
itives, clipping may insert new vertices into the primitive. The vertices de?ning a
primitive to be rasterized have texture coordinates and colors associated with them.
2.6.1 Begin and End
Vertices making up one of the supported geometric object types are speci?ed by
enclosing commands de?ning those vertices between the two commands
void Begin(enum mode );
void End(void );
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 20
There is no limit on the number of vertices that may be speci?ed between a Begin
and an End.
Points. A series of individual points may be speci?ed by calling Begin with an
argument value ofPOINTS. No special state need be kept between Begin and End
in this case, since each point is independent of previous and following points.
Line Strips. A series of one or more connected line segments is speci?ed by
enclosing a series of two or more endpoints within a Begin/End pair when Begin is
called with LINE STRIP. In this case, the ?rst vertex speci?es the ?rst segment’s
start point while the second vertex speci?es the ?rst segment’s endpoint and the
second segment’s start point. In general, the ith vertex (for i > 1) speci?es the
beginning of theith segment and the end of thei  1st. The last vertex speci?es
the end of the last segment. If only one vertex is speci?ed between the Begin/End
pair, then no primitive is generated.
The required state consists of the processed vertex produced from the last ver-
tex that was sent (so that a line segment can be generated from it to the current
vertex), and a boolean ?ag indicating if the current vertex is the ?rst vertex.
Line Loops. Line loops, speci?ed with the LINE LOOP argument value to
Begin, are the same as line strips except that a ?nal segment is added from the ?nal
speci?ed vertex to the ?rst vertex. The additional state consists of the processed
?rst vertex.
Separate Lines. Individual line segments, each speci?ed by a pair of vertices,
are generated by surrounding vertex pairs with Begin and End when the value
of the argument to Begin is LINES. In this case, the ?rst two vertices between a
Begin and End pair de?ne the ?rst segment, with subsequent pairs of vertices each
de?ning one more segment. If the number of speci?ed vertices is odd, then the last
one is ignored. The state required is the same as for lines but it is used differently: a
vertex holding the ?rst vertex of the current segment, and a boolean ?ag indicating
whether the current vertex is odd or even (a segment start or end).
Polygons. A polygon is described by specifying its boundary as a series of
line segments. When Begin is called with POLYGON, the bounding line segments
are speci?ed in the same way as line loops. Depending on the current state of the
GL, a polygon may be rendered in one of several ways such as outlining its border
or ?lling its interior. A polygon described with fewer than three vertices does not
generate a primitive.
Only convex polygons are guaranteed to be drawn correctly by the GL. If a
speci?ed polygon is nonconvex when projected onto the window, then the rendered
polygon need only lie within the convex hull of the projected vertices de?ning its
boundary.
The state required to support polygons consists of at least two processed ver-
tices (more than two are never required, although an implementation may use
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 21
4
2 2 2
3 6
4
4
5
5
1
1 3 5 1 3
(a) (b) (c)
Figure 2.4. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
numbers give the sequencing of the vertices between Begin and End. Note that in
(a) and (b) triangle edge ordering is determined by the ?rst triangle, while in (c) the
order of each triangle’s edges is independent of the other triangles.
more); this is because a convex polygon can be rasterized as its vertices arrive,
before all of them have been speci?ed. The order of the vertices is signi?cant in
lighting and polygon rasterization (see sections 2.19.1 and 3.6.1).
Triangle strips. A triangle strip is a series of triangles connected along shared
edges. A triangle strip is speci?ed by giving a series of de?ning vertices between
a Begin/End pair when Begin is called with TRIANGLE STRIP. In this case, the
?rst three vertices de?ne the ?rst triangle (and their order is signi?cant, just as for
polygons). Each subsequent vertex de?nes a new triangle using that point along
with two vertices from the previous triangle. A Begin/End pair enclosing fewer
than three vertices, whenTRIANGLE STRIP has been supplied to Begin, produces
no primitive. See ?gure 2.4.
The state required to support triangle strips consists of a ?ag indicating if the
?rst triangle has been completed, two stored processed vertices, (called vertex A
and vertex B), and a one bit pointer indicating which stored vertex will be replaced
with the next vertex. After a Begin(TRIANGLE STRIP), the pointer is initialized
to point to vertex A. Each vertex sent between a Begin/End pair toggles the pointer.
Therefore, the ?rst vertex is stored as vertex A, the second stored as vertex B, the
third stored as vertex A, and so on. Any vertex after the second one sent forms a
triangle from vertex A, vertex B, and the current vertex (in that order).
Triangle fans. A triangle fan is the same as a triangle strip with one exception:
each vertex after the ?rst always replaces vertex B of the two stored vertices. The
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 22
2 4 6 2 3 6 7
5 1 4 5 8
1 3
(a) (b)
Figure 2.5. (a) A quad strip. (b) Independent quads. The numbers give the sequenc-
ing of the vertices between Begin and End.
vertices of a triangle fan are enclosed between Begin and End when the value of
the argument to Begin isTRIANGLE FAN.
Separate Triangles. Separate triangles are speci?ed by placing vertices be-
tween Begin and End when the value of the argument to Begin isTRIANGLES. In
this case, The 3i + 1st, 3i + 2nd, and 3i + 3rd vertices (in that order) determine
a triangle for eachi = 0; 1;:::;n  1, where there are 3n +k vertices between
the Begin and End. k is either 0, 1, or 2; ifk is not zero, the ?nalk vertices are
ignored. For each triangle, vertex A is vertex 3i and vertex B is vertex 3i + 1.
Otherwise, separate triangles are the same as a triangle strip.
The rules given for polygons also apply to each triangle generated from a tri-
angle strip, triangle fan or from separate triangles.
Quadrilateral (quad) strips. Quad strips generate a series of edge-sharing
quadrilaterals from vertices appearing between Begin and End, when Begin is
called with QUAD STRIP. If the m vertices between the Begin and End are
v ;:::;v , where v is the jth speci?ed vertex, then quad i has vertices (in or-
1 m j
der)v ,v ,v , andv withi = 0;:::;bm=2c. The state required is thus
2i 2i+1 2i+3 2i+2
three processed vertices, to store the last two vertices of the previous quad along
with the third vertex (the ?rst new vertex) of the current quad, a ?ag to indicate
when the ?rst quad has been completed, and a one-bit counter to count members
of a vertex pair. See ?gure 2.5.
A quad strip with fewer than four vertices generates no primitive. If the number
of vertices speci?ed for a quadrilateral strip between Begin and End is odd, the
?nal vertex is ignored.
Version 3.0 (September 23, 2008)2.6. BEGIN/ENDPARADIGM 23
Separate Quadrilaterals Separate quads are just like quad strips except that
each group of four vertices, the 4j + 1st, the 4j + 2nd, the 4j + 3rd, and the
4j + 4th, generate a single quad, for j = 0; 1;:::;n  1. The total number of
vertices between Begin and End is 4n +k, where 0k 3; ifk is not zero, the
?nalk vertices are ignored. Separate quads are generated by calling Begin with
the argument valueQUADS.
The rules given for polygons also apply to each quad generated in a quad strip
or from separate quads.
The state required for Begin and End consists of an eleven-valued integer indi-
cating either one of the ten possible Begin/End modes, or that no Begin/End mode
is being processed.
Calling Begin will result in an INVALID FRAMEBUFFER OPERATION error if
the object bound to DRAW FRAMEBUFFER BINDING is not framebuffer complete
(see section 4.4.4).
2.6.2 Polygon Edges
Each edge of each primitive generated from a polygon, triangle strip, triangle fan,
separate triangle set, quadrilateral strip, or separate quadrilateral set, is ?agged as
either boundary or non-boundary. These classi?cations are used during polygon
rasterization; some modes affect the interpretation of polygon boundary edges (see
section 3.6.4). By default, all edges are boundary edges, but the ?agging of poly-
gons, separate triangles, or separate quadrilaterals may be altered by calling
void EdgeFlag(boolean ?ag );
void EdgeFlagv(boolean *?ag );
to change the value of a ?ag bit. If ?ag is zero, then the ?ag bit is set toFALSE; if
?ag is non-zero, then the ?ag bit is set toTRUE.
When Begin is supplied with one of the argument values POLYGON,
TRIANGLES, or QUADS, each vertex speci?ed within a Begin and End pair be-
gins an edge. If the edge ?ag bit isTRUE, then each speci?ed vertex begins an edge
that is ?agged as boundary. If the bit isFALSE, then induced edges are ?agged as
non-boundary.
The state required for edge ?agging consists of one current ?ag bit. Initially, the
bit isTRUE. In addition, each processed vertex of an assembled polygonal primitive
must be augmented with a bit indicating whether or not the edge beginning on that
vertex is boundary or non-boundary.
Version 3.0 (September 23, 2008)2.7. VERTEXSPECIFICATION 24
2.6.3 GL Commands within Begin/End
The only GL commands that are allowed within any Begin/End pairs are the com-
mands for specifying vertex coordinates, vertex colors, normal coordinates, texture
coordinates, generic vertex attributes, and fog coordinates (Vertex, Color, Sec-
ondaryColor, Index, Normal, TexCoord and MultiTexCoord, VertexAttrib,
FogCoord), the ArrayElement command (see section 2.8), the EvalCoord and
EvalPoint commands (see section 5.1), commands for specifying lighting mate-
rial parameters (Material commands; see section 2.19.2), display list invocation
commands (CallList and CallLists; see section 5.4), and the EdgeFlag command.
Executing any other GL command between the execution of Begin and the corre-
sponding execution of End results in the error INVALID OPERATION. Executing
Begin after Begin has already been executed but before an End is executed gen-
erates the INVALID OPERATION error, as does executing End without a previous
corresponding Begin.
Execution of the commands EnableClientState, DisableClientState, Push-
ClientAttrib, PopClientAttrib, ColorPointer, FogCoordPointer, EdgeFlag-
Pointer, IndexPointer, NormalPointer, TexCoordPointer, SecondaryCol-
orPointer, VertexPointer, VertexAttribPointer, ClientActiveTexture, Inter-
leavedArrays, and PixelStore is not allowed within any Begin/End pair, but an
error may or may not be generated if such execution occurs. If an error is not gen-
erated, GL operation is unde?ned. (These commands are described in sections 2.8,
3.7.1, and chapter 6.)
2.7 Vertex Specification
Vertices are speci?ed by giving their coordinates in two, three, or four dimensions.
This is done using one of several versions of the Vertex command:
void Vertexf234gfsifdg(T coords );
void Vertexf234gfsifdgv(T coords );
A call to any Vertex command speci?es four coordinates: x, y, z, and w. The
x coordinate is the ?rst coordinate, y is second, z is third, and w is fourth. A
call to Vertex2 sets thex andy coordinates; thez coordinate is implicitly set to
zero and thew coordinate to one. Vertex3 setsx,y, andz to the provided values
andw to one. Vertex4 sets all four coordinates, allowing the speci?cation of an
arbitrary point in projective three-space. Invoking a Vertex command outside of a
Begin/End pair results in unde?ned behavior.
Version 3.0 (September 23, 2008)2.7. VERTEXSPECIFICATION 25
Current values are used in associating auxiliary data with a vertex as described
in section 2.6. A current value may be changed at any time by issuing an appropri-
ate command. The commands
void TexCoordf1234gfsifdg(T coords );
void TexCoordf1234gfsifdgv(T coords );
specify the current homogeneous texture coordinates, named s, t, r, and q. The
TexCoord1 family of commands set thes coordinate to the provided single argu-
ment while settingt andr to 0 andq to 1. Similarly, TexCoord2 setss andt to the
speci?ed values,r to 0 andq to 1; TexCoord3 setss,t, andr, withq set to 1, and
TexCoord4 sets all four texture coordinates.
Implementations must support at least two sets of texture coordinates. The
commands
void MultiTexCoordf1234gfsifdg(enum texture,T coords)
void MultiTexCoordf1234gfsifdgv(enum texture,T
coords)
take the coordinate set to be modi?ed as the texture parameter. texture is a symbolic
constant of the form TEXTUREi, indicating that texture coordinate set i is to be
modi?ed. The constants obey TEXTUREi = TEXTURE0 +i (i is in the range 0 to
k  1, wherek is the implementation-dependent number of texture coordinate sets
de?ned byMAX TEXTURE COORDS).
The TexCoord commands are exactly equivalent to the corresponding Multi-
TexCoord commands with texture set toTEXTURE0.
Gets of CURRENT TEXTURE COORDS return the texture coordinate set de?ned
by the value ofACTIVE TEXTURE.
Specifying an invalid texture coordinate set for the texture argument of Multi-
TexCoord results in unde?ned behavior.
The current normal is set using
void Normal3fbsifdg(T coords );
void Normal3fbsifdgv(T coords );
Byte, short, or integer values passed to Normal are converted to ?oating-point
values as indicated for the corresponding (signed) type in table 2.10.
The current fog coordinate is set using
void FogCoordffdg(T coord );
void FogCoordffdgv(T coord );
Version 3.0 (September 23, 2008)2.7. VERTEXSPECIFICATION 26
There are several ways to set the current color and secondary color. The GL
stores a current single-valued color index, as well as a current four-valued RGBA
color and secondary color. Either the index or the color and secondary color are
signi?cant depending as the GL is in color index mode or RGBA mode. The mode
selection is made when the GL is initialized.
The commands to set RGBA colors are
void Colorf34gfbsifd ubusuig(T components );
void Colorf34gfbsifd ubusuigv(T components );
void SecondaryColor3fbsifd ubusuig(T components );
void SecondaryColor3fbsifd ubusuigv(T components );
The Color command has two major variants: Color3 and Color4. The four value
versions set all four values. The three value versions set R, G, and B to the provided
values; A is set to 1.0. (The conversion of integer color components (R, G, B, and
A) to ?oating-point values is discussed in section 2.19.)
The secondary color has only the three value versions. Secondary A is always
set to 1.0.
Versions of the Color and SecondaryColor commands that take ?oating-point
values accept values nominally between 0.0 and 1.0. 0.0 corresponds to the min-
imum while 1.0 corresponds to the maximum (machine dependent) value that a
component may take on in the framebuffer (see section 2.19 on colors and color-
ing). Values outside [0; 1] are not clamped.
The command
void Indexfsifd ubg(T index );
void Indexfsifd ubgv(T index );
updates the current (single-valued) color index. It takes one argument, the value
to which the current color index should be set. Values outside the (machine-
dependent) representable range of color indices are not clamped.
Vertex shaders (see section 2.20) can be written to access an array of 4-
component generic vertex attributes in addition to the conventional attributes spec-
i?ed previously. The ?rst slot of this array is numbered 0, and the size of the array
is speci?ed by the implementation-dependent constantMAX VERTEX ATTRIBS.
To load values into a generic shader attribute declared as a ?oating-point scalar,
vector, or matrix, use the commands
void VertexAttribf1234gfsfdg(uint index,T values );
void VertexAttribf123gfsfdgv(uint index,T values );
void VertexAttrib4fbsifd ubusuigv(uint index,T values );
Version 3.0 (September 23, 2008)2.7. VERTEXSPECIFICATION 27
void VertexAttrib4Nub(uint index,T values );
void VertexAttrib4Nfbsi ubusuigv(uint index,T values );
The VertexAttrib4N* commands specify ?xed-point values that are converted
to a normalized [0; 1] or [ 1; 1] range as shown in table 2.10, while the other com-
mands specify values that are converted directly to the internal ?oating-point rep-
resentation.
The resulting value(s) are loaded into the generic attribute at slot index, whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
sets the x coordinate to the provided single argument while setting y and z to 0 and
w to 1. Similarly, VertexAttrib2* commands set x and y to the speci?ed values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4* commands set all four coordinates.
The VertexAttrib* entry points may also be used to load shader attributes de-
clared as a ?oating-point matrix. Each column of a matrix takes up one generic
4-component attribute slot out of the MAX VERTEX ATTRIBS available slots. Ma-
trices are loaded into these slots in column major order. Matrix columns are loaded
in increasing slot numbers.
The resulting attribute values are unde?ned if the base type of the shader at-
tribute at slot index is not ?oating-point (e.g. is signed or unsigned integer). To
load values into a generic shader attribute declared as a signed or unsigned scalar
or vector, use the commands
void VertexAttribIf1234gfi uig(uint index,T values );
void VertexAttribIf1234gfi uigv(uint index,T values );
void VertexAttribI4fbs ubusgv(uint index,T values );
These commands specify values that are extended to full signed or unsigned
integers, then loaded into the generic attribute at slot index in the same fashion as
described above.
The resulting attribute values are unde?ned if the base type of the shader at-
tribute at slot index is ?oating-point; if the base type is integer and unsigned in-
teger values are supplied (the VertexAttribI*ui, VertexAttribI*us, and Vertex-
AttribI*ub commands); or if the base type is unsigned integer and signed integer
values are supplied (the VertexAttribI*i, VertexAttribI*s, and VertexAttribI*b
commands)
The error INVALID VALUE is generated by VertexAttrib* if index is greater
than or equal toMAX VERTEX ATTRIBS.
Setting generic vertex attribute zero speci?es a vertex; the four vertex coordi-
nates are taken from the values of attribute zero. A Vertex2, Vertex3, or Vertex4
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 28
command is completely equivalent to the corresponding VertexAttrib* command
with an index of zero. Setting any other generic vertex attribute updates the current
values of the attribute. There are no current values for vertex attribute zero.
There is no aliasing among generic attributes and conventional attributes. In
other words, an application can set all MAX VERTEX ATTRIBS generic attributes
and all conventional attributes without fear of one particular attribute overwriting
the value of another attribute.
The state required to support vertex speci?cation consists of four ?oating-point
numbers per texture coordinate set to store the current texture coordinatess,t,r,
and q, three ?oating-point numbers to store the three coordinates of the current
normal, one ?oating-point number to store the current fog coordinate, four ?oating-
point values to store the current RGBA color, four ?oating-point values to store the
current RGBA secondary color, one ?oating-point value to store the current color
index, and MAX VERTEX ATTRIBS  1 four-component ?oating-point vectors to
store generic vertex attributes.
There is no notion of a current vertex, so no state is devoted to vertex coor-
dinates or generic attribute zero. The initial texture coordinates are (s;t;r;q) =
(0; 0; 0; 1) for each texture coordinate set. The initial current normal has coor-
dinates (0; 0; 1). The initial fog coordinate is zero. The initial RGBA color is
(R;G;B;A) = (1; 1; 1; 1) and the initial RGBA secondary color is (0; 0; 0; 1).
The initial color index is 1. The initial values for all generic vertex attributes are
(0; 0; 0; 1).
2.8 Vertex Arrays
The vertex speci?cation commands described in section 2.7 accept data in almost
any format, but their use requires many command executions to specify even sim-
ple geometry. Vertex data may also be placed into arrays that are stored in the
client’s address space. Blocks of data in these arrays may then be used to spec-
ify multiple geometric primitives through the execution of a single GL command.
The client may specify up to seven plus the values of MAX TEXTURE COORDS and
MAX VERTEX ATTRIBS arrays: one each to store vertex coordinates, normals, col-
ors, secondary colors, color indices, edge ?ags, fog coordinates, two or more tex-
ture coordinate sets, and one or more generic vertex attributes. The commands
void VertexPointer(int size,enum type,sizei stride,
void *pointer );
void NormalPointer(enum type,sizei stride,
void *pointer );
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 29
void ColorPointer(int size,enum type,sizei stride,
void *pointer );
void SecondaryColorPointer(int size,enum type,
sizei stride,void *pointer );
void IndexPointer(enum type,sizei stride,void *pointer );
void EdgeFlagPointer(sizei stride,void *pointer );
void FogCoordPointer(enum type,sizei stride,
void *pointer );
void TexCoordPointer(int size,enum type,sizei stride,
void *pointer );
void VertexAttribPointer(uint index,int size,enum type,
boolean normalized,sizei stride,const
void *pointer );
void VertexAttribIPointer(uint index,int size,enum type,
sizei stride,const void *pointer );
describe the locations and organizations of these arrays. For each command, type
speci?es the data type of the values stored in the array. Because edge ?ags are al-
ways typeboolean, EdgeFlagPointer has no type argument. size, when present,
indicates the number of values per vertex that are stored in the array. Because
normals are always speci?ed with three values, NormalPointer has no size argu-
ment. Likewise, because color indices and edge ?ags are always speci?ed with
a single value, IndexPointer and EdgeFlagPointer also have no size argument.
Table 2.4 indicates the allowable values for size and type (when present). For type
the values BYTE, SHORT, INT, FLOAT, HALF FLOAT, and DOUBLE indicate types
byte, short, int, float, half, and double, respectively; and the values
UNSIGNED BYTE, UNSIGNED SHORT, and UNSIGNED INT indicate typesubyte,
ushort, anduint, respectively. The error INVALID VALUE is generated if size
is speci?ed with a value other than that indicated in the table.
The index parameter in the VertexAttribPointer and VertexAttribI-
Pointer commands identify the generic vertex attribute array being described.
The error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS. Generic attribute arrays with integer type arguments can
be handled in one of three ways: converted to ?oat by normalizing to [0; 1] or
[ 1; 1] as speci?ed in table 2.10, converted directly to ?oat, or left as integers.
Data for an array speci?ed by VertexAttribPointer will be converted to ?oating-
point by normalizing if normalized isTRUE, and converted directly to ?oating-point
otherwise. Data for an array speci?ed by VertexAttribIPointer will always be left
as integer values; such data are referred to as pure integers.
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 30
Integer
Command Sizes Handling Types
VertexPointer 2,3,4 cast short, int, float, half,
double
NormalPointer 3 normalize byte, short, int, float,
half,double
ColorPointer 3,4 normalize byte, ubyte, short,
ushort, int, uint, float,
half,double
SecondaryColorPointer 3 normalize byte, ubyte, short,
ushort, int, uint, float,
half,double
IndexPointer 1 cast ubyte, short, int, float,
double
FogCoordPointer 1 n/a float,half,double
TexCoordPointer 1,2,3,4 cast short, int, float, half,
double
EdgeFlagPointer 1 integer boolean
VertexAttribPointer 1,2,3,4 ?ag byte, ubyte, short,
ushort, int, uint, float,
half,double
VertexAttribIPointer 1,2,3,4 integer byte, ubyte, short,
ushort,int,uint
Table 2.4: Vertex array sizes (values per vertex) and data types. The “Integer Han-
dling” column indicates how ?xed-point data types are handled: “cast” means that
they converted to ?oating-point directly, “normalize” means that they are converted
to ?oating-point by normalizing to [0; 1] (for unsigned types) or [ 1; 1] (for signed
types), “integer” means that they remain as integer values, and “?ag” means that
either “cast” or “normalized” applies, depending on the setting of the normalized
?ag in VertexAttribPointer.
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 31
The one, two, three, or four values in an array that correspond to a single vertex
comprise an array element. The values within each array element are stored se-
quentially in memory. If stride is speci?ed as zero, then array elements are stored
sequentially as well. The error INVALID VALUE is generated if stride is negative.
Otherwise pointers to the ith and (i + 1)st elements of an array differ by stride
basic machine units (typically unsigned bytes), the pointer to the (i + 1)st element
being greater. For each command, pointer speci?es the location in memory of the
?rst value of the ?rst element of the array being speci?ed.
An individual array is enabled or disabled by calling one of
void EnableClientState(enum array );
void DisableClientState(enum array );
with array set to VERTEX ARRAY, NORMAL ARRAY, COLOR ARRAY,
SECONDARY COLOR ARRAY, INDEX ARRAY, EDGE FLAG ARRAY,
FOG COORD ARRAY, or TEXTURE COORD ARRAY, for the vertex, normal, color,
secondary color, color index, edge ?ag, fog coordinate, or texture coordinate array,
respectively.
An individual generic vertex attribute array is enabled or disabled by calling
one of
void EnableVertexAttribArray(uint index );
void DisableVertexAttribArray(uint index );
where index identi?es the generic vertex attribute array to enable or disable.
The error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS.
The command
void ClientActiveTexture(enum texture );
is used to select the vertex array client state parameters to be modi?ed by
the TexCoordPointer command and the array affected by EnableClientState and
DisableClientState with parameter TEXTURE COORD ARRAY. This command sets
the client state variable CLIENT ACTIVE TEXTURE. Each texture coordinate set
has a client state vector which is selected when this command is invoked. This
state vector includes the vertex array state. This call also selects the texture coor-
dinate set state used for queries of client state.
Specifying an invalid texture generates the errorINVALID ENUM. Valid values
of texture are the same as for the MultiTexCoord commands described in sec-
tion 2.7.
The command
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 32
void ArrayElement(int i );
transfers the ith element of every enabled array to the GL. The effect of
ArrayElement(i) is the same as the effect of the command sequence
if (normal array enabled)
Normal3[type]v(normal array elementi);
if (color array enabled)
Color[size][type]v(color array elementi);
if (secondary color array enabled)
SecondaryColor3[type]v(secondary color array elementi);
if (fog coordinate array enabled)
FogCoord[type]v(fog coordinate array elementi);
for (j = 0; j < textureUnits; j++) f
if (texture coordinate setj array enabled)
MultiTexCoord[size][type]v(TEXTURE0 +j, texture coordinate setj array elementi);
g
if (color index array enabled)
Index[type]v(color index array elementi);
if (edge ?ag array enabled)
EdgeFlagv(edge ?ag array elementi);
for (j = 1; j < genericAttributes; j++) f
if (generic vertex attributej array enabled) f
if (generic vertex attributej array is a pure integer array)
VertexAttribI[size][type]v(j, generic vertex attributej array elementi);
else if (generic vertex attributej array normalization ?ag is set, and
type is notFLOAT orDOUBLE)
VertexAttrib[size]N[type]v(j, generic vertex attributej array elementi);
else
VertexAttrib[size][type]v(j, generic vertex attribute j array elementi);
g
g
if (generic vertex attribute array 0 enabled) f
if (generic vertex attribute 0 array is a pure integer array)
VertexAttribI[size][type]v(0, generic vertex attribute 0 array elementi);
else if (generic vertex attribute 0 array normalization ?ag is set, and
type is notFLOAT orDOUBLE)
VertexAttrib[size]N[type]v(0, generic vertex attribute 0 array elementi);
else
VertexAttrib[size][type]v(0, generic vertex attribute 0 array elementi);
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 33
g else if (vertex array enabled) f
Vertex[size][type]v(vertex array elementi);
g
where textureUnits and genericAttributes give the number of texture coordinate
sets and generic vertex attributes supported by the implementation, respectively.
”[size]” and ”[type]” correspond to the size and type of the corresponding array.
For generic vertex attributes, it is assumed that a complete set of vertex attribute
commands exists, even though not all such functions are provided by the GL.
Changes made to array data between the execution of Begin and the corre-
sponding execution of End may affect calls to ArrayElement that are made within
the same Begin/End period in non-sequential ways. That is, a call to ArrayEle-
ment that precedes a change to array data may access the changed data, and a call
that follows a change to array data may access original data.
Specifying i < 0 results in unde?ned behavior. Generating the error
INVALID VALUE is recommended in this case.
The command
void DrawArrays(enum mode,int ?rst,sizei count );
constructs a sequence of geometric primitives using elements first through
first +count  1 of each enabled array. mode speci?es what kind of primi-
tives are constructed; it accepts the same token values as themode parameter of
the Begin command. The effect of
DrawArrays(mode;first;count);
is the same as the effect of the command sequence
if (mode orcount is invalid)
generate appropriate error
else f
Begin(mode);
for (int i = 0; i < count; i++)
ArrayElement(first+i);
End();
g
with one exception: the current normal coordinates, color, secondary color, color
index, edge ?ag, fog coordinate, texture coordinates, and generic attributes are
each indeterminate after execution of DrawArrays, if the corresponding array is
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 34
enabled. Current values corresponding to disabled arrays are not modi?ed by the
execution of DrawArrays.
Specifying first < 0 results in unde?ned behavior. Generating the error
INVALID VALUE is recommended in this case.
The command
void MultiDrawArrays(enum mode,int *?rst,
sizei *count,sizei primcount );
behaves identically to DrawArrays except that primcount separate ranges of
elements are speci?ed instead. It has the same effect as:
for (i = 0; i < primcount; i++) f
if (count[i] > 0)
DrawArrays(mode, first[i], count[i]);
g
The command
void DrawElements(enum mode,sizei count,enum type,
void *indices );
constructs a sequence of geometric primitives using the count elements
whose indices are stored in indices. type must be one of UNSIGNED BYTE,
UNSIGNED SHORT, orUNSIGNED INT, indicating that the values in indices are in-
dices of GL type ubyte, ushort, or uint respectively. mode speci?es what
kind of primitives are constructed; it accepts the same token values as themode
parameter of the Begin command. The effect of
DrawElements(mode;count;type;indices);
is the same as the effect of the command sequence
if (mode;count; ortype is invalid)
generate appropriate error
else f
Begin(mode);
for (int i = 0; i < count; i++)
ArrayElement(indices[i]);
End();
g
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 35
with one exception: the current normal coordinates, color, secondary color, color
index, edge ?ag, fog coordinate, texture coordinates, and generic attributes are each
indeterminate after the execution of DrawElements, if the corresponding array is
enabled. Current values corresponding to disabled arrays are not modi?ed by the
execution of DrawElements.
The command
void MultiDrawElements(enum mode,sizei *count,
enum type,void **indices,sizei primcount );
behaves identically to DrawElements except that primcount separate lists of
elements are speci?ed instead. It has the same effect as:
for (i = 0; i < primcount; i++) f
if (count[i]) > 0)
DrawElements(mode, count[i], type, indices[i]);
g
The command
void DrawRangeElements(enum mode,uint start,
uint end,sizei count,enum type,void *indices );
is a restricted form of DrawElements. mode, count, type, and indices match the
corresponding arguments to DrawElements, with the additional constraint that all
values in the array indices must lie between start and end inclusive.
Implementations denote recommended maximum amounts of vertex and index
data, which may be queried by calling GetIntegerv with the symbolic constants
MAX ELEMENTS VERTICES and MAX ELEMENTS INDICES. Ifend start + 1 is
greater than the value of MAX ELEMENTS VERTICES, or if count is greater than
the value of MAX ELEMENTS INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start;end] be
referenced. However, the implementation may partially process unused vertices,
reducing performance from what could be achieved with an optimal index set.
The error INVALID VALUE is generated ifend < start. Invalid mode, count,
or type parameters generate the same errors as would the corresponding call to
DrawElements. It is an error for indices to lie outside the range [start;end], but
implementations may not check for this. Such indices will cause implementation-
dependent behavior.
The command
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 36
void InterleavedArrays(enum format,sizei stride,
void *pointer );
ef?ciently initializes the six arrays and their enables to one of 14 con-
?gurations. format must be one of 14 symbolic constants: V2F,
V3F, C4UB V2F, C4UB V3F, C3F V3F, N3F V3F, C4F N3F V3F, T2F V3F,
T4F V4F, T2F C4UB V3F, T2F C3F V3F, T2F N3F V3F, T2F C4F N3F V3F, or
T4F C4F N3F V4F.
The effect of
InterleavedArrays(format;stride;pointer);
is the same as the effect of the command sequence
if (format orstride is invalid)
generate appropriate error
else f
int str;
sete ;e ;e ;s ;s ;s ;t ;p ;p ;p ; ands as a function
t c n t c v c c n v
of table 2.5 and the value offormat.
str =stride;
if (str is zero)
str =s;
DisableClientState(EDGE FLAG ARRAY);
DisableClientState(INDEX ARRAY);
DisableClientState(SECONDARY COLOR ARRAY);
DisableClientState(FOG COORD ARRAY);
if (e ) f
t
EnableClientState(TEXTURE COORD ARRAY);
TexCoordPointer(s ,FLOAT,str,pointer);
t
g else
DisableClientState(TEXTURE COORD ARRAY);
if (e ) f
c
EnableClientState(COLOR ARRAY);
ColorPointer(s ,t ,str,pointer +p );
c c c
g else
DisableClientState(COLOR ARRAY);
if (e ) f
n
EnableClientState(NORMAL ARRAY);
NormalPointer(FLOAT,str,pointer +p );
n
g else
Version 3.0 (September 23, 2008)2.8. VERTEXARRAYS 37
format e e e s s s t
t c n t c v c
V2F False False False 2
V3F False False False 3
C4UB V2F False True False 4 2 UNSIGNED BYTE
C4UB V3F False True False 4 3 UNSIGNED BYTE
C3F V3F False True False 3 3 FLOAT
N3F V3F False False True 3
C4F N3F V3F False True True 4 3 FLOAT
T2F V3F True False False 2 3
T4F V4F True False False 4 4
T2F C4UB V3F True True False 2 4 3 UNSIGNED BYTE
T2F C3F V3F True True False 2 3 3 FLOAT
T2F N3F V3F True False True 2 3
T2F C4F N3F V3F True True True 2 4 3 FLOAT
T4F C4F N3F V4F True True True 4 4 4 FLOAT
format p p p s
c n v
V2F 0 2f
V3F 0 3f
C4UB V2F 0 c c + 2f
C4UB V3F 0 c c + 3f
C3F V3F 0 3f 6f
N3F V3F 0 3f 6f
C4F N3F V3F 0 4f 7f 10f
T2F V3F 2f 5f
T4F V4F 4f 8f
T2F C4UB V3F 2f c + 2f c + 5f
T2F C3F V3F 2f 5f 8f
T2F N3F V3F 2f 5f 8f
T2F C4F N3F V3F 2f 6f 9f 12f
T4F C4F N3F V4F 4f 8f 11f 15f
Table 2.5: Variables that direct the execution of InterleavedArrays. f is
sizeof(FLOAT). c is 4 times sizeof(UNSIGNED BYTE), rounded up to
the nearest multiple of f. All pointer arithmetic is performed in units of
sizeof(UNSIGNED BYTE).
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 38
DisableClientState(NORMAL ARRAY);
EnableClientState(VERTEX ARRAY);
VertexPointer(s ,FLOAT,str,pointer +p );
v v
g
If the number of supported texture units (the value ofMAX TEXTURE COORDS)
is m and the number of supported generic vertex attributes (the value of
MAX VERTEX ATTRIBS) is n, then the client state required to implement vertex
arrays consists of an integer for the client active texture unit selector, 7 +m +n
boolean values, 7 +m +n memory pointers, 7 +m +n integer stride values,
7 +m +n symbolic constants representing array types, 3 +m +n integers rep-
resenting values per element, n boolean values indicating normalization, and n
boolean values indicating whether the attribute values are pure integers.
In the initial state, the client active texture unit selector is TEXTURE0, the
boolean values are each false, the memory pointers are each NULL, the strides are
each zero, the array types are each FLOAT, the integers representing values per
element are each four, and the normalized and pure integer ?ags are each false.
2.9 Buffer Objects
The vertex data arrays described in section 2.8 are stored in client memory. It
is sometimes desirable to store frequently used client data, such as vertex array
and pixel data, in high-performance server memory. GL buffer objects provide a
mechanism that clients can use to allocate, initialize, and render from such memory.
The name space for buffer objects is the unsigned integers, with zero reserved
for the GL. A buffer object is created by binding an unused name to a buffer target.
The binding is effected by calling
void BindBuffer(enum target,uint buffer );
target must be one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. The ARRAY BUFFER target is
discussed in section 2.9.2. The ELEMENT ARRAY BUFFER target is discussed in
section 2.9.3. The PIXEL UNPACK BUFFER and PIXEL PACK BUFFER targets are
discussed later in sections 3.7, 4.3.2, and 6.1. If the buffer object named buffer has
not been previously bound or has been deleted since the last binding, the GL cre-
ates a new state vector, initialized with a zero-sized memory buffer and comprising
the state values listed in table 2.6.
BindBuffer may also be used to bind an existing buffer object. If the bind is
successful no change is made to the state of the newly bound buffer object, and any
previous binding to target is broken.
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 39
Name Type Initial Value Legal Values
BUFFER SIZE integer 0 any non-negative integer
BUFFER USAGE enum STATIC DRAW STREAM DRAW,STREAM READ,
STREAM COPY,STATIC DRAW,
STATIC READ,STATIC COPY,
DYNAMIC DRAW,DYNAMIC READ,
DYNAMIC COPY
BUFFER ACCESS enum READ WRITE READ ONLY,WRITE ONLY,
READ WRITE
BUFFER ACCESS FLAGS integer 0 See section 2.9.1
BUFFER MAPPED boolean FALSE TRUE,FALSE
BUFFER MAP POINTER void* NULL address
BUFFER MAP OFFSET integer 0 any non-negative integer
BUFFER MAP LENGTH integer 0 any non-negative integer
Table 2.6: Buffer object parameters and their values.
While a buffer object is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which a buffer object is
bound return state from the bound object.
Initially, each buffer object target is bound to zero. There is no buffer object
corresponding to the name zero, so client attempts to modify or query buffer object
state for a target bound to zero generate anINVALID OPERATION error.
Buffer objects are deleted by calling
void DeleteBuffers(sizei n,const uint *buffers );
buffers contains n names of buffer objects to be deleted. After a buffer object is
deleted it has no contents, and its name is again unused. Unused names in buffers
are silently ignored, as is the value zero.
The command
void GenBuffers(sizei n,uint *buffers );
returns n previously unused buffer object names in buffers. These names are
marked as used, for the purposes of GenBuffers only, but they acquire buffer state
only when they are ?rst bound, just as if they were unused.
While a buffer object is bound, any GL operations on that object affect any
other bindings of that object. If a buffer object is deleted while it is bound, all
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 40
bindings to that object in the current context (i.e. in the thread that called Delete-
Buffers) are reset to zero. Bindings to that buffer in other contexts and other
threads are not affected, but attempting to use a deleted buffer in another thread
produces unde?ned results, including but not limited to possible GL errors and
rendering corruption. Using a deleted buffer in another context or thread may not,
however, result in program termination.
The data store of a buffer object is created and initialized by calling
void BufferData(enum target,sizeiptr size,const
void *data,enum usage );
with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER, size set to the size of the data
store in basic machine units, and data pointing to the source data in client memory.
If data is non-null, then the source data is copied to the buffer object’s data store.
If data is null, then the contents of the buffer object’s data store are unde?ned.
usage is speci?ed as one of nine enumerated values, indicating the expected
application usage pattern of the data store. The values are:
STREAM DRAW The data store contents will be speci?ed once by the application,
and used at most a few times as the source for GL drawing and image speci-
?cation commands.
STREAM READ The data store contents will be speci?ed once by reading data from
the GL, and queried at most a few times by the application.
STREAM COPY The data store contents will be speci?ed once by reading data from
the GL, and used at most a few times as the source for GL drawing and image
speci?cation commands.
STATIC DRAW The data store contents will be speci?ed once by the application,
and used many times as the source for GL drawing and image speci?cation
commands.
STATIC READ The data store contents will be speci?ed once by reading data from
the GL, and queried many times by the application.
STATIC COPY The data store contents will be speci?ed once by reading data from
the GL, and used many times as the source for GL drawing and image spec-
i?cation commands.
DYNAMIC DRAW The data store contents will be respeci?ed repeatedly by the ap-
plication, and used many times as the source for GL drawing and image
speci?cation commands.
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 41
Name Value
BUFFER SIZE size
BUFFER USAGE usage
BUFFER ACCESS READ WRITE
BUFFER ACCESS FLAGS 0
BUFFER MAPPED FALSE
BUFFER MAP POINTER NULL
BUFFER MAP OFFSET 0
BUFFER MAP LENGTH 0
Table 2.7: Buffer object initial state.
DYNAMIC READ The data store contents will be respeci?ed repeatedly by reading
data from the GL, and queried many times by the application.
DYNAMIC COPY The data store contents will be respeci?ed repeatedly by reading
data from the GL, and used many times as the source for GL drawing and
image speci?cation commands.
usage is provided as a performance hint only. The speci?ed usage value does
not constrain the actual usage pattern of the data store.
BufferData deletes any existing data store, and sets the values of the buffer
object’s state variables as shown in table 2.7.
Clients must align data elements consistent with the requirements of the client
platform, with an additional base-level requirement that an offset within a buffer to
a datum comprisingN basic machine units be a multiple ofN.
If the GL is unable to create a data store of the requested size, the error
OUT OF MEMORY is generated.
To modify some or all of the data contained in a buffer object’s data store, the
client may use the command
void BufferSubData(enum target,intptr offset,
sizeiptr size,const void *data );
with target set to ARRAY BUFFER. offset and size indicate the range of data in the
buffer object that is to be replaced, in terms of basic machine units. data speci-
?es a region of client memory size basic machine units in length, containing the
data that replace the speci?ed buffer range. An INVALID VALUE error is gener-
ated if offset or size is less than zero, or if offset + size is greater than the value
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 42
of BUFFER SIZE. An INVALID OPERATION error is generated if any part of the
speci?ed buffer range is mapped with MapBufferRange or MapBuffer (see sec-
tion 2.9.1).
2.9.1 Mapping and Unmapping Buffer Data
All or part of the data store of a buffer object may be mapped into the client’s
address space by calling
void *MapBufferRange(enum target,intptr offset,
sizeiptr length,bitfield access );
with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. offset and length indi-
cate the range of data in the buffer object that is to be mapped, in terms of basic
machine units. access is a bit?eld containing ?ags which describe the requested
mapping. These ?ags are described below.
If no error occurs, a pointer to the beginning of the mapped range is returned
once all pending operations on that buffer have completed, and may be used to
modify and/or query the corresponding range of the buffer, according to the fol-
lowing ?ag bits set in access:
 MAP READ BIT indicates that the returned pointer may be used to read buffer
object data. No GL error is generated if the pointer is used to query a map-
ping which excludes this ?ag, but the result is unde?ned and system errors
(possibly including program termination) may occur.
 MAP WRITE BIT indicates that the returned pointer may be used to modify
buffer object data. No GL error is generated if the pointer is used to modify
a mapping which excludes this ?ag, but the result is unde?ned and system
errors (possibly including program termination) may occur.
Pointer values returned by MapBuffer may not be passed as parameter values
to GL commands. For example, they may not be used to specify array pointers, or
to specify or query pixel or texture image data; such actions produce unde?ned re-
sults, although implementations may not check for such behavior for performance
reasons.
Mappings to the data stores of buffer objects may have nonstandard perfor-
mance characteristics. For example, such mappings may be marked as uncacheable
regions of memory, and in such cases reading from them may be very slow. To en-
sure optimal performance, the client should use the mapping in a fashion consistent
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 43
with the values ofBUFFER USAGE and access. Using a mapping in a fashion incon-
sistent with these values is liable to be multiple orders of magnitude slower than
using normal memory.
The following optional ?ag bits in access may be used to modify the mapping:
 MAP INVALIDATE RANGE BIT indicates that the previous contents of the
speci?ed range may be discarded. Data within this range are unde?ned with
the exception of subsequently written data. No GL error is generated if sub-
sequent GL operations access unwritten data, but the result is unde?ned and
system errors (possibly including program termination) may occur. This ?ag
may not be used in combination withMAP READ BIT.
 MAP INVALIDATE BUFFER BIT indicates that the previous contents of the
entire buffer may be discarded. Data within the entire buffer are unde?ned
with the exception of subsequently written data. No GL error is generated if
subsequent GL operations access unwritten data, but the result is unde?ned
and system errors (possibly including program termination) may occur. This
?ag may not be used in combination withMAP READ BIT.
 MAP FLUSH EXPLICIT BIT indicates that one or more discrete subranges
of the mapping may be modi?ed. When this ?ag is set, modi?cations to
each subrange must be explicitly ?ushed by calling FlushMappedBuffer-
Range. No GL error is set if a subrange of the mapping is modi?ed and
not ?ushed, but data within the corresponding subrange of the buffer are un-
de?ned. This ?ag may only be used in conjunction with MAP WRITE BIT.
When this option is selected, ?ushing is strictly limited to regions that are
explicitly indicated with calls to FlushMappedBufferRange prior to un-
map; if this option is not selected UnmapBuffer will automatically ?ush the
entire mapped range when called.
 MAP UNSYNCHRONIZED BIT indicates that the GL should not attempt to
synchronize pending operations on the buffer prior to returning from Map-
BufferRange. No GL error is generated if pending operations which source
or modify the buffer overlap the mapped region, but the result of such previ-
ous and any subsequent operations is unde?ned.
A successful MapBufferRange sets buffer object state values as shown in ta-
ble 2.8.
Errors
If an error occurs, MapBufferRange returns aNULL pointer.
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 44
Name Value
1
BUFFER ACCESS Depends on access
BUFFER ACCESS FLAGS access
BUFFER MAPPED TRUE
BUFFER MAP POINTER pointer to the data store
BUFFER MAP OFFSET offset
BUFFER MAP LENGTH length
Table 2.8: Buffer object state set by MapBufferRange.
1
BUFFER ACCESS is set to READ ONLY, WRITE ONLY, or READ WRITE if
access & (MAP READ BITjMAP WRITE BIT) is respectively MAP READ BIT,
MAP WRITE BIT, orMAP READ BITjMAP WRITE BIT.
AnINVALID VALUE error is generated if offset or length is negative, if oset+
length is greater than the value ofBUFFER SIZE, or if access has any bits set other
than those de?ned above.
An INVALID OPERATION error is generated for any of the following condi-
tions:
 The buffer is already in a mapped state.
 NeitherMAP READ BIT norMAP WRITE BIT is set.
 MAP READ BIT is set and any of MAP INVALIDATE RANGE BIT,
MAP INVALIDATE BUFFER BIT, orMAP UNSYNCHRONIZED BIT is set.
 MAP FLUSH EXPLICIT BIT is set andMAP WRITE BIT is not set.
An OUT OF MEMORY error is generated if MapBufferRange fails because
memory for the mapping could not be obtained.
No error is generated if memory outside the mapped range is modi?ed or
queried, but the result is unde?ned and system errors (possibly including program
termination) may occur.
The entire data store of a buffer object can be mapped into the client’s address
space by calling
void *MapBuffer(enum target,enum access );
MapBuffer is equivalent to calling MapBufferRange with the same target, offset
of zero, length equal to the value ofBUFFER SIZE, and the access value passed to
MapBufferRange equal to
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 45
 MAP READ BIT, if access isREAD ONLY
 MAP WRITE BIT, if access isWRITE ONLY
 MAP READ BITjMAP WRITE BIT, if access isREAD WRITE.
INVALID ENUM is generated if access is not one of the values described above.
Other errors are generated as described above for MapBufferRange.
If a buffer is mapped with theMAP FLUSH EXPLICIT BIT ?ag, modi?cations
to the mapped range may be indicated by calling
void FlushMappedBufferRange(enum target,intptr offset,
sizeiptr length );
with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. offset and length indi-
cate a modi?ed subrange of the mapping, in basic machine units. The speci?ed
subrange to ?ush is relative to the start of the currently mapped range of buffer.
FlushMappedBufferRange may be called multiple times to indicate distinct
subranges of the mapping which require ?ushing.
Errors
An INVALID VALUE error is generated if offset or length is negative, or if
oset + length exceeds the size of the mapping.
AnINVALID OPERATION error is generated if zero is bound to target.
An INVALID OPERATION error is generated if buffer is not mapped, or is
mapped without theMAP FLUSH EXPLICIT BIT ?ag.
After the client has speci?ed the contents of a mapped buffer range, and before
the data in that range are dereferenced by any GL commands, the mapping must
be relinquished by calling
boolean UnmapBuffer(enum target );
with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. Unmapping a mapped
buffer object invalidates the pointer to its data store and sets the ob-
ject’s BUFFER MAPPED, BUFFER MAP POINTER, BUFFER ACCESS FLAGS,
BUFFER MAP OFFSET, and BUFFER MAP LENGTH state variables to the initial
values shown in table 2.7.
UnmapBuffer returns TRUE unless data values in the buffer’s data store have
become corrupted during the period that the buffer was mapped. Such corruption
can be the result of a screen resolution change or other window system-dependent
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 46
event that causes system heaps such as those for high-performance graphics mem-
ory to be discarded. GL implementations must guarantee that such corruption can
occur only during the periods that a buffer’s data store is mapped. If such corrup-
tion has occurred, UnmapBuffer returns FALSE, and the contents of the buffer’s
data store become unde?ned.
If the buffer data store is already in the unmapped state, UnmapBuffer returns
FALSE, and an INVALID OPERATION error is generated. However, unmapping
that occurs as a side effect of buffer deletion or reinitialization is not an error.
2.9.2 Vertex Arrays in Buffer Objects
Blocks of vertex array data may be stored in buffer objects with the same format
and layout options supported for client-side vertex arrays. However, it is expected
that GL implementations will (at minimum) be optimized for data with all compo-
nents represented as ?oats, as well as for color data with components represented
as either ?oats or unsigned bytes.
A buffer object binding point is added to the client state associated with
each vertex array type. The commands that specify the locations and or-
ganizations of vertex arrays copy the buffer object name that is bound to
ARRAY BUFFER to the binding point corresponding to the vertex array of the
type being speci?ed. For example, the NormalPointer command copies the
value of ARRAY BUFFER BINDING (the queriable name of the buffer bind-
ing corresponding to the target ARRAY BUFFER) to the client state variable
NORMAL ARRAY BUFFER BINDING.
Rendering commands ArrayElement, DrawArrays, DrawElements,
DrawRangeElements, MultiDrawArrays, and MultiDrawElements operate as
previously de?ned, except that data for enabled vertex and attrib arrays are sourced
from buffers if the array’s buffer binding is non-zero. When an array is sourced
from a buffer object, the pointer value of that array is used to compute an offset, in
basic machine units, into the data store of the buffer object. This offset is computed
by subtracting a null pointer from the pointer value, where both pointers are treated
as pointers to basic machine units.
It is acceptable for vertex or attrib arrays to be sourced from any combination
of client memory and various buffer objects during a single rendering operation.
Any GL command that attempts to read data from a buffer object will fail and
generate an INVALID OPERATION error if the object is mapped at the time the
command is issued.
Version 3.0 (September 23, 2008)2.9. BUFFEROBJECTS 47
2.9.3 Array Indices in Buffer Objects
Blocks of array indices may be stored in buffer objects with the same format op-
tions that are supported for client-side index arrays. Initially zero is bound to
ELEMENT ARRAY BUFFER, indicating that DrawElements and DrawRangeEle-
ments are to source their indices from arrays passed as their indices parameters,
and that MultiDrawElements is to source its indices from the array of pointers to
arrays passed in as its indices parameter.
A buffer object is bound to ELEMENT ARRAY BUFFER by calling BindBuffer
with target set toELEMENT ARRAY BUFFER, and buffer set to the name of the buffer
object. If no corresponding buffer object exists, one is initialized as de?ned in
section 2.9.
While a non-zero buffer object name is bound to ELEMENT ARRAY BUFFER,
DrawElements and DrawRangeElements source their indices from that buffer
object, using their indices parameters as offsets into the buffer object in the same
fashion as described in section 2.9.2. MultiDrawElements also sources its in-
dices from that buffer object, using its indices parameter as a pointer to an array of
pointers that represent offsets into the buffer object.
Buffer objects created by binding an unused name to ARRAY BUFFER and to
ELEMENT ARRAY BUFFER are formally equivalent, but the GL may make different
choices about storage implementation based on the initial binding. In some cases
performance will be optimized by storing indices and array data in separate buffer
objects, and by creating those buffer objects with the corresponding binding points.
2.9.4 Buffer Object State
The state required to support buffer objects consists of binding names for the array
buffer, element buffer, pixel unpack buffer, and pixel pack buffer. Additionally,
each vertex array has an associated binding so there is a buffer object binding for
each of the vertex array, normal array, color array, index array, multiple texture
coordinate arrays, edge ?ag array, secondary color array, fog coordinate array, and
vertex attribute arrays. The initial values for all buffer object bindings is zero.
The state of each buffer object consists of a buffer size in basic machine units,
a usage parameter, an access parameter, a mapped boolean, a pointer to the mapped
buffer (NULL if unmapped), and the sized array of basic machine units for the buffer
data.
Version 3.0 (September 23, 2008)2.10. VERTEXARRAYOBJECTS 48
2.10 Vertex Array Objects
The buffer objects that are to be used by the vertex stage of the GL are collected
together to form a vertex array object. All state related to the de?nition of data
used by the vertex processor is encapsulated in a vertex array object.
The command
void GenVertexArrays(sizei n,uint *arrays );
returns n previous unused vertex array object names in arrays. These names are
marked as used, for the purposes of GenVertexArrays only, and are initialized
with the state listed in tables 6.6 through 6.9.
Vertex array objects are deleted by calling
void DeleteVertexArrays(sizei n,const uint *arrays );
arrays contains n names of vertex array objects to be deleted. Once a vertex array
object is deleted it has no contents and its name is again unused. If a vertex array
object that is currently bound is deleted, the binding for that object reverts to zero
and the default vertex array becomes current. Unused names in arrays are silently
ignored, as is the value zero.
A vertex array object is created by binding a name returned by GenVertexAr-
rays with the command
void BindVertexArray(uint array );
array is the vertex array object name. The resulting vertex array object is a new
state vector, comprising all the state values listed in tables 6.6 through 6.9.
BindVertexArray may also be used to bind an existing vertex array object.
If the bind is successful no change is made to the state of the bound vertex array
object, and any previous binding is broken.
The currently bound vertex array object is used for all commands which modify
vertex array state, such as VertexAttribPointer and EnableVertexAttribArray;
all commands which draw from vertex arrays, such as DrawArrays and DrawEle-
ments; and all queries of vertex array state (see chapter 6).
BindVertexArray fails and anINVALID OPERATION error is generated if ar-
ray is not a name returned from a previous call to GenVertexArrays, or if such a
name has since been deleted with DeleteVertexArrays.
AnINVALID OPERATION error is generated if any of the *Pointer commands
specifying the location and organization of vertex array data are called while a
non-zero vertex array object is bound and zero is bound to the ARRAY BUFFER
2
buffer object binding point .
2
This error makes it impossible to create a vertex array object containing client array pointers.
Version 3.0 (September 23, 2008)2.11. RECTANGLES 49
2.11 Rectangles
There is a set of GL commands to support ef?cient speci?cation of rectangles as
two corner vertices.
void Rectfsifdg(T x1,T y1,T x2,T y2 );
void Rectfsifdgv(T v1[2],T v2[2] );
Each command takes either four arguments organized as two consecutive pairs of
(x;y) coordinates, or two pointers to arrays each of which contains an x value
followed by ay value. The effect of the Rect command
Rect(x ;y ;x ;y );
1 1 2 2
is exactly the same as the following sequence of commands:
Begin(POLYGON);
Vertex2(x ;y );
1 1
Vertex2(x ;y );
2 1
Vertex2(x ;y );
2 2
Vertex2(x ;y );
1 2
End();
The appropriate Vertex2 command would be invoked depending on which of the
Rect commands is issued.
2.12 Coordinate Transformations
This section and the following discussion through section 2.19 describe the state
values and operations necessary for transforming vertex attributes according to a
?xed-functionality method. An alternate programmable method for transforming
vertex attributes is described in section 2.20.
Vertices, normals, and texture coordinates are transformed before their coordi-
nates are used to produce an image in the framebuffer. We begin with a description
of how vertex coordinates are transformed and how this transformation is con-
trolled.
Figure 2.6 diagrams the sequence of transformations that are applied to ver-
tices. The vertex coordinates that are presented to the GL are termed object co-
ordinates. The model-view matrix is applied to these coordinates to yield eye co-
ordinates. Then another matrix, called the projection matrix, is applied to eye
coordinates to yield clip coordinates. A perspective division is carried out on clip
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 50
Normalized
Projection
Model?View
Clip
Object Eye
Perspective Device
Division
Coordinates Coordinates Coordinates Coordinates
Matrix Matrix
Viewport Window
Transformation
Coordinates
Figure 2.6. Vertex transformation sequence.
coordinates to yield normalized device coordinates. A ?nal viewport transforma-
tion is applied to convert these coordinates into window coordinates.
Object coordinates, eye coordinates, and clip coordinates are four-dimensional,
consisting ofx,y,z, andw coordinates (in that order). The model-view and pro-
jection matrices are thus 4 4.
0 1
x
o
B C
y
o
B C
If a vertex in object coordinates is given by and the model-view matrix
@ A
z
o
w
o
isM, then the vertex’s eye coordinates are found as
0 1 0 1
x x
e o
B C B C
y y
e o
B C B C
=M :
@ A @ A
z z
e o
w w
e o
Similarly, ifP is the projection matrix, then the vertex’s clip coordinates are
0 1 0 1
x x
c e
B C B C
y y
c e
B C B C
=P :
@ A @ A
z z
c e
w w
c e
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 51
The vertex’s normalized device coordinates are then
0 1 0 1
x
c
x
d
w
c
y
e
@ A @ A
y =P :
d
w
c
z
e
z
d
w
c
2.12.1 Controlling the Viewport
The viewport transformation is determined by the viewport’s width and height in
pixels,p andp , respectively, and its center (o ;o ) (also in pixels). The vertex’s
x y x y
0 1
x
w
@ A
window coordinates, y ; are given by
w
z
w
0 1 0 1
p
x
x x +o
w d x
2
p
y
@ A @ A
y = y +o :
d y
w
2
f n n+f
z z +
w
d
2 2
The factor and offset applied toz encoded byn andf are set using
d
void DepthRange(clampd n,clampd f );
z is represented as either ?xed- or ?oating-point depending on whether the frame-
w
buffer’s depth buffer uses a ?xed- or ?oating-point representation. If the depth
m
buffer uses ?xed-point, we assume that it represents each valuek=(2   1), where
m
k2f0; 1;:::; 2   1g, ask (e.g. 1.0 is represented in binary as a string of all
ones). The parameters n and f are clamped to the range [0; 1], as are all arguments
of typeclampd orclampf.
Viewport transformation parameters are speci?ed using
void Viewport(int x,int y,sizei w,sizei h );
where x and y give the x and y window coordinates of the viewport’s lower left
corner and w and h give the viewport’s width and height, respectively. The viewport
parameters shown in the above equations are found from these values as o =
x
x +w=2 ando =y +h=2;p =w,p =h.
y x y
Viewport width and height are clamped to implementation-dependent maxi-
mums when speci?ed. The maximum width and height may be found by issuing
an appropriate Get command (see chapter 6). The maximum viewport dimensions
must be greater than or equal to the larger of the visible dimensions of the display
being rendered to (if a display exists), and the largest renderbuffer image which
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 52
can be successfully created and attached to a framebuffer object (see chapter 4).
INVALID VALUE is generated if either w or h is negative.
The state required to implement the viewport transformation is four integers
and two clamped ?oating-point values. In the initial state, w and h are set to the
width and height, respectively, of the window into which the GL is to do its render-
ing. If the default framebuffer is bound but no default framebuffer is associated
with the GL context (see chapter 4), then w and h are initially set to zero.o ando
x y
are set tow=2 andh=2, respectively.n andf are set to 0:0 and 1:0, respectively.
2.12.2 Matrices
The projection matrix and model-view matrix are set and modi?ed with a variety
of commands. The affected matrix is determined by the current matrix mode. The
current matrix mode is set with
void MatrixMode(enum mode );
which takes one of the pre-de?ned constants TEXTURE, MODELVIEW, COLOR, or
PROJECTION as the argument value. TEXTURE is described later in section 2.12.2,
andCOLOR is described in section 3.7.3. If the current matrix mode isMODELVIEW,
then matrix operations apply to the model-view matrix; ifPROJECTION, then they
apply to the projection matrix.
The two basic commands for affecting the current matrix are
void LoadMatrixffdg(T m[16] );
void MultMatrixffdg(T m[16] );
LoadMatrix takes a pointer to a 4 4 matrix stored in column-major order as 16
consecutive ?oating-point values, i.e. as
0 1
a a a a
1 5 9 13
B C
a a a a
2 6 10 14
B C
:
@ A
a a a a
3 7 11 15
a a a a
4 8 12 16
(This differs from the standard row-major C ordering for matrix elements. If the
standard ordering is used, all of the subsequent transformation equations are trans-
posed, and the columns representing vectors become rows.)
The speci?ed matrix replaces the current matrix with the one pointed to. Mult-
Matrix takes the same type argument as LoadMatrix, but multiplies the current
matrix by the one pointed to and replaces the current matrix with the product. IfC
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 53
is the current matrix andM is the matrix pointed to by MultMatrix’s argument,
0
then the resulting current matrix,C , is
0
C =CM:
The commands
void LoadTransposeMatrixffdg(T m[16] );
void MultTransposeMatrixffdg(T m[16] );
take pointers to 44 matrices stored in row-major order as 16 consecutive ?oating-
point values, i.e. as
0 1
a a a a
1 2 3 4
B C
a a a a
5 6 7 8
B C
:
@ A
a a a a
9 10 11 12
a a a a
13 14 15 16
The effect of
LoadTransposeMatrix[fd](m);
is the same as the effect of
T
LoadMatrix[fd](m );
The effect of
MultTransposeMatrix[fd](m);
is the same as the effect of
T
MultMatrix[fd](m );
The command
void LoadIdentity(void );
effectively calls LoadMatrix with the identity matrix:
0 1
1 0 0 0
B C
0 1 0 0
B C
:
@ A
0 0 1 0
0 0 0 1
There are a variety of other commands that manipulate matrices. Rotate,
Translate, Scale, Frustum, and Ortho manipulate the current matrix. Each com-
putes a matrix and then invokes MultMatrix with this matrix. In the case of
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 54
void Rotateffdg(T,T x,T y,T z );
 gives an angle of rotation in degrees; the coordinates of a vectorv are given by
T
v = (xyz) . The computed matrix is a counter-clockwise rotation about the line
through the origin with the speci?ed axis when that axis is pointing up (i.e. the
right-hand rule determines the sense of the rotation angle). The matrix is thus
0 1
0
B C
R 0
B C
:
@ A
0
0 0 0 1
  
T
0 0 0
Letu =v=jjvjj = x y z . If
0 1
0 0
0  z y
0 0
@ A
S = z 0  x
0 0
 y x 0
then
T T
R =uu + cos(I uu ) + sinS:
The arguments to
void Translateffdg(T x,T y,T z );
T
give the coordinates of a translation vector as (xy z) . The resulting matrix is a
translation by the speci?ed vector:
0 1
1 0 0 x
B C
0 1 0 y
B C
:
@ A
0 0 1 z
0 0 0 1
void Scaleffdg(T x,T y,T z );
produces a general scaling along thex-,y-, andz- axes. The corresponding matrix
is
0 1
x 0 0 0
B C
0 y 0 0
B C
:
@ A
0 0 z 0
0 0 0 1
For
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 55
void Frustum(double l,double r,double b,double t,
double n,double f );
T T
the coordinates (lb n) and (rt n) specify the points on the near clipping
plane that are mapped to the lower left and upper right corners of the window,
T
respectively (assuming that the eye is located at (0 0 0) ). f gives the distance
from the eye to the far clipping plane. If eithern orf is less than or equal to zero,
l is equal tor,b is equal tot, orn is equal tof, the errorINVALID VALUE results.
The corresponding matrix is
0 1
2n r+l
0 0
r l r l
B C
2n t+b
0 0
B C
t b t b
B C:
f+n 2fn
@ 0 0     A
f n f n
0 0  1 0
void Ortho(double l,double r,double b,double t,
double n,double f );
T T
describes a matrix that produces parallel projection. (lb  n) and (r t  n)
specify the points on the near clipping plane that are mapped to the lower left and
upper right corners of the window, respectively. f gives the distance from the eye
to the far clipping plane. Ifl is equal tor,b is equal tot, orn is equal tof, the
errorINVALID VALUE results. The corresponding matrix is
0 1
2 r+l
0 0  
r l r l
B C
2 t+b
0 0  
B C
t b t b
B C:
f+n
2
@ 0 0     A
f n f n
0 0 0 1
For each texture coordinate set, a 4 4 matrix is applied to the corresponding
texture coordinates. This matrix is applied as
0 10 1
m m m m s
1 5 9 13
B CB C
m m m m t
2 6 10 14
B CB C
;
@ A@ A
m m m m r
3 7 11 15
m m m m q
4 8 12 16
where the left matrix is the current texture matrix. The matrix is applied to the
coordinates resulting from texture coordinate generation (which may simply be the
current texture coordinates), and the resulting transformed coordinates become the
texture coordinates associated with a vertex. Setting the matrix mode toTEXTURE
causes the already described matrix operations to apply to the texture matrix.
The command
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 56
void ActiveTexture(enum texture );
speci?es the active texture unit selector,ACTIVE TEXTURE. Each texture unit con-
tains up to two distinct sub-units: a texture coordinate processing unit (consisting
of a texture matrix stack and texture coordinate generation state) and a texture
image unit (consisting of all the texture state de?ned in section 3.9). In implemen-
tations with a different number of supported texture coordinate sets and texture
image units, some texture units may consist of only one of the two sub-units.
The active texture unit selector speci?es the texture coordinate set accessed
by commands involving texture coordinate processing. Such commands include
those accessing the current matrix stack (if MATRIX MODE is TEXTURE), TexEnv
commands controlling point sprite coordinate replacement (see section 3.4), Tex-
Gen (section 2.12.4), Enable/Disable (if any texture coordinate generation enum
is selected), as well as queries of the current texture coordinates and current raster
texture coordinates. If the texture coordinate set number corresponding to the cur-
rent value of ACTIVE TEXTURE is greater than or equal to the implementation-
dependent constant MAX TEXTURE COORDS, the error INVALID OPERATION is
generated by any such command.
The active texture unit selector also selects the texture image unit accessed
by commands involving texture image processing (section 3.9). Such commands
include all variants of TexEnv (except for those controlling point sprite coordi-
nate replacement), TexParameter, and TexImage commands, BindTexture, En-
able/Disable for any texture target (e.g., TEXTURE 2D), and queries of all such
state. If the texture image unit number corresponding to the current value of
ACTIVE TEXTURE is greater than or equal to the implementation-dependent con-
stantMAX COMBINED TEXTURE IMAGE UNITS, the errorINVALID OPERATION is
generated by any such command.
ActiveTexture generates the errorINVALID ENUM if an invalid texture is spec-
i?ed. texture is a symbolic constant of the form TEXTUREi, indicating that tex-
ture uniti is to be modi?ed. The constants obey TEXTUREi = TEXTURE0 +i (i
is in the range 0 to k  1, where k is the larger of MAX TEXTURE COORDS and
MAX COMBINED TEXTURE IMAGE UNITS).
For backwards compatibility, the implementation-dependent
constant MAX TEXTURE UNITS speci?es the number of conventional texture units
supported by the implementation. Its value must be no larger than the minimum of
MAX TEXTURE COORDS andMAX COMBINED TEXTURE IMAGE UNITS.
There is a stack of matrices for each of matrix modes MODELVIEW,
PROJECTION, and COLOR, and for each texture unit. For MODELVIEW mode, the
stack depth is at least 32 (that is, there is a stack of at least 32 model-view ma-
trices). For the other modes, the depth is at least 2. Texture matrix stacks for all
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 57
texture units have the same depth. The current matrix in any mode is the matrix on
the top of the stack for that mode.
void PushMatrix(void );
pushes the stack down by one, duplicating the current matrix in both the top of the
stack and the entry below it.
void PopMatrix(void );
pops the top entry off of the stack, replacing the current matrix with the matrix
that was the second entry in the stack. The pushing or popping takes place on the
stack corresponding to the current matrix mode. Popping a matrix off a stack with
only one entry generates the errorSTACK UNDERFLOW; pushing a matrix onto a full
stack generatesSTACK OVERFLOW.
When the current matrix mode is TEXTURE, the texture matrix stack of the
active texture unit is pushed or popped.
The state required to implement transformations consists of an integer for the
active texture unit selector, a four-valued integer indicating the current matrix
mode, one stack of at least two 4 4 matrices for each of COLOR, PROJECTION,
and each texture coordinate set, TEXTURE; and a stack of at least 32 4 4 matri-
ces for MODELVIEW. Each matrix stack has an associated stack pointer. Initially,
there is only one matrix on each stack, and all matrices are set to the identity.
The initial active texture unit selector isTEXTURE0, and the initial matrix mode is
MODELVIEW.
2.12.3 Normal Transformation
Finally, we consider how the model-view matrix and transformation state affect
normals. Before use in lighting, normals are transformed to eye coordinates by a
matrix derived from the model-view matrix. Rescaling and normalization opera-
tions are performed on the transformed normals to make them unit length prior to
use in lighting. Rescaling and normalization are controlled by
void Enable(enum target );
and
void Disable(enum target );
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 58
with target equal to RESCALE NORMAL or NORMALIZE. This requires two bits of
state. The initial state is for normals not to be rescaled or normalized.
If the model-view matrix isM, then the normal is transformed to eye coordi-
nates by:
     
 1
0 0 0 0
n n n q = n n n q M
x y z x y z
0 1
x
B C
y
B C
where, if are the associated vertex coordinates, then
@ A
z
w
8
>
0; w = 0;
>
> 0 1
>
>
<
x
B C
 
B C
q = (2.1)
B C
 
n n n y
x y z B C
>
>
@ A
>
>
> z
:
; w =6 0
w
  
Implementations may choose instead to transform n n n to eye coor-
x y z
dinates using
     
 1
0 0 0
n n n = n n n M
x y z x y z u
whereM is the upper leftmost 3x3 matrix taken fromM.
u
Rescale multiplies the transformed normals by a scale factor
     
00 00 00 0 0 0
n n n =f n n n
x y z x y z
If rescaling is disabled, thenf = 1. If rescaling is enabled, thenf is computed
 1
as (m denotes the matrix element in rowi and columnj ofM , numbering the
ij
topmost row of the matrix as row 1 and the leftmost column as column 1)
1
f =p
2 2 2
m +m +m
31 32 33
Note that if the normals sent to GL were unit length and the model-view matrix
uniformly scales space, then rescale makes the transformed normals unit length.
Alternatively, an implementation may choose f as
1
q
f =
2 2 2
0 0 0
n +n +n
x y z
recomputingf for each normal. This makes all non-zero length normals unit length
regardless of their input length and the nature of the model-view matrix.
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 59
After rescaling, the ?nal transformed normal used in lighting,n , is computed
f
as
  
00 00 00
n =m n n n
f x y z
If normalization is disabled, thenm = 1. Otherwise
1
m =q
2 2 2
00 00 00
n +n +n
x y z
Because we specify neither the ?oating-point format nor the means for matrix
inversion, we cannot specify behavior in the case of a poorly-conditioned (nearly
singular) model-view matrixM. In case of an exactly singular matrix, the trans-
formed normal is unde?ned. If the GL implementation determines that the model-
view matrix is uninvertible, then the entries in the inverted matrix are arbitrary. In
any case, neither normal transformation nor use of the transformed normal may
lead to GL interruption or termination.
2.12.4 Generating Texture Coordinates
Texture coordinates associated with a vertex may either be taken from the current
texture coordinates or generated according to a function dependent on vertex coor-
dinates. The command
void TexGenfifdg(enum coord,enum pname,T param );
void TexGenfifdgv(enum coord,enum pname,T params );
controls texture coordinate generation. coord must be one of the constants S, T,
R, or Q, indicating that the pertinent coordinate is thes, t, r, orq coordinate, re-
spectively. In the ?rst form of the command, param is a symbolic constant speci-
fying a single-valued texture generation parameter; in the second form, params is
a pointer to an array of values that specify texture generation parameters. pname
must be one of the three symbolic constantsTEXTURE GEN MODE,OBJECT PLANE,
or EYE PLANE. If pname is TEXTURE GEN MODE, then either params points to
or param is an integer that is one of the symbolic constants OBJECT LINEAR,
EYE LINEAR,SPHERE MAP,REFLECTION MAP, orNORMAL MAP.
If TEXTURE GEN MODE indicates OBJECT LINEAR, then the generation func-
tion for the coordinate indicated by coord is
g =p x +p y +p z +p w :
1 o 2 o 3 o 4 o
Version 3.0 (September 23, 2008)2.12. COORDINATETRANSFORMATIONS 60
x ,y ,z , andw are the object coordinates of the vertex.p ;:::;p are speci?ed
o o o o 1 4
by calling TexGen with pname set toOBJECT PLANE in which case params points
to an array containingp ;:::;p . There is a distinct group of plane equation co-
1 4
ef?cients for each texture coordinate; coord indicates the coordinate to which the
speci?ed coef?cients pertain.
IfTEXTURE GEN MODE indicatesEYE LINEAR, then the function is
0 0 0 0
g =p x +p y +p z +p w
e e e e
1 2 3 4
where
     
 1
0 0 0 0
p p p p = p p p p M
1 2 3 4
1 2 3 4
x , y , z , and w are the eye coordinates of the vertex. p ;:::;p are set by
e e e e 1 4
calling TexGen with pname set to EYE PLANE in correspondence with setting the
coef?cients in the OBJECT PLANE case. M is the model-view matrix in effect
whenp ;:::;p are speci?ed. Computed texture coordinates may be inaccurate or
1 4
unde?ned ifM is poorly conditioned or singular.
When used with a suitably constructed texture image, calling TexGen with
TEXTURE GEN MODE indicating SPHERE MAP can simulate the re?ected image of
a spherical environment on a polygon. SPHERE MAP texture coordinates are gen-
erated as follows. Denote the unit vector pointing from the origin to the vertex
(in eye coordinates) byu. Denote the current normal, after transformation to eye
  
T
coordinates, byn . Letr = r r r , the re?ection vector, be given by
f x y z
T
r =u  2n (n u);
f f
q
2
2 2
and letm = 2 r +r + (r + 1) . Then the value assigned to ans coordinate
z
x y
1
(the ?rst TexGen argument value isS) iss =r =m + ; the value assigned to at
x
2
1
coordinate ist = r =m + . Calling TexGen with a coord of either R or Q when
y
2
pname indicatesSPHERE MAP generates the errorINVALID ENUM.
If TEXTURE GEN MODE indicates REFLECTION MAP, compute the re?ection
vector r as described for the SPHERE MAP mode. Then the value assigned to an
s coordinate iss =r ; the value assigned to at coordinate ist =r ; and the value
x y
assigned to an r coordinate is r = r . Calling TexGen with a coord of Q when
z
pname indicatesREFLECTION MAP generates the errorINVALID ENUM.
IfTEXTURE GEN MODE indicatesNORMAL MAP, compute the normal vectorn
f
as described in section 2.12.3. Then the value assigned to ans coordinate iss =
n ; the value assigned to at coordinate ist =n ; and the value assigned to an
f f
x y
r coordinate isr =n (the valuesn ,n , andn are the components ofn .)
f f f f f
z x y z
Calling TexGen with a coord of Q when pname indicates NORMAL MAP generates
the errorINVALID ENUM.
Version 3.0 (September 23, 2008)2.13. ASYNCHRONOUSQUERIES 61
A texture coordinate generation function is enabled or disabled using En-
able and Disable with an argument of TEXTURE GEN S, TEXTURE GEN T,
TEXTURE GEN R, orTEXTURE GEN Q (each indicates the corresponding texture co-
ordinate). When enabled, the speci?ed texture coordinate is computed according
to the current EYE LINEAR, OBJECT LINEAR or SPHERE MAP speci?cation, de-
pending on the current setting of TEXTURE GEN MODE for that coordinate. When
disabled, subsequent vertices will take the indicated texture coordinate from the
current texture coordinates.
The state required for texture coordinate generation for each texture unit com-
prises a ?ve-valued integer for each coordinate indicating coordinate generation
mode, and a bit for each coordinate to indicate whether texture coordinate genera-
tion is enabled or disabled. In addition, four coef?cients are required for the four
coordinates for each ofEYE LINEAR andOBJECT LINEAR. The initial state has the
texture generation function disabled for all texture coordinates. The initial values
ofp fors are all 0 exceptp which is one; fort all thep are zero exceptp , which
i 1 i 2
is 1. The values ofp forr andq are all 0. These values ofp apply for both the
i i
EYE LINEAR andOBJECT LINEAR versions. Initially all texture generation modes
areEYE LINEAR.
2.13 Asynchronous Queries
Asynchronous queries provide a mechanism to return information about the pro-
cessing of a sequence of GL commands. There are two query types supported by
the GL. Transform feedback queries (see section 2.15) returns information on the
number of vertices and primitives processed by the GL and written to one or more
buffer objects. Occlusion queries (see section 4.1.7) count the number of fragments
or samples that pass the depth test.
The results of asynchronous queries are not returned by the GL immediately
after the completion of the last command in the set; subsequent commands can
be processed while the query results are not complete. When available, the query
results are stored in an associated query object. The commands described in sec-
tion 6.1.12 provide mechanisms to determine when query results are available and
return the actual results of the query. The name space for query objects is the
unsigned integers, with zero reserved by the GL.
Each type of query supported by the GL has an active query object name. If
the active query object name for a query type is non-zero, the GL is currently
tracking the information corresponding to that query type and the query results
will be written into the corresponding query object. If the active query object for a
query type name is zero, no such information is being tracked.
Version 3.0 (September 23, 2008)2.13. ASYNCHRONOUSQUERIES 62
A query object is created and made active by calling
void BeginQuery(enum target,uint id );
target indicates the type of query to be performed; valid values of target are de?ned
in subsequent sections. If id is an unused query object name, the name is marked
as used and associated with a new query object of the type speci?ed by target.
Otherwise id must be the name of an existing query object of that type.
BeginQuery sets the active query object name for the query type given by
target to id. If BeginQuery is called with an id of zero, if the active query object
name for target is non-zero, if id is the name of an existing query object whose
type does not match target, if id is the active query object name for any query type,
or if id is the active query object for condtional rendering (see section 2.14), the
errorINVALID OPERATION is generated.
The command
void EndQuery(enum target );
marks the end of the sequence of commands to be tracked for the query type given
by target. The active query object for target is updated to indicate that query results
are not available, and the active query object name for target is reset to zero. When
the commands issued prior to EndQuery have completed and a ?nal query result
is available, the query object active when EndQuery is called is updated by the
GL. The query object is updated to indicate that the query results are available and
to contain the query result. If the active query object name for target is zero when
EndQuery is called, the errorINVALID OPERATION is generated.
The command
void GenQueries(sizei n,uint *ids );
returns n previously unused query object names in ids. These names are marked
as used, but no object is associated with them until the ?rst time they are used by
BeginQuery.
Query objects are deleted by calling
void DeleteQueries(sizei n,const uint *ids );
ids contains n names of query objects to be deleted. After a query object is deleted,
its name is again unused. Unused names in ids are silently ignored.
Query objects contain two pieces of state: a single bit indicating whether a
query result is available, and an integer containing the query result value. The
Version 3.0 (September 23, 2008)2.14. CONDITIONALRENDERING 63
number of bits used to represent the query result is implementation-dependent. In
the initial state of a query object, the result is available and its value is zero.
The necessary state for each query type is an unsigned integer holding the
active query object name (zero if no query object is active), and any state necessary
to keep the current results of an asynchronous query in progress.
2.14 Conditional Rendering
Conditional rendering can be used to discard rendering commands based on the
result of an occlusion query. Conditional rendering is started and stopped using the
commands
void BeginConditionalRender(uint id,enum mode );
void EndConditionalRender(void );
id speci?es the name of an occlusion query object whose results are used to deter-
mine if the rendering commands are discarded. If the result (SAMPLES PASSED)
of the query is zero, all rendering commands between BeginConditionalRender
and the corresponding EndConditionalRender are discarded. In this case, Begin,
End, all vertex array commands performing an implicit Begin and End, Draw-
Pixels (see section 3.7.4), Bitmap (see section 3.8), Clear (see section 4.2.3),
Accum (see section 4.2.4), CopyPixels (see section 4.3.3), and EvalMesh1 and
EvalMesh2 (see section 5.1) have no effect. The effect of commands setting cur-
rent vertex state, such as Color or VertexAttrib, are unde?ned. If the result of the
occlusion query is non-zero, such commands are not discarded.
mode speci?es how BeginConditionalRender interprets the results of the oc-
clusion query given by id. If mode isQUERY WAIT, the GL waits for the results of
the query to be available and then uses the results to determine if subsquent render-
ing commands are discarded. If mode is QUERY NO WAIT, the GL may choose to
unconditionally execute the subsequent rendering commands without waiting for
the query to complete.
If mode isQUERY BY REGION WAIT, the GL will also wait for occlusion query
results and discard rendering commands if the result of the occlusion query is zero.
If the query result is non-zero, subsequent rendering commands are executed, but
the GL may discard the results of the commands for any region of the framebuffer
that did not contribute to the sample count in the speci?ed occlusion query. Any
such discarding is done in an implementation-dependent manner, but the render-
ing command results may not be discarded for any samples that contributed to the
occlusion query sample count. If mode isQUERY BY REGION NO WAIT, the GL op-
Version 3.0 (September 23, 2008)2.15. TRANSFORMFEEDBACK 64
erates as in QUERY BY REGION WAIT, but may choose to unconditionally execute
the subsequent rendering commands without waiting for the query to complete.
If BeginConditionalRender is called while conditional rendering is in
progress, or if EndConditionalRender is called while conditional rendering
is not in progress, the error INVALID OPERATION is generated. The error
INVALID VALUE is generated if id is not the name of an existing query object
query. The error INVALID OPERATION is generated if id is the name of a query
object with a target other than SAMPLES PASSED, or id is the name of a query
currently in progress.
2.15 Transform Feedback
In transform feedback mode, attributes of the vertices of transformed primitives
processed by a vertex shader are written out to one or more buffer objects. The
vertices are fed back after vertex color clamping, but before clipping. The trans-
formed vertices may be optionally discarded after being stored into one or more
buffer objects, or they can be passed on down to the clipping stage for further
processing. The set of attributes captured is determined when a program is linked.
Transform feedback is started and ?nished by calling
void BeginTransformFeedback(enum primitiveMode );
and
void EndTransformFeedback(void );
respectively. Transform feedback is said to be active after a call to BeginTrans-
formFeedback and inactive after a call to EndTransformFeedback. primitive-
Mode is one of TRIANGLES, LINES, or POINTS, and speci?es the output type of
primitives that will be recorded into the buffer objects bound for transform feed-
back (see below). primitiveMode restricts the primitive types that may be rendered
while transform feedback is active, as shown in table 2.9.
Transform feedback commands must be paired; the
error INVALID OPERATION is generated by BeginTransformFeedback if trans-
form feedback is active, and by EndTransformFeedback if transform feedback is
inactive.
Transform feedback mode captures the values of varying variables written by
an active vertex shader. The error INVALID OPERATION is generated by Begin-
TransformFeedback if no vertex shader is active.
Version 3.0 (September 23, 2008)2.15. TRANSFORMFEEDBACK 65
Transform Feedback Allowed render primitive
primitiveMode (Begin) modes
POINTS POINTS
LINES LINES,LINE LOOP,LINE STRIP
TRIANGLES TRIANGLES,TRIANGLE STRIP,TRIANGLE FAN
QUADS,QUAD STRIP,POLYGON
Table 2.9: Legal combinations of the transform feedback primitive mode, as passed
to BeginTransformFeedback, and the current primitive mode.
When transform feedback is active, all geometric primitives generated must be
compatible with the value of primitiveMode passed to BeginTransformFeedback.
The error INVALID OPERATION is generated by Begin or any operation that im-
plicitly calls Begin (such as DrawElements) if mode is not one of the allowed
modes in table 2.9.
Buffer objects are made to be targets of transform feedback by calling one of
the commands
void BindBufferRange(enum target,uint index,
uint buffer,intptr offset,sizeiptr size );
void BindBufferBase(enum target,uint index,uint buffer );
with target set to TRANSFORM FEEDBACK BUFFER. There is an array of buffer
object binding points that are used while transform feedback is active, plus a
single general binding point that can be used by other buffer object manipu-
lation functions (e.g., BindBuffer, MapBuffer). Both commands bind the
buffer object named by buffer to the general binding point, and additionally bind
the buffer object to the binding point in the array given by index. The error
INVALID VALUE is generated if index is greater than or equal to the value of
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS.
For BindBufferRange, offset speci?es a starting offset into the buffer object
buffer, and size speci?es the amount of data that can be written to the buffer object
while transform feedback mode is active. Both offset and size are in basic machine
units. The error INVALID VALUE is generated if the value of size is less than or
equal to zero, if oset + size is greater than the value of BUFFER SIZE, or
if either offset or size are not a multiple of 4. BindBufferBase is equivalent
to calling BindBufferRange with offset zero and size equal to the size of buffer,
rounded down to the nearest multiple of 4.
Version 3.0 (September 23, 2008)2.15. TRANSFORMFEEDBACK 66
When an individual point, line, or triangle primitive reaches the transform feed-
back stage while transform feedback is active, the values of the speci?ed varying
variables of the vertex are appended to the buffer objects bound to the transform
feedback binding points. The attributes of the ?rst vertex received after Begin-
TransformFeedback are written at the starting offsets of the bound buffer objects
set by BindBufferRange, and subsequent vertex attributes are appended to the
buffer object. When capturing line and triangle primitives, all attributes of the ?rst
vertex are written ?rst, followed by attributes of the subsequent vertices. When
writing varying variables that are arrays, individual array elements are written in
order. For multi-component varying variables or varying array elements, the indi-
vidual components are written in order. The value for any attribute speci?ed to be
streamed to a buffer object but not actually written by a vertex shader is unde?ned.
When quads and polygons are provided to transform feedback with a primitive
mode ofTRIANGLES, they will be tessellated and recorded as triangles (the order of
tessellation within a primitive is unde?ned). Individual lines or triangles of a strip
or fan primitive will be extracted and recorded separately. Incomplete primitives
are not recorded.
Transform feedback can operate in either INTERLEAVED ATTRIBS or
SEPARATE ATTRIBS mode. In INTERLEAVED ATTRIBS mode, the values of
one or more varyings are written, interleaved, into the buffer object bound
to the ?rst transform feedback binding point (index = 0). If more than
one varying variable is written, they will be recorded in the order speci?ed
by TransformFeedbackVaryings (see section 2.20.3). In SEPARATE ATTRIBS
mode, the ?rst varying variable speci?ed by TransformFeedbackVaryings is
written to the ?rst transform feedback binding point; subsequent varying vari-
ables are written to the subsequent transform feedback binding points. The
total number of variables that may be captured in separate mode is given by
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS.
If recording the vertices of a primitive to the buffer objects being used for
transform feedback purposes would result in either exceeding the limits of any
buffer object’s size, or in exceeding the end position oset + size  1, as set
by BindBufferRange, then no vertices of that primitive are recorded in any
buffer object, and the counter corresponding to the asynchronous query target
TRANSFORM FEEDBACK PRIMITIVES WRITTEN (see section 2.16) is not incre-
mented.
In either separate or interleaved modes, all transform feedback binding points
that will be written to must have buffer objects bound when BeginTransform-
Feedback is called. The errorINVALID OPERATION is generated by BeginTrans-
formFeedback if any binding point used in transform feedback mode does not
have a buffer object bound. In interleaved mode, only the ?rst buffer object bind-
Version 3.0 (September 23, 2008)2.16. PRIMITIVEQUERIES 67
ing point is ever written to. The error INVALID OPERATION is also generated
by BeginTransformFeedback if no binding points would be used, either because
no program object is active or because the active program object has speci?ed no
varying variables to record.
While transform feedback is active, the set of attached buffer objects and the set
of varying variables captured may not be changed. If transform feedback is active,
the error INVALID OPERATION is generated by UseProgram, by LinkProgram
if program is the currently active program object, and by BindBufferRange or
BindBufferBase if target isTRANSFORM FEEDBACK BUFFER.
Buffers should not be bound or in use for both transform feedback and other
purposes in the GL. Speci?cally,
If a buffer object is simultaneously bound to a transform feedback buffer bind-
ing point and elsewhere in the GL, any writes to or reads from the buffer generate
unde?ned values. Examples of such bindings include DrawPixels and ReadPixels
to a pixel buffer object binding point and client access to a buffer mapped with
MapBuffer.
However, if a buffer object is written and read sequentially by transform feed-
back and other mechanisms, it is the responsibility of the GL to ensure that data
are accessed consistently, even if the implementation performs the operations in a
pipelined manner. For example, MapBuffer may need to block pending the com-
pletion of a previous transform feedback operation.
2.16 Primitive Queries
Primitive queries use query objects to track the number of primitives generated by
the GL and to track the number of primitives written to transform feedback buffers.
When BeginQuery is called with a target of PRIMITIVES GENERATED, the
primitives-generated count maintained by the GL is set to zero. When the generated
primitive query is active, the primitives-generated count is incremented every time
a primitive reaches the “Discarding Primitives Before Rasterization” stage (see
section 3.1) immediately before rasterization.
When BeginQuery is called with a target of
TRANSFORM FEEDBACK PRIMITIVES WRITTEN, the transform-feedback-
primitives-written count maintained by the GL is set to zero. When the transform
feedback primitive written query is active, the transform-feedback-primitives-
written count is incremented every time a primitive is recorded into a buffer object.
If transform feedback is not active, this counter is not incremented. If the primitive
does not ?t in the buffer object, the counter is not incremented.
These two queries can be used together to determine if all primitives have been
Version 3.0 (September 23, 2008)2.17. CLIPPING 68
written to the bound feedback buffers; if both queries are run simultaneously and
the query results are equal, all primitives have been written to the buffer(s). If the
number of primitives written is less than the number of primitives generated, the
buffer is full.
2.17 Clipping
Primitives are clipped to the clip volume. In clip coordinates, the view volume is
de?ned by
 w x w
c c c
 w y w
c c c
 w z w :
c c c
This view volume may be further restricted by as many as n client-de?ned clip
planes to generate the clip volume. (n is an implementation dependent maximum
that must be at least 6.) Each client-de?ned plane speci?es a half-space. The clip
volume is the intersection of all such half-spaces with the view volume (if there no
client-de?ned clip planes are enabled, the clip volume is the view volume).
A client-de?ned clip plane is speci?ed with
void ClipPlane(enum p,double eqn[4] );
The value of the ?rst argument, p, is a symbolic constant,CLIP PLANEi, wherei is
an integer between 0 andn  1, indicating one ofn client-de?ned clip planes. eqn
is an array of four double-precision ?oating-point values. These are the coef?cients
of a plane equation in object coordinates: p , p , p , andp (in that order). The
1 2 3 4
inverse of the current model-view matrix is applied to these coef?cients, at the time
they are speci?ed, yielding
     
0 0 0 0  1
p p p p = p p p p M
1 2 3 4
1 2 3 4
(whereM is the current model-view matrix; the resulting plane equation is unde-
?ned ifM is singular and may be inaccurate ifM is poorly-conditioned) to obtain
the plane equation coef?cients in eye coordinates. All points with eye coordinates
  
T
x y z w that satisfy
e e e e
0 1
x
e
  B C
y
e
0 0 0 0
B C
p p p p  0
1 2 3 4
@ A
z
e
w
e
Version 3.0 (September 23, 2008)2.17. CLIPPING 69
lie in the half-space de?ned by the plane; points that do not satisfy this condition
do not lie in the half-space.
  
T
When a vertex shader is active, the vector x y z w is no longer
e e e e
computed. Instead, the value of thegl ClipVertex built-in variable is used in its
place. Ifgl ClipVertex is not written by the vertex shader, its value is unde?ned,
which implies that the results of clipping to any client-de?ned clip planes are also
unde?ned. The user must ensure that the clip vertex and client-de?ned clip planes
are de?ned in the same coordinate space.
A vertex shader may, instead of writing togl ClipVertex, write a single clip
distance for each supported clip plane to elements of the gl ClipDistance[]
array. The half-space corresponding to clip plane n is then given by the set of
points satisfying the inequality
c (P ) 0;
n
wherec (P ) is the value of clip distancen at pointP . For point primitives,
n
c (P ) is simply the clip distance for the vertex in question. For line and triangle
n
primitives, per-vertex clip distances are interpolated using a weighted mean, with
weights derived according to the algorithms described in sections 3.5 and 3.6.
Client-de?ned clip planes are enabled with the generic Enable command and
disabled with the Disable command. The value of the argument to either com-
mand is CLIP PLANEi where i is an integer between 0 and n  1; specifying a
value ofi enables or disables the plane equation with indexi. The constants obey
CLIP PLANEi = CLIP PLANE0 +i.
If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded. If the prim-
itive is a line segment, then clipping does nothing to it if it lies entirely within the
clip volume and discards it if it lies entirely outside the volume. If part of the line
segment lies in the volume and part lies outside, then the line segment is clipped
and new vertex coordinates are computed for one or both vertices. A clipped line
segment endpoint lies on both the original line segment and the boundary of the
clip volume.
This clipping produces a value, 0 t 1, for each clipped vertex. If the
coordinates of a clipped vertex areP and the original vertices’ coordinates areP
1
andP , thent is given by
2
P =tP + (1 t)P :
1 2
The value oft is used in color, secondary color, texture coordinate, and fog coor-
dinate clipping (section 2.19.8).
Version 3.0 (September 23, 2008)2.18. CURRENTRASTERPOSITION 70
If the primitive is a polygon, then it is passed if every one of its edges lies
entirely inside the clip volume and either clipped or discarded otherwise. Polygon
clipping may cause polygon edges to be clipped, but because polygon connectivity
must be maintained, these clipped edges are connected by new edges that lie along
the clip volume’s boundary. Thus, clipping may require the introduction of new
vertices into a polygon. Edge ?ags are associated with these vertices so that edges
introduced by clipping are ?agged as boundary (edge ?agTRUE), and so that orig-
inal edges of the polygon that become cut off at these vertices retain their original
?ags.
If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge. This point
must lie in the intersection of the boundary edge and the convex hull of the vertices
of the original polygon. We impose this requirement because the polygon may not
be exactly planar.
Primitives rendered with clip planes must satisfy a complementarity crite-
  
0 0 0 0
rion. Suppose a single clip plane with coef?cients p p p p (or a num-
1 2 3 4
ber of similarly speci?ed clip planes) is enabled and a series of primitives are
drawn. Next, suppose that the original clip plane is respeci?ed with coef?cients
  
0 0 0 0
 p  p  p  p (and correspondingly for any other clip planes) and the
1 2 3 4
primitives are drawn again (and the GL is otherwise in the same state). In this case,
primitives must not be missing any pixels, nor may any pixels be drawn twice in
regions where those primitives are cut by the clip planes.
The state required for clipping is at least 6 sets of plane equations (each consist-
ing of four double-precision ?oating-point coef?cients) and at least 6 correspond-
ing bits indicating which of these client-de?ned plane equations are enabled. In the
initial state, all client-de?ned plane equation coef?cients are zero and all planes are
disabled.
2.18 Current Raster Position
The current raster position is used by commands that directly affect pixels in the
framebuffer. These commands, which bypass vertex transformation and primitive
assembly, are described in the next chapter. The current raster position, however,
shares some of the characteristics of a vertex.
The current raster position is set using one of the commands
void RasterPosf234gfsifdg(T coords );
void RasterPosf234gfsifdgv(T coords );
Version 3.0 (September 23, 2008)2.18. CURRENTRASTERPOSITION 71
RasterPos4 takes four values indicatingx,y,z, andw. RasterPos3 (or Raster-
Pos2) is analogous, but sets onlyx,y, andz withw implicitly set to 1 (or onlyx
andy withz implicitly set to 0 andw implicitly set to 1).
Gets ofCURRENT RASTER TEXTURE COORDS are affected by the setting of the
stateACTIVE TEXTURE.
The coordinates are treated as if they were speci?ed in a Vertex command. If
a vertex shader is active, this vertex shader is executed using the x, y, z, and w
coordinates as the object coordinates of the vertex. Otherwise, the x, y, z, and
w coordinates are transformed by the current model-view and projection matri-
ces. These coordinates, along with current values, are used to generate primary
and secondary colors and texture coordinates just as is done for a vertex. The col-
ors and texture coordinates so produced replace the colors and texture coordinates
stored in the current raster position’s associated data. If a vertex shader is active
then the current raster distance is set to the value of the shader built in varying
gl FogFragCoord. Otherwise, if the value of the fog source (see section 3.11)
is FOG COORD, then the current raster distance is set to the value of the current
fog coordinate. Otherwise, the current raster distance is set to the distance from
the origin of the eye coordinate system to the vertex as transformed by only the
current model-view matrix. This distance may be approximated as discussed in
section 3.11.
Since vertex shaders may be executed when the raster position is set, any at-
tributes not written by the shader will result in unde?ned state in the current raster
position. Vertex shaders should output all varying variables that would be used
when rasterizing pixel primitives using the current raster position.
The transformed coordinates are passed to clipping as if they represented a
point. If the “point” is not culled, then the projection to window coordinates is
computed (section 2.12) and saved as the current raster position, and the valid
bit is set. If the “point” is culled, the current raster position and its associated
data become indeterminate and the valid bit is cleared. Figure 2.7 summarizes the
behavior of the current raster position.
Alternately, the current raster position may be set by one of the WindowPos
commands:
void WindowPosf23gfifdsg(T coords );
void WindowPosf23gfifdsgv(const T coords );
WindowPos3 takes three values indicating x, y and z, while WindowPos2
takes two values indicatingx andy withz implicitly set to 0. The current raster
position, (x ;y ;z ;w ), is de?ned by:
w w w c
x =x
w
Version 3.0 (September 23, 2008)2.18. CURRENTRASTERPOSITION 72
Valid
Rasterpos In
Clip Project
Raster
Position
Vertex/Normal
Current
Transformation
Normal
Raster
Distance
Current
Lighting
Color & 
Materials
Associated
Texture
Data
Texgen
Current Matrix 0
Texture
Current
Coord Set 0
Raster
Position
Texture
Texgen
Matrix 1
Current
Texture
Coord Set 1
Texture
Texgen
Current Matrix 2
Texture
Coord Set 2
Texture
Texgen
Current Matrix 3
Texture
Coord Set 3
Figure 2.7. The current raster position and how it is set. Four texture units are
shown; however, multitexturing may support a different number of units depending
on the implementation.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 73
y =y
w
8
>n; z 0
<
z = f; z 1
w
>
:
n +z(f n); otherwise
w = 1
c
wheren andf are the values passed to DepthRange (see section 2.12.1).
Lighting, texture coordinate generation and transformation, and clipping are
not performed by the WindowPos functions. Instead, in RGBA mode, the current
raster color and secondary color are obtained from the current color and secondary
color, respectively. If vertex color clamping is enabled, the current raster color and
secondary color are clamped to [0; 1]. In color index mode, the current raster color
index is set to the current color index. The current raster texture coordinates are set
to the current texture coordinates, and the valid bit is set.
If the value of the fog source is FOG COORD SRC, then the current raster dis-
tance is set to the value of the current fog coordinate. Otherwise, the raster distance
is set to 0.
The current raster position requires six single-precision ?oating-point values
for itsx ,y , andz window coordinates, itsw clip coordinate, its raster distance
w w w c
(used as the fog coordinate in raster processing), a single valid bit, four ?oating-
point values to store the current RGBA color, four ?oating-point values to store the
current RGBA secondary color, one ?oating-point value to store the current color
index, and 4 ?oating-point values for texture coordinates for each texture unit. In
the initial state, the coordinates and texture coordinates are all (0; 0; 0; 1), the eye
coordinate distance is 0, the fog coordinate is 0, the valid bit is set, the associated
RGBA color is (1; 1; 1; 1), the associated RGBA secondary color is (0; 0; 0; 1), and
the associated color index color is 1. In RGBA mode, the associated color index
always has its initial value; in color index mode, the RGBA color and secondary
color always maintain their initial values.
2.19 Colors and Coloring
Figures 2.8 and 2.9 diagram the processing of RGBA colors and color indices be-
fore rasterization. Incoming colors arrive in one of several formats. Table 2.10
summarizes the conversions that take place on R, G, B, and A components depend-
ing on which version of the Color command was invoked to specify the compo-
nents. As a result of limited precision, some converted values will not be repre-
sented exactly. In color index mode, a single-valued color index is not mapped.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 74
Convert to
k
[0,2 ?1]
[0.0,1.0]
Current
Clamp to
RGBA
[0.0, 1.0]
Color Lighting
Convert to
k k
[?2 ,2 ?1]
[?1.0,1.0]
float
Color
Clipping
Flatshade?
Convert to
fixed?point
Primitive
Clipping
Figure 2.8. Processing of RGBA colors. The heavy dotted lines indicate both pri-
mary and secondary vertex colors, which are processed in the same fashion. See
table 2.10 for the interpretation ofk.
Convert to
n
[0,2 ?1]
Current
float
Mask to
Color
float
n
Index Lighting
[0.0, 2 ?1]
Color
Clipping
Flatshade?
Convert to
fixed?point
Primitive
Clipping
Figure 2.9. Processing of color indices.n is the number of bits in a color index.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 75
GL Type ofc Conversion to ?oating-point
c
ubyte
8
2 1
2c+1
byte
8
2 1
c
ushort
16
2  1
2c+1
short
16
2  1
c
uint
32
2  1
2c+1
int
32
2  1
half c
float c
double c
Table 2.10: Component conversions. Color, normal, and depth component values
(c) of different types are converted to an internal ?oating-point representation using
the equations in this table. All arithmetic is done in the internal ?oating point
format. These conversions apply to components speci?ed as parameters to GL
commands and to components in pixel data. The equations remain the same even if
the implemented ranges of the GL data types are greater than the minimum required
ranges. (Refer to table 2.2)
Next, lighting, if enabled, produces either a color index or primary and sec-
ondary colors. If lighting is disabled, the current color index or current color
(primary color) and current secondary color are used in further processing. Af-
ter lighting, RGBA colors may be clamped to the range [0; 1] as described in
section 2.19.6. A color index is converted to ?xed-point and then its integer por-
tion is masked (see section 2.19.6). After clamping or masking, a primitive may
be ?atshaded, indicating that all vertices of the primitive are to have the same col-
ors. Finally, if a primitive is clipped, then colors (and texture coordinates) must be
computed at the vertices introduced or modi?ed by clipping.
2.19.1 Lighting
GL lighting computes colors for each vertex sent to the GL. This is accomplished
by applying an equation de?ned by a client-speci?ed lighting model to a collection
of parameters that can include the vertex coordinates, the coordinates of one or
more light sources, the current normal, and parameters de?ning the characteristics
of the light sources and a current material. The following discussion assumes that
the GL is in RGBA mode. (Color index lighting is described in section 2.19.5.)
Lighting is turned on or off using the generic Enable or Disable commands
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 76
with the symbolic valueLIGHTING. If lighting is off, the current color and current
secondary color are assigned to the vertex primary and secondary color, respec-
tively. If lighting is on, colors computed from the current lighting parameters are
assigned to the vertex primary and secondary colors.
Lighting Operation
A lighting parameter is of one of ?ve types: color, position, direction, real, or
boolean. A color parameter consists of four ?oating-point values, one for each of
R, G, B, and A, in that order. There are no restrictions on the allowable values for
these parameters. A position parameter consists of four ?oating-point coordinates
(x, y, z, and w) that specify a position in object coordinates (w may be zero,
indicating a point at in?nity in the direction given by x, y, and z). A direction
parameter consists of three ?oating-point coordinates (x, y, andz) that specify a
direction in object coordinates. A real parameter is one ?oating-point value. The
various values and their types are summarized in table 2.11. The result of a lighting
computation is unde?ned if a value for a parameter is speci?ed that is outside the
range given for that parameter in the table.
There aren light sources, indexed byi = 0;:::;n 1. (n is an implementation
dependent maximum that must be at least 8.) Note that the default values ford
cli
ands differ fori = 0 andi> 0.
cli
Before specifying the way that lighting computes colors, we introduce oper-
ators and notation that simplify the expressions involved. If c and c are col-
1 2
ors without alpha where c = (r ;g ;b ) and c = (r ;g ;b ), then de?ne
1 1 1 1 2 2 2 2
c c = (r r ;g g ;b b ). Addition of colors is accomplished by addition of
1 2 1 2 1 2 1 2
the components. Multiplication of colors by a scalar means multiplying each com-
ponent by that scalar. Ifd andd are directions, then de?ne
1 2
d d = maxfd d ; 0g:
1 2 1 2
(Directions are taken to have three coordinates.) IfP andP are (homogeneous,
1 2
   !
with four coordinates) points then letP P be the unit vector that points fromP
1 2 1
toP . Note that ifP has a zerow coordinate andP has non-zerow coordinate,
2 2 1
   !
thenP P is the unit vector corresponding to the direction speci?ed by thex,y,
1 2
andz coordinates ofP ; ifP has a zerow coordinate andP has a non-zerow
2 1 2
   !
coordinate thenP P is the unit vector that is the negative of that corresponding
1 2
to the direction speci?ed byP . If bothP andP have zerow coordinates, then
1 1 2
   !
P P is the unit vector obtained by normalizing the direction corresponding to
1 2
P  P .
2 1
^
Ifd is an arbitrary direction, then letd be the unit vector ind’s direction. Let
kP Pk be the distance between P and P . Finally, let V be the point corre-
1 2 1 2
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 77
Parameter Type Default Value Description
Material Parameters
a color (0:2; 0:2; 0:2; 1:0) ambient color of material
cm
d color (0:8; 0:8; 0:8; 1:0) diffuse color of material
cm
s color (0:0; 0:0; 0:0; 1:0) specular color of material
cm
e color (0:0; 0:0; 0:0; 1:0) emissive color of material
cm
s real 0.0 specular exponent (range:
rm
[0:0; 128:0])
a real 0:0 ambient color index
m
d real 1:0 diffuse color index
m
s real 1:0 specular color index
m
Light Source Parameters
a color (0:0; 0:0; 0:0; 1:0) ambient intensity of lighti
cli
d (i = 0) color (1:0; 1:0; 1:0; 1:0) diffuse intensity of light 0
cli
d (i> 0) color (0:0; 0:0; 0:0; 1:0) diffuse intensity of lighti
cli
s (i = 0) color (1:0; 1:0; 1:0; 1:0) specular intensity of light 0
cli
s (i> 0) color (0:0; 0:0; 0:0; 1:0) specular intensity of lighti
cli
P position (0:0; 0:0; 1:0; 0:0) position of lighti
pli
s direction (0:0; 0:0; 1:0) direction of spotlight for lighti
dli
s real 0.0 spotlight exponent for light i
rli
(range: [0:0; 128:0])
c real 180.0 spotlight cutoff angle for lighti
rli
(range: [0:0; 90:0], 180:0)
k real 1.0 constant attenuation factor for
0i
light i (range: [0:0;1))
k real 0.0 linear attenuation factor for
1i
light i (range: [0:0;1))
k real 0.0 quadratic attenuation factor for
2i
light i (range: [0:0;1))
Lighting Model Parameters
a color (0:2; 0:2; 0:2; 1:0) ambient color of scene
cs
v boolean FALSE viewer assumed to be at
bs
(0; 0; 0) in eye coordinates
(TRUE) or (0; 0;1) (FALSE)
c enum SINGLE COLOR controls computation of colors
es
t boolean FALSE use two-sided lighting mode
bs
Table 2.11: Summary of lighting parameters. The range of individual color com-
ponents is ( 1; +1).
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 78
sponding to the vertex being lit, andn be the corresponding normal. LetP be the
e
eyepoint ((0; 0; 0; 1) in eye coordinates).
Lighting produces two colors at a vertex: a primary colorc and a secondary
pri
colorc . The values ofc andc depend on the light model color control,c .
sec pri sec es
Ifc = SINGLE COLOR, then the equations to computec andc are
es pri sec
c = e
pri cm
+ a a
cm cs
n 1
X
+ (att )(spot ) [a a
i i cm cli
  !
i=0
+ (nVP )d d
pli cm cli
s
^ rm
+ (f )(nh ) s s ]
i i cm cli
c = (0; 0; 0; 1)
sec
Ifc = SEPARATE SPECULAR COLOR, then
es
c = e
pri cm
+ a a
cm cs
n 1
X
+ (att )(spot ) [a a
i i cm cli
  !
i=0
+ (nVP )d d ]
pli cm cli
n 1
X
s
rm
^
c = (att )(spot )(f )(nh ) s s
sec i i i i cm cli
i=0
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 79
where
(
  !
1; nVP =6 0;
pli
f = (2.2)
i
0; otherwise,
(
  !   !
VP +VP; v = TRUE;
pli e bs
h =    (2.3)
  !
i T
VP + 0 0 1 ; v = FALSE;
pli bs
8
1
<
; ifP ’sw6= 0,
pli
2
k + k kVP k + k kVP k
0i 1i pli 2i pli
att = (2.4)
i
:
1:0; otherwise.
8
   !    !
s
rli
>
(P V ^s ) ; c =6 180:0;P V ^s  cos(c );
<
pli dli rli pli dli rli
   !
spot = (2.5)
i ^
0:0; c 6= 180:0;P Vs < cos(c );
rli pli dli rli
>
:
1:0; c = 180:0:
rli
All computations are carried out in eye coordinates.
The value of A produced by lighting is the alpha value associated with d .
cm
A is always associated with the primary colorc ; the alpha component ofc is
pri sec
always 1.
Results of lighting are unde?ned if thew coordinate (w in eye coordinates) of
e
V is zero.
Lighting may operate in two-sided mode (t = TRUE), in which a front color
bs
is computed with one set of material parameters (the front material) and a back
color is computed with a second set of material parameters (the back material).
This second computation replacesn with n. Ift = FALSE, then the back color
bs
and front color are both assigned the color computed using the front material with
n.
Additionally, vertex shaders can operate in two-sided color mode. When a ver-
tex shader is active, front and back colors can be computed by the vertex shader and
written to the gl FrontColor, gl BackColor, gl FrontSecondaryColor
and gl BackSecondaryColor outputs. If VERTEX PROGRAM TWO SIDE is en-
abled, the GL chooses between front and back colors, as described below. Oth-
erwise, the front color output is always selected. Two-sided color mode is
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 80
enabled and disabled by calling Enable or Disable with the symbolic value
VERTEX PROGRAM TWO SIDE.
The selection between back and front colors depends on the primitive of which
the vertex being lit is a part. If the primitive is a point or a line segment, the front
color is always selected. If it is a polygon, then the selection is based on the sign of
the (clipped or unclipped) polygon’s signed area computed in window coordinates.
One way to compute this area is
n 1
X
1
i i1 i1 i
a = x y  x y (2.6)
w w w w
2
i=0
i i
where x and y are the x and y window coordinates of the ith vertex of the
w w
n-vertex polygon (vertices are numbered starting at zero for purposes of this com-
putation) andi 1 is (i + 1) modn. The interpretation of the sign of this value is
controlled with
void FrontFace(enum dir );
Setting dir toCCW (corresponding to counter-clockwise orientation of the projected
polygon in window coordinates) indicates that if a 0, then the color of each
vertex of the polygon becomes the back color computed for that vertex while if
a> 0, then the front color is selected. If dir isCW, thena is replaced by a in the
above inequalities. This requires one bit of state; initially, it indicatesCCW.
2.19.2 Lighting Parameter Specification
Lighting parameters are divided into three categories: material parameters, light
source parameters, and lighting model parameters (see table 2.11). Sets of lighting
parameters are speci?ed with
void Materialfifg(enum face,enum pname,T param );
void Materialfifgv(enum face,enum pname,T params );
void Lightfifg(enum light,enum pname,T param );
void Lightfifgv(enum light,enum pname,T params );
void LightModelfifg(enum pname,T param );
void LightModelfifgv(enum pname,T params );
pname is a symbolic constant indicating which parameter is to be set (see ta-
ble 2.12). In the vector versions of the commands, params is a pointer to a group
of values to which to set the indicated parameter. The number of values pointed to
depends on the parameter being set. In the non-vector versions, param is a value to
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 81
which to set a single-valued parameter. (If param corresponds to a multi-valued pa-
rameter, the errorINVALID ENUM results.) For the Material command, face must
be one ofFRONT,BACK, orFRONT AND BACK, indicating that the property name of
the front or back material, or both, respectively, should be set. In the case of Light,
light is a symbolic constant of the form LIGHTi, indicating that lighti is to have
the speci?ed parameter set. The constants obeyLIGHTi = LIGHT0 +i.
Table 2.12 gives, for each of the three parameter groups, the correspondence
between the pre-de?ned constant names and their names in the lighting equations,
along with the number of values that must be speci?ed with each. Color parame-
ters speci?ed with Material and Light are converted to ?oating-point values (if
speci?ed as integers) as indicated in table 2.10 for signed integers. The error
INVALID VALUE occurs if a speci?ed lighting parameter lies outside the allowable
range given in table 2.11. (The symbol “1” indicates the maximum representable
magnitude for the indicated type.)
Material properties can be changed inside a Begin/End pair by calling Ma-
terial. However, when a vertex shader is active such property changes are not
guaranteed to update material parameters, de?ned in table 2.12, until the following
End command.
The current model-view matrix is applied to the position parameter indicated
with Light for a particular light source when that position is speci?ed. These
transformed values are the values used in the lighting equation.
The spotlight direction is transformed when it is speci?ed using only the upper
leftmost 3x3 portion of the model-view matrix. That is, ifM is the upper left 3x3
u
matrix taken from the current model-view matrixM, then the spotlight direction
0 1
d
x
@ A
d
y
d
z
is transformed to
0 1 0 1
0
d d
x
x
0
@ A @ A
d =M d :
u y
y
0
d d
z
z
An individual light is enabled or disabled by calling Enable or Disable with the
symbolic valueLIGHTi (i is in the range 0 ton 1, wheren is the implementation-
dependent number of lights). If light i is disabled, the ith term in the lighting
equation is effectively removed from the summation.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 82
Parameter Name Number of values
Material Parameters (Material)
a AMBIENT 4
cm
d DIFFUSE 4
cm
a ;d AMBIENT AND DIFFUSE 4
cm cm
s SPECULAR 4
cm
e EMISSION 4
cm
s SHININESS 1
rm
a ;d ;s COLOR INDEXES 3
m m m
Light Source Parameters (Light)
a AMBIENT 4
cli
d DIFFUSE 4
cli
s SPECULAR 4
cli
P POSITION 4
pli
s SPOT DIRECTION 3
dli
s SPOT EXPONENT 1
rli
c SPOT CUTOFF 1
rli
k CONSTANT ATTENUATION 1
0
k LINEAR ATTENUATION 1
1
k QUADRATIC ATTENUATION 1
2
Lighting Model Parameters (LightModel)
a LIGHT MODEL AMBIENT 4
cs
v LIGHT MODEL LOCAL VIEWER 1
bs
t LIGHT MODEL TWO SIDE 1
bs
c LIGHT MODEL COLOR CONTROL 1
es
Table 2.12: Correspondence of lighting parameter symbols to names.
AMBIENT AND DIFFUSE is used to seta andd to the same value.
cm cm
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 83
Current
Color*() To subsequent vertex operations
Color
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is AMBIENT or AMBIENT_AND_DIFFUSE,
and ColorMaterial is enabled. Down otherwise.
Front Ambient
To lighting equations
Color
Material*(FRONT,AMBIENT)
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is DIFFUSE or AMBIENT_AND_DIFFUSE,
and ColorMaterial is enabled. Down otherwise.
Front Diffuse
To lighting equations
Color
Material*(FRONT,DIFFUSE)
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is SPECULAR, and ColorMaterial is
enabled. Down otherwise.
Front Specular
To lighting equations
Color
Material*(FRONT,SPECULAR)
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is EMISSION, and ColorMaterial is
enabled. Down otherwise.
Front Emission
To lighting equations
Color
Material*(FRONT,EMISSION)
State values flow along this path only when a command is issued
State values flow continuously along this path
Figure 2.10. ColorMaterial operation. Material properties are continuously up-
dated from the current color while ColorMaterial is enabled and has the appro-
priate mode. Only the front material properties are included in this ?gure. The
back material properties are treated identically, except that face must be BACK or
FRONT AND BACK.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 84
2.19.3 ColorMaterial
It is possible to attach one or more material properties to the current color, so
that they continuously track its component values. This behavior is enabled and
disabled by calling Enable or Disable with the symbolic valueCOLOR MATERIAL.
The command that controls which of these modes is selected is
void ColorMaterial(enum face,enum mode );
face is one of FRONT, BACK, or FRONT AND BACK, indicating whether the front
material, back material, or both are affected by the current color. mode is one
of EMISSION, AMBIENT, DIFFUSE, SPECULAR, or AMBIENT AND DIFFUSE and
speci?es which material property or properties track the current color. If mode is
EMISSION,AMBIENT,DIFFUSE, orSPECULAR, then the value ofe ,a ,d or
cm cm cm
s , respectively, will track the current color. If mode isAMBIENT AND DIFFUSE,
cm
botha andd track the current color. The replacements made to material prop-
cm cm
erties are permanent; the replaced values remain until changed by either sending a
new color or by setting a new material value when ColorMaterial is not currently
enabled to override that particular value. When COLOR MATERIAL is enabled, the
indicated parameter or parameters always track the current color. For instance,
calling
ColorMaterial(FRONT,AMBIENT)
while COLOR MATERIAL is enabled sets the front materiala to the value of the
cm
current color.
Material properties can be changed inside a Begin/End pair indirectly by en-
abling ColorMaterial mode and making Color calls. However, when a vertex
shader is active such property changes are not guaranteed to update material pa-
rameters, de?ned in table 2.12, until the following End command.
2.19.4 Lighting State
The state required for lighting consists of all of the lighting parameters (front
and back material parameters, lighting model parameters, and at least 8 sets of
light parameters), a bit indicating whether a back color distinct from the front
color should be computed, at least 8 bits to indicate which lights are enabled,
a ?ve-valued variable indicating the current ColorMaterial mode, a bit indicat-
ing whether or not COLOR MATERIAL is enabled, and a single bit to indicate
whether lighting is enabled or disabled. In the initial state, all lighting parame-
ters have their default values. Back color evaluation does not take place, Color-
Material isFRONT AND BACK andAMBIENT AND DIFFUSE, and both lighting and
COLOR MATERIAL are disabled.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 85
2.19.5 Color Index Lighting
A simpli?ed lighting computation applies in color index mode that uses many of
the parameters controlling RGBA lighting, but none of the RGBA material param-
eters. First, the RGBA diffuse and specular intensities of light i (d and s ,
cli cli
respectively) determine color index diffuse and specular light intensities, d and
li
s from
li
d = (:30)R(d ) + (:59)G(d ) + (:11)B(d )
li cli cli cli
and
s = (:30)R(s ) + (:59)G(s ) + (:11)B(s ):
li cli cli cli
R(x) indicates the R component of the colorx and similarly forG(x) andB(x).
Next, let
n
X
s
rm
^
s = (att )(spot )(s )(f )(nh )
i i i i
li
i=0
whereatt andspot are given by equations 2.4 and 2.5, respectively, andf and
i i i
0
^
h are given by equations 2.2 and 2.3, respectively. Lets = minfs; 1g. Finally,
i
let
n
X
  !
d = (att )(spot )(d )(nVP ):
i i li pli
i=0
Then color index lighting produces a valuec, given by
0 0
c =a +d(1 s )(d  a ) +s (s  a ):
m m m m m
The ?nal color index is
0
c = minfc;s g:
m
The valuesa ,d ands are material properties described in tables 2.11 and 2.12.
m m m
Any ambient light intensities are incorporated intoa . As with RGBA lighting,
m
disabled lights cause the corresponding terms from the summations to be omitted.
The interpretation oft and the calculation of front and back colors is carried out
bs
as has already been described for RGBA lighting.
The values a , d , and s are set with Material using a pname of
m m m
COLOR INDEXES. Their initial values are 0, 1, and 1, respectively. The additional
state consists of three ?oating-point values. These values have no effect on RGBA
lighting.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 86
2.19.6 Clamping or Masking
When the GL is in RGBA mode and vertex color clamping is enabled, all compo-
nents of both primary and secondary colors are clamped to the range [0; 1] after
lighting. If color clamping is disabled, the primary and secondary colors are un-
modi?ed. Vertex color clamping is controlled by calling
void ClampColor(enum target,enum clamp );
with target set toCLAMP VERTEX COLOR. If clamp isTRUE, vertex color clamp-
ing is enabled; if clamp is FALSE, vertex color clamping is disabled. If clamp is
FIXED ONLY, vertex color clamping is enabled if all enabled color buffers have
?xed-point components.
For a color index, the index is ?rst converted to ?xed-point with an unspeci?ed
number of bits to the right of the binary point; the nearest ?xed-point value is
selected. Then, the bits to the right of the binary point are left alone while the
n
integer portion is masked (bitwise ANDed) with 2   1, wheren is the number of
bits in a color in the color index buffer (buffers are discussed in chapter 4).
The state required for color clamping is a three-valued integer, initially set to
TRUE.
2.19.7 Flatshading
A primitive may be ?atshaded, meaning that all vertices of the primitive are as-
signed the same color index or the same primary and secondary colors. These
colors are the colors of the vertex that spawned the primitive. For a point, these
are the colors associated with the point. For a line segment, they are the colors of
the second (?nal) vertex of the segment. For a polygon, they come from a selected
vertex depending on how the polygon was generated. Table 2.13 summarizes the
possibilities.
Flatshading is controlled by
void ShadeModel(enum mode );
mode value must be either of the symbolic constants SMOOTH or FLAT. If mode is
SMOOTH (the initial state), vertex colors are treated individually. If mode is FLAT,
?atshading is turned on. ShadeModel thus requires one bit of state.
If a vertex shader is active, the ?at shading control applies to the built-in vary-
ing variables gl FrontColor, gl BackColor, gl FrontSecondaryColor
and gl BackSecondaryColor. Non-color varying variables can be speci?ed
as being ?at-shaded via the flat quali?er, as described in section 4.3.6 of the
OpenGL Shading Language Specification.
Version 3.0 (September 23, 2008)2.19. COLORSANDCOLORING 87
Primitive type of polygoni Vertex
single polygon (i 1) 1
triangle strip i + 2
triangle fan i + 2
independent triangle 3i
quad strip 2i + 2
independent quad 4i
Table 2.13: Polygon ?atshading color selection. The colors used for ?atshading
the ith polygon generated by the indicated Begin/End type are derived from the
current color (if lighting is disabled) in effect when the indicated vertex is speci?ed.
If lighting is enabled, the colors are produced by lighting the indicated vertex.
Vertices are numbered 1 throughn, wheren is the number of vertices between the
Begin/End pair.
2.19.8 Color and Associated Data Clipping
After lighting, clamping or masking and possible ?atshading, colors are clipped.
Those colors associated with a vertex that lies within the clip volume are unaffected
by clipping. If a primitive is clipped, however, the colors assigned to vertices
produced by clipping are clipped colors.
Let the colors assigned to the two verticesP andP of an unclipped edge be
1 2
c andc . The value oft (section 2.17) for a clipped pointP is used to obtain the
1 2
color associated withP as
c =tc + (1 t)c :
1 2
(For a color index color, multiplying a color by a scalar means multiplying the
index by the scalar. For an RGBA color, it means multiplying each of R, G, B, and
A by the scalar. Both primary and secondary colors are treated in the same fashion.)
Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clipping against one plane of the clip volume’s boundary at a time. Color clipping
is done in the same way, so that clipped points always occur at the intersection of
polygon edges (possibly already clipped) with the clip volume’s boundary.
Texture and fog coordinates, vertex shader varying variables (section 2.20.3),
and point sizes computed on a per vertex basis must also be clipped when a primi-
tive is clipped. The method is exactly analogous to that used for color clipping.
For vertex shader varying variables speci?ed to be interpolated without per-
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 88
spective correction (using the noperspective quali?er), the value oft used to
obtain the varying value associated withP will be adjusted to produce results that
vary linearly in screen space.
2.19.9 Final Color Processing
In RGBA mode with vertex color clamping disabled, the ?oating- point RGBA
components are not modi?ed.
In RGBA mode with vertex color clamping enabled, each color component (al-
ready clamped to [0; 1]) may be converted (by rounding to nearest) to a ?xed-point
value withm bits. We assume that the ?xed-point representation used represents
m m
each valuek=(2   1), wherek2f0; 1;:::; 2   1g, ask (e.g. 1.0 is represented
in binary as a string of all ones). m must be at least as large as the number of bits
in the corresponding component of the framebuffer. m must be at least 2 for A if
the framebuffer does not contain an A component, or if there is only 1 bit of A in
the framebuffer. GL implementations are not required to convert clamped color
components to ?xed-point.
m
Because a number of the formk=(2   1) may not be represented exactly as
a limited-precision ?oating-point quantity, we place a further requirement on the
?xed-point conversion of RGBA components. Suppose that lighting is disabled, the
color associated with a vertex has not been clipped, and one of Colorub, Colorus,
or Colorui was used to specify that color. When these conditions are satis?ed, an
RGBA component must convert to a value that matches the component as speci?ed
in the Color command: if m is less than the number of bits b with which the
component was speci?ed, then the converted value must equal the most signi?cant
m bits of the speci?ed value; otherwise, the most signi?cantb bits of the converted
value must equal the speci?ed value.
A color index is converted (by rounding to nearest) to a ?xed-point value with
at least as many bits as there are in the color index portion of the framebuffer.
2.20 Vertex Shaders
The sequence of operations described in sections 2.12 through 2.19 is a ?xed-
function method for processing vertex data. Applications can more generally de-
scribe the operations that occur on vertex values and their associated data by using
a vertex shader.
A vertex shader is an array of strings containing source code for the operations
that are meant to occur on each vertex that is processed. The language used for
vertex shaders is described in the OpenGL Shading Language Specification.
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 89
To use a vertex shader, shader source code is ?rst loaded into a shader ob-
ject and then compiled. One or more vertex shader objects are then attached to
a program object. A program object is then linked, which generates executable
code from all the compiled shader objects attached to the program. When a linked
program object is used as the current program object, the executable code for the
vertex shaders it contains is used to process vertices.
In addition to vertex shaders, fragment shaders can be created, compiled, and
linked into program objects. Fragment shaders affect the processing of fragments
during rasterization, and are described in section 3.12. A single program object
can contain both vertex and fragment shaders.
When the program object currently in use includes a vertex shader, its vertex
shader is considered active and is used to process vertices. If the program object
has no vertex shader, or no program object is currently in use, the ?xed-function
method for processing vertices is used instead.
2.20.1 Shader Objects
The source code that makes up a program that gets executed by one of the pro-
grammable stages is encapsulated in one or more shader objects.
The name space for shader objects is the unsigned integers, with zero re-
served for the GL. This name space is shared with program objects. The following
sections de?ne commands that operate on shader and program objects by name.
Commands that accept shader or program object names will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object and INVALID OPERATION if the provided name identi?es an object
that is not the expected type.
To create a shader object, use the command
uint CreateShader(enum type );
The shader object is empty when it is created. The type argument speci?es the type
of shader object to be created. For vertex shaders, type must beVERTEX SHADER.
A non-zero name that can be used to reference the shader object is returned. If an
error occurs, zero will be returned.
The command
void ShaderSource(uint shader,sizei count,const
char **string,const int *length );
loads source code into the shader object named shader. string is an array of count
pointers to optionally null-terminated character strings that make up the source
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 90
code. The length argument is an array with the number ofchars in each string (the
string length). If an element in length is negative, its accompanying string is null-
terminated. If length isNULL, all strings in the string argument are considered null-
terminated. The ShaderSource command sets the source code for the shader to
the text strings in the string array. If shader previously had source code loaded into
it, the existing source code is completely replaced. Any length passed in excludes
the null terminator in its count.
The strings that are loaded into a shader object are expected to form the source
code for a valid shader as de?ned in the OpenGL Shading Language Specification.
Once the source code for a shader has been loaded, a shader object can be
compiled with the command
void CompileShader(uint shader );
Each shader object has a boolean status, COMPILE STATUS, that is modi?ed as
a result of compilation. This status can be queried with GetShaderiv (see sec-
tion 6.1.15). This status will be set toTRUE if shader was compiled without errors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification. If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compile does not restore the old state of shader.
Changing the source code of a shader object with ShaderSource does not
change its compile status or the compiled shader code.
Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log can be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section 6.1.15).
Shader objects can be deleted with the command
void DeleteShader(uint shader );
If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is ?agged for deletion and will be deleted when it is no longer
attached to any program object. If an object is ?agged for deletion, its boolean
status bit DELETE STATUS is set to true. The value of DELETE STATUS can be
queried with GetShaderiv (see section 6.1.15). DeleteShader will silently ignore
the value zero.
2.20.2 Program Objects
The shader objects that are to be used by the programmable stages of the GL are
collected together to form a program object. The programs that are executed by
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 91
these programmable stages are called executables. All information necessary for
de?ning an executable is encapsulated in a program object. A program object is
created with the command
uint CreateProgram(void );
Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, 0 will be
returned.
To attach a shader object to a program object, use the command
void AttachShader(uint program,uint shader );
The errorINVALID OPERATION is generated if shader is already attached to pro-
gram.
Shader objects may be attached to program objects before source code has
been loaded into the shader object, or before the shader object has been compiled.
Multiple shader objects of the same type may be attached to a single program
object, and a single shader object may be attached to more than one program object.
To detach a shader object from a program object, use the command
void DetachShader(uint program,uint shader );
The errorINVALID OPERATION is generated if shader is not attached to program.
If shader has been ?agged for deletion and is not attached to any other program
object, it is deleted.
In order to use the shader objects contained in a program object, the program
object must be linked. The command
void LinkProgram(uint program );
will link the program object named program. Each program object has a boolean
status, LINK STATUS, that is modi?ed as a result of linking. This status can be
queried with GetProgramiv (see section 6.1.15). This status will be set toTRUE if
a valid executable is created, and FALSE otherwise. Linking can fail for a variety
of reasons as speci?ed in the OpenGL Shading Language Specification. Linking
will also fail if one or more of the shader objects, attached to program are not
compiled successfully, or if more active uniform or active sampler variables are
used in program than allowed (see section 2.20.3). If LinkProgram failed, any
information about a previous link of that program object is lost. Thus, a failed link
does not restore the old state of program.
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 92
Each program object has an information log that is overwritten as a result of a
link operation. This information log can be queried with GetProgramInfoLog to
obtain more information about the link operation or the validation information (see
section 6.1.15).
If a valid executable is created, it can be made part of the current rendering
state with the command
void UseProgram(uint program );
This command will install the executable code as part of current rendering state if
the program object program contains valid executable code, i.e. has been linked
successfully. If UseProgram is called with program set to 0, it is as if the GL
had no programmable stages and the ?xed-function paths will be used instead.
If program has not been successfully linked, the error INVALID OPERATION is
generated and the current rendering state is not modi?ed.
While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutable code of the program object.
If the program object that is in use is re-linked successfully, the LinkProgram
command will install the generated executable code as part of the current rendering
state if the speci?ed program object was already in use as a result of a previous call
to UseProgram.
If that program object that is in use is re-linked unsuccessfully, the link status
will be set to FALSE, but existing executable and associated state will remain part
of the current rendering state until a subsequent call to UseProgram removes it
from use. After such a program is removed from use, it can not be made part of the
current rendering state until it is successfully re-linked.
Program objects can be deleted with the command
void DeleteProgram(uint program );
If program is not the current program for any GL context, it is deleted immediately.
Otherwise, program is ?agged for deletion and will be deleted when it is no longer
the current program for any context. When a program object is deleted, all shader
objects attached to it are detached. DeleteProgram will silently ignore the value
zero.
2.20.3 Shader Variables
A vertex shader can reference a number of variables as it executes. Vertex attributes
are the per-vertex values speci?ed in section 2.7. Uniforms are per-program vari-
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 93
ables that are constant during program execution. Samplers are a special form of
uniform used for texturing (section 3.9). Varying variables hold the results of ver-
tex shader execution that are used later in the pipeline. The following sections
describe each of these variable types.
Vertex Attributes
Vertex shaders can access built-in vertex attribute variables corresponding to the
per-vertex state set by commands such as Vertex, Normal, Color. Vertex shaders
can also de?ne named attribute variables, which are bound to the generic vertex
attributes that are set by VertexAttrib*. This binding can be speci?ed by the ap-
plication before the program is linked, or automatically assigned by the GL when
the program is linked.
When an attribute variable declared as afloat,vec2,vec3 orvec4 is bound
to a generic attribute indexi, its value(s) are taken from thex, (x;y), (x;y;z), or
(x;y;z;w) components, respectively, of the generic attributei. When an attribute
variable is declared as a mat2, mat3x2 or mat4x2, its matrix columns are taken
from the (x;y) components of generic attributesi andi+1 (mat2), from attributes
i throughi + 2 (mat3x2), or from attributesi throughi + 3 (mat4x2). When an
attribute variable is declared as a mat2x3, mat3 or mat4x3, its matrix columns
are taken from the (x;y;z) components of generic attributesi andi + 1 (mat2x3),
from attributesi throughi +2 (mat3), or from attributesi throughi +3 (mat4x3).
When an attribute variable is declared as a mat2x4, mat3x4 or mat4, its matrix
columns are taken from the (x;y;z;w) components of generic attributesi andi+1
(mat2x4), from attributesi throughi + 2 (mat3x4), or from attributesi through
i + 3 (mat4).
An attribute variable (either conventional or generic) is considered active if it is
determined by the compiler and linker that the attribute may be accessed when the
shader is executed. Attribute variables that are declared in a vertex shader but never
used will not count against the limit. In cases where the compiler and linker cannot
make a conclusive determination, an attribute will be considered active. A program
object will fail to link if the sum of the active generic and active conventional
attributes exceedsMAX VERTEX ATTRIBS.
To determine the set of active vertex attributes used by a program, and to de-
termine their types, use the command:
void GetActiveAttrib(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name );
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 94
This command provides information about the attribute selected by index. An in-
dex of 0 selects the ?rst active attribute, and an index ofACTIVE ATTRIBUTES  1
selects the last active attribute. The value ofACTIVE ATTRIBUTES can be queried
with GetProgramiv (see section 6.1.15). If index is greater than or equal to
ACTIVE ATTRIBUTES, the error INVALID VALUE is generated. Note that index
simply identi?es a member in a list of active attributes, and has no relation to the
generic attribute that the corresponding variable is bound to.
The parameter program is the name of a program object for which the com-
mand LinkProgram has been issued in the past. It is not necessary for program to
have been linked successfully. The link could have failed because the number of
active attributes exceeded the limit.
The name of the selected attribute is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null termi-
nator, is returned in length. If length isNULL, no length is returned. The maximum
number of characters that may be written into name, including the null terminator,
is speci?ed by bufSize. The returned attribute name can be the name of a generic
attribute or a conventional attribute (which begin with the pre?x "gl ", see the
OpenGL Shading Language speci?cation for a complete list). The length of the
longest attribute name in program is given byACTIVE ATTRIBUTE MAX LENGTH,
which can be queried with GetProgramiv (see section 6.1.15).
For the selected attribute, the type of the attribute is returned into
type. The size of the attribute is returned into size. The value in
size is in units of the type returned in type. The type returned can
be any of FLOAT, FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, FLOAT MAT2,
FLOAT MAT3, FLOAT MAT4, FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2,
FLOAT MAT3x4, FLOAT MAT4x2, FLOAT MAT4x3, INT, INT VEC2, INT VEC3,
INT VEC4, UNSIGNED INT, UNSIGNED INT VEC2, UNSIGNED INT VEC3, or
UNSIGNED INT VEC4.
If an error occurred, the return parameters length, size, type and name will be
unmodi?ed.
This command will return as much information about active attributes as pos-
sible. If no information is available, length will be set to zero and name will be an
empty string. This situation could arise if GetActiveAttrib is issued after a failed
link.
After a program object has been linked successfully, the bindings of attribute
variable names to indices can be queried. The command
int GetAttribLocation(uint program,const char *name );
returns the generic attribute index that the attribute variable named name was bound
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 95
to when the program object named program was last linked. name must be a null-
terminated string. If name is active and is an attribute matrix, GetAttribLocation
returns the index of the ?rst column of that matrix. If program has not been suc-
cessfully linked, the error INVALID OPERATION is generated. If name is not an
active attribute, if name is a conventional attribute, or if an error occurs, -1 will be
returned.
The binding of an attribute variable to a generic attribute index can also be
speci?ed explicitly. The command
void BindAttribLocation(uint program,uint index,const
char *name );
speci?es that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
was bound previously, its assigned binding is replaced with index. name must be a
null terminated string. The errorINVALID VALUE is generated if index is equal or
greater than MAX VERTEX ATTRIBS. BindAttribLocation has no effect until the
program is linked. In particular, it doesn’t modify the bindings of active attribute
variables in a program that has already been linked.
Built-in attribute variables are automatically bound to conventional attributes,
and can not have an assigned binding. The error INVALID OPERATION is gener-
ated if name starts with the reserved"gl " pre?x.
When a program is linked, any active attributes without a binding speci?ed
through BindAttribLocation will be automatically be bound to vertex attributes
by the GL. Such bindings can be queried using the command GetAttribLocation.
LinkProgram will fail if the assigned binding of an active attribute variable would
cause the GL to reference a non-existant generic attribute (one greater than or equal
to MAX VERTEX ATTRIBS). LinkProgram will fail if the attribute bindings as-
signed by BindAttribLocation do not leave not enough space to assign a location
for an active matrix attribute, which requires multiple contiguous generic attributes.
LinkProgram will also fail if the vertex shaders used in the program object contain
assignments (not removed during pre-processing) to an attribute variable bound to
generic attribute zero and to the conventional vertex position (gl Vertex).
BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name (except a name
starting with"gl ") to an index, including a name that is never used as an attribute
in any vertex shader object. Assigned bindings for attribute variables that do not
exist or are not active are ignored.
The values of generic attributes sent to generic attribute index i are part of
current state, just like the conventional attributes. If a new program object has
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 96
been made active, then these values will be tracked by the GL in such a way that
the same values will be observed by attributes in the new program object that are
also bound to indexi.
It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. A link error can occur if the linker determines that every path through the
shader consumes multiple aliased attributes, but implementations are not required
to generate an error in this case. The compiler and linker are allowed to assume that
no aliasing is done, and may employ optimizations that work only in the absence
of aliasing. It is not possible to alias generic attributes with conventional ones.
Uniform Variables
Shaders can declare named uniform variables, as described in the OpenGL Shading
Language Specification. Values for these uniforms are constant over a primitive,
and typically they are constant across many primitives. Uniforms are program
object-speci?c state. They retain their values once loaded, and their values are
restored whenever a program object is used, as long as the program object has not
been re-linked. A uniform is considered active if it is determined by the compiler
and linker that the uniform will actually be accessed when the executable code
is executed. In cases where the compiler and linker cannot make a conclusive
determination, the uniform will be considered active.
The amount of storage available for uniform variables accessed by
a vertex shader is speci?ed by the implementation dependent constant
MAX VERTEX UNIFORM COMPONENTS. This value represents the number of indi-
vidual ?oating-point, integer, or boolean values that can be held in uniform vari-
able storage for a vertex shader. A uniform matrix will consume no more than
4min(r;c) such values, wherer andc are the number of rows and columns in
the matrix. A link error will be generated if an attempt is made to utilize more than
the space available for vertex shader uniform variables.
When a program is successfully linked, all active uniforms belonging to the
program object are initialized as de?ned by the version of the OpenGL Shading
Language used to compile the program. A successful link will also generate a
location for each active uniform. The values of active uniforms can be changed
using this location and the appropriate Uniform* command (see below). These
locations are invalidated and new ones assigned after each successful re-link.
To ?nd the location of an active uniform variable within a program object, use
the command
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 97
int GetUniformLocation(uint program,const
char *name );
This command will return the location of uniform variable name. name must be a
null terminated string, without white space. The value -1 will be returned if name
does not correspond to an active uniform variable name in program or if name starts
with the reserved pre?x"gl ". If program has not been successfully linked, the
error INVALID OPERATION is generated. After a program is linked, the location
of a uniform variable will not change, unless the program is re-linked.
A valid name cannot be a structure, an array of structures, or any portion of
a single vector or a matrix. In order to identify a valid name, the "." (dot) and
"[]" operators can be used in name to specify a member of a structure or element
of an array.
The ?rst element of a uniform array is identi?ed using the name of the uniform
array appended with"[0]". Except if the last part of the string name indicates a
uniform array, then the location of the ?rst element of that array can be retrieved
by either using the name of the uniform array, or the name of the uniform array
appended with"[0]".
To determine the set of active uniform attributes used by a program, and to
determine their sizes and types, use the command:
void GetActiveUniform(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name );
This command provides information about the uniform selected by index. An in-
dex of 0 selects the ?rst active uniform, and an index of ACTIVE UNIFORMS  1
selects the last active uniform. The value of ACTIVE UNIFORMS can be queried
with GetProgramiv (see section 6.1.15). If index is greater than or equal to
ACTIVE UNIFORMS, the errorINVALID VALUE is generated. Note that index sim-
ply identi?es a member in a list of active uniforms, and has no relation to the
location assigned to the corresponding uniform variable.
The parameter program is a name of a program object for which the command
LinkProgram has been issued in the past. It is not necessary for program to have
been linked successfully. The link could have failed because the number of active
uniforms exceeded the limit.
If an error occurred, the return parameters length, size, type and name will be
unmodi?ed.
For the selected uniform, the uniform name is returned into name. The string
name will be null terminated. The actual number of characters written into name,
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 98
excluding the null terminator, is returned in length. If length isNULL, no length is
returned. The maximum number of characters that may be written into name, in-
cluding the null terminator, is speci?ed by bufSize. The returned uniform name
can be the name of built-in uniform state as well. The complete list of built-
in uniform state is described in section 7.5 of the OpenGL Shading Language
speci?cation. The length of the longest uniform name in program is given by
ACTIVE UNIFORM MAX LENGTH, which can be queried with GetProgramiv (see
section 6.1.15).
Each uniform variable, declared in a shader, is broken down into one or more
strings using the "." (dot) and "[]" operators, if necessary, to the point that it
is legal to pass each string back into GetUniformLocation. Each of these strings
constitutes one active uniform, and each string is assigned an index.
For the selected uniform, the type of the uniform is returned into type.
The size of the uniform is returned into size. The value in size is in units
of the type returned in type. The type returned can be any of FLOAT,
FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, INT, INT VEC2, INT VEC3,
INT VEC4, BOOL, BOOL VEC2, BOOL VEC3, BOOL VEC4, FLOAT MAT2,
FLOAT MAT3, FLOAT MAT4, FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2,
FLOAT MAT3x4, FLOAT MAT4x2, FLOAT MAT4x3, SAMPLER 1D, SAMPLER 2D,
SAMPLER 3D, SAMPLER CUBE, SAMPLER 1D SHADOW, SAMPLER 2D SHADOW,
SAMPLER 1D ARRAY, SAMPLER 2D ARRAY, SAMPLER 1D ARRAY SHADOW,
SAMPLER 2D ARRAY SHADOW, SAMPLER CUBE SHADOW, INT SAMPLER 1D,
INT SAMPLER 2D, INT SAMPLER 3D, INT SAMPLER CUBE,
INT SAMPLER 1D ARRAY, INT SAMPLER 2D ARRAY, UNSIGNED INT,
UNSIGNED INT VEC2, UNSIGNED INT VEC3, UNSIGNED INT VEC4,
UNSIGNED INT SAMPLER 1D, UNSIGNED INT SAMPLER 2D,
UNSIGNED INT SAMPLER 3D, UNSIGNED INT SAMPLER CUBE,
UNSIGNED INT SAMPLER 1D ARRAY, orUNSIGNED INT SAMPLER 2D ARRAY.
If one or more elements of an array are active, GetActiveUniform will return
the name of the array in name, subject to the restrictions listed above. The type of
the array is returned in type. The size parameter contains the highest array element
index used, plus one. The compiler or linker determines the highest index used.
There will be only one active uniform reported by the GL per uniform array.
GetActiveUniform will return as much information about active uniforms as
possible. If no information is available, length will be set to zero and name will be
an empty string. This situation could arise if GetActiveUniform is issued after a
failed link.
To load values into the uniform variables of the program object that is currently
in use, use the commands
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 99
void Uniformf1234gfifg(int location,T value );
void Uniformf1234gfifgv(int location,sizei count,
T value );
void Uniformf1,2,3,4gui(int location,T value );
void Uniformf1,2,3,4guiv(int location,sizei count,
T value );
void UniformMatrixf234gfv(int location,sizei count,
boolean transpose,const float *value );
void UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gfv(
int location,sizei count,boolean transpose,const
float *value );
The given values are loaded into the uniform variable location identi?ed by loca-
tion.
The Uniform*ffvg commands will load count sets of one to four ?oating-point
values into a uniform location de?ned as a ?oat, a ?oating-point vector, an array of
?oats, or an array of ?oating-point vectors.
The Uniform*ifvg commands will load count sets of one to four integer val-
ues into a uniform location de?ned as a sampler, an integer, an integer vector, an
array of samplers, an array of integers, or an array of integer vectors. Only the
Uniform1ifvg commands can be used to load sampler values (see below).
The Uniform*uifvg commands will load count sets of one to four unsigned
integer values into a uniform location de?ned as a unsigned integer, an unsigned
integer vector, an array of unsigned integers or an array of unsigned integer vectors.
The UniformMatrixf234gfv commands will load count 2 2, 3 3, or 4 4
matrices (corresponding to 2, 3, or 4 in the command name) of ?oating-point values
into a uniform location de?ned as a matrix or an array of matrices. If transpose
is FALSE, the matrix is speci?ed in column major order, otherwise in row major
order.
The UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gfv commands will load count
23, 32, 24, 42, 34, or 43 matrices (corresponding to the numbers in the
command name) of ?oating-point values into a uniform location de?ned as a matrix
or an array of matrices. The ?rst number in the command name is the number of
columns; the second is the number of rows. For example, UniformMatrix2x4fv
is used to load a matrix consisting of two columns and four rows. If transpose
is FALSE, the matrix is speci?ed in column major order, otherwise in row major
order.
When loading values for a uniform declared as a boolean, a boolean vector,
an array of booleans, or an array of boolean vectors, the Uniform*ifvg, Uni-
form*uifvg, and Uniform*ffvg set of commands can be used to load boolean
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 100
values. Type conversion is done by the GL. The uniform is set to FALSE if the
input value is 0 or 0.0f, and set toTRUE otherwise. The Uniform* command used
must match the size of the uniform, as declared in the shader. For example, to
load a uniform declared as abvec2, any of the Uniform2fif uig* commands may
be used. An INVALID OPERATION error will be generated if an attempt is made
to use a non-matching Uniform* command. In this example using Uniform1iv
would generate an error.
For all other uniform types the Uniform* command used must match the size
and type of the uniform, as declared in the shader. No type conversions are done.
For example, to load a uniform declared as a vec4, Uniform4ffvg must be used.
To load a 3x3 matrix, UniformMatrix3fv must be used. AnINVALID OPERATION
error will be generated if an attempt is made to use a non-matching Uniform*
command. In this example, using Uniform4ifvg would generate an error.
When loadingN elements starting at an arbitrary positionk in a uniform de-
clared as an array, elements k through k +N  1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
element index used, as reported by GetActiveUniform, will be ignored by the GL.
If the value of location is -1, the Uniform* commands will silently ignore the
data passed in, and the current uniform values will not be changed.
If any of the following conditions occur, anINVALID OPERATION error is gen-
erated by the Uniform* commands, and no uniform values are changed:
 if the size indicated in the name of the Uniform* command used does not
match the size of the uniform declared in the shader,
 if the uniform declared in the shader is not of type boolean and the type
indicated in the name of the Uniform* command used does not match the
type of the uniform,
 if count is greater than one, and the uniform declared in the shader is not an
array variable,
 if no variable with a location of location exists in the program object cur-
rently in use and location is not -1, or
 if there is no program object currently in use.
Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates
the texture image unit being accessed. Setting a sampler’s value toi selects texture
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 101
image unit number i. The values of i range from zero to the implementation-
dependent maximum supported number of texture image units.
The type of the sampler identi?es the target on the texture image unit. The
texture object bound to that texture image unit’s target is then used for the texture
lookup. For example, a variable of typesampler2D selects targetTEXTURE 2D on
its texture image unit. Binding of texture objects to targets is done as usual with
BindTexture. Selecting the texture image unit to bind to is done as usual with
ActiveTexture.
The location of a sampler needs to be queried with GetUniformLocation, just
like any uniform variable. Sampler values need to be set by calling Uniform1ifvg.
Loading samplers with any of the other Uniform* entry points is not allowed and
will result in anINVALID OPERATION error.
It is not allowed to have variables of different sampler types pointing to the
same texture image unit within a program object. This situation can only be de-
tected at the next rendering command issued, and an INVALID OPERATION error
will then be generated.
Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)
contained in the program object exceed the maximum allowable limits. If it de-
termines that the count of active samplers exceeds the allowable limits, then the
link fails (these limits can be different for different types of shaders). Each active
sampler variable counts against the limit, even if multiple samplers refer to the
same texture image unit. If this cannot be determined at link time, for example if
the program object only contains a vertex shader, then it will be determined at the
next rendering command issued, and an INVALID OPERATION error will then be
generated.
Varying Variables
A vertex shader may de?ne one or more varying variables (see the OpenGL Shad-
ing Language speci?cation). These values are expected to be interpolated across
the primitive being rendered. The OpenGL Shading Language speci?cation de?nes
a set of built-in varying variables for vertex shaders that correspond to the values
required for the ?xed-function processing that occurs after vertex processing.
The number of interpolators available for processing varying vari-
ables is given by the value of the implementation-dependent constant
MAX VARYING COMPONENTS. This value represents the number of individual
?oating-point values that can be interpolated; varying variables declared as vec-
tors, matrices, and arrays will all consume multiple interpolators. When a program
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 102
is linked, all components of any varying variable written by a vertex shader, read
by a fragment shader, or used for transform feedback will count against this limit.
The transformed vertex position (gl Position) is not a varying variable and does
not count against this limit. A program whose shaders access more than the value
ofMAX VARYING COMPONENTS components worth of varying variables may fail to
link, unless device-dependent optimizations are able to make the program ?t within
available hardware resources.
Each program object can specify a set of one or more varying variables to be
recorded in transform feedback mode with the command
void TransformFeedbackVaryings(uint program,
sizei count,const char **varyings,enum bufferMode );
program speci?es the program object. count speci?es the number of vary-
ing variables used for transform feedback. varyings is an array of count zero-
terminated strings specifying the names of the varying variables to use for
transform feedback. The varying variables speci?ed in varyings can be ei-
ther built-in varying variables (beginning with "gl ") or user-de?ned ones.
varying variables are written out in the order they appear in the array vary-
ings. bufferMode is either INTERLEAVED ATTRIBS or SEPARATE ATTRIBS,
and identi?es the mode used to capture the varying variables when transform
feedback is active. The error INVALID VALUE is generated if program is
not the name of a program object, or if bufferMode is SEPARATE ATTRIBS
and count is greater than the value of the implementation-dependent limit
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS.
The state set by TransformFeedbackVaryings has no effect on the execu-
tion of the program until program is subsequently linked. When LinkProgram is
called, the program is linked so that the values of the speci?ed varying variables
for the vertices of each primitive generated by the GL are written to a single buffer
object (if the buffer mode is INTERLEAVED ATTRIBS) or multiple buffer objects
(if the buffer mode isSEPARATE ATTRIBS). A program will fail to link if:
 the count speci?ed by TransformFeedbackVaryings is non-zero, but the
program object has no vertex shader;
 any variable name speci?ed in the varyings array is not declared as an output
in the vertex shader.
 any two entries in the varyings array specify the same varying variable;
 the total number of components
to capture in any varying variable in varyings is greater than the constant
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 103
MAX TRANSFORM FEEDBACK SEPARATE COMPONENTS and the buffer mode
isSEPARATE ATTRIBS; or
 the total number of components to capture is greater than the constant
MAX TRANSFORM FEEDBACK INTERLEAVED COMPONENTS and the buffer
mode isINTERLEAVED ATTRIBS.
To determine the set of varying variables in a linked program object that will
be captured in transform feedback mode, the command:
void GetTransformFeedbackVarying(uint program,
uint index,sizei bufSize,sizei *length,sizei *size,
enum *type,char *name );
provides information about the varying variable selected by index. An index of
0 selects the ?rst varying variable speci?ed in the varyings array of Transform-
FeedbackVaryings, and an index ofTRANSFORM FEEDBACK VARYINGS-1 selects
the last such varying variable. The value of TRANSFORM FEEDBACK VARYINGS
can be queried with GetProgramiv (see section 6.1.15). If index is greater than or
equal to TRANSFORM FEEDBACK VARYINGS, the error INVALID VALUE is gener-
ated. The parameter program is the name of a program object for which the com-
mand LinkProgram has been issued in the past. If a new set of varying variables is
speci?ed by TransformFeedbackVaryings after a program object has been linked,
the information returned by GetTransformFeedbackVarying will not re?ect those
variables until the program is re-linked.
The name of the selected varying is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null
terminator, is returned in length. If length is NULL, no length is returned. The
maximum number of characters that may be written into name, including the null
terminator, is speci?ed by bufSize. The returned varying name can be the name
of a user de?ned varying variable or the name of a built- in varying (which be-
gin with the pre?x gl , see the OpenGL Shading Language speci?cation for a
complete list). The length of the longest varying name in program is given by
TRANSFORM FEEDBACK VARYING MAX LENGTH, which can be queried with Get-
Programiv (see section 6.1.15).
For the selected varying variable, its type is returned into type. The size of the
varying is returned into size. The value in size is in units of the type returned in type.
The type returned can be any ofFLOAT,FLOAT VEC2,FLOAT VEC3,FLOAT VEC4,
INT, INT VEC2, INT VEC3, INT VEC4, UNSIGNED INT, UNSIGNED INT VEC2,
UNSIGNED INT VEC3, UNSIGNED INT VEC4, FLOAT MAT2, FLOAT MAT3, or
FLOAT MAT4. If an error occurred, the return parameters length, size, type and
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 104
name will be unmodi?ed. This command will return as much information about
the varying variables as possible. If no information is available, length will be set
to zero and name will be an empty string. This situation could arise if GetTrans-
formFeedbackVarying is called after a failed link.
2.20.4 Shader Execution
If a successfully linked program object that contains a vertex shader is made current
by calling UseProgram, the executable version of the vertex shader is used to
process incoming vertex values rather than the ?xed-function vertex processing
described in sections 2.12 through 2.19. In particular,
 The model-view and projection matrices are not applied to vertex coordi-
nates (section 2.12).
 The texture matrices are not applied to texture coordinates (section 2.12.2).
 Normals are not transformed to eye coordinates, and are not rescaled or nor-
malized (section 2.12.3).
 Normalization of AUTO NORMAL evaluated normals is not performed. (sec-
tion 5.1).
 Texture coordinates are not generated automatically (section 2.12.4).
 Per vertex lighting is not performed (section 2.19.1).
 Color material computations are not performed (section 2.19.3).
 Color index lighting is not performed (section 2.19.5).
 All of the above applies when setting the current raster position (sec-
tion 2.18).
The following operations are applied to vertex values that are the result of
executing the vertex shader:
 Color clamping or masking (section 2.19.6).
 Perspective division on clip coordinates (section 2.12).
 Viewport mapping, including depth range scaling (section 2.12.1).
 Clipping, including client-de?ned clip planes (section 2.17).
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 105
 Front face determination (section 2.19.1).
 Flat-shading (section 2.19.7).
 Color, texture coordinate, fog, point-size and generic attribute clipping (sec-
tion 2.19.8).
 Final color processing (section 2.19.9.
There are several special considerations for vertex shader execution described
in the following sections.
Shader Only Texturing
This section describes texture functionality that is only accessible through vertex or
fragment shaders. Also refer to section 3.9 and to the OpenGL Shading Language
Specification, section 8.7.
Additional OpenGL Shading Language texture lookup functions (see section
8.7 of the OpenGL Shading Language Specification) return either signed or un-
signed integer values if the internal format of the texture is signed or unsigned,
respectively.
Texel Fetches
The OpenGL Shading Language texel fetch functions provide the ability to
extract a single texel from a speci?ed texture image. The integer coordinates passed
to the texel fetch functions are used directly as the texel coordinates (i;j;k) into the
texture image. This in turn means the texture image is point-sampled (no ?ltering
is performed).
The level of detail accessed is computed by adding the speci?ed level-of-detail
parameter lod to the base level of the texture,level .
base
The texel fetch functions can not perform depth comparisons or access cube
maps. Unlike ?ltered texel accesses, texel fetches do not support LOD clamping or
any texture wrap mode, and require a mipmapped mini?cation ?lter to access any
level of detail other than the base level.
The results of the texel fetch are unde?ned if any of the following conditions
hold:
 the computed LOD is less than the texture’s base level (level ) or greater
base
than the maximum level (level )
max
 the computed LOD is not the texture’s base level and the texture’s mini?ca-
tion ?lter isNEAREST orLINEAR
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 106
 the layer speci?ed for array textures is negative or greater than the number
of layers in the array texture,
 the texel coordinates (i;j;k) refer to a border texel outside the de?ned ex-
tents of the speci?ed LOD, where any of
i< b iw  b
s s s
j < b jh  b
s s s
k< b kd  b
s s s
and the size parametersw ,h ,d , andb refer to the width, height, depth,
s s s s
and border size of the image, as in equations 3.15
 the texture being accessed is not complete (or cube complete for cubemaps).
Texture Size Query
The OpenGL Shading Language texture size functions provide the ability to
query the size of a texture image. The LOD value lod passed in as an argument
to the texture size functions is added to the level of the texture to determine
base
a texture image level. The dimensions of that image level, excluding a possible
border, are then returned. If the computed texture image level is outside the range
[level ;level ], the results are unde?ned. When querying the size of an array
max
base
texture, both the dimensions and the layer index are returned.
Texture Access
Vertex shaders have the ability to do a lookup into a texture map, if sup-
ported by the GL implementation. The maximum number of texture image units
available to a vertex shader is MAX VERTEX TEXTURE IMAGE UNITS; a maxi-
mum number of zero indicates that the GL implemenation does not support
texture accesses in vertex shaders. The maximum number of texture image
units available to the fragment stage of the GL is MAX TEXTURE IMAGE UNITS.
Both the vertex shader and fragment processing combined cannot use more
than MAX COMBINED TEXTURE IMAGE UNITS texture image units. If both
the vertex shader and the fragment processing stage access the same texture
image unit, then that counts as using two texture image units against the
MAX COMBINED TEXTURE IMAGE UNITS limit.
When a texture lookup is performed in a vertex shader, the ?ltered texture value
 is computed in the manner described in sections 3.9.7 and 3.9.8, and converted
it to a texture source color C according to table 3.23 (section 3.9.13). A four-
s
component vector (R ;G ;B ;A ) is returned to the vertex shader.
s s s s
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 107
In a vertex shader, it is not possible to perform automatic level-of-detail calcu-
lations using partial derivatives of the texture coordinates with respect to window
coordinates as described in section 3.9.7. Hence, there is no automatic selection of
an image array level. Minification or magni?cation of a texture map is controlled
by a level-of-detail value optionally passed as an argument in the texture lookup
functions. If the texture lookup function supplies an explicit level-of-detail valuel,
then the pre-bias level-of-detail value (x;y) =l (replacing equation 3.16). If
base
the texture lookup function does not supply an explicit level-of-detail value, then
 (x;y) = 0. The scale factor(x;y) and its approximation functionf(x;y)
base
(see equation 3.20) are ignored.
Texture lookups involving textures with depth component data can either re-
turn the depth data directly or return the results of a comparison with a refer-
ence depth value speci?ed in the coordinates passed to the texture lookup func-
tion, as described in section 3.9.14. The comparison operation is requested in the
shader by using any of the shadow sampler types and in the texture using the
TEXTURE COMPARE MODE parameter. These requests must be consistent; the re-
sults of a texture lookup are unde?ned if:
 The sampler used in a texture lookup function is not one of the shadow
sampler types, the texture object’s internal format isDEPTH COMPONENT or
DEPTH STENCIL, and theTEXTURE COMPARE MODE is notNONE.
 The sampler used in a texture lookup function is one of the shadow sam-
pler types, the texture object’s internal format is DEPTH COMPONENT or
DEPTH STENCIL, and theTEXTURE COMPARE MODE isNONE.
 The sampler used in a texture lookup function is one of the shadow sampler
types, and the texture object’s internal format is notDEPTH COMPONENT or
DEPTH STENCIL.
The stencil index texture internal component is ignored if the base internal
format isDEPTH STENCIL.
If a vertex shader uses a sampler where the associated texture object is not com-
plete, as de?ned in section 3.9.10, the texture image unit will return (R;G;B;A)
= (0; 0; 0; 1).
Shader Inputs
Besides having access to vertex attributes and uniform variables, vertex shaders can
access the read-only built-in variablegl VertexID.gl VertexID holds the inte-
ger indexi explicitly passed to ArrayElement to specify the vertex, or implicitly
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 108
passed by the DrawArrays, MultiDrawArrays, DrawElements, MultiDrawEle-
ments, and DrawRangeElements commands. The value of gl VertexID is de-
?ned if and only if:
 the vertex comes from a vertex array command that speci?es a com-
plete primitive (DrawArrays, MultiDrawArrays, DrawElements, Mul-
tiDrawElements, or DrawRangeElements)
 all enabled vertex arrays have non-zero buffer object bindings, and
 the vertex does not come from a display list, even if the display list was
compiled using one of the vertex array commands described above with data
sourced from buffer objects.
Also see section 7.1 of the OpenGL Shading Language Specification.
Shader Outputs
A vertex shader can write to built-in as well as user-de?ned varying variables.
These values are expected to be interpolated across the primitive it outputs, un-
less they are speci?ed to be ?at shaded. Refer to section 2.19.7 and the OpenGL
Shading Language speci?cation sections 4.3.6, 7.1 and 7.6 for more detail.
The built-in output variables gl FrontColor, gl BackColor,
gl FrontSecondaryColor, and gl BackSecondaryColor hold the front and
back colors for the primary and secondary colors for the current vertex.
The built-in output variable gl TexCoord[] is an array and holds the set of
texture coordinates for the current vertex.
The built-in output variablegl FogFragCoord is used as thec value described
in section 3.11.
The built-in special variable gl Position is intended to hold the homoge-
neous vertex position. Writinggl Position is optional.
The built-in special variables gl ClipVertex and gl ClipDistance re-
spectively hold the vertex coordinate and clip distance(s) used in the clip-
ping stage, as described in section 2.17. If clipping is enabled, only one of
gl ClipVertex andgl ClipDistance should be written.
The built in special variable gl PointSize, if written, holds the size of the
point to be rasterized, measured in pixels.
Position Invariance
If a vertex shader uses the built-in functionftransform to generate a vertex posi-
tion, then this generally guarantees that the transformed position will be the same
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 109
whether using this vertex shader or the ?xed-function pipeline. This allows for cor-
rect multi-pass rendering algorithms, where some passes use ?xed-function vertex
transformation and other passes use a vertex shader. If a vertex shader does not use
ftransform to generate a position, transformed positions are not guaranteed to
match, even if the sequence of instructions used to compute the position match the
sequence of transformations described in section 2.12.
Validation
It is not always possible to determine at link time if a program object actually
will execute. Therefore validation is done when the ?rst rendering command is
issued, to determine if the currently active program object can be executed. If
it cannot be executed then no fragments will be rendered, and Begin, Raster-
Pos, or any command that performs an implicit Begin will generate the error
INVALID OPERATION.
This error is generated by Begin, RasterPos, or any command that performs
an implicit Begin if:
 any two active samplers in the current program object are of different types,
but refer to the same texture image unit,
 any active sampler in the current program object refers to a texture image
unit where ?xed-function fragment processing accesses a texture target that
does not match the sampler type, or
 the sum of the number of active samplers in the program and the number of
texture image units enabled for ?xed-function fragment processing exceeds
the combined limit on the total number of texture image units allowed.
Fixed-function fragment processing operations will be performed if the pro-
gram object in use has no fragment shader.
The INVALID OPERATION error reported by these rendering commands may
not provide enough information to ?nd out why the currently active program object
would not execute. No information at all is available about a program object that
would still execute, but is inef?cient or suboptimal given the current GL state. As
a development aid, use the command
void ValidateProgram(uint program );
to validate the program object program against the current GL state. Each program
object has a boolean status, VALIDATE STATUS, that is modi?ed as a result of
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 110
validation. This status can be queried with GetProgramiv (see section 6.1.15).
If validation succeeded this status will be set to TRUE, otherwise it will be set to
FALSE. If validation succeeded the program object is guaranteed to execute, given
the current GL state. If validation failed, the program object is guaranteed to not
execute, given the current GL state.
ValidateProgram will check for all the conditions that could lead to an
INVALID OPERATION error when rendering commands are issued, and may check
for other conditions as well. For example, it could give a hint on how to optimize
some piece of shader code. The information log of program is overwritten with
information on the results of the validation, which could be an empty string. The
results written to the information log are typically only useful during application
development; an application should not expect different GL implementations to
produce identical information.
A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tions should ensure that all valid shaders and program objects may be successfully
compiled, linked and executed.
Unde?ned Behavior
When using array or matrix variables in a shader, it is possible to access a vari-
able with an index computed at run time that is outside the declared extent of the
variable. Such out-of-bounds reads will return unde?ned values; out-of-bounds
writes will have unde?ned results and could corrupt other variables used by shader
or the GL. The level of protection provided against such errors in the shader is
implementation-dependent.
2.20.5 Required State
The GL maintains state to indicate which shader and program object names are in
use. Initially, no shader or program objects exist, and no names are in use.
The state required per shader object consists of:
 An unsigned integer specifying the shader object name.
 An integer holding the value ofSHADER TYPE.
 A boolean holding the delete status, initiallyFALSE.
 A boolean holding the status of the last compile, initiallyFALSE.
 An array of typechar containing the information log, initially empty.
Version 3.0 (September 23, 2008)2.20. VERTEXSHADERS 111
 An integer holding the length of the information log.
 An array of type char containing the concatenated shader string, initially
empty.
 An integer holding the length of the concatenated shader string.
The state required per program object consists of:
 An unsigned integer indicating the program object object name.
 A boolean holding the delete status, initiallyFALSE.
 A boolean holding the status of the last link attempt, initiallyFALSE.
 A boolean holding the status of the last validation attempt, initallyFALSE.
 An integer holding the number of attached shader objects.
 A list of unsigned integers to keep track of the names of the shader objects
attached.
 An array of typechar containing the information log, initially empty.
 An integer holding the length of the information log.
 An integer holding the number of active uniforms.
 For each active uniform, three integers, holding its location, size, and type,
and an array of typechar holding its name.
 An array of words that hold the values of each active uniform.
 An integer holding the number of active attributes.
 For each active attribute, three integers holding its location, size, and type,
and an array of typechar holding its name.
Additional state required to support vertex shaders consists of:
 A bit indicating whether or not vertex program two-sided color mode is en-
abled, initially disabled.
 A bit indicating whether or not vertex program point size mode (sec-
tion 3.4.1) is enabled, initially disabled.
Additionally, one unsigned integer is required to hold the name of the current pro-
gram object, if any.
Version 3.0 (September 23, 2008)Chapter 3
Rasterization
Rasterization is the process by which a primitive is converted to a two-dimensional
image. Each point of this image contains such information as color and depth.
Thus, rasterizing a primitive consists of two parts. The ?rst is to determine which
squares of an integer grid in window coordinates are occupied by the primitive. The
second is assigning a depth value and one or more color values to each such square.
The results of this process are passed on to the next stage of the GL (per-fragment
operations), which uses the information to update the appropriate locations in the
framebuffer. Figure 3.1 diagrams the rasterization process. The color values as-
signed to a fragment are initially determined by the rasterization operations (sec-
tions 3.4 through 3.8) and modi?ed by either the execution of the texturing, color
sum, and fog operations de?ned in sections 3.9, 3.10, and 3.11, or by a fragment
shader as de?ned in section 3.12. The ?nal depth value is initially determined by
the rasterization operations and may be modi?ed or replaced by a fragment shader.
The results from rasterizing a point, line, polygon, pixel rectangle or bitmap can be
routed through a fragment shader.
A grid square along with its parameters of assigned colors,z (depth), fog coor-
dinate, and texture coordinates is called a fragment; the parameters are collectively
dubbed the fragment’s associated data. A fragment is located by its lower left cor-
ner, which lies on integer grid coordinates. Rasterization operations also refer to a
fragment’s center, which is offset by (1=2; 1=2) from its lower left corner (and so
lies on half-integer coordinates).
Grid squares need not actually be square in the GL. Rasterization rules are not
affected by the actual aspect ratio of the grid squares. Display of non-square grids,
however, will cause rasterized points and line segments to appear fatter in one
direction than the other. We assume that fragments are square, since it simpli?es
antialiasing and texturing.
112113
FRAGMENT_PROGRAM enable
Point
Rasterization
From
Line
Primitive
Rasterization
Fragment
Assembly
Texturing
Program
Polygon
Rasterization
Color Sum
Pixel
DrawPixels
Rectangle
Rasterization
Bitmap Fog
Bitmap
Rasterization
Fragments
Figure 3.1. Rasterization.
Version 3.0 (September 23, 2008)3.1. DISCARDINGPRIMITIVESBEFORERASTERIZATION 114
Several factors affect rasterization. Primitives may be discarded before ras-
terization. Lines and polygons may be stippled. Points may be given differing
diameters and line segments differing widths. A point, line segment, or polygon
may be antialiased.
3.1 Discarding Primitives Before Rasterization
Primitives can be optionally discarded before rasterization by calling Enable and
Disable withRASTERIZER DISCARD. When enabled, primitives are discarded im-
mediately before the rasterization stage, but after the optional transform feedback
stage (see section 2.15). When disabled, primitives are passed through to the ras-
terization stage to be processed normally. RASTERIZER DISCARD also affects the
DrawPixels, CopyPixels, Bitmap, Clear and Accum commands.
3.2 Invariance
0
Consider a primitivep obtained by translating a primitivep through an offset (x;y)
0
in window coordinates, wherex andy are integers. As long as neitherp norp is
0 0
clipped, it must be the case that each fragmentf produced fromp is identical to
0
a corresponding fragmentf fromp except that the center off is offset by (x;y)
from the center off.
3.3 Antialiasing
Antialiasing of a point, line, or polygon is effected in one of two ways depending
on whether the GL is in RGBA or color index mode.
In RGBA mode, the R, G, and B values of the rasterized fragment are left
unaffected, but the A value is multiplied by a ?oating-point value in the range
[0; 1] that describes a fragment’s screen pixel coverage. The per-fragment stage of
the GL can be set up to use the A value to blend the incoming fragment with the
corresponding pixel already present in the framebuffer.
In color index mode, the least signi?cantb bits (to the left of the binary point)
of the color index are used for antialiasing;b = minf4;mg, wherem is the number
of bits in the color index portion of the framebuffer. The antialiasing process sets
theseb bits based on the fragment’s coverage value: the bits are set to zero for no
coverage and to all ones for complete coverage.
The details of how antialiased fragment coverage values are computed are dif-
?cult to specify in general. The reason is that high-quality antialiasing may take
Version 3.0 (September 23, 2008)3.3. ANTIALIASING 115
into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
ber of grid squares neighboring the one corresponding to the fragment, and not just
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
not entirely accurate coverage computation.
In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of
uniform intensity. The square is called a fragment square and has lower left corner
(x;y) and upper right corner (x+1;y+1). We recognize that this simple box ?lter
may not produce the most favorable antialiasing results, but it provides a simple,
well-de?ned model.
A GL implementation may use other methods to perform antialiasing, subject
to the following conditions:
1. Iff andf are two fragments, and the portion off covered by some prim-
1 2 1
itive is a subset of the corresponding portion off covered by the primitive,
2
then the coverage computed forf must be less than or equal to that com-
1
puted forf .
2
2. The coverage computation for a fragment f must be local: it may depend
only onf’s relationship to the boundary of the primitive being rasterized. It
may not depend onf’sx andy coordinates.
Another property that is desirable, but not required, is:
3. The sum of the coverage values for all fragments produced by rasterizing a
particular primitive must be constant, independent of any rigid motions in
window coordinates, as long as none of those fragments lies along window
edges.
In some implementations, varying degrees of antialiasing quality may be obtained
by providing GL hints (section 5.7), allowing a user to make an image quality
versus speed tradeoff.
3.3.1 Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, poly-
gons, bitmaps, and images. The technique is to sample all primitives multiple times
Version 3.0 (September 23, 2008)3.3. ANTIALIASING 116
at each pixel. The color sample values are resolved to a single, displayable color
each time a pixel is updated, so the antialiasing appears to be automatic at the
application level. Because each sample includes color, depth, and stencil informa-
tion, the color (including texture operation), depth, and stencil functions perform
equivalently to the single-sample mode.
An additional buffer, called the multisample buffer, is added to the framebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.
Color buffers (left, right, front, back, and aux) do coexist with the multisample
buffer, however.
Multisample antialiasing is most valuable for rendering polygons, because it
requires no sorting for hidden surface elimination, and it correctly handles adjacent
polygons, object silhouettes, and even intersecting polygons. If only points or
lines are being rendered, the “smooth” antialiasing mechanism provided by the
base GL may result in a higher quality image. This mechanism is designed to
allow multisample and smooth antialiasing techniques to be alternated during the
rendering of a single scene.
If the value of SAMPLE BUFFERS is one, the rasterization of all primi-
tives is changed, and is referred to as multisample rasterization. Otherwise,
primitive rasterization is referred to as single-sample rasterization. The value
of SAMPLE BUFFERS is queried by calling GetIntegerv with pname set to
SAMPLE BUFFERS.
During multisample rendering the contents of a pixel fragment are changed
in two ways. First, each fragment includes a coverage value with SAMPLES bits.
The value ofSAMPLES is an implementation-dependent constant, and is queried by
calling GetIntegerv with pname set toSAMPLES.
Second, each fragment includesSAMPLES depth values, color values, and sets
of texture coordinates, instead of the single depth value, color value, and set of
texture coordinates that is maintained in single-sample rendering mode. An imple-
mentation may choose to assign the same color value and the same set of texture
coordinates to more than one sample. The location for evaluating the color value
and the set of texture coordinates can be anywhere within the pixel including the
fragment center or any of the sample locations. The color value and the set of tex-
ture coordinates need not be evaluated at the same location. Each pixel fragment
thus consists of integer x and y grid coordinates,SAMPLES color and depth values,
SAMPLES sets of texture coordinates, and a coverage value with a maximum of
SAMPLES bits.
Multisample rasterization is enabled or disabled by calling Enable or Disable
Version 3.0 (September 23, 2008)3.4. POINTS 117
with the symbolic constantMULTISAMPLE.
If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signed by single-sample rasterization, or they may be assigned as described below
for multisample rasterization.
IfMULTISAMPLE is enabled, multisample rasterization of all primitives differs
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has SAMPLES locations associated with it. These locations are
exact positions, rather than regions or areas, and each is referred to as a sample
point. The sample points associated with a pixel may be located inside or outside
of the unit square that is considered to bound the pixel. Furthermore, the relative
locations of sample points may be identical for each pixel in the framebuffer, or
they may differ.
If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position speci?c.
The invariance requirement described in section 3.2 is relaxed for all multisample
rasterization, because the sample locations may be a function of pixel location.
It is not possible to query the actual sample locations of a pixel.
3.4 Points
If a vertex shader is not active, then the rasterization of points is controlled with
void PointSize(float size );
size speci?es the requested size of a point. The default value is 1.0. A value less
than or equal to zero results in the errorINVALID VALUE.
The requested point size is multiplied with a distance attenuation factor,
clamped to a speci?ed point size range, and further clamped to the implementation-
dependent point size range to produce the derived point size:
s
 !
 
1
derived size =clamp size
2
a +bd +cd
whered is the eye-coordinate distance from the eye, (0; 0; 0; 1) in eye coordinates,
to the vertex, anda,b, andc are distance attenuation function coef?cients.
If multisampling is not enabled, the derived size is passed on to rasterization as
the point width.
Version 3.0 (September 23, 2008)3.4. POINTS 118
If a vertex shader is active and vertex program point size mode is enabled,
then the derived point size is taken from the (potentially clipped) shader built-in
gl PointSize and clamped to the implementation-dependent point size range. If
the value written togl PointSize is less than or equal to zero, results are unde-
?ned. If a vertex shader is active and vertex program point size mode is disabled,
then the derived point size is taken from the point size state as speci?ed by the
PointSize command. In this case no distance attenuation is performed. Vertex pro-
gram point size mode is enabled and disabled by calling Enable or Disable with
the symbolic valueVERTEX PROGRAM POINT SIZE.
If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 3.14) instead of allowing the point width to go below a given
threshold. In this case, the width of the rasterized point is

derived size derived sizethreshold
width = (3.1)
threshold otherwise
and the fade factor is computed as follows:
(
1 derived sizethreshold
fade =    (3.2)
2
derived size
otherwise
threshold
The distance attenuation function coef?cientsa,b, andc, the bounds of the ?rst
point size range clamp, and the point fadethreshold, are speci?ed with
void PointParameterfifg(enum pname,T param );
void PointParameterfifgv(enum pname,const T params );
If pname is POINT SIZE MIN or POINT SIZE MAX, then param speci-
?es, or params points to the lower or upper bound respectively to which
the derived point size is clamped. If the lower bound is greater than
the upper bound, the point size after clamping is unde?ned. If pname is
POINT DISTANCE ATTENUATION, then params points to the coef?cients a, b,
and c. If pname is POINT FADE THRESHOLD SIZE, then param speci?es,
or params points to the point fade threshold. Values of POINT SIZE MIN,
POINT SIZE MAX, or POINT FADE THRESHOLD SIZE less than zero result in the
errorINVALID VALUE.
Point antialiasing is enabled or disabled by calling Enable or Disable with the
symbolic constantPOINT SMOOTH. The default state is for point antialiasing to be
disabled.
Point sprites are enabled or disabled by calling Enable or Disable with the
symbolic constant POINT SPRITE. The default state is for point sprites to be dis-
Version 3.0 (September 23, 2008)3.4. POINTS 119
abled. When point sprites are enabled, the state of the point antialiasing enable is
ignored.
The point sprite texture coordinate replacement mode is set with one of the Tex-
Env* commands described in section 3.9.13, where target is POINT SPRITE and
pname is COORD REPLACE. The possible values for param are FALSE and TRUE.
The default value for each texture coordinate set is for point sprite texture coordi-
nate replacement to be disabled.
The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT SPRITE COORD ORIGIN and param is
LOWER LEFT orUPPER LEFT. The default value isUPPER LEFT.
3.4.1 Basic Point Rasterization
In the default state, a point is rasterized by truncating itsx andy coordinates
w w
(recall that the subscripts indicate that these arex andy window coordinates) to
integers. This (x;y) address, along with data derived from the data associated
with the vertex corresponding to the point, is sent as a single fragment to the per-
fragment stage of the GL.
The effect of a point width other than 1:0 depends on the state of point antialias-
ing and point sprites. If antialiasing and point sprites are disabled, the actual width
is determined by rounding the supplied width to the nearest integer, then clamp-
ing it to the implementation-dependent maximum non-antialiased point width.
This implementation-dependent value must be no less than the implementation-
dependent maximum antialiased point width, rounded to the nearest integer value,
and in any event no less than 1. If rounding the speci?ed width results in the value
0, then it is as if the value were 1. If the resulting width is odd, then the point
1 1
(x;y) = (bx c + ;by c + )
w w
2 2
is computed from the vertex’sx andy , and a square grid of the odd width cen-
w w
tered at (x;y) de?nes the centers of the rasterized fragments (recall that fragment
centers lie at half-integer window coordinate values). If the width is even, then the
center point is
1 1
(x;y) = (bx + c;by + c);
w w
2 2
the rasterized fragment centers are the half-integer window coordinate values
within the square of the even width centered on (x;y). See ?gure 3.2.
Version 3.0 (September 23, 2008)3.4. POINTS 120
5.5
4.5
     
           
3.5
     
2.5
1.5
0.5
0.5 1.5 2.5 3.5 4.5 5.5 0.5 1.5 2.5 3.5 4.5 5.5
Odd Width Even Width
Figure 3.2. Rasterization of non-antialiased wide points. The crosses show fragment
centers produced by rasterization for any point that lies within the shaded region.
The dotted grid lines lie on half-integer coordinates.
Version 3.0 (September 23, 2008)3.4. POINTS 121
6.0
5.0
                             
                             
                             
                             
4.0
                             
                             
                             
                             
3.0
                             
                             
                             
                             
2.0
                             
                             
                             
                             
1.0
0.0
0.0 1.0 2.0 3.0 4.0 5.0 6.0
Figure 3.3. Rasterization of antialiased wide points. The black dot indicates the
point to be rasterized. The shaded region has the speci?ed width. The X marks
indicate those fragment centers produced by rasterization. A fragment’s computed
coverage value is based on the portion of the shaded region that covers the corre-
sponding fragment square. Solid lines lie on integer coordinates.
Version 3.0 (September 23, 2008)3.4. POINTS 122
All fragments produced in rasterizing a non-antialiased point are assigned the
same associated data, which are those of the vertex corresponding to the point.
If antialiasing is enabled and point sprites are disabled, then point rasterization
produces a fragment for each fragment square that intersects the region lying within
the circle having diameter equal to the current point width and centered at the
point’s (x ;y ) (?gure 3.3). The coverage value for each fragment is the window
w w
coordinate area of the intersection of the circular region with the corresponding
fragment square (but see section 3.3). This value is saved and used in the ?nal
step of rasterization (section 3.13). The data associated with each fragment are
otherwise the data associated with the point being rasterized.
Not all widths need be supported when point antialiasing is on, but the width
1:0 must be provided. If an unsupported width is requested, the nearest supported
width is used instead. The range of supported widths and the width of evenly-
spaced gradations within that range are implementation dependent. The range and
gradations may be obtained using the query mechanism described in chapter 6. If,
for instance, the width range is from 0.1 to 2.0 and the gradation width is 0.1, then
the widths 0:1; 0:2;:::; 1:9; 2:0 are supported.
If point sprites are enabled, then point rasterization produces a fragment for
each framebuffer pixel whose center lies inside a square centered at the point’s
(x ;y ), with side length equal to the current point size.
w w
All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. How-
ever, for each texture coordinate set where COORD REPLACE is TRUE, these
texture coordinates are replaced with point sprite texture coordinates. The s
coordinate varies from 0 to 1 across the point horizontally left-to-right. If
POINT SPRITE COORD ORIGIN is LOWER LEFT, the t coordinate varies from 0
to 1 vertically bottom-to-top. Otherwise if the point sprite texture coordinate ori-
gin is UPPER LEFT, the t coordinate varies from 0 to 1 vertically top-to-bottom.
Ther andq coordinates are replaced with the constants 0 and 1, respectively.
The following formula is used to evaluate thes andt coordinates:
  
1
x +  x
1
f w
2
s = + (3.3)
2 size
8
1
(y +  y )
< f w
1
2
+ ;POINT SPRITE COORD ORIGIN = LOWER LEFT
2 size
t =
1
y +  y
( f w)
: 1
2
  ;POINT SPRITE COORD ORIGIN = UPPER LEFT
2 size
(3.4)
wheresize is the point’s size,x andy are the (integral) window coordinates of
f f
the fragment, andx andy are the exact, unrounded window coordinates of the
w w
Version 3.0 (September 23, 2008)3.5. LINESEGMENTS 123
vertex for the point.
The widths supported for point sprites must be a superset of those supported
for antialiased points. There is no requirement that these widths must be equally
spaced. If an unsupported width is requested, the nearest supported width is used
instead.
3.4.2 Point Rasterization State
The state required to control point rasterization consists of the ?oating-point point
width, three ?oating-point values specifying the minimum and maximum point size
and the point fade threshold size, three ?oating-point values specifying the distance
attenuation coef?cients, a bit indicating whether or not antialiasing is enabled, a bit
for the point sprite texture coordinate replacement mode for each texture coordinate
set, and a bit for the point sprite texture coordinate origin.
3.4.3 Point Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE BUFFERS is one, then points
are rasterized using the following algorithm, regardless of whether point antialias-
ing (POINT SMOOTH) is enabled or disabled. Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (x ;y ). This region is a circle having diameter
w w
equal to the current point width if POINT SPRITE is disabled, or a square with
side equal to the current point width if POINT SPRITE is enabled. Coverage bits
that correspond to sample points that intersect the region are 1, other coverage bits
are 0. All data associated with each sample for the fragment are the data associ-
ated with the point being rasterized, with the exception of texture coordinates when
POINT SPRITE is enabled; these texture coordinates are computed as described in
section 3.4.
Point size range and number of gradations are equivalent to those supported
for antialiased points when POINT SPRITE is disabled. The set of point sizes
supported is equivalent to those for point sprites without multisample when
POINT SPRITE is enabled.
3.5 Line Segments
A line segment results from a line strip Begin/End object, a line loop, or a se-
ries of separate line segments. Line segment rasterization is controlled by several
variables. Line width, which may be set by calling
Version 3.0 (September 23, 2008)3.5. LINESEGMENTS 124
void LineWidth(float width );
with an appropriate positive ?oating-point width, controls the width of rasterized
line segments. The default width is 1:0. Values less than or equal to 0:0 generate
the error INVALID VALUE. Antialiasing is controlled with Enable and Disable
using the symbolic constantLINE SMOOTH. Finally, line segments may be stippled.
Stippling is controlled by a GL command that sets a stipple pattern (see below).
3.5.1 Basic Line Segment Rasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major. x-major line segments have slope in the closed interval [ 1; 1]; all
other line segments arey-major (slope is determined by the segment’s endpoints).
We shall specify rasterization only forx-major segments except in cases where the
modi?cations fory-major segments are not self-evident.
Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
are produced by rasterizing a line segment. For each fragmentf with center at win-
dow coordinatesx andy , de?ne a diamond-shaped region that is the intersection
f f
of four half planes:
R =f (x;y)jjx xj +jy yj< 1=2:g
f f f
Essentially, a line segment starting atp and ending atp produces those frag-
a b
mentsf for which the segment intersectsR , except ifp is contained inR . See
f b f
?gure 3.4.
To avoid dif?culties when an endpoint lies on a boundary ofR we (in princi-
f
ple) perturb the supplied endpoints by a tiny amount. Letp andp have window
a b
0
coordinates (x ;y ) and (x ;y ), respectively. Obtain the perturbed endpointsp
a a b b
a
2 0 2
given by (x ;y )  (; ) andp given by (x ;y )  (; ). Rasterizing the line
a a b b
b
segment starting atp and ending atp produces those fragmentsf for which the
a b
0 0 0
segment starting atp and ending onp intersectsR , except ifp is contained in
f
a
b b
R .  is chosen to be so small that rasterizing the line segment produces the same
f
fragments when is substituted for for any 0<.
When p and p lie on fragment centers, this characterization of fragments
a b
reduces to Bresenham’s algorithm with one modi?cation: lines produced in this
description are “half-open,” meaning that the ?nal fragment (corresponding top )
b
is not drawn. This means that when rasterizing a series of connected line segments,
shared endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).
Because the initial and ?nal conditions of the diamond-exit rule may be dif?cult
to implement, other line segment rasterization algorithms are allowed, subject to
the following rules:
Version 3.0 (September 23, 2008)3.5. LINESEGMENTS 125
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
Figure 3.4. Visualization of Bresenham’s algorithm. A portion of a line segment is
shown. A diamond shaped region of height 1 is placed around each fragment center;
those regions that the line segment exits cause rasterization to produce correspond-
ing fragments.
1. The coordinates of a fragment produced by the algorithm may not deviate by
more than one unit in eitherx ory window coordinates from a corresponding
fragment produced by the diamond-exit rule.
2. The total number of fragments produced by the algorithm may differ from
that produced by the diamond-exit rule by no more than one.
3. For anx-major line, no two fragments may be produced that lie in the same
window-coordinate column (for ay-major line, no two fragments may ap-
pear in the same row).
4. If two line segments share a common endpoint, and both segments are either
x-major (both left-to-right or both right-to-left) ory-major (both bottom-to-
top or both top-to-bottom), then rasterizing both segments may not produce
duplicate fragments, nor may any fragments be omitted so as to interrupt
continuity of the connected segments.
Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given
Version 3.0 (September 23, 2008)3.5. LINESEGMENTS 126
byp = (x ;y ) and letp = (x ;y ) andp = (x ;y ). Set
r d d a a a b b b
(p  p ) (p  p )
r a b a
t = : (3.5)
2
kp  pk
a
b
(Note thatt = 0 atp andt = 1 atp .) The value of an associated datumf for
a b
the fragment, whether it be primary or secondary R, G, B, or A (in RGBA mode)
or a color index (in color index mode), the fog coordinate, ans,t,r, orq texture
coordinate, or the clipw coordinate, is found as
(1 t)f =w +tf =w
a a b b
f = (3.6)
(1 t)=w +t=w
a
b
wheref andf are the data associated with the starting and ending endpoints of
a b
the segment, respectively;w andw are the clipw coordinates of the starting and
a b
ending endpoints of the segments, respectively. However, depth values for lines
must be interpolated by
z = (1 t)z +tz (3.7)
a
b
wherez andz are the depth values of the starting and ending endpoints of the
a
b
segment, respectively.
3.5.2 Other Line Segment Features
We have just described the rasterization of non-antialiased line segments of width
one using the default line stipple ofFFFF . We now describe the rasterization
16
of line segments for general values of the line segment rasterization parameters.
Line Stipple
The command
void LineStipple(int factor,ushort pattern );
de?nes a line stipple. pattern is an unsigned short integer. The line stipple is taken
from the lowest order 16 bits of pattern. It determines those fragments that are
to be drawn when the line is rasterized. factor is a count that is used to modify
the effective line stipple by causing each bit in line stipple to be used factor times.
factor is clamped to the range [1; 256]. Line stippling may be enabled or disabled
using Enable or Disable with the constantLINE STIPPLE. When disabled, it is as
if the line stipple has its default value.
Line stippling masks certain fragments that are produced by rasterization so
that they are not sent to the per-fragment stage of the GL. The masking is achieved
Version 3.0 (September 23, 2008)3.5. LINESEGMENTS 127
using three parameters: the 16-bit line stipple p, the line repeat count r, and an
integer stipple counters. Let
b =bs=rc mod 16;
Then a fragment is produced if thebth bit ofp is 1, and not produced otherwise.
The bits of p are numbered with 0 being the least signi?cant and 15 being the
most signi?cant. The initial value ofs is zero; s is incremented after production
of each fragment of a line segment (fragments are produced in order, beginning at
the starting point and working towards the ending point). s is reset to 0 whenever
a Begin occurs, and before every line segment in a group of independent segments
(as speci?ed when Begin is invoked withLINES).
If the line segment has been clipped, then the value ofs at the beginning of the
line segment is indeterminate.
Wide Lines
The actual width of non-antialiased lines is determined by rounding the supplied
width to the nearest integer, then clamping it to the implementation-dependent
maximum non-antialiased line width. This implementation-dependent value must
be no less than the implementation-dependent maximum antialiased line width,
rounded to the nearest integer value, and in any event no less than 1. If rounding
the speci?ed width results in the value 0, then it is as if the value were 1.
Non-antialiased line segments of width other than one are rasterized by off-
setting them in the minor direction (for an x-major line, the minor direction is
y, and for a y-major line, the minor direction is x) and replicating fragments in
the minor direction (see ?gure 3.5). Let w be the width rounded to the nearest
integer (if w = 0, then it is as if w = 1). If the line segment has endpoints
given by (x ;y ) and (x ;y ) in window coordinates, the segment with endpoints
0 0 1 1
(x ;y   (w  1)=2) and (x ;y   (w  1)=2) is rasterized, but instead of a single
0 0 1 1
fragment, a column of fragments of heightw (a row of fragments of lengthw for
a y-major segment) is produced at each x (y for y-major) location. The lowest
fragment of this column is the fragment that would be produced by rasterizing the
segment of width 1 with the modi?ed coordinates. The whole column is not pro-
duced if the stipple bit for the column’sx location is zero; otherwise, the whole
column is produced.
Antialiasing
Rasterized antialiased line segments produce fragments whose fragment squares
intersect a rectangle centered on the line segment. Two of the edges are parallel to
Version 3.0 (September 23, 2008)3.5. LINESEGMENTS 128
width = 2 width = 3
Figure 3.5. Rasterization of non-antialiased wide lines. x-major line segments are
shown. The heavy line segment is the one speci?ed to be rasterized; the light seg-
ment is the offset segment used for rasterization. x marks indicate the fragment
centers produced by rasterization.
the speci?ed line segment; each is at a distance of one-half the current width from
that segment: one above the segment and one below it. The other two edges pass
through the line endpoints and are perpendicular to the direction of the speci?ed
line segment. Coverage values are computed for each fragment by computing the
area of the intersection of the rectangle with the fragment square (see ?gure 3.6;
see also section 3.3). Equation 3.6 is used to compute associated data values just as
with non-antialiased lines; equation 3.5 is used to ?nd the value oft for each frag-
ment whose square is intersected by the line segment’s rectangle. Not all widths
need be supported for line segment antialiasing, but width 1:0 antialiased segments
must be provided. As with the point width, a GL implementation may be queried
for the range and number of gradations of available antialiased line widths.
For purposes of antialiasing, a stippled line is considered to be a sequence of
contiguous rectangles centered on the line segment. Each rectangle has width equal
to the current line width and length equal to 1 pixel (except the last, which may be
shorter). These rectangles are numbered from 0 ton, starting with the rectangle
incident on the starting endpoint of the segment. Each of these rectangles is ei-
ther eliminated or produced according to the procedure given under Line Stipple,
above, where “fragment” is replaced with “rectangle.” Each rectangle so produced
Version 3.0 (September 23, 2008)3.5. LINESEGMENTS 129
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
Figure 3.6. The region used in rasterizing and ?nding corresponding coverage val-
ues for an antialiased line segment (an x-major line segment is shown).
is rasterized as if it were an antialiased polygon, described below (but culling, non-
default settings of PolygonMode, and polygon stippling are not applied).
3.5.3 Line Rasterization State
The state required for line rasterization consists of the ?oating-point line width, a
16-bit line stipple, the line stipple repeat count, a bit indicating whether stippling
is enabled or disabled, and a bit indicating whether line antialiasing is on or off.
In addition, during rasterization, an integer stipple counter must be maintained to
implement line stippling. The initial value of the line width is 1:0. The initial value
of the line stipple isFFFF (a stipple of all ones). The initial value of the line
16
stipple repeat count is one. The initial state of line stippling is disabled. The initial
state of line segment antialiasing is disabled.
3.5.4 Line Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE BUFFERS is one, then lines
are rasterized using the following algorithm, regardless of whether line antialiasing
(LINE SMOOTH) is enabled or disabled. Line rasterization produces a fragment for
each framebuffer pixel with one or more sample points that intersect the rectangular
region that is described in the Antialiasing portion of section 3.5.2 (Other Line
Segment Features). If line stippling is enabled, the rectangular region is subdivided
Version 3.0 (September 23, 2008)3.6. POLYGONS 130
into adjacent unit-length rectangles, with some rectangles eliminated according to
the procedure given in section 3.5.2, where “fragment” is replaced by “rectangle”.
Coverage bits that correspond to sample points that intersect a retained rectan-
gle are 1, other coverage bits are 0. Each color, depth, and set of texture coordinates
is produced by substituting the corresponding sample location into equation 3.5,
then using the result to evaluate equation 3.7. An implementation may choose to
assign the same color value and the same set of texture coordinates to more than
one sample by evaluating equation 3.5 at any location within the pixel including
the fragment center or any one of the sample locations, then substituting into equa-
tion 3.6. The color value and the set of texture coordinates need not be evaluated
at the same location.
Line width range and number of gradations are equivalent to those supported
for antialiased lines.
3.6 Polygons
A polygon results from a polygon Begin/End object, a triangle resulting from a
triangle strip, triangle fan, or series of separate triangles, or a quadrilateral arising
from a quadrilateral strip, series of separate quadrilaterals, or a Rect command.
Like points and line segments, polygon rasterization is controlled by several vari-
ables. Polygon antialiasing is controlled with Enable and Disable with the sym-
bolic constant POLYGON SMOOTH. The analog to line segment stippling for poly-
gons is polygon stippling, described below.
3.6.1 Basic Polygon Rasterization
The ?rst step of polygon rasterization is to determine if the polygon is back facing
or front facing. This determination is made by examining the sign of the area com-
puted by equation 2.6 of section 2.19.1 (including the possible reversal of this sign
as indicated by the last call to FrontFace). If this sign is positive, the polygon is
frontfacing; otherwise, it is back facing. This determination is used in conjunction
with the CullFace enable bit and mode value to decide whether or not a particular
polygon is rasterized. The CullFace mode is set by calling
void CullFace(enum mode );
mode is a symbolic constant: one of FRONT, BACK or FRONT AND BACK. Culling
is enabled or disabled with Enable or Disable using the symbolic constant
CULL FACE. Front facing polygons are rasterized if either culling is disabled or
Version 3.0 (September 23, 2008)3.6. POLYGONS 131
the CullFace mode is BACK while back facing polygons are rasterized only if ei-
ther culling is disabled or the CullFace mode is FRONT. The initial setting of the
CullFace mode isBACK. Initially, culling is disabled.
The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon boundary edge. In
such a case we require that if two polygons lie on either side of a common edge
(with identical endpoints) on which a fragment center lies, then exactly one of the
polygons results in the production of the fragment during rasterization.
As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. De?ne barycentric coordinates for a triangle. Barycentric coordinates are
a set of three numbers, a, b, andc, each in the range [0; 1], witha +b +c = 1.
These coordinates uniquely specify any pointp within the triangle or on the trian-
gle’s boundary as
p =ap +bp +cp ;
a b c
wherep ,p , andp are the vertices of the triangle.a,b, andc can be found as
a b c
A(pp p ) A(pp p ) A(pp p )
b c a c a b
a = ; b = ; c = ;
A(p p p ) A(p p p ) A(p p p )
a b c a b c a b c
where A(lmn) denotes the area in window coordinates of the triangle with vertices
l,m, andn.
Denote an associated datum atp ,p , orp asf ,f , orf , respectively. Then
a b c a b c
the valuef of a datum at a fragment produced by rasterizing a triangle is given by
af =w +bf =w +cf =w
a a b b c c
f = (3.8)
a=w +b=w +c=w
a b c
where w , w and w are the clip w coordinates of p , p , and p , respectively.
a b c a b c
a,b, andc are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygons must be interpolated by
z =az +bz +cz ;
a b c
wherez ,z , andz are the depth values ofp ,p , andp , respectively.
a b c a b c
Version 3.0 (September 23, 2008)3.6. POLYGONS 132
For a polygon with more than three edges, we require only that a convex com-
bination of the values of the datum at the polygon’s vertices can be used to obtain
the value assigned to each fragment produced by the rasterization algorithm. That
is, it must be the case that at every fragment
n
X
f = af
i i
i=1
wheren is the number of vertices in the polygon,f is the value of thef at vertex
i
P
n
i; for eachi 0 a  1 and a = 1. The values of thea may differ from
i i i
i=1
fragment to fragment, but at vertexi,a = 0;j6=i anda = 1.
j i
One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
also satis?es the restrictions (in this case, the numerator and denominator of equa-
tion 3.8 should be iterated independently and a division performed for each frag-
ment).
3.6.2 Stippling
Polygon stippling works much the same way as line stippling, masking out certain
fragments produced by rasterization so that they are not sent to the next stage of
the GL. This is the case regardless of the state of polygon antialiasing. Stippling is
controlled with
void PolygonStipple(ubyte *pattern );
pattern is a pointer to memory into which a 32 32 pattern is packed. The pattern
is unpacked from memory according to the procedure given in section 3.7.4 for
DrawPixels; it is as if the height and width passed to that command were both equal
to 32, the type were BITMAP, and the format were COLOR INDEX. The unpacked
values (before any conversion or arithmetic would have been performed) form a
stipple pattern of zeros and ones.
If x and y are the window coordinates of a rasterized polygon fragment,
w w
then that fragment is sent to the next stage of the GL if and only if the bit of the
pattern (x mod 32;y mod 32) is 1.
w w
Polygon stippling may be enabled or disabled with Enable or Disable using
the constantPOLYGON STIPPLE. When disabled, it is as if the stipple pattern were
all ones.
Version 3.0 (September 23, 2008)3.6. POLYGONS 133
3.6.3 Antialiasing
Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interior of the polygon intersects that fragment’s square. A coverage value is com-
puted at each such fragment, and this value is saved to be applied as described
in section 3.13. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’s interior and dividing this integrated value by the area of the intersection.
For a fragment square lying entirely within the polygon, the value of a datum at the
fragment’s center may be used instead of integrating the value across the fragment.
Polygon stippling operates in the same way whether polygon antialiasing is
enabled or not. The polygon point sampling rule de?ned in section 3.6.1, however,
is not enforced for antialiased polygons.
3.6.4 Options Controlling Polygon Rasterization
The interpretation of polygons for rasterization is controlled using
void PolygonMode(enum face,enum mode );
face is one of FRONT, BACK, or FRONT AND BACK, indicating that the rasterizing
method described by mode replaces the rasterizing method for front facing poly-
gons, back facing polygons, or both front and back facing polygons, respectively.
mode is one of the symbolic constants POINT, LINE, or FILL. Calling Polygon-
Mode withPOINT causes certain vertices of a polygon to be treated, for rasteriza-
tion purposes, just as if they were enclosed within a Begin(POINT) and End pair.
The vertices selected for this treatment are those that have been tagged as having a
polygon boundary edge beginning on them (see section 2.6.2). LINE causes edges
that are tagged as boundary to be rasterized as line segments. (The line stipple
counter is reset at the beginning of the ?rst rasterized edge of the polygon, but
not for subsequent edges.) FILL is the default mode of polygon rasterization, cor-
responding to the description in sections 3.6.1, 3.6.2, and 3.6.3. Note that these
modes affect only the ?nal rasterization of polygons: in particular, a polygon’s ver-
tices are lit, and the polygon is clipped and possibly culled before these modes are
applied.
Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.
Version 3.0 (September 23, 2008)3.6. POLYGONS 134
3.6.5 Depth Offset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determines this value is speci?ed by calling
void PolygonOffset(float factor,float units );
factor scales the maximum depth slope of the polygon, and units scales an im-
plementation dependent constant that relates to the usable resolution of the depth
buffer. The resulting values are summed to produce the polygon offset value. Both
factor and units may be either positive or negative.
The maximum depth slopem of a triangle is
s
   
2 2
@z @z
w w
m = + (3.9)
@x @y
w w
where (x ;y ;z ) is a point on the triangle.m may be approximated as
w w w
   
   
@z @z
w w
   
m = max ; : (3.10)
   
@x @y
w w
If the polygon has more than three vertices, one or more values ofm may be used
during rasterization. Each may take any value in the range [min,max], wheremin
andmax are the smallest and largest values obtained by evaluating equation 3.9 or
equation 3.10 for the triangles formed by all three-vertex combinations.
The minimum resolvable differencer is an implementation-dependent param-
eter that depends on the depth buffer representation. It is the smallest difference in
window coordinatez values that is guaranteed to remain distinct throughout poly-
gon rasterization and in the depth buffer. All pairs of fragments generated by the
rasterization of two polygons with otherwise identical vertices, butz values that
w
differ byr, will have distinct depth values.
For ?xed-point depth buffer representations,r is constant throughout the range
of the entire depth buffer. For ?oating-point depth buffers, there is no single min-
imum resolvable difference. In this case, the minimum resolvable difference for a
given polygon is dependent on the maximum exponent,e, in the range ofz values
spanned by the primitive. Ifn is the number of bits in the ?oating-point mantissa,
the minimum resolvable difference,r, for the given primitive is de?ned as
e n
r = 2 :
Version 3.0 (September 23, 2008)3.6. POLYGONS 135
The offset valueo for a polygon is
o =mfactor +runits: (3.11)
m is computed as described above. If the depth buffer uses a ?xed-point represen-
tation,m is a function of depth values in the range [0; 1], ando is applied to depth
values in the same range.
Boolean state valuesPOLYGON OFFSET POINT,POLYGON OFFSET LINE, and
POLYGON OFFSET FILL determine whether o is applied during the rasterization
of polygons in POINT, LINE, and FILL modes. These boolean state values are
enabled and disabled as argument values to the commands Enable and Disable. If
POLYGON OFFSET POINT is enabled, o is added to the depth value of each frag-
ment produced by the rasterization of a polygon in POINT mode. Likewise, if
POLYGON OFFSET LINE or POLYGON OFFSET FILL is enabled,o is added to the
depth value of each fragment produced by the rasterization of a polygon in LINE
orFILL modes, respectively.
For ?xed-point depth buffers, fragment depth values are always limited to the
range [0; 1], either by clamping after offset addition is performed (preferred), or
by clamping the vertex values used in the rasterization of the polygon. Frag-
ment depth values are clamped even when the depth buffer uses a ?oating-point
representation.
3.6.6 Polygon Multisample Rasterization
IfMULTISAMPLE is enabled and the value ofSAMPLE BUFFERS is one, then poly-
gons are rasterized using the following algorithm, regardless of whether polygon
antialiasing (POLYGON SMOOTH) is enabled or disabled. Polygon rasterization pro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 3.6.1, including the special
treatment for sample points that lie on a polygon boundary edge. If a polygon is
culled, based on its orientation and the CullFace mode, then no fragments are pro-
duced during rasterization. Fragments are culled by the polygon stipple just as they
are for aliased and antialiased polygons.
Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each color, depth, and set of texture co-
ordinates is produced by substituting the corresponding sample location into the
barycentric equations described in section 3.6.1, using the approximation to equa-
tion 3.8 that omitsw components. An implementation may choose to assign the
same color value and the same set of texture coordinates to more than one sample
by barycentric evaluation using any location with the pixel including the fragment
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 136
center or one of the sample locations. The color value and the set of texture coor-
dinates need not be evaluated at the same location.
The rasterization described above applies only to the FILL state of Polygon-
Mode. For POINT and LINE, the rasterizations described in sections 3.4.3 (Point
Multisample Rasterization) and 3.5.4 (Line Multisample Rasterization) apply.
3.6.7 Polygon Rasterization State
The state required for polygon rasterization consists of a polygon stipple pattern,
whether stippling is enabled or disabled, the current state of polygon antialiasing
(enabled or disabled), the current values of the PolygonMode setting for each of
front and back facing polygons, whether point, line, and ?ll mode polygon offsets
are enabled or disabled, and the factor and bias values of the polygon offset equa-
tion. The initial stipple pattern is all ones; initially stippling is disabled. The initial
setting of polygon antialiasing is disabled. The initial state for PolygonMode is
FILL for both front and back facing polygons. The initial polygon offset factor
and bias values are both 0; initially polygon offset is disabled for all modes.
3.7 Pixel Rectangles
Rectangles of color, depth, and certain other values may be converted to fragments
using the DrawPixels command (described in section 3.7.4). Some of the param-
eters and operations governing the operation of DrawPixels are shared by Read-
Pixels (used to obtain pixel values from the framebuffer) and CopyPixels (used to
copy pixels from one framebuffer location to another); the discussion of ReadPix-
els and CopyPixels, however, is deferred until chapter 4 after the framebuffer has
been discussed in detail. Nevertheless, we note in this section when parameters
and state pertaining to DrawPixels also pertain to ReadPixels or CopyPixels.
A number of parameters control the encoding of pixels in buffer object or client
memory (for reading and writing) and how pixels are processed before being placed
in or after being read from the framebuffer (for reading, writing, and copying).
These parameters are set with three commands: PixelStore, PixelTransfer, and
PixelMap.
3.7.1 Pixel Storage Modes and Pixel Buffer Objects
Pixel storage modes affect the operation of DrawPixels and ReadPixels (as well as
other commands; see sections 3.6.2, 3.8, and 3.9) when one of these commands is
issued. This may differ from the time that the command is executed if the command
is placed in a display list (see section 5.4). Pixel storage modes are set with
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 137
Parameter Name Type Initial Value Valid Range
UNPACK SWAP BYTES boolean FALSE TRUE/FALSE
UNPACK LSB FIRST boolean FALSE TRUE/FALSE
UNPACK ROW LENGTH integer 0 [0;1)
UNPACK SKIP ROWS integer 0 [0;1)
UNPACK SKIP PIXELS integer 0 [0;1)
UNPACK ALIGNMENT integer 4 1,2,4,8
UNPACK IMAGE HEIGHT integer 0 [0;1)
UNPACK SKIP IMAGES integer 0 [0;1)
Table 3.1: PixelStore parameters pertaining to one or more of DrawPixels, Col-
orTable, ColorSubTable, ConvolutionFilter1D, ConvolutionFilter2D, Separa-
bleFilter2D, PolygonStipple, TexImage1D, TexImage2D, TexImage3D, Tex-
SubImage1D, TexSubImage2D, and TexSubImage3D.
void PixelStorefifg(enum pname,T param );
pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Table 3.1 summarizes the pixel storage parameters, their types,
their initial values, and their allowable ranges. Setting a parameter to a value out-
side the given range results in the errorINVALID VALUE.
The version of PixelStore that takes a ?oating-point value may be used to
set any type of parameter; if the parameter is boolean, then it is set to FALSE if
the passed value is 0:0 and TRUE otherwise, while if the parameter is an integer,
then the passed value is rounded to the nearest integer. The integer version of
the command may also be used to set any type of parameter; if the parameter is
boolean, then it is set toFALSE if the passed value is 0 andTRUE otherwise, while
if the parameter is a ?oating-point value, then the passed value is converted to
?oating-point.
In addition to storing pixel data in client memory, pixel data may also
be stored in buffer objects (described in section 2.9). The current pixel un-
pack and pack buffer objects are designated by the PIXEL UNPACK BUFFER and
PIXEL PACK BUFFER targets respectively.
Initially, zero is bound for the PIXEL UNPACK BUFFER, indicating that image
speci?cation commands such as DrawPixels source their pixels from client mem-
ory pointer parameters. However, if a non-zero buffer object is bound as the current
pixel unpack buffer, then the pointer parameter is treated as an offset into the des-
ignated buffer object.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 138
3.7.2 The Imaging Subset
Some pixel transfer and per-fragment operations are only made available in GL
implementations which incorporate the optional imaging subset. The imaging
subset includes both new commands, and new enumerants allowed as parame-
ters to existing commands. If the subset is supported, all of these calls and enu-
merants must be implemented as described later in the GL speci?cation. If the
subset is not supported, calling any unsupported command generates the error
INVALID OPERATION, and using any of the new enumerants generates the error
INVALID ENUM.
The individual operations available only in the imaging subset are described in
section 3.7.3. Imaging subset operations include:
1. Color tables, including all commands and enumerants described in sub-
sections Color Table Specification, Alternate Color Table Specification
Commands, Color Table State and Proxy State, Color Table Lookup,
Post Convolution Color Table Lookup, and Post Color Matrix Color Ta-
ble Lookup, as well as the query commands described in section 6.1.7.
2. Convolution, including all commands and enumerants described in sub-
sections Convolution Filter Specification, Alternate Convolution Filter
Specification Commands, and Convolution, as well as the query com-
mands described in section 6.1.8.
3. Color matrix, including all commands and enumerants described in subsec-
tions Color Matrix Specification and Color Matrix Transformation, as
well as the simple query commands described in section 6.1.6.
4. Histogram and minmax, including all commands and enumerants described
in subsections Histogram Table Specification, Histogram State and
Proxy State, Histogram, Minmax Table Specification, and Minmax, as
well as the query commands described in section 6.1.9 and section 6.1.10.
The imaging subset is supported only if the EXTENSIONS string includes
the substring "GL ARB imaging" Querying EXTENSIONS is described in sec-
tion 6.1.11.
If the imaging subset is not supported, the related pixel transfer operations are
not performed; pixels are passed unchanged to the next operation.
3.7.3 Pixel Transfer Modes
Pixel transfer modes affect the operation of DrawPixels (section 3.7.4), ReadPix-
els (section 4.3.2), and CopyPixels (section 4.3.3) at the time when one of these
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 139
Parameter Name Type Initial Value Valid Range
MAP COLOR boolean FALSE TRUE/FALSE
MAP STENCIL boolean FALSE TRUE/FALSE
INDEX SHIFT integer 0 ( 1;1)
INDEX OFFSET integer 0 ( 1;1)
x SCALE ?oat 1.0 ( 1;1)
DEPTH SCALE ?oat 1.0 ( 1;1)
x BIAS ?oat 0.0 ( 1;1)
DEPTH BIAS ?oat 0.0 ( 1;1)
POST CONVOLUTION x SCALE ?oat 1.0 ( 1;1)
POST CONVOLUTION x BIAS ?oat 0.0 ( 1;1)
POST COLOR MATRIX x SCALE ?oat 1.0 ( 1;1)
POST COLOR MATRIX x BIAS ?oat 0.0 ( 1;1)
Table 3.2: PixelTransfer parameters.x isRED,GREEN,BLUE, orALPHA.
commands is executed (which may differ from the time the command is issued).
Some pixel transfer modes are set with
void PixelTransferfifg(enum param,T value );
param is a symbolic constant indicating a parameter to be set, and value is the value
to set it to. Table 3.2 summarizes the pixel transfer parameters that are set with
PixelTransfer, their types, their initial values, and their allowable ranges. Setting
a parameter to a value outside the given range results in the errorINVALID VALUE.
The same versions of the command exist as for PixelStore, and the same rules
apply to accepting and converting passed values to set parameters.
The pixel map lookup tables are set with
void PixelMapfui us fgv(enum map,sizei size,T values );
map is a symbolic map name, indicating the map to set, size indicates the size of
the map, and values refers to an array of size map values.
The entries of a table may be speci?ed using one of three types: single-
precision ?oating-point, unsigned short integer, or unsigned integer, depending on
which of the three versions of PixelMap is called. A table entry is converted to the
appropriate type when it is speci?ed. An entry giving a color component value is
converted according to table 2.10 and then clamped to the range [0; 1]. An entry
giving a color index value is converted from an unsigned short integer or unsigned
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 140
Map Name Address Value Init. Size Init. Value
PIXEL MAP I TO I color idx color idx 1 0.0
PIXEL MAP S TO S stencil idx stencil idx 1 0
PIXEL MAP I TO R color idx R 1 0.0
PIXEL MAP I TO G color idx G 1 0.0
PIXEL MAP I TO B color idx B 1 0.0
PIXEL MAP I TO A color idx A 1 0.0
PIXEL MAP R TO R R R 1 0.0
PIXEL MAP G TO G G G 1 0.0
PIXEL MAP B TO B B B 1 0.0
PIXEL MAP A TO A A A 1 0.0
Table 3.3: PixelMap parameters.
integer to ?oating-point. An entry giving a stencil index is converted from single-
precision ?oating-point to an integer by rounding to nearest. The various tables
and their initial sizes and entries are summarized in table 3.3. A table that takes
n
an index as an address must havesize = 2 or the errorINVALID VALUE results.
The maximum allowable size of each table is speci?ed by the implementation de-
pendent valueMAX PIXEL MAP TABLE, but must be at least 32 (a single maximum
applies to all tables). The error INVALID VALUE is generated if a size larger than
the implemented maximum, or less than one, is given to PixelMap.
If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), values is an offset into the pixel unpack
buffer; otherwise, values is a pointer to client memory. All pixel storage and pixel
transfer modes are ignored when specifying a pixel map.n machine units are read
wheren is the size of the pixel map times the size of afloat,uint, orushort
datum in basic machine units, depending on the respective PixelMap version. If
a pixel unpack buffer object is bound anddata +n is greater than the size of the
pixel buffer, anINVALID OPERATION error results. If a pixel unpack buffer object
is bound and values is not evenly divisible by the number of basic machine units
needed to store in memory afloat,uint, orushort datum depending on their
respective PixelMap version, anINVALID OPERATION error results.
Color Table Specification
Color lookup tables are speci?ed with
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 141
Table Name Type
COLOR TABLE regular
POST CONVOLUTION COLOR TABLE
POST COLOR MATRIX COLOR TABLE
PROXY COLOR TABLE proxy
PROXY POST CONVOLUTION COLOR TABLE
PROXY POST COLOR MATRIX COLOR TABLE
Table 3.4: Color table names. Regular tables have associated image data. Proxy
tables have no image data, and are used only to determine if an image can be loaded
into the corresponding regular table.
void ColorTable(enum target,enum internalformat,
sizei width,enum format,enum type,void *data );
target must be one of the regular color table names listed in table 3.4 to de-
?ne the table. A proxy table name is a special case discussed later in this
section. width, format, type, and data specify an image in memory with the
same meaning and allowed values as the corresponding arguments to DrawPix-
els (see section 3.7.4), with height taken to be 1. The maximum allowable width
of a table is implementation-dependent, but must be at least 32. The formats
COLOR INDEX,DEPTH COMPONENT, DEPTH STENCIL, andSTENCIL INDEX and
the typeBITMAP are not allowed.
The speci?ed image is taken from memory and processed just as if DrawPixels
were called, stopping after the ?nal expansion to RGBA. The R, G, B, and A com-
ponents of each pixel are then scaled by the fourCOLOR TABLE SCALE parameters
and biased by the four COLOR TABLE BIAS parameters. These parameters are set
by calling ColorTableParameterfv as described below. If fragment color clamp-
ing is enabled or internalformat is ?xed-point, components are clamped to [0; 1].
Otherwise, components are not modi?ed.
Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format speci?ed by (or derived from) inter-
nalformat, in the same manner as for textures (section 3.9.1). internalformat must
be one of the formats in table 3.15 or tables 3.16- 3.18, with the exception of the
RED, RG, DEPTH COMPONENT, and DEPTH STENCIL base and sized internal for-
mats in those tables, all sized internal formats with non-?xed internal data types
(see section 3.9), and sized internal formatRGB9 E5.
The color lookup table is rede?ned to have width entries, each with the speci-
?ed internal format. The table is formed with indices 0 throughwidth  1. Table
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 142
locationi is speci?ed by theith image pixel, counting from zero.
The error INVALID VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE TOO LARGE is generated if the speci?ed color
lookup table is too large for the implementation.
The scale and bias parameters for a table are speci?ed by calling
void ColorTableParameterfifgv(enum target,enum pname,
T params );
target must be a regular color table name. pname is one of COLOR TABLE SCALE
orCOLOR TABLE BIAS. params points to an array of four values: red, green, blue,
and alpha, in that order.
A GL implementation may vary its allocation of internal component resolution
based on any ColorTable parameter, but the allocation must not be a function of
any other factor, and cannot be changed once it is established. Allocations must
be invariant; the same allocation must be made each time a color table is speci?ed
with the same parameter values. These allocation rules also apply to proxy color
tables, which are described later in this section.
Alternate Color Table Specification Commands
Color tables may also be speci?ed using image data taken directly from the frame-
buffer, and portions of existing tables may be respeci?ed.
The command
void CopyColorTable(enum target,enum internalformat,
int x,int y,sizei width );
de?nes a color table in exactly the manner of ColorTable, except that table data
are taken from the framebuffer, rather than from client memory. target must be a
regular color table name. x, y, and width correspond precisely to the corresponding
arguments of CopyPixels (refer to section 4.3.3); they specify the image’s width
and the lower left (x;y) coordinates of the framebuffer region to be copied. The
image is taken from the framebuffer exactly as if these arguments were passed to
CopyPixels with argument type set toCOLOR and height set to 1, stopping after the
?nal expansion to RGBA.
Subsequent processing is identical to that described for ColorTable, beginning
with scaling byCOLOR TABLE SCALE. Parameters target, internalformat and width
are speci?ed using the same values, with the same meanings, as the equivalent
arguments of ColorTable. format is taken to beRGBA.
Two additional commands,
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 143
void ColorSubTable(enum target,sizei start,sizei count,
enum format,enum type,void *data );
void CopyColorSubTable(enum target,sizei start,int x,
int y,sizei count );
respecify only a portion of an existing color table. No change is made to the inter-
nalformat or width parameters of the speci?ed color table, nor is any change made
to table entries outside the speci?ed portion. target must be a regular color table
name.
ColorSubTable arguments format, type, and data match the corresponding ar-
guments to ColorTable, meaning that they are speci?ed using the same values,
and have the same meanings. Likewise, CopyColorSubTable arguments x, y, and
count match the x, y, and width arguments of CopyColorTable. Both of the Color-
SubTable commands interpret and process pixel groups in exactly the manner of
their ColorTable counterparts, except that the assignment of R, G, B, and A pixel
group values to the color table components is controlled by the internalformat of
the table, not by an argument to the command.
Arguments start and count of ColorSubTable and CopyColorSubTable spec-
ify a subregion of the color table starting at index start and ending at index
start +count  1. Counting from zero, the nth pixel group is assigned to the
table entry with index count + n. The error INVALID VALUE is generated if
start +count>width.
Calling CopyColorTable or CopyColorSubTable
will result in an INVALID FRAMEBUFFER OPERATION error if the object bound
toREAD FRAMEBUFFER BINDING is not framebuffer complete (see section 4.4.4).
Color Table State and Proxy State
The state necessary for color tables can be divided into two categories. For each
of the three tables, there is an array of values. Each array has associated with it
a width, an integer describing the internal format of the table, six integer values
describing the resolutions of each of the red, green, blue, alpha, luminance, and
intensity components of the table, and two groups of four ?oating-point numbers to
store the table scale and bias. Each initial array is null (zero width, internal format
RGBA, with zero-sized components). The initial value of the scale parameters is
(1,1,1,1) and the initial value of the bias parameters is (0,0,0,0).
In addition to the color lookup tables, partially instantiated proxy color lookup
tables are maintained. Each proxy table includes width and internal format state
values, as well as state for the red, green, blue, alpha, luminance, and intensity
component resolutions. Proxy tables do not include image data, nor do they in-
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 144
clude scale and bias parameters. When ColorTable is executed with target speci-
?ed as one of the proxy color table names listed in table 3.4, the proxy state values
of the table are recomputed and updated. If the table is too large, no error is gener-
ated, but the proxy format, width and component resolutions are set to zero. If the
color table would be accommodated by ColorTable called with target set to the
corresponding regular table name (COLOR TABLE is the regular name correspond-
ing to PROXY COLOR TABLE, for example), the proxy state values are set exactly
as though the regular table were being speci?ed. Calling ColorTable with a proxy
target has no effect on the image or state of any actual color table.
There is no image associated with any of the proxy targets. They cannot be
used as color tables, and they must never be queried using GetColorTable. The
errorINVALID ENUM is generated if this is attempted.
Convolution Filter Specification
A two-dimensional convolution ?lter image is speci?ed by calling
void ConvolutionFilter2D(enum target,enum internalformat,
sizei width,sizei height,enum format,enum type,
void *data );
target must beCONVOLUTION 2D. width, height, format, type, and data specify an
image in memory with the same meaning and allowed values as the correspond-
ing parameters to DrawPixels. The formats COLOR INDEX, DEPTH COMPONENT,
DEPTH STENCIL, andSTENCIL INDEX and the typeBITMAP are not allowed.
The speci?ed image is extracted from memory and processed just as if
DrawPixels were called, stopping after the ?nal expansion to RGBA. The
R, G, B, and A components of each pixel are then scaled by the four two-
dimensional CONVOLUTION FILTER SCALE parameters and biased by the four
two-dimensionalCONVOLUTION FILTER BIAS parameters. These parameters are
set by calling ConvolutionParameterfv as described below. No clamping takes
place at any time during this process.
Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format speci?ed by (or derived from) internal-
format, in the same manner as for textures (section 3.9.1). internalformat accepts
the same values as the corresponding argument of ColorTable.
The red, green, blue, alpha, luminance, and/or intensity components of the
pixels are stored in ?oating point, rather than integer format. They form a two-
dimensional image indexed with coordinatesi;j such thati increases from left to
right, starting at zero, and j increases from bottom to top, also starting at zero.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 145
Image locationi;j is speci?ed by theNth pixel, counting from zero, where
N =i +jwidth
The error INVALID VALUE is generated if width or height is greater
than the maximum supported value. These values are queried with Get-
ConvolutionParameteriv, setting target to CONVOLUTION 2D and pname to
MAX CONVOLUTION WIDTH orMAX CONVOLUTION HEIGHT, respectively.
The scale and bias parameters for a two-dimensional ?lter are speci?ed by
calling
void ConvolutionParameterfifgv(enum target,enum pname,
T params );
with target CONVOLUTION 2D. pname is one of CONVOLUTION FILTER SCALE
or CONVOLUTION FILTER BIAS. params points to an array of four values: red,
green, blue, and alpha, in that order.
A one-dimensional convolution ?lter is de?ned using
void ConvolutionFilter1D(enum target,enum internalformat,
sizei width,enum format,enum type,void *data );
target must be CONVOLUTION 1D. internalformat, width, format, and type have
identical semantics and accept the same values as do their two-dimensional coun-
terparts. data must point to a one-dimensional image, however.
The image is extracted from memory and processed as if ConvolutionFilter2D
were called with a height of 1, except that it is scaled and biased by the one-
dimensional CONVOLUTION FILTER SCALE and CONVOLUTION FILTER BIAS
parameters. These parameters are speci?ed exactly as the two-dimensional
parameters, except that ConvolutionParameterfv is called with target
CONVOLUTION 1D.
The image is formed with coordinatesi such thati increases from left to right,
starting at zero. Image locationi is speci?ed by theith pixel, counting from zero.
The error INVALID VALUE is generated if width is greater than the maximum
supported value. This value is queried using GetConvolutionParameteriv, setting
target toCONVOLUTION 1D and pname toMAX CONVOLUTION WIDTH.
Special facilities are provided for the de?nition of two-dimensional sepa-
rable ?lters – ?lters whose image can be represented as the product of two
one-dimensional images, rather than as full two-dimensional images. A two-
dimensional separable convolution ?lter is speci?ed with
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 146
void SeparableFilter2D(enum target,enum internalformat,
sizei width,sizei height,enum format,enum type,
void *row,void *column );
target must be SEPARABLE 2D. internalformat speci?es the formats of the table
entries of the two one-dimensional images that will be retained. row points to a
width pixel wide image of the speci?ed format and type. column points to a height
pixel high image, also of the speci?ed format and type.
The two images are extracted from memory and processed as if Convolu-
tionFilter1D were called separately for each, except that each image is scaled
and biased by the two-dimensional separable CONVOLUTION FILTER SCALE and
CONVOLUTION FILTER BIAS parameters. These parameters are speci?ed exactly
as the one-dimensional and two-dimensional parameters, except that Convolution-
Parameteriv is called with targetSEPARABLE 2D.
Alternate Convolution Filter Specification Commands
One and two-dimensional ?lters may also be speci?ed using image data taken di-
rectly from the framebuffer.
The command
void CopyConvolutionFilter2D(enum target,
enum internalformat,int x,int y,sizei width,
sizei height );
de?nes a two-dimensional ?lter in exactly the manner of ConvolutionFilter2D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must beCONVOLUTION 2D. x, y, width, and height correspond precisely
to the corresponding arguments of CopyPixels (refer to section 4.3.3); they specify
the image’s width and height, and the lower left (x;y) coordinates of the frame-
buffer region to be copied. The image is taken from the framebuffer exactly as
if these arguments were passed to CopyPixels with argument type set to COLOR,
stopping after the ?nal expansion to RGBA.
Subsequent processing is identical to that described for ConvolutionFilter2D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, width, and height are speci?ed using the same values, with the same
meanings, as the equivalent arguments of ConvolutionFilter2D. format is taken to
beRGBA.
The command
void CopyConvolutionFilter1D(enum target,
enum internalformat,int x,int y,sizei width );
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 147
de?nes a one-dimensional ?lter in exactly the manner of ConvolutionFilter1D,
except that image data are taken from the framebuffer, rather than from client mem-
ory. target must beCONVOLUTION 1D. x, y, and width correspond precisely to the
corresponding arguments of CopyPixels (refer to section 4.3.3); they specify the
image’s width and the lower left (x;y) coordinates of the framebuffer region to
be copied. The image is taken from the framebuffer exactly as if these arguments
were passed to CopyPixels with argument type set to COLOR and height set to 1,
stopping after the ?nal expansion to RGBA.
Subsequent processing is identical to that described for ConvolutionFilter1D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, and width are speci?ed using the same values, with the same mean-
ings, as the equivalent arguments of ConvolutionFilter2D. format is taken to be
RGBA.
Calling CopyConvolutionFilter1D or CopyConvolutionFilter2D will re-
sult in an INVALID FRAMEBUFFER OPERATION error if the object bound to
READ FRAMEBUFFER BINDING is not framebuffer complete (see section 4.4.4).
Convolution Filter State
The required state for convolution ?lters includes a one-dimensional image array,
two one-dimensional image arrays for the separable ?lter, and a two-dimensional
image array. Each ?lter has associated with it a width and height (two-dimensional
and separable only), an integer describing the internal format of the ?lter, and two
groups of four ?oating-point numbers to store the ?lter scale and bias.
Each initial convolution ?lter is null (zero width and height, internal format
RGBA, with zero-sized components). The initial value of all scale parameters is
(1,1,1,1) and the initial value of all bias parameters is (0,0,0,0).
Color Matrix Specification
Setting the matrix mode to COLOR causes the matrix operations described in sec-
tion 2.12.2 to apply to the top matrix on the color matrix stack. All matrix opera-
tions have the same effect on the color matrix as they do on the other matrices.
Histogram Table Specification
The histogram table is speci?ed with
void Histogram(enum target,sizei width,
enum internalformat,boolean sink );
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 148
target must be HISTOGRAM if a histogram table is to be speci?ed. target value
PROXY HISTOGRAM is a special case discussed later in this section. width speci-
?es the number of entries in the histogram table, and internalformat speci?es the
format of each table entry. The maximum allowable width of the histogram table
is implementation-dependent, but must be at least 32. sink speci?es whether pixel
groups will be consumed by the histogram operation (TRUE) or passed on to the
minmax operation (FALSE).
If no error results from the execution of Histogram, the speci?ed histogram
table is rede?ned to have width entries, each with the speci?ed internal format.
The entries are indexed 0 throughwidth  1. Each component in each entry is set
to zero. The values in the previous histogram table, if any, are lost.
The error INVALID VALUE is generated if width is not zero or a non-negative
power of two. The errorTABLE TOO LARGE is generated if the speci?ed histogram
table is too large for the implementation. internalformat accepts the same values
as the corresponding argument of ColorTable, with the exception of the values 1,
2, 3, and 4.
A GL implementation may vary its allocation of internal component resolution
based on any Histogram parameter, but the allocation must not be a function of any
other factor, and cannot be changed once it is established. In particular, allocations
must be invariant; the same allocation must be made each time a histogram is
speci?ed with the same parameter values. These allocation rules also apply to the
proxy histogram, which is described later in this section.
Histogram State and Proxy State
The state necessary for histogram operation is an array of values, with which is
associated a width, an integer describing the internal format of the histogram, ?ve
integer values describing the resolutions of each of the red, green, blue, alpha,
and luminance components of the table, and a ?ag indicating whether or not pixel
groups are consumed by the operation. The initial array is null (zero width, internal
formatRGBA, with zero-sized components). The initial value of the ?ag is false.
In addition to the histogram table, a partially instantiated proxy histogram table
is maintained. It includes width, internal format, and red, green, blue, alpha, and
luminance component resolutions. The proxy table does not include image data or
the ?ag. When Histogram is executed with target set to PROXY HISTOGRAM, the
proxy state values are recomputed and updated. If the histogram array is too large,
no error is generated, but the proxy format, width, and component resolutions are
set to zero. If the histogram table would be accomodated by Histogram called
with target set to HISTOGRAM, the proxy state values are set exactly as though
the actual histogram table were being speci?ed. Calling Histogram with target
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 149
PROXY HISTOGRAM has no effect on the actual histogram table.
There is no image associated with PROXY HISTOGRAM. It cannot be used as
a histogram, and its image must never queried using GetHistogram. The error
INVALID ENUM results if this is attempted.
Minmax Table Specification
The minmax table is speci?ed with
void Minmax(enum target,enum internalformat,
boolean sink );
target must be MINMAX. internalformat speci?es the format of the table entries.
sink speci?es whether pixel groups will be consumed by the minmax operation
(TRUE) or passed on to ?nal conversion (FALSE).
internalformat accepts the same values as the corresponding argument of Col-
orTable, with the exception of the values 1, 2, 3, and 4, as well as theINTENSITY
base and sized internal formats. The resulting table always has 2 entries, each
with values corresponding only to the components of the internal format.
The state necessary for minmax operation is a table containing two elements
(the ?rst element stores the minimum values, the second stores the maximum val-
ues), an integer describing the internal format of the table, and a ?ag indicating
whether or not pixel groups are consumed by the operation. The initial state is
a minimum table entry set to the maximum representable value and a maximum
table entry set to the minimum representable value. Internal format is set toRGBA
and the initial value of the ?ag is false.
3.7.4 Rasterization of Pixel Rectangles
The process of drawing pixels encoded in buffer object or client memory is dia-
grammed in ?gure 3.7. We describe the stages of this process in the order in which
they occur.
Pixels are drawn using
void DrawPixels(sizei width,sizei height,enum format,
enum type,void *data );
format is a symbolic constant indicating what the values in memory represent.
width and height are the width and height, respectively, of the pixel rectan-
gle to be drawn. data refers to the data to be drawn. The correspon-
dence between the type token values and the GL data types they indicate is
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 150
byte, short, int, or float pixel
data stream (index or component)
                                                             
                                                             
                                                             
unpack
                                                             
                                                             
RGBA, L color
                                                             
index
                                                             
convert
                          Pixel Storage                                   
to float
                                                             
Operations
                                                             
                                                             
convert
                                                             
L to RGB
                                                             
                                                               
                                                               
                                                               
Pixel Transfer
scale shift
                                                               
Operations
and bias and offset
                                                               
                                                               
                                                               
                                                               
RGBA to RGBA index to RGBA index to index 
                                                               
lookup lookup lookup
                                                               
                                                               
                                                               
color table 
                                                               
lookup
                                                               
                                                               
                                                               
post
                                                               
convolution color table 
color matrix
                                                               
scale and bias lookup
                                                               
                                                               
                                                               
post color table histogram
                                                               
convolution lookup
                                                               
                                                               
                                                               
                                                               
color matrix minmax
      scale and bias                                                         
                                                               
                                                               
mask to
final
clamp
n
conversion
to [0,1] (2 ? 1)
RGBA pixel
color index pixel
data out data out
Figure 3.7. Operation of DrawPixels. Output is RGBA pixels if the GL is in RGBA
mode, color index pixels otherwise. Operations in dashed boxes may be enabled
or disabled. RGBA and color index pixel paths are shown; depth and stencil pixel
Version 3.0 (September 23, 2008)
paths are not shown.3.7. PIXELRECTANGLES 151
given in table 3.5. If the GL is in color index mode and format is not one of
COLOR INDEX, STENCIL INDEX, DEPTH COMPONENT, or DEPTH STENCIL, then
the error INVALID OPERATION occurs. Results of rasterization are unde?ned if
any of the selected draw buffers of the draw framebuffer have an integer format and
no fragment shader is active. If format contains integer components, as shown
in table 3.6, an INVALID OPERATION error is generated. If type is BITMAP and
format is not COLOR INDEX or STENCIL INDEX then the error INVALID ENUM
occurs. If format is DEPTH STENCIL and type is not UNSIGNED INT 24 8 or
FLOAT 32 UNSIGNED INT 24 8 REV, then the error INVALID ENUM occurs. If
format is one of the integer component formats as de?ned in table 3.6 and type
is FLOAT, the error INVALID ENUM occurs. Some additional constraints on the
combinations of format and type values that are accepted are discussed below.
Calling DrawPixels will result in anINVALID FRAMEBUFFER OPERATION er-
ror if the object bound toDRAW FRAMEBUFFER BINDING is not framebuffer com-
plete (see section 4.4.4).
Unpacking
Data are taken from the currently bound pixel unpack buffer or client memory as a
sequence of signed or unsigned bytes (GL data typesbyte andubyte), signed or
unsigned short integers (GL data typesshort andushort), signed or unsigned
integers (GL data typesint anduint), or ?oating point values (GL data types
half and float). These elements are grouped into sets of one, two, three, or
four values, depending on the format, to form a group. Table 3.6 summarizes the
format of groups obtained from memory; it also indicates those formats that yield
indices and those that yield ?oating-point or integer components.
If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
and the pixels are unpacked from the buffer relative to this offset; otherwise, data is
a pointer to client memory and the pixels are unpacked from client memory relative
to the pointer. If a pixel unpack buffer object is bound and unpacking the pixel data
according to the process described below would access memory beyond the size of
the pixel unpack buffer’s memory size, anINVALID OPERATION error results. If a
pixel unpack buffer object is bound and data is not evenly divisible by the number
of basic machine units needed to store in memory the corresponding GL data type
from table 3.5 for the type parameter, anINVALID OPERATION error results.
By default the values of each GL data type are interpreted as they would be
speci?ed in the language of the client’s GL binding. If UNPACK SWAP BYTES is
enabled, however, then the values are interpreted with the bit orderings modi?ed
as per table 3.7. The modi?ed bit orderings are de?ned only if the GL data type
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 152
type Parameter Corresponding Special
Token Name GL Data Type Interpretation
UNSIGNED BYTE ubyte No
BITMAP ubyte Yes
BYTE byte No
UNSIGNED SHORT ushort No
SHORT short No
UNSIGNED INT uint No
INT int No
HALF FLOAT half No
FLOAT float No
UNSIGNED BYTE 3 3 2 ubyte Yes
UNSIGNED BYTE 2 3 3 REV ubyte Yes
UNSIGNED SHORT 5 6 5 ushort Yes
UNSIGNED SHORT 5 6 5 REV ushort Yes
UNSIGNED SHORT 4 4 4 4 ushort Yes
UNSIGNED SHORT 4 4 4 4 REV ushort Yes
UNSIGNED SHORT 5 5 5 1 ushort Yes
UNSIGNED SHORT 1 5 5 5 REV ushort Yes
UNSIGNED INT 8 8 8 8 uint Yes
UNSIGNED INT 8 8 8 8 REV uint Yes
UNSIGNED INT 10 10 10 2 uint Yes
UNSIGNED INT 2 10 10 10 REV uint Yes
UNSIGNED INT 24 8 uint Yes
UNSIGNED INT 10F 11F 11F REV uint Yes
UNSIGNED INT 5 9 9 9 REV uint Yes
FLOAT 32 UNSIGNED INT 24 8 REV n/a Yes
Table 3.5: DrawPixels and ReadPixels type parameter values and the correspond-
ing GL data types. Refer to table 2.2 for de?nitions of GL data types. Special
interpretations are described near the end of section 3.7.4.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 153
Format Name Element Meaning and Order Target Buffer
COLOR INDEX Color Index Color
STENCIL INDEX Stencil Index Stencil
DEPTH COMPONENT Depth Depth
DEPTH STENCIL Depth and Stencil Index Depth and Stencil
RED R Color
GREEN G Color
BLUE B Color
ALPHA A Color
RG R, G Color
RGB R, G, B Color
RGBA R, G, B, A Color
BGR B, G, R Color
BGRA B, G, R, A Color
LUMINANCE Luminance Color
LUMINANCE ALPHA Luminance, A Color
RED INTEGER iR Color
GREEN INTEGER iG Color
BLUE INTEGER iB Color
ALPHA INTEGER iA Color
RG INTEGER iR, iG Color
RGB INTEGER iR, iG, iB Color
RGBA INTEGER iR, iG, iB, iA Color
BGR INTEGER iB, iG, iR Color
BGRA INTEGER iB, iG, iR, iA Color
Table 3.6: DrawPixels and ReadPixels formats. The second column gives a de-
scription of and the number and order of elements in a group. Unless speci?ed as an
index, formats yield components. Components are ?oating-point unless pre?xed
with the letter ’i’, which indicates they are integer.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 154
Element Size Default Bit Ordering Modi?ed Bit Ordering
8 bit [7::0] [7::0]
16 bit [15::0] [7::0][15::8]
32 bit [31::0] [7::0][15::8][23::16][31::24]
Table 3.7: Bit ordering modi?cation of elements when UNPACK SWAP BYTES is
enabled. These reorderings are de?ned only when GL data typeubyte has 8 bits,
and then only for GL data types with 8, 16, or 32 bits. Bit 0 is the least signi?cant.
ubyte has eight bits, and then for each speci?c GL data type only if that type is
represented with 8, 16, or 32 bits.
The groups in memory are treated as being arranged in a rectangle. This
rectangle consists of a series of rows, with the ?rst element of the ?rst group
of the ?rst row pointed to by the pointer passed to DrawPixels. If the value of
UNPACK ROW LENGTH is not positive, then the number of groups in a row is width;
otherwise the number of groups is UNPACK ROW LENGTH. Ifp indicates the loca-
tion in memory of the ?rst element of the ?rst row, then the ?rst element of theNth
row is indicated by
p +Nk (3.12)
whereN is the row number (counting from zero) and k is de?ned as

nl sa;
k = (3.13)
a=sdsnl=ae s<a
where n is the number of elements in a group, l is the number of groups in
the row, a is the value of UNPACK ALIGNMENT, and s is the size, in units of GL
ubytes, of an element. If the number of bits per element is not 1, 2, 4, or 8 times
the number of bits in a GLubyte, thenk =nl for all values ofa.
There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK ROW LENGTH, UNPACK SKIP ROWS, and UNPACK SKIP PIXELS. Before
obtaining the ?rst group from memory, the pointer supplied to DrawPixels is effec-
tively advanced by (UNPACK SKIP PIXELS)n+(UNPACK SKIP ROWS)k elements.
Then width groups are obtained from contiguous elements in memory (without ad-
vancing the pointer), after which the pointer is advanced byk elements. height sets
of width groups of values are obtained this way. See ?gure 3.8.
Calling DrawPixels with a type matching one of the types in table 3.8 is a
special case in which all the components of each group are packed into a sin-
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 155
ROW_LENGTH
                   
                   
                   
                   
      subimage             
                   
                   
SKIP_PIXELS
                   
SKIP_ROWS
Figure 3.8. Selecting a subimage from an image. The indicated parameter names
are pre?xed byUNPACK for DrawPixels and byPACK for ReadPixels.
gle unsigned byte, unsigned short, or unsigned int, depending on the type. If
type is FLOAT 32 UNSIGNED INT 24 8 REV, the components of each group are
two 32-bit words; the ?rst word contains the ?oat component, and the second
word contains packed 24-bit and 8-bit components. The number of components
per packed pixel is ?xed by the type, and must match the number of compo-
nents per group indicated by the format parameter, as listed in table 3.8. The
error INVALID OPERATION is generated if a mismatch occurs. This constraint
also holds for all other functions that accept or return pixel data using type and
format parameters to de?ne the type and format of that data.
Bit?eld locations of the ?rst, second, third, and fourth components of each
packed pixel type are illustrated in tables 3.9, 3.10, and 3.11. Each bit?eld is
interpreted as an unsigned integer value. If the base GL type is supported with
more than the minimum precision (e.g. a 9-bit byte) the packed components are
right-justi?ed in the pixel.
Components are normally packed with the ?rst component in the most signif-
icant bits of the bit?eld, and successive component occupying progressively less
signi?cant locations. Types whose token names end with REV reverse the compo-
nent packing order from least to most signi?cant locations. In all cases, the most
signi?cant bit of each component is packed in the most signi?cant bit location of
its location in the bit?eld.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 156
type Parameter GL Data Number of Matching
Token Name Type Components Pixel Formats
UNSIGNED BYTE 3 3 2 ubyte 3 RGB
UNSIGNED BYTE 2 3 3 REV ubyte 3 RGB
UNSIGNED SHORT 5 6 5 ushort 3 RGB
UNSIGNED SHORT 5 6 5 REV ushort 3 RGB
UNSIGNED SHORT 4 4 4 4 ushort 4 RGBA,BGRA
UNSIGNED SHORT 4 4 4 4 REV ushort 4 RGBA,BGRA
UNSIGNED SHORT 5 5 5 1 ushort 4 RGBA,BGRA
UNSIGNED SHORT 1 5 5 5 REV ushort 4 RGBA,BGRA
UNSIGNED INT 8 8 8 8 uint 4 RGBA,BGRA
UNSIGNED INT 8 8 8 8 REV uint 4 RGBA,BGRA
UNSIGNED INT 10 10 10 2 uint 4 RGBA,BGRA
UNSIGNED INT 2 10 10 10 REV uint 4 RGBA,BGRA
UNSIGNED INT 24 8 uint 2 DEPTH STENCIL
UNSIGNED INT 10F 11F 11F REV uint 3 RGB
UNSIGNED INT 5 9 9 9 REV uint 4 RGB
FLOAT 32 UNSIGNED INT 24 8 REV n/a 2 DEPTH STENCIL
Table 3.8: Packed pixel formats.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 157
UNSIGNED BYTE 3 3 2:
7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED BYTE 2 3 3 REV:
7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
Table 3.9: UNSIGNED BYTE formats. Bit numbers are indicated for each compo-
nent.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 158
UNSIGNED SHORT 5 6 5:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED SHORT 5 6 5 REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
UNSIGNED SHORT 4 4 4 4:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED SHORT 4 4 4 4 REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED SHORT 5 5 5 1:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED SHORT 1 5 5 5 REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table 3.10: UNSIGNED SHORT formats
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 159
UNSIGNED INT 8 8 8 8:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED INT 8 8 8 8 REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED INT 10 10 10 2:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED INT 2 10 10 10 REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED INT 24 8:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd
UNSIGNED INT 10F 11F 11F REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
UNSIGNED INT 5 9 9 9 REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table 3.11: UNSIGNED INT formats
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 160
Format First Second Third Fourth
Component Component Component Component
RGB red green blue
RGBA red green blue alpha
BGRA blue green red alpha
DEPTH STENCIL depth stencil
Table 3.12: Packed pixel ?eld assignments.
The assignment of component to ?elds in the packed pixel is as described in
table 3.12.
Byte swapping, if enabled, is performed before the component are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
of components per group is understood to be one.
Calling DrawPixels with a type ofUNSIGNED INT 10F 11F 11F REV and for-
mat ofRGB is a special case in which the data are a series of GLuint values. Each
uint value speci?es 3 packed components as shown in table 3.11. The 1st, 2nd, and
3rd components are called f (11 bits), f (11 bits), and f (10 bits) re-
red green blue
spectively.
f and f are treated as unsigned 11-bit ?oating-point values and con-
red green
verted to ?oating-point red and green components respectively as described in sec-
tion 2.1.3.f is treated as an unsigned 10-bit ?oating-point value and converted
blue
to a ?oating-point blue component as described in section 2.1.4.
Calling DrawPixels with a type of UNSIGNED INT 5 9 9 9 REV and format
of RGB is a special case in which the data are a series of GL uint values. Each
uint value speci?es 4 packed components as shown in table 3.11. The 1st, 2nd,
3rd, and 4th components are calledp , p , p , andp respectively and
green exp
red blue
are treated as unsigned integers. These are then used to compute ?oating-point
RGB components (ignoring the ”Conversion to ?oating-point” section below in this
case) as follows:
p  B N
exp
red =p 2
red
p  B N
exp
green =p 2
green
p  B N
exp
blue =p 2
blue
whereB = 15 (the exponent bias) andN = 9 (the number of mantissa bits).
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 161
Calling DrawPixels with a type ofBITMAP is a special case in which the data
are a series of GL ubyte values. Each ubyte value speci?es 8 1-bit elements
with its 8 least-signi?cant bits. The 8 single-bit elements are ordered from most
signi?cant to least signi?cant if the value ofUNPACK LSB FIRST isFALSE; other-
wise, the ordering is from least signi?cant to most signi?cant. The values of bits
other than the 8 least signi?cant in eachubyte are not signi?cant.
The ?rst element of the ?rst row is the ?rst bit (as de?ned above) of theubyte
pointed to by the pointer passed to DrawPixels. The ?rst element of the second
row is the ?rst bit (again as de?ned above) of theubyte at locationp +k, where
k is computed as
 
l
k =a (3.14)
8a
There is a mechanism for selecting a sub-rectangle of elements from aBITMAP
image as well. Before obtaining the ?rst element from memory, the pointer sup-
plied to DrawPixels is effectively advanced byUNPACK SKIP ROWSkubytes.
ThenUNPACK SKIP PIXELS 1-bit elements are ignored, and the subsequent width
1-bit elements are obtained, without advancing theubyte pointer, after which the
pointer is advanced byk ubytes. height sets of width elements are obtained this
way.
Conversion to ?oating-point
This step applies only to groups of ?oating-point components. It is not performed
on indices or integer components. For groups containing both components and
indices, such asDEPTH STENCIL, the indices are not converted.
Each element in a group is converted to a ?oating-point value according to the
appropriate formula in table 2.10 (section 2.19). For packed pixel types, each ele-
N
ment in the group is converted by computingc= (2   1), wherec is the unsigned
integer value of the bit?eld containing the element andN is the number of bits in
the bit?eld.
Conversion to RGB
This step is applied only if the format isLUMINANCE orLUMINANCE ALPHA. If the
format is LUMINANCE, then each group of one element is converted to a group of
R, G, and B (three) elements by copying the original single element into each of
the three new elements. If the format is LUMINANCE ALPHA, then each group of
two elements is converted to a group of R, G, B, and A (four) elements by copying
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 162
the ?rst original element into each of the ?rst three new elements and copying the
second original element to the A (fourth) new element.
Final Expansion to RGBA
This step is performed only for non-depth component groups. Each group is con-
verted to a group of 4 elements as follows: if a group does not contain an A ele-
ment, then A is added and set to 1 for integer components or 1.0 for ?oating-point
components. If any of R, G, or B is missing from the group, each missing element
is added and assigned a value of 0 for integer components or 0.0 for ?oating-point
components.
Pixel Transfer Operations
This step is actually a sequence of steps. Because the pixel transfer operations
are performed equivalently during the drawing, copying, and reading of pixels,
and during the speci?cation of texture images (either from memory or from the
framebuffer), they are described separately in section 3.7.5. After the processing
described in that section is completed, groups are processed as described in the
following sections.
Final Conversion
For a color index, ?nal conversion consists of masking the bits of the index to the
n
left of the binary point by 2   1, wheren is the number of bits in an index buffer.
For integer RGBA components, no conversion is performed. For ?oating-
point RGBA components, if fragment color clamping is enabled, each element
is clamped to [0; 1], and may be converted to ?xed-point according to the rules
given in section 2.19.9. If fragment color clamping is disabled, RGBA compo-
nents are unmodi?ed. Fragment color clamping is controlled using ClampColor,
as described in section 2.19.6, with a target ofCLAMP FRAGMENT COLOR.
For a depth component, an element is processed according to the depth buffer’s
representation. For ?xed-point depth buffers, the element is ?rst clamped to the
range [0; 1] and then converted to ?xed-point as if it were a windowz value (see
section 2.12.1). Conversion is not necessary when the depth buffer uses a ?oating-
point representation, but clamping is.
n
Stencil indices are masked by 2   1, where n is the number of bits in the
stencil buffer.
The state required for fragment color clamping is a three-valued integer. The
initial value of fragment color clamping isFIXED ONLY.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 163
Conversion to Fragments
The conversion of a group to fragments is controlled with
void PixelZoom(floatz ,floatz );
x y
Let (x ;y ) be the current raster position (section 2.18). (If the current raster
rp rp
position is invalid, then DrawPixels is ignored; pixel transfer operations do not
update the histogram or minmax tables, and no fragments are generated. However,
the histogram and minmax tables are updated even if the corresponding fragments
are later rejected by the pixel ownership (section 4.1.1) or scissor (section 4.1.2)
tests.) If a particular group (index or components) is thenth in a row and belongs to
themth row, consider the region in window coordinates bounded by the rectangle
with corners
(x +z n;y +z m) and (x +z (n + 1);y +z (m + 1))
rp x rp y rp x rp y
(eitherz orz may be negative). A fragment representing group (n;m) is pro-
x y
duced for each framebuffer pixel inside, or on the bottom or left boundary, of this
rectangle
A fragment arising from a group consisting of color data takes on the color
index or color components of the group and the current raster position’s associated
depth value, while a fragment arising from a depth component takes that compo-
nent’s depth value and the current raster position’s associated color index or color
components. In both cases, the fog coordinate is taken from the current raster posi-
tion’s associated raster distance, the secondary color is taken from the current raster
position’s associated secondary color, and texture coordinates are taken from the
current raster position’s associated texture coordinates. Groups arising from Draw-
Pixels with a format of DEPTH STENCIL orSTENCIL INDEX are treated specially
and are described in section 4.3.1.
3.7.5 Pixel Transfer Operations
The GL de?nes six kinds of pixel groups:
1. Floating-point RGBA component: Each group comprises four color compo-
nents in ?oating-point format: red, green, blue, and alpha.
2. Integer RGBA component: Each group comprises four color components in
integer format: red, green, blue, and alpha.
3. Depth component: Each group comprises a single depth component.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 164
4. Color index: Each group comprises a single color index.
5. Stencil index: Each group comprises a single stencil index.
6. Depth/stencil: Each group comprises a single depth component and a single
stencil index.
Each operation described in this section is applied sequentially to each pixel
group in an image. Many operations are applied only to pixel groups of certain
kinds; if an operation is not applicable to a given group, it is skipped. None of the
operations de?ned in this section affect integer RGBA component pixel groups.
Arithmetic on Components
This step applies only to RGBA component and depth component groups, and to
the depth components in depth/stencil groups. Each component is multiplied by an
appropriate signed scale factor: RED SCALE for an R component, GREEN SCALE
for a G component, BLUE SCALE for a B component, andALPHA SCALE for an A
component, or DEPTH SCALE for a depth component. Then the result is added to
the appropriate signed bias: RED BIAS, GREEN BIAS, BLUE BIAS, ALPHA BIAS,
orDEPTH BIAS.
Arithmetic on Indices
This step applies only to color index and stencil index groups, and to the stencil
indices in depth/stencil groups. If the index is a ?oating-point value, it is converted
to ?xed-point, with an unspeci?ed number of bits to the right of the binary point
and at leastdlog (MAX PIXEL MAP TABLE)e bits to the left of the binary point.
2
Indices that are already integers remain so; any fraction bits in the resulting ?xed-
point value are zero.
The ?xed-point index is then shifted by jINDEX SHIFTj bits, left if
INDEX SHIFT> 0 and right otherwise. In either case the shift is zero-?lled. Then,
the signed integer offsetINDEX OFFSET is added to the index.
RGBA to RGBA Lookup
This step applies only to RGBA component groups, and is skipped ifMAP COLOR is
FALSE. First, each component is clamped to the range [0; 1]. There is a table associ-
ated with each of the R, G, B, and A component elements: PIXEL MAP R TO R for
R, PIXEL MAP G TO G for G, PIXEL MAP B TO B for B, and PIXEL MAP A TO A
for A. Each element is multiplied by an integer one less than the size of the corre-
sponding table, and, for each element, an address is found by rounding this value
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 165
to the nearest integer. For each element, the addressed value in the corresponding
table replaces the element.
Color Index Lookup
This step applies only to color index groups. If the GL command that invokes the
pixel transfer operation requires that RGBA component pixel groups be generated,
then a conversion is performed at this step. RGBA component pixel groups are
required if
1. The groups will be rasterized, and the GL is in RGBA mode, or
2. The groups will be loaded as an image into texture memory, or
3. The groups will be returned to client memory with a format other than
COLOR INDEX.
If RGBA component groups are required, then the integer part of the in-
dex is used to reference 4 tables of color components: PIXEL MAP I TO R,
PIXEL MAP I TO G, PIXEL MAP I TO B, and PIXEL MAP I TO A. Each of these
n
tables must have 2 entries for some integer value of n (n may be different for
each table). For each table, the index is ?rst rounded to the nearest integer; the
n
result is ANDed with 2   1, and the resulting value used as an address into the
table. The indexed value becomes an R, G, B, or A value, as appropriate. The
group of four elements so obtained replaces the index, changing the group’s type
to RGBA component.
If RGBA component groups are not required, and if MAP COLOR is enabled,
then the index is looked up in the PIXEL MAP I TO I table (otherwise, the index
n
is not looked up). Again, the table must have 2 entries for some integern. The
n
index is ?rst rounded to the nearest integer; the result is ANDed with 2   1, and
the resulting value used as an address into the table. The value in the table replaces
the index. The ?oating-point table value is ?rst rounded to a ?xed-point value with
unspeci?ed precision. The group’s type remains color index.
Stencil Index Lookup
This step applies only to stencil index groups, and to the stencil indices in
depth/stencil groups. If MAP STENCIL is enabled, then the index is looked up
in the PIXEL MAP S TO S table (otherwise, the index is not looked up). The table
n n
must have 2 entries for some integern. The integer index is ANDed with 2   1,
and the resulting value used as an address into the table. The integer value in the
table replaces the index.
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 166
Base Internal Format R G B A
ALPHA A
t
LUMINANCE L L L
t t t
LUMINANCE ALPHA L L L A
t t t t
INTENSITY I I I I
t t t t
RGB R G B
t t t
RGBA R G B A
t t t t
Table 3.13: Color table lookup. R ,G ,B ,A ,L , andI are color table values
t t t t t t
that are assigned to pixel components R, G, B, and A depending on the table
format. When there is no assignment, the component value is left unchanged by
lookup.
Color Table Lookup
This step applies only to RGBA component groups. Color table lookup is only
done if COLOR TABLE is enabled. If a zero-width table is enabled, no lookup is
performed.
The internal format of the table determines which components of the group
will be replaced (see table 3.13). The components to be replaced are converted
to indices by clamping to [0; 1], multiplying by an integer one less than the width
of the table, and rounding to the nearest integer. Components are replaced by the
table entry at the index.
The required state is one bit indicating whether color table lookup is enabled
or disabled. In the initial state, lookup is disabled.
Convolution
This step applies only to RGBA component groups. If CONVOLUTION 1D
is enabled, the one-dimensional convolution ?lter is applied only to the one-
dimensional texture images passed to TexImage1D, TexSubImage1D, Copy-
TexImage1D, and CopyTexSubImage1D. If CONVOLUTION 2D is enabled, the
two-dimensional convolution ?lter is applied only to the two-dimensional im-
ages passed to DrawPixels, CopyPixels, ReadPixels, TexImage2D, TexSubIm-
age2D, CopyTexImage2D, CopyTexSubImage2D, and CopyTexSubImage3D.
If SEPARABLE 2D is enabled, and CONVOLUTION 2D is disabled, the separable
two-dimensional convolution ?lter is instead applied these images.
The convolution operation is a sum of products of source image pixels and
convolution ?lter pixels. Source image pixels always have four components: red,
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 167
Base Filter Format R G B A
ALPHA R G B A A
s s s s f
LUMINANCE R L G L B L A
s f s f s f s
LUMINANCE ALPHA R L G L B L A A
s f s f s f s f
INTENSITY R I G I B I A I
s f s f s f s f
RGB R R G G B B A
s f s f s f s
RGBA R R G G B B A A
s f s f s f s f
Table 3.14: Computation of ?ltered color components depending on ?lter image
format.CF indicates the convolution of image componentC with ?lterF .
green, blue, and alpha, denoted in the equations below as R , G , B , and A .
s s s s
Filter pixels may be stored in one of ?ve formats, with 1, 2, 3, or 4 components.
These components are denoted as R , G , B , A , L , and I in the equations
f f f f f f
below. The result of the convolution operation is the 4-tuple R,G,B,A. Depending
on the internal format of the ?lter, individual color components of each source
image pixel are convolved with one ?lter component, or are passed unmodi?ed.
The rules for this are de?ned in table 3.14.
The convolution operation is de?ned differently for each of the three convolu-
tion ?lters. The variablesW andH refer to the dimensions of the convolution
f f
?lter. The variablesW andH refer to the dimensions of the source pixel image.
s s
The convolution equations are de?ned as follows, whereC refers to the ?ltered
result, C refers to the one- or two-dimensional convolution ?lter, andC and
f row
C refer to the two one-dimensional ?lters comprising the two-dimensional
column
0
separable ?lter.C depends on the source image colorC and the convolution bor-
s
s
der mode as described below.C , the ?ltered output image, depends on all of these
r
variables and is described separately for each border mode. The pixel indexing
nomenclature is decribed in the Convolution Filter Specification subsection of
section 3.7.3.
One-dimensional ?lter:
W  1
f
X
0 0 0
C[i ] = C [i +n]C [n]
s f
n=0
Two-dimensional ?lter:
W  1H  1
f f
X X
0 0 0 0 0
C[i;j ] = C [i +n;j +m]C [n;m]
f
s
n=0 m=0
Two-dimensional separable ?lter:
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 168
W  1H  1
f f
X X
0 0 0 0 0
C[i;j ] = C [i +n;j +m]C [n]C [m]
row column
s
n=0 m=0
IfW of a one-dimensional ?lter is zero, thenC[i] is always set to zero. Like-
f
wise, if eitherW orH of a two-dimensional ?lter is zero, thenC[i;j] is always
f f
set to zero.
The convolution border mode for a speci?c convolution ?lter is speci?ed by
calling
void ConvolutionParameterfifg(enum target,enum pname,
T param );
where target is the name of the ?lter, pname isCONVOLUTION BORDER MODE, and
param is one ofREDUCE,CONSTANT BORDER orREPLICATE BORDER.
Border ModeREDUCE
The width and height of source images convolved with border mode REDUCE are
reduced by W   1 and H   1, respectively. If this reduction would generate
f f
a resulting image with zero or negative width and/or height, the output is simply
null, with no error generated. The coordinates of the image that results from a con-
volution with border modeREDUCE are zero throughW  W in width, and zero
s f
throughH  H in height. In cases where errors can result from the speci?cation
s
f
of invalid image dimensions, it is these resulting dimensions that are tested, not
the dimensions of the source image. (A speci?c example is TexImage1D and Tex-
Image2D, which specify constraints for image dimensions. Even if TexImage1D
or TexImage2D is called with a null pixel pointer, the dimensions of the result-
ing texture image are those that would result from the convolution of the speci?ed
image).
0
When the border mode is REDUCE,C equals the source image colorC and
s
s
C equals the ?ltered resultC.
r
For the remaining border modes, de?ne C =bW =2c and C =bH =2c.
w f h f
The coordinates (C ;C ) de?ne the center of the convolution ?lter.
w h
Border ModeCONSTANT BORDER
If the convolution border mode is CONSTANT BORDER, the output image has the
same dimensions as the source image. The result of the convolution is the same
as if the source image were surrounded by pixels with the same color as the
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 169
current convolution border color. Whenever the convolution ?lter extends be-
yond one of the edges of the source image, the constant-color border pixels are
used as input to the ?lter. The current convolution border color is set by call-
ing ConvolutionParameterfv or ConvolutionParameteriv with pname set to
CONVOLUTION BORDER COLOR and params containing four values that comprise
the RGBA color to be used as the image border. Integer color components are inter-
preted linearly such that the largest positive integer maps to 1.0, and the smallest
negative integer maps to -1.0. Floating point color components are not clamped
when they are speci?ed.
For a one-dimensional ?lter, the result color is de?ned by
C [i] =C[i C ]
r w
0 0 0
whereC[i ] is computed using the following equation forC [i ]:
s

0 0
C [i ]; 0i <W
s s
0 0
C [i ] =
s
C ; otherwise
c
andC is the convolution border color.
c
For a two-dimensional or two-dimensional separable ?lter, the result color is
de?ned by
C [i;j] =C[i C ;j C ]
r w h
0 0 0 0 0
whereC[i;j ] is computed using the following equation forC [i;j ]:
s

0 0 0 0
C [i;j ]; 0i <W ; 0j <H
0 0 0 s s s
C [i;j ] =
s
C ; otherwise
c
Border ModeREPLICATE BORDER
The convolution border mode REPLICATE BORDER also produces an output im-
age with the same dimensions as the source image. The behavior of this mode is
identical to that of the CONSTANT BORDER mode except for the treatment of pixel
locations where the convolution ?lter extends beyond the edge of the source im-
age. For these locations, it is as if the outermost one-pixel border of the source
image was replicated. Conceptually, each pixel in the leftmost one-pixel column
of the source image is replicatedC times to provide additional image data along
w
the left edge, each pixel in the rightmost one-pixel column is replicatedC times
w
to provide additional image data along the right edge, and each pixel value in the
top and bottom one-pixel rows is replicated to createC rows of image data along
h
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 170
the top and bottom edges. The pixel value at each corner is also replicated in order
to provide data for the convolution operation at each corner of the source image.
For a one-dimensional ?lter, the result color is de?ned by
C [i] =C[i C ]
r w
0 0 0
whereC[i ] is computed using the following equation forC [i ]:
s
0 0 0
C [i ] =C [clamp(i;W )]
s s
s
and the clamping function clamp(val;max) is de?ned as
8
0; val< 0
<
clamp(val;max) = val; 0val<max
:
max  1; valmax
For a two-dimensional or two-dimensional separable ?lter, the result color is
de?ned by
C [i;j] =C[i C ;j C ]
r w h
0 0 0 0 0
whereC[i;j ] is computed using the following equation forC [i;j ]:
s
0 0 0 0 0
C [i;j ] =C [clamp(i;W ); clamp(j;H )]
s s s
s
If a convolution operation is performed, each component of
the resulting image is scaled by the corresponding PixelTrans-
fer parameters: POST CONVOLUTION RED SCALE for an R com-
ponent, POST CONVOLUTION GREEN SCALE for a G compo-
nent, POST CONVOLUTION BLUE SCALE for a B component, and
POST CONVOLUTION ALPHA SCALE for an A component. The result
is added to the corresponding bias: POST CONVOLUTION RED BIAS,
POST CONVOLUTION GREEN BIAS, POST CONVOLUTION BLUE BIAS, or
POST CONVOLUTION ALPHA BIAS.
The required state is three bits indicating whether each of one-dimensional,
two-dimensional, or separable two-dimensional convolution is enabled or disabled,
an integer describing the current convolution border mode, and four ?oating-point
values specifying the convolution border color. In the initial state, all convolu-
tion operations are disabled, the border mode is REDUCE, and the border color is
(0; 0; 0; 0).
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 171
Post Convolution Color Table Lookup
This step applies only to RGBA component groups. Post convolution color
table lookup is enabled or disabled by calling Enable or Disable with
the symbolic constant POST CONVOLUTION COLOR TABLE. The post convo-
lution table is de?ned by calling ColorTable with a target argument of
POST CONVOLUTION COLOR TABLE. In all other respects, operation is identical
to color table lookup, as de?ned earlier in section 3.7.5.
The required state is one bit indicating whether post convolution table lookup
is enabled or disabled. In the initial state, lookup is disabled.
Color Matrix Transformation
This step applies only to RGBA component groups. The components are
transformed by the color matrix. Each transformed component is multiplied
by an appropriate signed scale factor: POST COLOR MATRIX RED SCALE
for an R component, POST COLOR MATRIX GREEN SCALE for a G
component, POST COLOR MATRIX BLUE SCALE for a B component,
and POST COLOR MATRIX ALPHA SCALE for an A component. The
result is added to a signed bias: POST COLOR MATRIX RED BIAS,
POST COLOR MATRIX GREEN BIAS, POST COLOR MATRIX BLUE BIAS, or
POST COLOR MATRIX ALPHA BIAS. The resulting components replace each
component of the original group.
That is, ifM is the color matrix, a subscript ofs represents the scale term for
c
a component, and a subscript ofb represents the bias term, then the components
0 1
R
B C
G
B C
@ A
B
A
are transformed to
0 1 0 1 0 1 0 1
0
R R 0 0 0 R R
s b
0
B C B C B C B C
G 0 G 0 0 G G
s b
B C B C B C B C
= M + :
c
0
@ A @ A @ A @ A
B 0 0 B 0 B B
s b
0
A 0 0 0 A A A
s
b
Post Color Matrix Color Table Lookup
This step applies only to RGBA component groups. Post color matrix
color table lookup is enabled or disabled by calling Enable or Disable
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 172
with the symbolic constant POST COLOR MATRIX COLOR TABLE. The post color
matrix table is de?ned by calling ColorTable with a target argument of
POST COLOR MATRIX COLOR TABLE. In all other respects, operation is identical
to color table lookup, as de?ned in section 3.7.5.
The required state is one bit indicating whether post color matrix lookup is
enabled or disabled. In the initial state, lookup is disabled.
Histogram
This step applies only to RGBA component groups. Histogram operation is
enabled or disabled by calling Enable or Disable with the symbolic constant
HISTOGRAM.
If the width of the table is non-zero, then indicesR , G , B , andA are de-
i i i i
rived from the red, green, blue, and alpha components of each pixel group (without
modifying these components) by clamping each component to [0; 1], multiplying
by one less than the width of the histogram table, and rounding to the nearest in-
teger. If the format of the HISTOGRAM table includes red or luminance, the red or
luminance component of histogram entryR is incremented by one. If the format
i
of the HISTOGRAM table includes green, the green component of histogram entry
G is incremented by one. The blue and alpha components of histogram entries
i
B and A are incremented in the same way. If a histogram entry component is
i i
incremented beyond its maximum value, its value becomes unde?ned; this is not
an error.
If the Histogram sink parameter is FALSE, histogram operation has no effect
on the stream of pixel groups being processed. Otherwise, all RGBA pixel groups
are discarded immediately after the histogram operation is completed. Because
histogram precedes minmax, no minmax operation is performed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modi?ed whether or not pixel
groups are discarded.
Minmax
This step applies only to RGBA component groups. Minmax operation is enabled
or disabled by calling Enable or Disable with the symbolic constantMINMAX.
If the format of the minmax table includes red or luminance, the red compo-
nent value replaces the red or luminance value in the minimum table element if
and only if it is less than that component. Likewise, if the format includes red or
luminance and the red component of the group is greater than the red or luminance
value in the maximum element, the red group component replaces the red or lumi-
Version 3.0 (September 23, 2008)3.7. PIXELRECTANGLES 173
nance maximum component. If the format of the table includes green, the green
group component conditionally replaces the green minimum and/or maximum if
it is smaller or larger, respectively. The blue and alpha group components are
similarly tested and replaced, if the table format includes blue and/or alpha. The
internal type of the minimum and maximum component values is ?oating point,
with at least the same representable range as a ?oating point number used to rep-
resent colors (section 2.1.1). There are no semantics de?ned for the treatment of
group component values that are outside the representable range.
If the Minmax sink parameter is FALSE, minmax operation has no effect on
the stream of pixel groups being processed. Otherwise, all RGBA pixel groups are
discarded immediately after the minmax operation is completed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
values are returned. However, texture object state is modi?ed whether or not pixel
groups are discarded.
3.7.6 Pixel Rectangle Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE BUFFERS is one, then pixel
rectangles are rasterized using the following algorithm. Let (X ;Y ) be the cur-
rp rp
rent raster position. (If the current raster position is invalid, then DrawPixels is
ignored.) If a particular group (index or components) is thenth in a row and be-
longs to themth row, consider the region in window coordinates bounded by the
rectangle with corners
(X +Z n;Y +Z m)
rp x rp y
and
(X +Z  (n + 1);Y +Z  (m + 1))
rp x rp y
whereZ andZ are the pixel zoom factors speci?ed by PixelZoom, and may each
x y
be either positive or negative. A fragment representing group (n;m) is produced
for each framebuffer pixel with one or more sample points that lie inside, or on
the bottom or left boundary, of this rectangle. Each fragment so produced takes its
associated data from the group and from the current raster position, in a manner
consistent with the discussion in the Conversion to Fragments subsection of sec-
tion 3.7.4. All depth and color sample values are assigned the same value, taken
either from their group (for depth and color component groups) or from the cur-
rent raster position (if they are not). All sample values are assigned the same fog
coordinate and the same set of texture coordinates, taken from the current raster
position.
Version 3.0 (September 23, 2008)3.8. BITMAPS 174
A single pixel rectangle will generate multiple, perhaps very many fragments
for the same framebuffer pixel, depending on the pixel zoom factors.
3.8 Bitmaps
Bitmaps are rectangles of zeros and ones specifying a particular pattern of frag-
ments to be produced. Each of these fragments has the same associated data. These
data are those associated with the current raster position.
Bitmaps are sent using
void Bitmap(sizeiw,sizeih,floatx ,floaty ,
bo bo
floatx ,floaty ,ubyte *data );
bi bi
w andh comprise the integer width and height of the rectangular bitmap, respec-
tively. (x ;y ) gives the ?oating-point x and y values of the bitmap’s origin.
bo bo
(x ;y ) gives the ?oating-point x and y increments that are added to the raster
bi bi
position after the bitmap is rasterized. data is a pointer to a bitmap.
Like a polygon pattern, a bitmap is unpacked from memory according to the
procedure given in section 3.7.4 for DrawPixels; it is as if the width and height
passed to that command were equal tow andh, respectively, the type wereBITMAP,
and the format were COLOR INDEX. The unpacked values (before any conversion
or arithmetic would have been performed) form a stipple pattern of zeros and ones.
See ?gure 3.9.
A bitmap sent using Bitmap is rasterized as follows. First, if the current raster
position is invalid (the valid bit is reset), the bitmap is ignored. Otherwise, a rect-
angular array of fragments is constructed, with lower left corner at
(x ;y ) = (bx  x c;by  y c)
ll ll rp bo rp bo
and upper right corner at (x +w;y +h) wherew andh are the width and height of
ll ll
the bitmap, respectively. Fragments in the array are produced if the corresponding
bit in the bitmap is 1 and not produced otherwise. The associated data for each
fragment are those associated with the current raster position. Once the fragments
have been produced, the current raster position is updated:
(x ;y ) (x +x ;y +y ):
rp rp rp bi rp bi
Thez andw values of the current raster position remain unchanged.
Calling Bitmap will result in an INVALID FRAMEBUFFER OPERATION error
if the object bound toDRAW FRAMEBUFFER BINDING is not framebuffer complete
(see section 4.4.4).
Version 3.0 (September 23, 2008)3.8. BITMAPS 175
 ! !   !                
 ! !   !                
" " # " #  ! #  !     !                                    
" " # " #   #                                  
"$ $" %# $" #%   %#                                        
$ $ % $ % %            
$& &$ ’% $& %’ ’%                  
& & ’ & ’ ’            
& & ’ & ’ ’                        
                 
                                   
                       
                                      
h = 12
                       
                             
           
                 
           
           
           
           
y
 = 1.0                  
bo
           
           
x
 = 2.5
bo
w = 8
Figure 3.9. A bitmap and its associated parameters.x andy are not shown.
bi bi
Bitmap Multisample Rasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then
bitmaps are rasterized using the following algorithm. If the current raster position
is invalid, the bitmap is ignored. Otherwise, a screen-aligned array of pixel-size
rectangles is constructed, with its lower left corner at (X ;Y ), and its upper
rp rp
right corner at (X +w;Y +h), where w and h are the width and height of
rp rp
the bitmap. Rectangles in this array are eliminated if the corresponding bit in the
bitmap is 0, and are retained otherwise. Bitmap rasterization produces a fragment
for each framebuffer pixel with one or more sample points either inside or on the
bottom or left edge of a retained rectangle.
Coverage bits that correspond to sample points either inside or on the bottom
or left edge of a retained rectangle are 1, other coverage bits are 0. The associated
data for each sample are those associated with the current raster position. Once the
fragments have been produced, the current raster position is updated exactly as it
is in the single-sample rasterization case.
Version 3.0 (September 23, 2008)3.9. TEXTURING 176
3.9 Texturing
Texturing maps a portion of one or more speci?ed images onto each primitive for
which texturing is enabled. This mapping is accomplished by using the color of an
image at the location indicated by a texture coordinate set’s (s;t;r;q) cordinates.
The internal data type of a texture may be ?xed-point, ?oating-point, signed
integer or unsigned integer, depending on the internal format of the texture. The
correspondence between the internal format and the internal data type is given in ta-
bles 3.16-3.18. Fixed-point and ?oating-point textures return a ?oating-point value
and integer textures return signed or unsigned integer values. When a fragment
shader is active, the shader is responsible for interpreting the result of a texture
lookup as the correct data type, otherwise the result is unde?ned. When not us-
ing a fragment shader, ?oating-point texture values are assumed, and the results of
using integer textures in this case are unde?ned.
Six types of texture are supported; each is a collection of images built from one-
, two-, or three-dimensional array of image elements referred to as texels. One-,
two-, and three-dimensional textures consist respectively of one-, two-, or three-
dimensional texel arrays. One- and two-dimensional array textures are arrays of
one- or two-dimensional images, consisting of one or more layers. Finally, a cube
map is a special two-dimensional array texture with six layers that represent the
faces of a cube. When accessing a cube map, the texture coordinates are projected
onto one of the six faces of the cube.
Implementations must support texturing using at least two images at a time.
Each fragment or vertex carries multiple sets of texture coordinates (s;t;r;q)
which are used to index separate images to produce color values which are collec-
tively used to modify the resulting transformed vertex or fragment color. Texturing
is speci?ed only for RGBA mode; its use in color index mode is unde?ned. The
following subsections (up to and including section 3.9.7) specify the GL operation
with a single texture and section 3.9.17 speci?es the details of how multiple texture
units interact.
The GL provides two ways to specify the details of how texturing of a primitive
is effected. The ?rst is referred to as ?xed-function fragment shading, or simply
?xed-function, and is described in this section. The second is referred to as a
fragment shader, and is described in section 3.12. The speci?cation of the image to
be texture mapped and the means by which the image is ?ltered when applied to the
primitive are common to both methods and are discussed in this section. The ?xed-
function method for determining what RGBA value is produced is also described in
this section. If a fragment shader is active, the method for determining the RGBA
value is speci?ed by an application-supplied fragment shader as described in the
OpenGL Shading Language Specification.
Version 3.0 (September 23, 2008)3.9. TEXTURING 177
When no fragment shader is active, the coordinates used for texturing are
(s=q;t=q;r=q), derived from the original texture coordinates (s;t;r;q). If the q
texture coordinate is less than or equal to zero, the coordinates used for texturing
are unde?ned. When a fragment shader is active, the (s;t;r;q) coordinates are
available to the fragment shader. The coordinates used for texturing in a fragment
shader are de?ned by the OpenGL Shading Language Specification.
3.9.1 Texture Image Specification
The command
void TexImage3D(enum target,int level,int internalformat,
sizei width,sizei height,sizei depth,int border,
enum format,enum type,void *data );
is used to specify a three-dimensional texture image. target must be one of
TEXTURE 3D for a three-dimensional texture or TEXTURE 2D ARRAY for an two-
dimensional array texture. Additionally, target may be eitherPROXY TEXTURE 3D
for a three-dimensional proxy texture, or PROXY TEXTURE 2D ARRAY for a two-
dimensional proxy array texture, as discussed in section 3.9.11. format, type, and
data match the corresponding arguments to DrawPixels (refer to section 3.7.4);
they specify the format of the image data, the type of those data, and a reference to
the image data in the currently bound pixel unpack buffer or client memory. The
formatSTENCIL INDEX is not allowed.
The groups in memory are treated as being arranged in a sequence of ad-
jacent rectangles. Each rectangle is a two-dimensional image, whose size and
organization are speci?ed by the width and height parameters to TexImage3D.
The values ofUNPACK ROW LENGTH andUNPACK ALIGNMENT control the row-to-
row spacing in these images in the same manner as DrawPixels. If the value of
the integer parameter UNPACK IMAGE HEIGHT is not positive, then the number
of rows in each two-dimensional image is height; otherwise the number of rows
is UNPACK IMAGE HEIGHT. Each two-dimensional image comprises an integral
number of rows, and is exactly adjacent to its neighbor images.
The mechanism for selecting a sub-volume of a three-dimensional image re-
lies on the integer parameter UNPACK SKIP IMAGES. If UNPACK SKIP IMAGES
is positive, the pointer is advanced byUNPACK SKIP IMAGES times the number of
elements in one two-dimensional image before obtaining the ?rst group from mem-
ory. Then depth two-dimensional images are processed, each having a subimage
extracted in the same manner as DrawPixels.
The selected groups are processed exactly as for DrawPixels, stopping just be-
fore ?nal conversion. If the internalformat of the texture is signed or unsigned
Version 3.0 (September 23, 2008)3.9. TEXTURING 178
integer, the components are clamped to the representable range of the internal for-
n 1 n 1
mat. For signed formats, this is [ 2 ; 2   1] wheren is the number of bits
n
per component; for unsigned formats, the range is [0; 2   1]. For color com-
ponent groups, if the internalformat of the texture is ?xed-point, the R, G, B, and
A values are clamped to [0; 1]. For depth component groups, the depth value is
clamped to [0; 1]. Otherwise, values are not modi?ed. Stencil index values are
n
masked by 2   1, wheren is the number of stencil bits in the internal format res-
olution (see below). If the base internal format is DEPTH STENCIL and format is
not DEPTH STENCIL, then the values of the stencil index texture components are
unde?ned.
Components are then selected from the resulting R, G, B, A, depth, or stencil
values to obtain a texture with the base internal format speci?ed by (or derived
from) internalformat. Table 3.15 summarizes the mapping of R, G, B, A, depth,
or stencil values to texture components, as a function of the base internal format of
the texture image. internalformat may be speci?ed as one of the internal format
symbolic constants listed in table 3.15, as one of the sized internal format symbolic
constants listed in tables 3.16- 3.18, as one of the generic compressed internal for-
mat symbolic constants listed in table 3.19, or as one of the speci?c compressed
internal format symbolic constants (if listed in table 3.19). internalformat may (for
backwards compatibility with the 1.0 version of the GL) also take on the integer
values 1, 2, 3, and 4, which are equivalent to symbolic constants LUMINANCE,
LUMINANCE ALPHA,RGB, andRGBA respectively. Specifying a value for internal-
format that is not one of the above values generates the errorINVALID VALUE.
Textures with a base internal format of DEPTH COMPONENT or
DEPTH STENCIL are supported by texture image speci?cation com-
mands only if target is TEXTURE 1D, TEXTURE 2D, TEXTURE 1D ARRAY,
TEXTURE 2D ARRAY, TEXTURE CUBE MAP, PROXY TEXTURE 1D,
PROXY TEXTURE 2D, PROXY TEXTURE 1D ARRAY, PROXY TEXTURE 2D ARRAY,
or PROXY TEXTURE CUBE MAP. Using these formats in conjunction with any
other target will result in anINVALID OPERATION error.
Textures with a base internal format of DEPTH COMPONENT or
DEPTH STENCIL require either depth component data or depth/stencil com-
ponent data. Textures with other base internal formats require RGBA component
data. The error INVALID OPERATION is generated if one of the base internal
format and format is DEPTH COMPONENT or DEPTH STENCIL, and the other is
neither of these values.
Textures with integer internal formats tables 3.16- 3.17 require integer data.
The error INVALID OPERATION is generated if the internal format is integer and
format is not one of the integer formats listed in table 3.6; if the internal format is
not integer and format is an integer format; or if format is an integer format and
Version 3.0 (September 23, 2008)3.9. TEXTURING 179
Base Internal Format RGBA, Depth, and Stencil Values Internal Components
ALPHA A A
DEPTH COMPONENT Depth D
DEPTH STENCIL Depth,Stencil D,S
LUMINANCE R L
LUMINANCE ALPHA R,A L,A
INTENSITY R I
RED R R
RG R,G R,G
RGB R,G,B R,G,B
RGBA R,G,B,A R,G,B,A
Table 3.15: Conversion from RGBA, depth, and stencil pixel components to inter-
nal texture, table, or ?lter components. See section 3.9.13 for a description of the
texture componentsR,G,B,A,L,I,D, andS.
type isFLOAT.
The GL provides no speci?c compressed internal formats but does provide a
mechanism to obtain token values for such formats provided by extensions. The
number of speci?c compressed internal formats supported by the renderer can
be obtained by querying the value ofNUM COMPRESSED TEXTURE FORMATS. The
set of speci?c compressed internal formats supported by the renderer can be ob-
tained by querying the value of COMPRESSED TEXTURE FORMATS. The only val-
ues returned by this query are those corresponding to formats suitable for general-
purpose usage. The renderer will not enumerate formats with restrictions that need
to be speci?cally understood prior to use.
Generic compressed internal formats are never used directly as the internal for-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a speci?c com-
pressed internal format of the GL’s choosing with the same base internal format.
If no speci?c compressed format is available, internalformat is instead replaced by
the corresponding base internal format. If internalformat is given as or mapped
to a speci?c compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
might not support 3D textures or borders), internalformat is replaced by the corre-
sponding base internal format and the texture image will not be compressed by the
GL.
Version 3.0 (September 23, 2008)3.9. TEXTURING 180
The internal component resolution is the number of bits allocated to each value
in a texture image. If internalformat is speci?ed as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing. If a sized internal format is speci?ed, the mapping of the R, G, B, A, depth,
and stencil values to texture components is equivalent to the mapping of the cor-
responding base internal format’s components, as speci?ed in table 3.15; the type
(unsigned int, ?oat, etc.) is assigned the same type speci?ed by internalformat;
and the memory allocation per texture component is assigned by the GL to match
the allocations listed in tables 3.16- 3.18 as closely as possible. (The de?nition of
closely is left up to the implementation. However, a non-zero number of bits must
be allocated for each component whose desired allocation in tables 3.16- 3.18 is
non-zero, and zero bits must be allocated for all other components).
Required Texture Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, ?oat, etc.) for each base internal
format.
In addition, implementations are required to support the following sized in-
ternal formats. Requesting one of these internal formats for any texture type will
allocate exactly the internal component sizes and types shown for that format in
tables 3.16- 3.17:
 Color formats:
– RGBA32F, RGBA32I, RGBA32UI, RGBA16, RGBA16F, RGBA16I,
RGBA16UI, RGBA8, RGBA8I, RGBA8UI, SRGB8 ALPHA8, and
RGB10 A2.
– R11F G11F B10F.
– RG32F, RG32I, RG32UI, RG16, RG16F, RG16I, RG16UI, RG8, RG8I,
andRG8UI.
– R32F,R32I,R32UI,R16F,R16I,R16UI,R16,R8,R8I, andR8UI.
– ALPHA8.
 Color formats (texture-only):
– RGB32F,RGB32I, andRGB32UI.
– RGB16F,RGB16I,RGB16UI, andRGB16.
– RGB8,RGB8I,RGB8UI, andSRGB8.
Version 3.0 (September 23, 2008)3.9. TEXTURING 181
– RGB9 E5.
– COMPRESSED RG RGTC2 andCOMPRESSED SIGNED RG RGTC2.
– COMPRESSED RED RGTC1 andCOMPRESSED SIGNED RED RGTC1.
 Depth formats: DEPTH COMPONENT32F, DEPTH COMPONENT24, and
DEPTH COMPONENT16.
 Combined depth+stencil formats: DEPTH32F STENCIL8 and
DEPTH24 STENCIL8.
Encoding of Special Internal Formats
If internalformat is R11F G11F B10F, the red, green, and blue bits are converted
to unsigned 11-bit, unsigned 11-bit, and unsigned 10-bit ?oating-point values as
described in sections 2.1.3 and 2.1.4.
If internalformat is RGB9 E5, the red, green, and blue bits are converted to a
shared exponent format according to the following procedure:
Componentsred,green, andblue are ?rst clamped (in the process, mapping
NaN to zero) as follows:
red =max(0;min(sharedexp ;red))
c max
green =max(0;min(sharedexp ;green))
c max
blue =max(0;min(sharedexp ;blue))
c max
where
N
(2   1)
E  B
max
sharedexp = 2 :
max
N
2
N is the number of mantissa bits per component (9),B is the exponent bias (15),
andE is the maximum allowed biased exponent value (31).
max
The largest clamped component,max , is determined:
c
max =max(red ;green ;blue )
c c c c
A preliminary shared exponentexp is computed:
p
exp =max( B  1;blog (max )c) + 1 +B
p 2 c
A re?ned shared exponentexp is computed:
s
j k
max
c
max = + 0:5
s
exp  B N
p
2
Version 3.0 (September 23, 2008)3.9. TEXTURING 182
(
N
exp ; 0max < 2
p s
exp =
s
N
exp + 1; max = 2
p s
N
Finally, three integer values in the range 0 to 2   1 are computed:
 
red
c
red = + 0:5
s
exp B N
s
2
j k
green
c
green = + 0:5
s
exp B N
s
2
 
blue
c
blue = + 0:5
s
exp B N
s
2
The resultingred ,green ,blue , andexp are stored in the red, green, blue,
s s s s
and shared bits respectively of the texture image.
An implementation accepting pixel data of type UNSIGNED INT 5 9 9 9 REV
with format RGB is allowed to store the components “as is” if the implementation
can determine the current pixel transfer state acts as an identity transform on the
components.
Sized Base R G B A Shared
Internal Format Internal Format bits bits bits bits bits
ALPHA4 ALPHA 4
ALPHA8 ALPHA 8
ALPHA12 ALPHA 12
ALPHA16 ALPHA 16
R8 RED 8
R16 RED 16
RG8 RG 8 8
RG16 RG 16 16
R3 G3 B2 RGB 3 3 2
RGB4 RGB 4 4 4
RGB5 RGB 5 5 5
RGB8 RGB 8 8 8
RGB10 RGB 10 10 10
RGB12 RGB 12 12 12
RGB16 RGB 16 16 16
Sized internal color formats continued on next page
Version 3.0 (September 23, 2008)3.9. TEXTURING 183
Sized internal color formats continued from previous page
Sized Base R G B A Shared
Internal Format Internal Format bits bits bits bits bits
RGBA2 RGBA 2 2 2 2
RGBA4 RGBA 4 4 4 4
RGB5 A1 RGBA 5 5 5 1
RGBA8 RGBA 8 8 8 8
RGB10 A2 RGBA 10 10 10 2
RGBA12 RGBA 12 12 12 12
RGBA16 RGBA 16 16 16 16
SRGB8 RGB 8 8 8
SRGB8 ALPHA8 RGBA 8 8 8 8
R16F RED f16
RG16F RG f16 f16
RGB16F RGB f16 f16 f16
RGBA16F RGBA f16 f16 f16 f16
R32F RED f32
RG32F RG f32 f32
RGB32F RGB f32 f32 f32
RGBA32F RGBA f32 f32 f32 f32
R11F G11F B10F RGB f11 f11 f10
RGB9 E5 RGB 9 9 9 5
R8I RED i8
R8UI RED ui8
R16I RED i16
R16UI RED ui16
R32I RED i32
R32UI RED ui32
RG8I RG i8 i8
RG8UI RG ui8 ui8
RG16I RG i16 i16
RG16UI RG ui16 ui16
RG32I RG i32 i32
RG32UI RG ui32 ui32
RGB8I RGB i8 i8 i8
RGB8UI RGB ui8 ui8 ui8
RGB16I RGB i16 i16 i16
Sized internal color formats continued on next page
Version 3.0 (September 23, 2008)3.9. TEXTURING 184
Sized internal color formats continued from previous page
Sized Base R G B A Shared
Internal Format Internal Format bits bits bits bits bits
RGB16UI RGB ui16 ui16 ui16
RGB32I RGB i32 i32 i32
RGB32UI RGB ui32 ui32 ui32
RGBA8I RGBA i8 i8 i8 i8
RGBA8UI RGBA ui8 ui8 ui8 ui8
RGBA16I RGBA i16 i16 i16 i16
RGBA16UI RGBA ui16 ui16 ui16 ui16
RGBA32I RGBA i32 i32 i32 i32
RGBA32UI RGBA ui32 ui32 ui32 ui32
Table 3.16: Correspondence of sized internal color formats to base
internal formats, internal data type, and desired component reso-
lutions for each sized internal format. The component resolution
pre?x indicates the internal data type: f is ?oating point, i is signed
integer, ui is unsigned integer, and no pre?x is ?xed-point.
Sized Base A L I
Internal Format Internal Format bits bits bits
LUMINANCE4 LUMINANCE 4
LUMINANCE8 LUMINANCE 8
LUMINANCE12 LUMINANCE 12
LUMINANCE16 LUMINANCE 16
LUMINANCE4 ALPHA4 LUMINANCE ALPHA 4 4
LUMINANCE6 ALPHA2 LUMINANCE ALPHA 2 6
LUMINANCE8 ALPHA8 LUMINANCE ALPHA 8 8
LUMINANCE12 ALPHA4 LUMINANCE ALPHA 4 12
LUMINANCE12 ALPHA12 LUMINANCE ALPHA 12 12
LUMINANCE16 ALPHA16 LUMINANCE ALPHA 16 16
INTENSITY4 INTENSITY 4
INTENSITY8 INTENSITY 8
INTENSITY12 INTENSITY 12
INTENSITY16 INTENSITY 16
Sized internal luminance formats continued on next page
Version 3.0 (September 23, 2008)3.9. TEXTURING 185
Sized Base D S
Internal Format Internal Format bits bits
DEPTH COMPONENT16 DEPTH COMPONENT 16
DEPTH COMPONENT24 DEPTH COMPONENT 24
DEPTH COMPONENT32 DEPTH COMPONENT 32
DEPTH COMPONENT32F DEPTH COMPONENT f32
DEPTH24 STENCIL8 DEPTH STENCIL 24 8
DEPTH32F STENCIL8 DEPTH STENCIL f32 8
Table 3.18: Correspondence of sized internal depth and stencil formats to base
internal formats, internal data type, and desired component resolutions for each
sized internal format. The component resolution pre?x indicates the internal data
type: f is ?oating point, i is signed integer, ui is unsigned integer, and no pre?x is
?xed-point.
Sized internal luminance formats continued from previous page
Sized Base A L I
Internal Format Internal Format bits bits bits
SLUMINANCE LUMINANCE 8
SLUMINANCE ALPHA8 LUMINANCE ALPHA 8 8
Table 3.17: Correspondence of sized internal luminance and inten-
sity formats to base internal formats, internal data type, and desired
component resolutions for each sized internal format. The compo-
nent resolution pre?x indicates the internal data type: f is ?oating
point, i is signed integer, ui is unsigned integer, and no pre?x is
?xed-point.
If a compressed internal format is speci?ed, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internal format’s components, as speci?ed in table 3.15. The speci?ed image
is compressed using a (possibly lossy) compression algorithm chosen by the GL.
A GL implementation may vary its allocation of internal component resolution
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low), or TexImage1D (see below) parameter (except target), but the allocation and
chosen compressed image format must not be a function of any other state and can-
not be changed once they are established. In addition, the choice of a compressed
Version 3.0 (September 23, 2008)3.9. TEXTURING 186
Compressed Internal Format Base Internal Format Type
COMPRESSED ALPHA ALPHA Generic
COMPRESSED LUMINANCE LUMINANCE Generic
COMPRESSED LUMINANCE ALPHA LUMINANCE ALPHA Generic
COMPRESSED INTENSITY INTENSITY Generic
COMPRESSED RED RED Generic
COMPRESSED RG RG Generic
COMPRESSED RGB RGB Generic
COMPRESSED RGBA RGBA Generic
COMPRESSED SRGB RGB Generic
COMPRESSED SRGB ALPHA RGBA Generic
COMPRESSED SLUMINANCE LUMINANCE Generic
COMPRESSED SLUMINANCE ALPHA LUMINANCE ALPHA Generic
COMPRESSED RED RGTC1 RED Speci?c
COMPRESSED SIGNED RED RGTC1 RED Speci?c
COMPRESSED RG RGTC2 RG Speci?c
COMPRESSED SIGNED RG RGTC2 RG Speci?c
Table 3.19: Generic and speci?c compressed internal formats. The speci?c
RGTC formats are described in appendix C.1.
* *
Version 3.0 (September 23, 2008)3.9. TEXTURING 187
image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each
time a texture image is speci?ed with the same parameter values. These allocation
rules also apply to proxy textures, which are described in section 3.9.11.
The image itself (referred to by data) is a sequence of groups of values. The
?rst group is the lower left back corner of the texture image. Subsequent groups
?ll out rows of width width from left to right; height rows are stacked from bottom
to top forming a single two-dimensional image slice; and depth slices are stacked
from back to front. When the ?nal R, G, B, and A components have been computed
for a group, they are assigned to components of a texel as described by table 3.15.
Counting from zero, each resultingNth texel is assigned internal integer coordi-
nates (i;j;k), where
i = (N modwidth) w
b
N
j = (b c modheight) h
b
width
N
k = (b c moddepth) d
b
widthheight
andw ,h , andd are the speci?ed border width, height, and depth.w andh are
b b b b b
the speci?ed border value;d is the speci?ed border value if target isTEXTURE 3D,
b
or zero if target isTEXTURE 2D ARRAY. Thus the last two-dimensional image slice
of the three-dimensional image is indexed with the highest value ofk.
Each color component is converted (by rounding to nearest) to a ?xed-point
value withn bits, wheren is the number of bits of storage allocated to that com-
ponent in the image array. We assume that the ?xed-point representation used
n n
represents each valuek=(2   1), wherek2f0; 1;:::; 2   1g, ask (e.g. 1.0 is
represented in binary as a string of all ones).
The level argument to TexImage3D is an integer level-of-detail number. Levels
of detail are discussed below, under Mipmapping. The main texture image has a
level of detail number of 0. If a level-of-detail less than zero is speci?ed, the error
INVALID VALUE is generated.
The border argument to TexImage3D is a border width. The signi?cance of
borders is described below. The border width affects the dimensions of the texture
image: let
w =w + 2w
s t b
h =h + 2h (3.15)
s t b
d =d + 2d
s t b
Version 3.0 (September 23, 2008)3.9. TEXTURING 188
wherew ,h , andd are the speci?ed image width, depth, and depth, andw ,
s s s t
h , andd are the dimensions of the texture image internal to the border. Ifw ,h ,
t t t t
ord are less than zero, then the errorINVALID VALUE is generated.
t
An image with zero width, height, or depth indicates the null texture. If
the null texture is speci?ed for the level-of-detail speci?ed by texture parameter
TEXTURE BASE LEVEL (see section 3.9.4), it is as if texturing were disabled.
Currently, the maximum border widthb is 1. If border is less than zero, or
t
greater thanb , then the errorINVALID VALUE is generated.
t
The maximum allowable width, height, or depth of a texel array for a three-
dimensional texture is an implementation dependent function of the level-of-detail
k lod
and internal format of the resulting image array. It must be at least 2 + 2b
t
for image arrays of level-of-detail 0 through k, where k is the log base 2 of
MAX 3D TEXTURE SIZE, lod is the level-of-detail of the image array, and b is
t
the maximum border width. It may be zero for image arrays of any level-of-detail
greater than k. The error INVALID VALUE is generated if the speci?ed image is
too large to be stored under any conditions.
If a pixel unpack buffer object is bound and storing texture data would access
memory beyond the end of the pixel unpack buffer, anINVALID OPERATION error
results.
In a similar fashion, the maximum allowable width of a texel array for a one-
or two-dimensional, or one- or two-dimensional array texture, and the maximum
allowable height of a two-dimensional or two-dimensional array texture, must be
k lod
at least 2 +2b for image arrays of level 0 throughk, wherek is the log base 2
t
ofMAX TEXTURE SIZE. The maximum allowable width and height of a cube map
k lod
texture must be the same, and must be at least 2 + 2b for image arrays level
t
0 through k, where k is the log base 2 of MAX CUBE MAP TEXTURE SIZE. The
maximum number of layers for one- and two-dimensional array textures (height or
depth, respectively) must be at leastMAX ARRAY TEXTURE LAYERS for all levels.
An implementation may allow an image array of level 0 to be created only if
that single image array can be supported. Additional constraints on the creation of
image arrays of level 1 or greater are described in more detail in section 3.9.10.
The command
void TexImage2D(enum target,int level,
int internalformat,sizei width,sizei height,
int border,enum format,enum type,void *data );
is used to specify a two-dimensional texture image. target must be one
of TEXTURE 2D for a two-dimensional texture, TEXTURE 1D ARRAY for a
one-dimensional array texture, or one of TEXTURE CUBE MAP POSITIVE X,
Version 3.0 (September 23, 2008)3.9. TEXTURING 189
TEXTURE CUBE MAP NEGATIVE X, TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP NEGATIVE Y, TEXTURE CUBE MAP POSITIVE Z, or
TEXTURE CUBE MAP NEGATIVE Z for a cube map texture. Additionally, tar-
get may be either PROXY TEXTURE 2D for a two-dimensional proxy texture,
PROXY TEXTURE 1D ARRAY for a one-dimensional proxy array texture, or
PROXY TEXTURE CUBE MAP for a cube map proxy texture in the special case
discussed in section 3.9.11. The other parameters match the corresponding
parameters of TexImage3D.
For the purposes of decoding the texture image, TexImage2D is equivalent to
calling TexImage3D with corresponding arguments and depth of 1, except that
 The border depth,d , is zero, and the depth of the image is always 1 regard-
b
less of the value of border.
 The border height, h , is zero if target is TEXTURE 1D ARRAY, and border
b
otherwise.
 Convolution will be performed on the image (possibly changing its width
and height) ifSEPARABLE 2D orCONVOLUTION 2D is enabled.
 UNPACK SKIP IMAGES is ignored.
A two-dimensional texture consists of a single two-dimensional texture image.
A cube map texture is a set of six two-dimensional texture images. The six cube
map texture targets form a single cube map texture though each target names a
distinct face of the cube map. TheTEXTURE CUBE MAP targets listed above up-
*
date their appropriate cube map face 2D texture image. Note that the six cube map
two-dimensional image tokens such asTEXTURE CUBE MAP POSITIVE X are used
when specifying, updating, or querying one of a cube map’s six two-dimensional
images, but when enabling cube map texturing or binding to a cube map texture
object (that is when the cube map is accessed as a whole as opposed to a particular
two-dimensional image), theTEXTURE CUBE MAP target is speci?ed.
When the target parameter to TexImage2D is one of the six cube map two-
dimensional image targets, the errorINVALID VALUE is generated if the width and
height parameters are not equal.
Finally, the command
void TexImage1D(enum target,int level,
int internalformat,sizei width,int border,
enum format,enum type,void *data );
Version 3.0 (September 23, 2008)3.9. TEXTURING 190
is used to specify a one-dimensional texture image. target must be either
TEXTURE 1D, or PROXY TEXTURE 1D in the special case discussed in sec-
tion 3.9.11.)
For the purposes of decoding the texture image, TexImage1D is equivalent to
calling TexImage2D with corresponding arguments and height of 1, except that
 The border height and depth (h andd ) are always zero, regardless of the
b b
value of border.
 Convolution will be performed on the image (possibly changing its width)
only ifCONVOLUTION 1D is enabled.
The image indicated to the GL by the image pointer is decoded and copied into
the GL’s internal memory. This copying effectively places the decoded image in-
side a border of the maximum allowable widthb whether or not a border has been
t
1
speci?ed (see ?gure 3.10) . If no border or a border smaller than the maximum
allowable width has been speci?ed, then the image is still stored as if it were sur-
rounded by a border of the maximum possible width. Any excess border (which
surrounds the speci?ed image, including any border) is assigned unspeci?ed val-
ues. A two-dimensional texture has a border only at its left, right, top, and bottom
ends, and a one-dimensional texture has a border only at its left and right ends.
We shall refer to the (possibly border augmented) decoded image as the texel
array. A three-dimensional texel array has width, height, and depthw ,h , and
s s
d as de?ned in equation 3.15. A two-dimensional texel array has depthd = 1,
s s
with heighth and widthw as above, and a one-dimensional texel array has depth
s s
d = 1, heighth = 1, and widthw as above.
s s s
An element (i;j;k) of the texel array is called a texel (for a two-dimensional
texture or one-dimensional array texture, k is irrelevant; for a one-dimensional
texture, j and k are both irrelevant). The texture value used in texturing a frag-
ment is determined by that fragment’s associated (s;t;r) coordinates, but may not
correspond to any actual texel. See ?gure 3.10.
If the data argument of TexImage1D, TexImage2D, or TexImage3D is a null
pointer (a zero-valued pointer in the C implementation), and the pixel unpack
buffer object is zero, a one-, two-, or three-dimensional texel array is created
with the speci?ed target, level, internalformat, border, width, height, and depth,
but with unspeci?ed image contents. In this case no pixel values are accessed in
client memory, and no pixel processing is performed. Errors are generated, how-
ever, exactly as though the data pointer were valid. Otherwise if the pixel unpack
buffer object is non-zero, the data argument is treatedly normally to refer to the
beginning of the pixel unpack buffer object’s data.
1
Figure 3.10 needs to show a three-dimensional texture image.
Version 3.0 (September 23, 2008)3.9. TEXTURING 191
5.0
4
1.0
3
?
2
t v j
?
1
0
0.0
?1
?1.0
?1 0 1 2 3 4 5 6 7 8
i
?1.0 u 9.0
0.0 s 1.0
Figure 3.10. A texture image and the coordinates used to access it. This is a two-
dimensional texture with n = 3 and m = 2. A one-dimensional texture would
consist of a single horizontal strip. and, values used in blending adjacent texels
to obtain a texture value, are also shown.
Version 3.0 (September 23, 2008)3.9. TEXTURING 192
3.9.2 Alternate Texture Image Specification Commands
Two-dimensional and one-dimensional texture images may also be speci?ed us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existing texture images may be respeci?ed.
The command
void CopyTexImage2D(enum target,int level,
enum internalformat,int x,int y,sizei width,
sizei height,int border );
de?nes a two-dimensional texel array in exactly the manner of TexImage2D, ex-
cept that the image data are taken from the framebuffer rather than from client
memory. Currently, target must be one of TEXTURE 2D, TEXTURE 1D ARRAY,
TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z. x, y,
width, and height correspond precisely to the corresponding arguments to Copy-
Pixels (refer to section 4.3.3); they specify the image’s width and height, and the
lower left (x;y) coordinates of the framebuffer region to be copied. The image is
taken from the framebuffer exactly as if these arguments were passed to CopyP-
ixels with argument type set to COLOR, DEPTH, or DEPTH STENCIL, depending
on internalformat, stopping after pixel transfer processing is complete. RGBA
data is taken from the current color buffer, while depth component and stencil
index data are taken from the depth and stencil buffers, respectively. The er-
rorINVALID OPERATION is generated if depth component data is required and no
depth buffer is present; if stencil index data is required and no stencil buffer is
present; if integer RGBA data is required and the format of the current color buffer
is not integer; or if ?oating- or ?xed-point RGBA data is required and the format
of the current color buffer is integer.
Subsequent processing is identical to that described for TexImage2D, begin-
ning with clamping of the R, G, B, A, or depth values, and masking of the stencil
index values from the resulting pixel groups. Parameters level, internalformat, and
border are speci?ed using the same values, with the same meanings, as the equiv-
alent arguments of TexImage2D, except that internalformat may not be speci?ed
as 1, 2, 3, or 4. An invalid value speci?ed for internalformat generates the error
INVALID ENUM. The constraints on width, height, and border are exactly those for
the equivalent arguments of TexImage2D.
When the target parameter to CopyTexImage2D is one of the six cube map
two-dimensional image targets, the errorINVALID VALUE is generated if the width
and height parameters are not equal.
Version 3.0 (September 23, 2008)3.9. TEXTURING 193
The command
void CopyTexImage1D(enum target,int level,
enum internalformat,int x,int y,sizei width,
int border );
de?nes a one-dimensional texel array in exactly the manner of TexImage1D, ex-
cept that the image data are taken from the framebuffer, rather than from client
memory. Currently, target must beTEXTURE 1D. For the purposes of decoding the
texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D with
corresponding arguments and height of 1, except that the height of the image is
always 1, regardless of the value of border. level, internalformat, and border are
speci?ed using the same values, with the same meanings, as the equivalent argu-
ments of TexImage1D, except that internalformat may not be speci?ed as 1, 2,
3, or 4. The constraints on width and border are exactly those of the equivalent
arguments of TexImage1D.
Six additional commands,
void TexSubImage3D(enum target,int level,int xoffset,
int yoffset,int zoffset,sizei width,sizei height,
sizei depth,enum format,enum type,void *data );
void TexSubImage2D(enum target,int level,int xoffset,
int yoffset,sizei width,sizei height,enum format,
enum type,void *data );
void TexSubImage1D(enum target,int level,int xoffset,
sizei width,enum format,enum type,void *data );
void CopyTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,int x,int y,
sizei width,sizei height );
void CopyTexSubImage2D(enum target,int level,
int xoffset,int yoffset,int x,int y,sizei width,
sizei height );
void CopyTexSubImage1D(enum target,int level,
int xoffset,int x,int y,sizei width );
respecify only a rectangular subregion of an existing texel array. No change is
made to the internalformat, width, height, depth, or border parameters of the spec-
i?ed texel array, nor is any change made to texel values outside the speci?ed
subregion. Currently the target arguments of TexSubImage1D and CopyTex-
SubImage1D must be TEXTURE 1D, the target arguments of TexSubImage2D
Version 3.0 (September 23, 2008)3.9. TEXTURING 194
and CopyTexSubImage2D must be one of TEXTURE 2D, TEXTURE 1D ARRAY,
TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, orTEXTURE CUBE MAP NEGATIVE Z, and the
target arguments of TexSubImage3D and CopyTexSubImage3D must be
TEXTURE 3D orTEXTURE 2D ARRAY. The level parameter of each command spec-
i?es the level of the texel array that is modi?ed. If level is less than zero or greater
than the base 2 logarithm of the maximum texture width, height, or depth, the error
INVALID VALUE is generated.
TexSubImage3D arguments width, height, depth, format, type, and data match
the corresponding arguments to TexImage3D, meaning that they are speci?ed us-
ing the same values, and have the same meanings. Likewise, TexSubImage2D
arguments width, height, format, type, and data match the corresponding argu-
ments to TexImage2D, and TexSubImage1D arguments width, format, type, and
data match the corresponding arguments to TexImage1D.
CopyTexSubImage3D and CopyTexSubImage2D arguments x, y, width,
2
and height match the corresponding arguments to CopyTexImage2D . CopyTex-
SubImage1D arguments x, y, and width match the corresponding arguments to
CopyTexImage1D. Each of the TexSubImage commands interprets and processes
pixel groups in exactly the manner of its TexImage counterpart, except that the as-
signment of R, G, B, A, depth, and stencil index pixel group values to the texture
components is controlled by the internalformat of the texel array, not by an argu-
ment to the command. The same constraints and errors apply to the TexSubImage
commands’ argument format and the internalformat of the texel array being re-
speci?ed as apply to the format and internalformat arguments of its TexImage
counterparts.
Arguments xoffset, yoffset, and zoffset of TexSubImage3D and CopyTex-
SubImage3D specify the lower left texel coordinates of a width-wide by height-
high by depth-deep rectangular subregion of the texel array. The depth argument
associated with CopyTexSubImage3D is always 1, because framebuffer memory
is two-dimensional - only a portion of a single s;t slice of a three-dimensional
texture is replaced by CopyTexSubImage3D.
Negative values of xoffset, yoffset, and zoffset correspond to the coordinates of
border texels, addressed as in ?gure 3.10. Taking w , h , d , w , h , and d to
s s s b b b
be the speci?ed width, height, depth, and border width, border height, and border
depth of the texel array, and takingx, y, z, w, h, andd to be the xoffset, yoffset,
zoffset, width, height, and depth argument values, any of the following relationships
2
Because the framebuffer is inherently two-dimensional, there is no CopyTexImage3D com-
mand.
Version 3.0 (September 23, 2008)3.9. TEXTURING 195
generates the errorINVALID VALUE:
x< w
b
x +w>w  w
s b
y< h
b
y +h>h  h
s b
z< d
b
z +d>d  d
s b
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i;j;k], where
i =x + (n modw)
n
j =y + (b c modh)
w
n
k =z + (b c modd
widthheight
Arguments xoffset and yoffset of TexSubImage2D and CopyTexSubImage2D
specify the lower left texel coordinates of a width-wide by height-high rectangular
subregion of the texel array. Negative values of xoffset and yoffset correspond to
the coordinates of border texels, addressed as in ?gure 3.10. Takingw ,h , andb
s s s
to be the speci?ed width, height, and border width of the texel array, and takingx,
y,w, andh to be the xoffset, yoffset, width, and height argument values, any of the
following relationships generates the errorINVALID VALUE:
x< b
s
x +w>w  b
s s
y< b
s
y +h>h  b
s s
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i;j], where
i =x + (n modw)
n
j =y + (b c modh)
w
Version 3.0 (September 23, 2008)3.9. TEXTURING 196
The xoffset argument of TexSubImage1D and CopyTexSubImage1D speci-
?es the left texel coordinate of a width-wide subregion of the texel array. Negative
values of xoffset correspond to the coordinates of border texels. Takingw andb
s s
to be the speci?ed width and border width of the texel array, andx andw to be the
xoffset and width argument values, either of the following relationships generates
the errorINVALID VALUE:
x< b
s
x +w>w  b
s s
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i], where
i =x + (n modw)
Texture images with compressed internal formats may be stored in such a way
that it is not possible to modify an image with subimage commands without having
to decompress and recompress the texture image. Even if the image were modi-
?ed in this manner, it may not be possible to preserve the contents of some of
the texels outside the region being modi?ed. To avoid these complications, the
GL does not support arbitrary modi?cations to texture images with compressed
internal formats. Calling TexSubImage3D, CopyTexSubImage3D, TexSubIm-
age2D, CopyTexSubImage2D, TexSubImage1D, or CopyTexSubImage1D will
result in anINVALID OPERATION error if xoffset, yoffset, or zoffset is not equal to
 b (border width). In addition, the contents of any texel outside the region mod-
s
i?ed by such a call are unde?ned. These restrictions may be relaxed for speci?c
compressed internal formats whose images are easily modi?ed.
If the internal format of the texture image being modi?ed is one of the speci?c
RGTC formats described in table 3.19, the texture is stored using one of the RGTC
texture image encodings (see appendix C.1). Since RGTC images are easily
edited along 4 4 texel boundaries, the limitations on subimage location and size
are relaxed for TexSubImage2D, TexSubImage3D, CopyTexSubImage2D, and
CopyTexSubImage3D. These commands will generate anINVALID OPERATION
error if one of the following conditions occurs:
 width is not a multiple of four or equal to TEXTURE WIDTH, unless xoffset
and yoffset are both zero.
 height is not a multiple of four or equal toTEXTURE HEIGHT, unless xoffset
and yoffset are both zero.
Version 3.0 (September 23, 2008)3.9. TEXTURING 197
 xoffset or yoffset is not a multiple of four.
The contents of any 4 4 block of texels of an RGTC compressed texture
image that does not intersect the area being modi?ed are preserved during valid
TexSubImage* and CopyTexSubImage* calls.
Calling CopyTexSubImage3D, CopyTex-
Image2D, CopyTexSubImage2D, CopyTexImage1D, or CopyTexSubImage1D
will result in anINVALID FRAMEBUFFER OPERATION error if the object bound to
READ FRAMEBUFFER BINDING is not framebuffer complete (see section 4.4.4).
3.9.3 Compressed Texture Images
Texture images may also be speci?ed or modi?ed using image data already stored
in a known compressed image format, such as the RGTC formats de?ned in ap-
pendix C, or additional formats de?ned by GL extensions.
The commands
void CompressedTexImage1D(enum target,int level,
enum internalformat,sizei width,int border,
sizei imageSize,void *data );
void CompressedTexImage2D(enum target,int level,
enum internalformat,sizei width,sizei height,
int border,sizei imageSize,void *data );
void CompressedTexImage3D(enum target,int level,
enum internalformat,sizei width,sizei height,
sizei depth,int border,sizei imageSize,void *data );
de?ne one-, two-, and three-dimensional texture images, respectively, with incom-
ing data stored in a speci?c compressed image format. The target, level, internal-
format, width, height, depth, and border parameters have the same meaning as in
TexImage1D, TexImage2D, and TexImage3D. data refers to compressed image
data stored in the speci?c compressed image format corresponding to internal-
format. If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
and the compressed data is read from the buffer relative to this offset; otherwise,
data is a pointer to client memory and the compressed data is read from client
memory relative to the pointer.
internalformat must be a supported speci?c compressed internal format. An
INVALID ENUM error will be generated if any other values, including any of the six
generic compressed internal formats, is speci?ed.
Version 3.0 (September 23, 2008)3.9. TEXTURING 198
For all other compressed internal formats, the compressed image will be de-
coded according to the speci?cation de?ning the internalformat token. Com-
pressed texture images are treated as an array of imageSize ubytes relative to
data. If a pixel unpack buffer object is bound anddata +imageSize is greater
than the size of the pixel buffer, an INVALID OPERATION error results. All pixel
storage and pixel transfer modes are ignored when decoding a compressed texture
image. If the imageSize parameter is not consistent with the format, dimensions,
and contents of the compressed image, an INVALID VALUE error results. If the
compressed image is not encoded according to the de?ned image format, the re-
sults of the call are unde?ned.
Speci?c compressed internal formats may impose format-speci?c restrictions
on the use of the compressed image speci?cation calls or parameters. For example,
the compressed image format might be supported only for 2D textures, or might
not allow non-zero border values. Any such restrictions will be documented in the
extension speci?cation de?ning the compressed internal format; violating these
restrictions will result in anINVALID OPERATION error.
Any restrictions imposed by speci?c compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in
compressed form, providing the same image to CompressedTexImage1D,
CompressedTexImage2D, or CompressedTexImage3D will not result in an
INVALID OPERATION error if the following restrictions are satis?ed:
 data points to a compressed texture image returned by GetCompressedTex-
Image (section 6.1.4).
 target, level, and internalformat match the target, level and format parame-
ters provided to the GetCompressedTexImage call returning data.
 width, height, depth, border, internalformat, and image-
Size match the values of TEXTURE WIDTH, TEXTURE HEIGHT,
TEXTURE DEPTH, TEXTURE BORDER, TEXTURE INTERNAL FORMAT,
and TEXTURE COMPRESSED IMAGE SIZE for image level level in effect at
the time of the GetCompressedTexImage call returning data.
This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
and format.
If internalformat is one of the speci?cRGTC or formats described in table 3.19,
the compressed image data is stored using one of the RGTC compressed texture im-
age encodings (see appendix C.1) The RGTC texture compression algorithm sup-
ports only two-dimensional images without borders. If internalformat is an RGTC
Version 3.0 (September 23, 2008)3.9. TEXTURING 199
format, CompressedTexImage1D will generate an INVALID ENUM error; Com-
pressedTexImage2D will generate an INVALID OPERATION error if border is
non-zero; and CompressedTexImage3D will generate an INVALID OPERATION
error if border is non-zero or target is notTEXTURE 2D ARRAY.
The commands
void CompressedTexSubImage1D(enum target,int level,
int xoffset,sizei width,enum format,sizei imageSize,
void *data );
void CompressedTexSubImage2D(enum target,int level,
int xoffset,int yoffset,sizei width,sizei height,
enum format,sizei imageSize,void *data );
void CompressedTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth,enum format,
sizei imageSize,void *data );
respecify only a rectangular region of an existing texel array, with incoming data
stored in a known compressed image format. The target, level, xoffset, yoffset, zoff-
set, width, height, and depth parameters have the same meaning as in TexSubIm-
age1D, TexSubImage2D, and TexSubImage3D. data points to compressed im-
age data stored in the compressed image format corresponding to format. Since
the core GL provides no speci?c image formats, using any of these six generic
compressed internal formats as format will result in anINVALID ENUM error.
The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D. These commands do not provide for im-
age format conversion, so an INVALID OPERATION error results if format does
not match the internal format of the texture image being modi?ed. If the image-
Size parameter is not consistent with the format, dimensions, and contents of the
compressed image (too little or too much data), anINVALID VALUE error results.
As with CompressedTexImage calls, compressed internal formats may have
additional restrictions on the use of the compressed image speci?cation calls or
parameters. Any such restrictions will be documented in the speci?cation de?n-
ing the compressed internal format; violating these restrictions will result in an
INVALID OPERATION error.
Any restrictions imposed by speci?c compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in com-
pressed form, providing the same image to CompressedTexSubImage1D, Com-
pressedTexSubImage2D, CompressedTexSubImage3D will not result in an
INVALID OPERATION error if the following restrictions are satis?ed:
Version 3.0 (September 23, 2008)3.9. TEXTURING 200
 data points to a compressed texture image returned by GetCompressedTex-
Image (section 6.1.4).
 target, level, and format match the target, level and format parameters pro-
vided to the GetCompressedTexImage call returning data.
 width, height, depth, format, and imageSize match the val-
ues of TEXTURE WIDTH, TEXTURE HEIGHT, TEXTURE DEPTH,
TEXTURE INTERNAL FORMAT, and TEXTURE COMPRESSED IMAGE SIZE
for image level level in effect at the time of the GetCompressedTexImage
call returning data.
 width, height, depth, format match the values of TEXTURE WIDTH,
TEXTURE HEIGHT, TEXTURE DEPTH, and TEXTURE INTERNAL FORMAT
currently in effect for image level level.
 xoffset, yoffset, and zoffset are all  b, where b is the value of
TEXTURE BORDER currently in effect for image level level.
This guarantee applies not just to images returned by GetCompressedTexIm-
age, but also to any other properly encoded compressed texture image of the same
size.
Calling CompressedTexSubImage3D, CompressedTexSubImage2D, or
CompressedTexSubImage1D will result in anINVALID OPERATION error if xoff-
set, yoffset, or zoffset is not equal to b (border width), or if width, height,
s
and depth do not match the values of TEXTURE WIDTH, TEXTURE HEIGHT, or
TEXTURE DEPTH, respectively. The contents of any texel outside the region modi-
?ed by the call are unde?ned. These restrictions may be relaxed for speci?c com-
pressed internal formats whose images are easily modi?ed.
If internalformat is one of the speci?c RGTC or formats described in ta-
ble 3.19, the texture is stored using one of the RGTC compressed texture image
encodings (see appendix C.1). If internalformat is an RGTC format, Com-
pressedTexSubImage1D will generate an INVALID ENUM error; Compressed-
TexSubImage2D will generate an INVALID OPERATION error if border is non-
zero; and CompressedTexSubImage3D will generate an INVALID OPERATION
error if border is non-zero or target is not TEXTURE 2D ARRAY. Since RGTC im-
ages are easily edited along 4 4 texel boundaries, the limitations on subimage
location and size are relaxed for CompressedTexSubImage2D and Compressed-
TexSubImage3D. These commands will result in an INVALID OPERATION error
if one of the following conditions occurs:
 width is not a multiple of four or equal toTEXTURE WIDTH.
Version 3.0 (September 23, 2008)3.9. TEXTURING 201
 height is not a multiple of four or equal toTEXTURE HEIGHT.
 xoffset or yoffset is not a multiple of four.
The contents of any 4 4 block of texels of an RGTC compressed texture
image that does not intersect the area being modi?ed are preserved during valid
TexSubImage* and CopyTexSubImage* calls.
3.9.4 Texture Parameters
Various parameters control how the texel array is treated when speci?ed or
changed, and when applied to a fragment. Each parameter is set by calling
void TexParameterfifg(enum target,enum pname,T param );
void TexParameterfifgv(enum target,enum pname,
T *params );
void TexParameterIfi uigv(enum target,enum pname,
T *params );
target is
the target, eitherTEXTURE 1D,TEXTURE 2D,TEXTURE 3D, TEXTURE 1D ARRAY,
TEXTURE 2D ARRAY. or TEXTURE CUBE MAP. pname is a symbolic constant indi-
cating the parameter to be set; the possible constants and corresponding parameters
are summarized in table 3.20. In the ?rst form of the command, param is a value
to which to set a single-valued parameter; in the remaining forms, params is an
array of parameters whose type depends on the parameter being set.
If the value for TEXTURE PRIORITY is speci?ed as an integer, the conversion
for signed integers from table 2.10 is applied to convert this value to ?oating-point,
followed by clamping the value to lie in [0; 1].
If the values for TEXTURE BORDER COLOR are speci?ed with TexParame-
terIiv or TexParameterIuiv, the values are unmodi?ed and stored with an internal
data type of integer. If speci?ed with TexParameteriv, the conversion for signed
integers from table 2.10 is applied to convert these values to ?oating-point. Other-
wise the values are unmodi?ed and stored as ?oating-point.
In the remainder of section 3.9, denote by lod , lod , level ,
min max base
and level the values of the texture parameters TEXTURE MIN LOD,
max
TEXTURE MAX LOD, TEXTURE BASE LEVEL, and TEXTURE MAX LEVEL respec-
tively.
Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cube map itself.
Version 3.0 (September 23, 2008)3.9. TEXTURING 202
Name Type Legal Values
TEXTURE WRAP S enum CLAMP,CLAMP TO EDGE,REPEAT,
CLAMP TO BORDER,
MIRRORED REPEAT
TEXTURE WRAP T enum CLAMP,CLAMP TO EDGE,REPEAT,
CLAMP TO BORDER,
MIRRORED REPEAT
TEXTURE WRAP R enum CLAMP,CLAMP TO EDGE,REPEAT,
CLAMP TO BORDER,
MIRRORED REPEAT
TEXTURE MIN FILTER enum NEAREST,
LINEAR,
NEAREST MIPMAP NEAREST,
NEAREST MIPMAP LINEAR,
LINEAR MIPMAP NEAREST,
LINEAR MIPMAP LINEAR,
TEXTURE MAG FILTER enum NEAREST,
LINEAR
TEXTURE BORDER COLOR 4 ?oats, any 4 values
integers, or
unsigned
integers
TEXTURE PRIORITY ?oat any value in [0; 1]
TEXTURE MIN LOD ?oat any value
TEXTURE MAX LOD ?oat any value
TEXTURE BASE LEVEL integer any non-negative integer
TEXTURE MAX LEVEL integer any non-negative integer
TEXTURE LOD BIAS ?oat any value
DEPTH TEXTURE MODE enum RED, LUMINANCE, INTENSITY,
ALPHA
TEXTURE COMPARE MODE enum NONE,
COMPARE REF TO TEXTURE
TEXTURE COMPARE FUNC enum LEQUAL,GEQUAL
LESS,GREATER,
EQUAL,NOTEQUAL,
ALWAYS,NEVER
GENERATE MIPMAP boolean TRUE orFALSE
Table 3.20: Texture parameters and their values.
Version 3.0 (September 23, 2008)3.9. TEXTURING 203
Major Axis Direction Target s t m
c c a
+r TEXTURE CUBE MAP POSITIVE X  r  r r
x z y x
 r TEXTURE CUBE MAP NEGATIVE X r  r r
x z y x
+r TEXTURE CUBE MAP POSITIVE Y r r r
y x z y
 r TEXTURE CUBE MAP NEGATIVE Y r  r r
y x z y
+r TEXTURE CUBE MAP POSITIVE Z r  r r
z x y z
 r TEXTURE CUBE MAP NEGATIVE Z  r  r r
z x y z
Table 3.21: Selection of cube map images based on major axis direction of texture
coordinates.
If the value of texture parameter GENERATE MIPMAP is TRUE, specifying or
changing texel arrays may have side effects, which are discussed in the Automatic
Mipmap Generation discussion of section 3.9.7.
3.9.5 Depth Component Textures
Depth textures and the depth components of depth/stencil textures can be treated
as RED, LUMINANCE, INTENSITY or ALPHA textures during texture ?ltering and
application (see section 3.9.14). The initial state for depth and depth/stencil tex-
tures treats them asLUMINANCE textures except in a forward-compatible context,
where the initial state instead treats them asRED textures.
3.9.6 Cube Map Texture Selection
  
When cube map texturing is enabled, the s t r texture coordinates are treated
  
as a direction vector r r r emanating from the center of a cube (the q
x y z
coordinate can be ignored, since it merely scales the vector without affecting the
direction.) At texture application time, the interpolated per-fragment direction vec-
tor selects one of the cube map face’s two-dimensional images based on the largest
magnitude coordinate direction (the major axis direction). If two or more coor-
dinates have the identical magnitude, the implementation may de?ne the rule to
disambiguate this situation. The rule must be deterministic and depend only on
  
r r r . The target column in table 3.21 explains how the major axis direc-
x y z
tion maps to the two-dimensional image of a particular cube map target.
Using thes ,t , andm determined by the major axis direction as speci?ed in
c c a
  
table 3.21, an updated s t is calculated as follows:
Version 3.0 (September 23, 2008)3.9. TEXTURING 204
 
1 s
c
s = + 1
2 jmj
a
 
1 t
c
t = + 1
2 jmj
a
  
This new s t is used to ?nd a texture value in the determined face’s two-
dimensional texture image using the rules given in sections 3.9.7 through 3.9.8.
3.9.7 Texture Minification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the
mapping to framebuffer space, then a ?ltering, followed ?nally by a resampling
of the ?ltered, warped, reconstructed image before applying it to a fragment. In
the GL this mapping is approximated by one of two simple ?ltering schemes. One
of these schemes is selected based on whether the mapping from texture space to
framebuffer space is deemed to magnify or minify the texture image.
Scale Factor and Level of Detail
The choice is governed by a scale factor(x;y) and the level-of-detail parameter
(x;y), de?ned as
 (x;y) = log [(x;y)] (3.16)
base
2
0
 (x;y) = (x;y) +clamp(bias +bias +bias ) (3.17)
base texobj texunit shader
8
0
lod ;  >lod
>
max max
>
<
0 0
; lod  lod
min max
 = (3.18)
0
> lod ;  <lod
min min
>
:
undefined; lod >lod
min max
bias is the value ofTEXTURE LOD BIAS for the bound texture object (as de-
texobj
scribed in section 3.9.4). bias is the value of TEXTURE LOD BIAS for the
texunit
current texture unit (as described in section 3.9.13). bias is the value of
shader
the optional bias parameter in the texture lookup functions available to fragment
shaders. If the texture access is performed in a fragment shader without a provided
Version 3.0 (September 23, 2008)3.9. TEXTURING 205
bias, or outside a fragment shader, thenbias is zero. The sum of these values
shader
is clamped to the range [ bias ;bias ] where bias is the value of the
max max max
implementation de?ned constantMAX TEXTURE LOD BIAS.
If(x;y) is less than or equal to the constantc (see section 3.9.8) the texture
is said to be magni?ed; if it is greater, the texture is mini?ed. Sampling of mini?ed
textures is described in the remainder of this section, while sampling of magni?ed
textures is described in section 3.9.8.
The initial values of lod and lod are chosen so as to never clamp the
min max
normal range of. They may be respeci?ed for a speci?c texture by calling Tex-
Parameter[if] with pname set to TEXTURE MIN LOD or TEXTURE MAX LOD re-
spectively.
Lets(x;y) be the function that associates ans texture coordinate with each set
of window coordinates (x;y) that lie within a primitive; de?net(x;y) andr(x;y)
analogously. Let
u(x;y) =w s(x;y) +
t u
v(x;y) =h t(x;y) + (3.19)
t v
w(x;y) =d r(x;y) +
t w
where w , h , and d are as de?ned by equation 3.15 with w , h , and d equal
t t t s s s
to the width, height, and depth of the image array whose level is level . For
base
a one-dimensional or one-dimensional array texture, de?ne v(x;y)  0 and
w(x;y) 0; for a two-dimensional, two-dimensional array, or cube map texture,
de?new(x;y) 0.
( ; ; ) are the texel offsets speci?ed in the OpenGL Shading Lan-
u v w
guage texture lookup functions that support offsets. If the texture function
used does not support offsets, or for ?xed-function texture accesses, all three
shader offsets are taken to be zero. If any of the offset values are outside the
range of the implementation-de?ned values MIN PROGRAM TEXEL OFFSET and
MAX PROGRAM TEXEL OFFSET, results of the texture lookup are unde?ned.
For a polygon, is given at a fragment with window coordinates (x;y) by
8 9
s s
           
< 2 2 2 2 2 2=
@u @v @w @u @v @w
 = max + + ; + +
: @x @x @x @y @y @y ;
(3.20)
where@u=@x indicates the derivative ofu with respect to windowx, and similarly
for the other derivatives.
Version 3.0 (September 23, 2008)3.9. TEXTURING 206
For a line, the formula is
s
      
2 2 2
@u @u @v @v @w @w
 = x + y + x + y + x + y l;
@x @y @x @y @x @y
(3.21)
where x = x  x and y = y  y with (x ;y ) and (x ;y ) being the
2 1 2 1 1 1 2 2
p
2 2
segment’s window coordinate endpoints andl = x + y . For a point, pixel
rectangle, or bitmap, 1.
While it is generally agreed that equations 3.20 and 3.21 give the best results
when texturing, they are often impractical to implement. Therefore, an imple-
mentation may approximate the ideal  with a function f(x;y) subject to these
conditions:
1. f(x;y) is continuous and monotonically increasing in each ofj@u=@xj,
j@u=@yj,j@v=@xj,j@v=@yj,j@w=@xj, andj@w=@yj
2. Let
   
   
@u @u
   
m = max ;
u
   
@x @y
   
 
   
@v @v
   
m = max ;
v
   
@x @y
   
 
   
@w @w
   
m = max ; :
w
   
@x @y
Then maxfm ;m ;m gf(x;y)m +m +m .
u v w u v w
Coordinate Wrapping and Texel Selection
After generatingu(x;y),v(x;y), andw(x;y), they may be clamped and wrapped
before sampling the texture, depending on the corresponding texture wrap modes.
Let
(
clamp(u(x;y); 0;w ); TEXTURE WRAP S isCLAMP
t
0
u (x;y) =
u(x;y); otherwise
(
clamp(v(x;y); 0;h ); TEXTURE WRAP T isCLAMP
t
0
v (x;y) =
v(x;y); otherwise
(
clamp(w(x;y); 0;h ); TEXTURE WRAP R isCLAMP
t
0
w (x;y) =
w(x;y); otherwise
Version 3.0 (September 23, 2008)3.9. TEXTURING 207
whereclamp(a;b;c) returnsb ifa<b,c ifa>c, anda otherwise.
The value assigned to TEXTURE MIN FILTER is used to determine how the
texture value for a fragment is selected.
When the value ofTEXTURE MIN FILTER isNEAREST, the texel in the image
0 0 0
array of level level that is nearest (in Manhattan distance) to (u;v;w ) is
base
obtained. Let (i;j;k) be integers such that
0
i =wrap(bu (x;y)c)
0
j =wrap(bv (x;y)c)
0
k =wrap(bw (x;y)c)
and the value returned bywrap() is de?ned in table 3.22. For a three-dimensional
texture, the texel at location (i;j;k) becomes the texture value. For two-
dimensional, two-dimensional array, or cube map textures,k is irrelevant, and the
texel at location (i;j) becomes the texture value. For one-dimensional texture or
one-dimensional array textures, j andk are irrelevant, and the texel at locationi
becomes the texture value.
For one- and two-dimensional array textures, the texel is obtained from image
layerl, where
(
clamp(bt + 0:5c; 0;h   1); for one-dimensional array textures
t
l =
clamp(br + 0:5c; 0;d   1); for two-dimensional array textures
t
Wrap mode Result ofwrap(coord)
(
clamp(coord; 0;size  1); forNEAREST ?ltering
CLAMP
clamp(coord; 1;size); forLINEAR ?ltering
CLAMP TO EDGE clamp(coord; 0;size  1)
CLAMP TO BORDER clamp(coord; 1;size)
REPEAT fmod(coord;size)
MIRRORED REPEAT (size  1) mirror(fmod(coord; 2size) size)
Table 3.22: Texel location wrap mode application. fmod(a;b) returns a b
a
b c. mirror(a) returns a if a  0, and (1 + a) otherwise. The values
b
of mode and size are TEXTURE WRAP S and w , TEXTURE WRAP T and h , and
t t
TEXTURE WRAP R andd when wrappingi,j, ork coordinates, respectively.
t
Version 3.0 (September 23, 2008)3.9. TEXTURING 208
If the selected (i;j;k), (i;j), ori location refers to a border texel that satis?es
any of the conditions
i< b iw +b
s t s
j < b jh +b
s t s
k< b kd +b
s t s
then the border values de?ned by TEXTURE BORDER COLOR are used in place of
the non-existent texel. If the texture contains color components, the values of
TEXTURE BORDER COLOR are interpreted as an RGBA color to match the texture’s
internal format in a manner consistent with table 3.15. The internal data type of the
border values must be consistent with the type returned by the texture as described
in section 3.9, or the result is unde?ned. The border values for texture components
stored as ?xed-point values are clamped to [0; 1] before they are used. If the tex-
ture contains depth components, the ?rst component ofTEXTURE BORDER COLOR
is interpreted as a depth value.
When the value ofTEXTURE MIN FILTER isLINEAR, a 222 cube of texels
in the image array of levellevel is selected. Let
base
0
i =wrap(bu  0:5c)
0
0
j =wrap(bv   0:5c)
0
0
k =wrap(bw   0:5c)
0
0
i =wrap(bu  0:5c + 1)
1
0
j =wrap(bv   0:5c + 1)
1
0
k =wrap(bw   0:5c + 1)
1
0
alpha =frac(u  0:5)
0
beta =frac(v   0:5)
0
gamma =frac(w   0:5)
wherefrac(x) denotes the fractional part ofx.
For a three-dimensional texture, the texture value is found as
 = (1 )(1 )(1 ) +(1 )(1 )
i j k i j k
0 0 0 1 0 0
+ (1 )(1 ) +(1 )
i j k i j k
0 1 0 1 1 0
(3.22)
+ (1 )(1 ) +(1 )
i j k i j k
0 0 1 1 0 1
+ (1 ) +
i j k i j k
0 1 1 1 1 1
Version 3.0 (September 23, 2008)3.9. TEXTURING 209
where is the texel at location (i;j;k) in the three-dimensional texture image.
ijk
For a two-dimensional, two-dimensional array, or cube map textures,
 =(1 )(1 ) +(1 )
i j i j
0 0 1 0
+ (1 ) +
i j i j
0 1 1 1
where is the texel at location (i;j) in the two-dimensional texture image. For
ij
two-dimensional array textures, all texels are obtained from layerl, where
l =clamp(br + 0:5c; 0;d   1):
t
And for a one-dimensional or one-dimensional array texture,
 = (1 ) +
i i
0 1
where  is the texel at location i in the one-dimensional texture. For one-
i
dimensional array textures, both texels are obtained from layerl, where
l =clamp(bt + 0:5c; 0;h   1):
t
For any texel in the equation above that refers to a border texel outside the
de?ned range of the image, the texel value is taken from the texture border color as
withNEAREST ?ltering.
If all of the following conditions are satis?ed, then the value of the selected ,
ijk
 , or in the above equations is unde?ned instead of referring to the value of the
ij i
texel at location (i;j;k), (i;j), or (i) respectively. See chapter 4 for discussion of
framebuffer objects and their attachments.
 The currentDRAW FRAMEBUFFER BINDING names a framebuffer object F.
 The texture is attached to one of the attachment points, A, of framebuffer
object F.
 The value ofTEXTURE MIN FILTER is NEAREST or LINEAR, and the value
ofFRAMEBUFFER ATTACHMENT TEXTURE LEVEL for attachment point A is
equal to the value ofTEXTURE BASE LEVEL
-or-
The value of TEXTURE MIN FILTER is NEAREST MIPMAP NEAREST,
NEAREST MIPMAP LINEAR, LINEAR MIPMAP NEAREST,
or LINEAR MIPMAP LINEAR, and the value of
FRAMEBUFFER ATTACHMENT TEXTURE LEVEL for attachment point A
is within the the inclusive range fromTEXTURE BASE LEVEL toq.
Version 3.0 (September 23, 2008)3.9. TEXTURING 210
Mipmapping
TEXTURE MIN FILTER values NEAREST MIPMAP NEAREST,
NEAREST MIPMAP LINEAR, LINEAR MIPMAP NEAREST, and
LINEAR MIPMAP LINEAR each require the use of a mipmap. A mipmap is
an ordered set of arrays representing the same image; each array has a resolution
lower than the previous one. If the image array of level level , excluding its
base
border, has dimensions w h d , then there areblog (maxsize)c + 1 levels
t t t
2
in the mipmap. where
8
>w ; for 1D and 1D array textures
t
<
maxsize = max(w ;h ); for 2D, 2D array, and cube map textures
t t
>
:
max(w ;h ;d ); for 3D textures
t t t
Numbering the levels such that levellevel is the 0th level, theith array has
base
dimensions
w h d
t t t
max(1;b c) max(1;b c) max(1;b c)
w h d
d d d
where
i
w = 2
d
(
1; for 1D and 1D array textures
h =
d
i
2; otherwise
(
i
2; for 3D textures
d =
d
1; otherwise
until the last array is reached with dimension 1 1 1.
Each array in a mipmap is de?ned using TexImage3D, TexImage2D, Copy-
TexImage2D, TexImage1D, or CopyTexImage1D; the array being set is indicated
with the level-of-detail argument level. Level-of-detail numbers proceed from
level for the original texel array through p =blog (maxsize)c +level
base 2 base
with each unit increase indicating an array of half the dimensions of the previous
one (rounded down to the next integer if fractional) as already described. All ar-
rays fromlevel throughq = minfp;level g must be de?ned, as discussed
base max
in section 3.9.10.
The values of level and level may be respeci?ed for a speci?c tex-
base max
ture by calling TexParameter[if] with pname set to TEXTURE BASE LEVEL or
TEXTURE MAX LEVEL respectively.
Version 3.0 (September 23, 2008)3.9. TEXTURING 211
The errorINVALID VALUE is generated if either value is negative.
The mipmap is used in conjunction with the level of detail to approximate the
application of an appropriately ?ltered texture to a fragment. Let c be the value
of at which the transition from mini?cation to magni?cation occurs (since this
discussion pertains to mini?cation, we are concerned only with values of where
>c).
For mipmap ?lters NEAREST MIPMAP NEAREST and
LINEAR MIPMAP NEAREST, thedth mipmap array is selected, where
8
1
>level ; 
base
<
2
1 1 1
d = dlevel + + e  1; > ;level +q + (3.23)
base base
2 2 2
>
:
1 1
q; > ;level +>q +
base
2 2
The rules for NEAREST or LINEAR ?ltering are then applied to the selected
array. Speci?cally, the coordinate (u;v;w) is computed as in equation 3.19, with
w ,h , andd equal to the width, height, and depth of the image array whose level
s s s
isd.
For mipmap ?ltersNEAREST MIPMAP LINEAR andLINEAR MIPMAP LINEAR,
the leveld andd mipmap arrays are selected, where
1 2
(
q; level +q
base
d = (3.24)
1
blevel +c; otherwise
base
(
q; level +q
base
d = (3.25)
2
d + 1; otherwise
1
The rules for NEAREST or LINEAR ?ltering are then applied to each of the
selected arrays, yielding two corresponding texture values and . Speci?cally,
1 2
for leveld , the coordinate (u;v;w) is computed as in equation 3.19, withw ,h ,
1 s s
andd equal to the width, height, and depth of the image array whose level isd .
s 1
0 0 0
For leveld the coordinate (u;v;w ) is computed as in equation 3.19, withw ,
2 s
h , andd equal to the width, height, and depth of the image array whose level is
s s
d .
2
The ?nal texture value is then found as
 = [1  frac()] + frac() :
1 2
Version 3.0 (September 23, 2008)3.9. TEXTURING 212
Automatic Mipmap Generation
If the value of texture parameter GENERATE MIPMAP is TRUE, and a change is
made to the interior or border texels of thelevel array of a mipmap by one of the
base
texture image speci?cation operations de?ned in sections 3.9.1 through 3.9.3, then
3
a complete set of mipmap arrays (as de?ned in section 3.9.10) will be computed.
Array levels level + 1 through p are replaced with arrays derived from the
base
modi?edlevel array, regardless of their previous contents. All other mipmap
base
arrays, including thelevel array, are left unchanged by this computation.
base
The internal formats and border widths of the derived mipmap arrays all match
those of the level array, and the dimensions of the derived arrays follow the
base
requirements described in section 3.9.10.
The contents of the derived arrays are computed by repeated, ?ltered reduction
of thelevel array. For one- and two-dimensional array textures, each layer is
base
?ltered independently. No particular ?lter algorithm is required, though a box ?lter
is recommended as the default ?lter. In some implementations, ?lter quality may
be affected by hints (section 5.7).
Automatic mipmap generation is available only for non-proxy texture image
targets.
Manual Mipmap Generation
Mipmaps can be generated manually with the command
void GenerateMipmap(enum target );
where target is one of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, or TEXTURE CUBE MAP. Mipmap
generation affects the texture image attached to target. For cube map textures, an
INVALID OPERATION error is generated if the texture bound to target is not cube
complete, as de?ned in section 3.9.10.
Mipmap generation replaces texel array levelslevel + 1 throughq with ar-
base
rays derived from thelevel array, as described above for Automatic Mipmap
base
Generation. All other mipmap arrays, including thelevel array, are left un-
base
changed by this computation. For arrays in the range level + 1 through q,
base
inclusive, automatic and manual mipmap generation generate the same derived ar-
rays, given identicallevel arrays.
base
3
Automatic mipmap generation is not performed for changes resulting from rendering operations
targeting a texel array bound as a color buffer of a framebuffer object.
Version 3.0 (September 23, 2008)3.9. TEXTURING 213
3.9.8 Texture Magnification
When  indicates magni?cation, the value assigned to TEXTURE MAG FILTER
determines how the texture value is obtained. There are two possible values
for TEXTURE MAG FILTER: NEAREST and LINEAR. NEAREST behaves exactly as
NEAREST forTEXTURE MIN FILTER andLINEAR behaves exactly asLINEAR for
TEXTURE MIN FILTER as described in section 3.9.7, including the texture coordi-
nate wrap modes speci?ed in table 3.22. The level-of-detaillevel texel array
base
is always used for magni?cation.
Finally, there is the choice of c, the mini?cation vs. magni?cation switch-
over point. If the magni?cation ?lter is given by LINEAR and the mini?cation
?lter is given byNEAREST MIPMAP NEAREST orNEAREST MIPMAP LINEAR, then
c = 0:5. This is done to ensure that a mini?ed texture does not appear “sharper”
than a magni?ed texture. Otherwisec = 0.
3.9.9 Combined Depth/Stencil Textures
If the texture image has a base internal format ofDEPTH STENCIL, then the stencil
index texture component is ignored. The texture value does not include a stencil
index component, but includes only the depth component.
3.9.10 Texture Completeness
A texture is said to be complete if all the image arrays and texture parameters
required to utilize the texture for texture application are consistently de?ned. The
de?nition of completeness varies depending on the texture dimensionality.
For one-, two-, or three-dimensional textures and one- or two-dimensional
array textures, a texture is complete if the following conditions all hold true:
 The set of mipmap arrays level through q (where q is de?ned in the
base
Mipmapping discussion of section 3.9.7) were each speci?ed with the same
internal format.
 The border widths of each array are the same.
 The dimensions of the arrays follow the sequence described in the Mipmap-
ping discussion of section 3.9.7.
 level level
max
base
 Each dimension of thelevel array is positive.
base
Version 3.0 (September 23, 2008)3.9. TEXTURING 214
 If the internal format of the arrays is integer (see tables 3.16- 3.17,
TEXTURE MAG FILTER must beNEAREST andTEXTURE MIN FILTER must
beNEAREST orNEAREST MIPMAP NEAREST.
Array levelsk wherek < level ork > q are insigni?cant to the de?nition of
base
completeness.
For cube map textures, a texture is cube complete if the following conditions
all hold true:
 Thelevel arrays of each of the six texture images making up the cube
base
map have identical, positive, and square dimensions.
 Thelevel arrays were each speci?ed with the same internal format.
base
 Thelevel arrays each have the same border width.
base
Finally, a cube map texture is mipmap cube complete if, in addition to being
cube complete, each of the six texture images considered individually is complete.
Effects of Completeness on Texture Application
If one-, two-, or three-dimensional texturing (but not cube map textur-
ing) is enabled for a texture unit at the time a primitive is rasterized, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture image
bound to the enabled texture target is not complete, then it is as if texture mapping
were disabled for that texture unit.
If cube map texturing is enabled for a texture unit at the time a primitive
is rasterized, and if the bound cube map texture is not cube complete, then it
is as if texture mapping were disabled for that texture unit. Additionally, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture is not
mipmap cube complete, then it is as if texture mapping were disabled for that tex-
ture unit.
Effects of Completeness on Texture Image Specification
An implementation may allow a texture image array of level 1 or greater to be cre-
ated only if a mipmap complete set of image arrays consistent with the requested
array can be supported. A mipmap complete set of arrays is equivalent to a com-
plete set of arrays wherelevel = 0 andlevel = 1000, and where, excluding
base max
borders, the dimensions of the image array being created are understood to be half
the corresponding dimensions of the next lower numbered array (rounded down to
the next integer if fractional).
Version 3.0 (September 23, 2008)3.9. TEXTURING 215
3.9.11 Texture State and Proxy State
The state necessary for texture can be divided into two categories. First, there are
the nine sets of mipmap arrays (one each for the one-, two-, and three-dimensional
texture targets and six for the cube map texture targets) and their number. Each
array has associated with it a width, height (two- and three-dimensional and cube
map only), and depth (three-dimensional only), a border width, an integer describ-
ing the internal format of the image, eight integer values describing the resolu-
tions of each of the red, green, blue, alpha, luminance, intensity, depth, and
stencil components of the image, eight integer values describing the type (un-
signed normalized, integer, ?oating-point, etc.) of each of the components, a
boolean describing whether the image is compressed or not, and an integer size
of a compressed image. Each initial texel array is null (zero width, height,
and depth, zero border width, internal format 1, with the compressed ?ag set to
FALSE, a zero compressed size, and zero-sized components). Next, there are the
four sets of texture properties, corresponding to the one-, two-, three-dimensional,
and cube map texture targets. Each set consists of the selected mini?cation and
magni?cation ?lters, the wrap modes for s, t (two- and three-dimensional and
cube map only), and r (three-dimensional only), the TEXTURE BORDER COLOR,
two ?oating-point numbers describing the minimum and maximum level of de-
tail, two integers describing the base and maximum mipmap array, a boolean
?ag indicating whether the texture is resident, a boolean indicating whether au-
tomatic mipmap generation should be performed, three integers describing the
depth texture mode, compare mode, and compare function, and the priority as-
sociated with each set of properties. The value of the resident ?ag is deter-
mined by the GL and may change as a result of other GL operations. The ?ag
may only be queried, not set, by applications (see section 3.9.12). In the initial
state, the value assigned toTEXTURE MIN FILTER isNEAREST MIPMAP LINEAR,
and the value for TEXTURE MAG FILTER is LINEAR. s, t, and r wrap modes
are all set to REPEAT. The values of TEXTURE MIN LOD and TEXTURE MAX LOD
are -1000 and 1000 respectively. The values of TEXTURE BASE LEVEL and
TEXTURE MAX LEVEL are 0 and 1000 respectively. TEXTURE PRIORITY is 1.0,
and TEXTURE BORDER COLOR is (0,0,0,0). The value of GENERATE MIPMAP
is false. The values of DEPTH TEXTURE MODE, TEXTURE COMPARE MODE, and
TEXTURE COMPARE FUNC are LUMINANCE, NONE, and LEQUAL respectively. The
initial value ofTEXTURE RESIDENT is determined by the GL.
In addition to image arrays for one-, two-, and three-dimensional textures, one-
and two-dimensional array textures, and the six image arrays for the cube map tex-
ture, partially instantiated image arrays are maintained for one-, two-, and three-
dimensional textures and one- and two-dimensional array textures. Additionally,
Version 3.0 (September 23, 2008)3.9. TEXTURING 216
a single proxy image array is maintained for the cube map texture. Each proxy
image array includes width, height, depth, border width, and internal format state
values, as well as state for the red, green, blue, alpha, luminance, intensity, depth,
and stencil component resolutions and types Proxy arrays do not include image
data nor texture parameters. When TexImage3D is executed with target speci?ed
as PROXY TEXTURE 3D, the three-dimensional proxy state values of the speci?ed
level-of-detail are recomputed and updated. If the image array would not be sup-
ported by TexImage3D called with target set to TEXTURE 3D, no error is gener-
ated, but the proxy width, height, depth, border width, and component resolutions
are set to zero, and the component types are set toNONE. If the image array would
be supported by such a call to TexImage3D, the proxy state values are set exactly
as though the actual image array were being speci?ed. No pixel data are transferred
or processed in either case.
Proxy arrays for one- and two-dimensional textures and one- and two-
dimensional array textures are operated on in the same way when TexImage1D
is executed with target speci?ed asPROXY TEXTURE 1D, TexImage2D is executed
with target speci?ed as PROXY TEXTURE 2D or PROXY TEXTURE 1D ARRAY, or
TexImage3D is executed with target speci?ed asPROXY TEXTURE 2D ARRAY.
The cube map proxy arrays are operated on in the same manner when TexIm-
age2D is executed with the target ?eld speci?ed as PROXY TEXTURE CUBE MAP,
with the addition that determining that a given cube map texture is supported with
PROXY TEXTURE CUBE MAP indicates that all six of the cube map 2D images are
supported. Likewise, if the speci?edPROXY TEXTURE CUBE MAP is not supported,
none of the six cube map 2D images are supported.
There is no image associated with any of the proxy textures. There-
fore PROXY TEXTURE 1D, PROXY TEXTURE 2D, and PROXY TEXTURE 3D, and
PROXY TEXTURE CUBE MAP cannot be used as textures, and their images must
never be queried using GetTexImage. The error INVALID ENUM is generated if
this is attempted. Likewise, there is no non level-related state associated with a
proxy texture, and GetTexParameteriv or GetTexParameterfv may not be called
with a proxy texture target. The error INVALID ENUM is generated if this is at-
tempted.
3.9.12 Texture Objects
In addition to the default textures TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
TEXTURE 1D ARRAY,TEXTURE 2D ARRAY, andTEXTURE CUBE MAP, named one-,
two-, and three-dimensional, one- and two-dimensional array, and cube map tex-
ture objects can be created and operated upon. The name space for texture objects
is the unsigned integers, with zero reserved by the GL.
Version 3.0 (September 23, 2008)3.9. TEXTURING 217
A texture object is created by binding an unused name to TEXTURE 1D,
TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, or
TEXTURE CUBE MAP. The binding is effected by calling
void BindTexture(enum target,uint texture );
with target set to the desired texture target and texture set to the unused name.
The resulting texture object is a new state vector, comprising all the state val-
ues listed in section 3.9.11, set to the same initial values. If the new texture ob-
ject is bound to TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY,
TEXTURE 2D ARRAY, orTEXTURE CUBE MAP, it is and remains a one-, two-, three-
dimensional, one- or two-dimensional array, or cube map texture respectively until
it is deleted.
BindTexture may also be used to bind an existing texture object
to either TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY,
TEXTURE 2D ARRAY, orTEXTURE CUBE MAP. The errorINVALID OPERATION is
generated if an attempt is made to bind a texture object of different dimensionality
than the speci?ed target. If the bind is successful no change is made to the state of
the bound texture object, and any previous binding to target is broken.
While a texture object is bound, GL operations on the target to which it is
bound affect the bound object, and queries of the target to which it is bound return
state from the bound object. If texture mapping of the dimensionality of the target
to which a texture object is bound is enabled, the state of the bound texture object
directs the texturing operation.
In the initial state, TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, and TEXTURE CUBE MAP have one-,
two-, three-dimensional, one- and two-dimensional array, and cube map tex-
ture state vectors respectively associated with them. In order that access to
these initial textures not be lost, they are treated as texture objects all of
whose names are 0. The initial one-, two-, three-dimensional, one- and two-
dimensional rray, and cube map texture is therefore operated upon, queried,
and applied as TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY,
TEXTURE 2D ARRAY, orTEXTURE CUBE MAP respectively while 0 is bound to the
corresponding targets.
Texture objects are deleted by calling
void DeleteTextures(sizei n,uint *textures );
textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
Version 3.0 (September 23, 2008)3.9. TEXTURING 218
a texture that is currently bound to one of the targets TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, TEXTURE 1D ARRAY,TEXTURE 2D ARRAY, orTEXTURE CUBE MAP
is deleted, it is as though BindTexture had been executed with the same target and
texture zero. Additionally, special care must be taken when deleting a texture
if any of the images of the texture are attached to a framebuffer object. See sec-
tion 4.4.2 for details.
Unused names in textures are silently ignored, as is the value zero.
The command
void GenTextures(sizei n,uint *textures );
returns n previously unused texture object names in textures. These names are
marked as used, for the purposes of GenTextures only, but they acquire texture
state and a dimensionality only when they are ?rst bound, just as if they were
unused.
An implementation may choose to establish a working set of texture objects on
which binding operations are performed with higher performance. A texture object
that is currently part of the working set is said to be resident. The command
boolean AreTexturesResident(sizei n,uint *textures,
boolean *residences );
returnsTRUE if all of the n texture objects named in textures are resident, or if the
implementation does not distinguish a working set. If at least one of the texture
objects named in textures is not resident, thenFALSE is returned, and the residence
of each texture object is returned in residences. Otherwise the contents of resi-
dences are not changed. If any of the names in textures are unused or are zero,
FALSE is returned, the errorINVALID VALUE is generated, and the contents of res-
idences are indeterminate. The residence status of a single bound texture object
can also be queried by calling GetTexParameteriv or GetTexParameterfv with
target set to the target to which the texture object is bound, and pname set to
TEXTURE RESIDENT.
AreTexturesResident indicates only whether a texture object is currently resi-
dent, not whether it could not be made resident. An implementation may choose to
make a texture object resident only on ?rst use, for example. The client may guide
the GL implementation in determining which texture objects should be resident by
specifying a priority for each texture object. The command
void PrioritizeTextures(sizei n,uint *textures,
clampf *priorities );
Version 3.0 (September 23, 2008)3.9. TEXTURING 219
sets the priorities of the n texture objects named in textures to the values in priori-
ties. Each priority value is clamped to the range [0,1] before it is assigned. Zero in-
dicates the lowest priority, with the least likelihood of being resident. One indicates
the highest priority, with the greatest likelihood of being resident. The priority of a
single bound texture object may also be changed by calling TexParameteri, Tex-
Parameterf, TexParameteriv, or TexParameterfv withtarget set to the target to
which the texture object is bound,pname set toTEXTURE PRIORITY, andparam
orparams specifying the new priority value (which is clamped to the range [0,1]
before being assigned). PrioritizeTextures silently ignores attempts to prioritize
unused texture object names or zero (default textures).
The texture object name space, including the initial one-, two-, and three-
dimensional, one- and two-dimensional array, and cube map texture objects, is
shared among all texture units. A texture object may be bound to more than one
texture unit simultaneously. After a texture object is bound, any GL operations on
that target object affect any other texture units to which the same texture object is
bound.
Texture binding is affected by the setting of the stateACTIVE TEXTURE.
If a texture object is deleted, it as if all texture units which are bound to that
texture object are rebound to texture object zero.
3.9.13 Texture Environments and Texture Functions
The command
void TexEnvfifg(enum target,enum pname,T param );
void TexEnvfifgv(enum target,enum pname,T params );
sets parameters of the texture environment that speci?es how texture values are
interpreted when texturing a fragment, or sets per-texture-unit ?ltering parameters.
target must be one of POINT SPRITE, TEXTURE ENV or
TEXTURE FILTER CONTROL. pname is a symbolic constant indicating the
parameter to be set. In the ?rst form of the command, param is a value to which to
set a single-valued parameter; in the second form, params is a pointer to an array
of parameters: either a single symbolic constant or a value or group of values to
which the parameter should be set.
When target is POINT SPRITE, point sprite rasterization behavior is affected
as described in section 3.4.
When target is TEXTURE FILTER CONTROL, pname must be
TEXTURE LOD BIAS. In this case the parameter is a single signed ?oating
point value,bias , that biases the level of detail parameter as described in
texunit
section 3.9.7.
Version 3.0 (September 23, 2008)3.9. TEXTURING 220
When target is TEXTURE ENV, the possible environment parameters are
TEXTURE ENV MODE, TEXTURE ENV COLOR, COMBINE RGB, COMBINE ALPHA,
RGB SCALE, ALPHA SCALE, SRCn RGB, SRCn ALPHA, OPERANDn RGB, and
OPERANDn ALPHA, wheren = 0, 1, or 2. TEXTURE ENV MODE may be set to one of
REPLACE,MODULATE,DECAL,BLEND,ADD, orCOMBINE.TEXTURE ENV COLOR is
set to an RGBA color by providing four single-precision ?oating-point values. If
integers are provided forTEXTURE ENV COLOR, then they are converted to ?oating-
point as speci?ed in table 2.10 for signed integers.
The value of TEXTURE ENV MODE speci?es a texture function. The result of
this function depends on the fragment and the texel array value. The precise form
of the function depends on the base internal formats of the texel arrays that were
last speci?ed.
4
C andA are the primary color components of the incoming fragment; C
s
f f
and A are the components of the texture source color, derived from the ?ltered
s
texture valuesR ,G ,B ,A ,L , andI as shown in table 3.23; C andA are
t t t t t t c c
the components of the texture environment color;C andA are the components
p p
resulting from the previous texture environment (for texture environment 0,C and
p
A are identical toC andA , respectively); andC andA are the primary color
p f f v v
components computed by the texture function.
If fragment color clamping is enabled, all of these color values, including the
results, are clamped to the range [0; 1]. If fragment color clamping is disabled, the
values are not clamped. The texture functions are speci?ed in tables 3.24, 3.25,
and 3.26.
If the value ofTEXTURE ENV MODE isCOMBINE, the form of the texture func-
tion depends on the values of COMBINE RGB and COMBINE ALPHA, according to
table 3.26. The RGB and ALPHA results of the texture function are then multiplied
by the values of RGB SCALE and ALPHA SCALE, respectively. If fragment color
clamping is enabled, the arguments and results used in table 3.26 are clamped to
[0; 1]. Otherwise, the results are unmodi?ed.
The arguments Arg0, Arg1, and Arg2 are determined by the values of
SRCn RGB, SRCn ALPHA, OPERANDn RGB and OPERANDn ALPHA, where n = 0,
n n
1, or 2, as shown in tables 3.27 and 3.28. C andA denote the texture source
s s
color and alpha from the texture image bound to texture unitn
The state required for the current texture environment, for each texture unit,
consists of a six-valued integer indicating the texture function, an eight-valued in-
teger indicating theRGB combiner function and a six-valued integer indicating the
4
In the remainder of section 3.9.13, the notationC is used to denote each of the three components
x
R ,G , andB of a color speci?ed byx. Operations onC are performed independently for each
x x x x
color component. The A component of colors is usually operated on in a different fashion, and is
therefore denoted separately byA .
x
Version 3.0 (September 23, 2008)3.9. TEXTURING 221
Texture Base Texture source color
Internal Format C A
s s
ALPHA (0; 0; 0) A
t
LUMINANCE (L ;L ;L ) 1
t t t
LUMINANCE ALPHA (L ;L ;L ) A
t t t t
INTENSITY (I ;I ;I ) I
t t t t
RED (R ; 0; 0) 1
t
RG (R ;G ; 0) 1
t t
RGB (R ;G ;B ) 1
t t t
RGBA (R ;G ;B ) A
t t t t
Table 3.23: Correspondence of ?ltered texture components to texture source com-
ponents.
Texture Base REPLACE MODULATE DECAL
Internal Format Function Function Function
ALPHA C =C C =C unde?ned
v p v p
A =A A =A A
v s v p s
LUMINANCE C =C C =C C unde?ned
v s v p s
(or 1) A =A A =A
v p v p
LUMINANCE ALPHA C =C C =C C unde?ned
v s v p s
(or 2) A =A A =A A
v s v p s
INTENSITY C =C C =C C unde?ned
v s v p s
A =A A =A A
v s v p s
RGB,RG,RED, C =C C =C C C =C
v s v p s v s
or 3 A =A A =A A =A
v p v p v p
RGBA C =C C =C C C =C (1 A ) +C A
v s v p s v p s s s
or 4 A =A A =A A A =A
v s v p s v p
Table 3.24: Texture functionsREPLACE,MODULATE, andDECAL.
Version 3.0 (September 23, 2008)3.9. TEXTURING 222
Texture Base BLEND ADD
Internal Format Function Function
ALPHA C =C C =C
v p v p
A =A A A =A A
v p s v p s
LUMINANCE C =C (1 C ) +C C C =C +C
v p s c s v p s
(or 1) A =A A =A
v p v p
LUMINANCE ALPHA C =C (1 C ) +C C C =C +C
v p s c s v p s
(or 2) A =A A A =A A
v p s v p s
INTENSITY C =C (1 C ) +C C C =C +C
v p s c s v p s
A =A (1 A ) +A A A =A +A
v p s c s v p s
RGB,RG,RED, C =C (1 C ) +C C C =C +C
v p s c s v p s
or 3 A =A A =A
v p v p
RGBA C =C (1 C ) +C C C =C +C
v p s c s v p s
or 4 A =A A A =A A
v p s v p s
Table 3.25: Texture functionsBLEND andADD.
ALPHA combiner function, six four-valued integers indicating the combiner RGB
and ALPHA source arguments, three four-valued integers indicating the combiner
RGB operands, three two-valued integers indicating the combinerALPHA operands,
and four ?oating-point environment color values. In the initial state, the texture
and combiner functions are eachMODULATE, the combinerRGB andALPHA sources
are eachTEXTURE,PREVIOUS, andCONSTANT for sources 0, 1, and 2 respectively,
the combinerRGB operands for sources 0 and 1 are eachSRC COLOR, the combiner
RGB operand for source 2, as well as for the combiner ALPHA operands, are each
SRC ALPHA, and the environment color is (0; 0; 0; 0).
The state required for the texture ?ltering parameters, for each texture unit,
consists of a single ?oating-point level of detail bias. The initial value of the bias
is 0:0.
3.9.14 Texture Comparison Modes
Texture values can also be computed according to a speci?ed comparison func-
tion. Texture parameter TEXTURE COMPARE MODE speci?es the comparison
operands, and parameterTEXTURE COMPARE FUNC speci?es the comparison func-
tion. The format of the resulting texture sample is determined by the value of
DEPTH TEXTURE MODE.
Version 3.0 (September 23, 2008)3.9. TEXTURING 223
COMBINE RGB Texture Function
REPLACE Arg0
MODULATE Arg0Arg1
ADD Arg0 +Arg1
ADD SIGNED Arg0 +Arg1  0:5
INTERPOLATE Arg0Arg2 +Arg1 (1 Arg2)
SUBTRACT Arg0 Arg1
DOT3 RGB 4 ((Arg0   0:5) (Arg1   0:5)+
r r
(Arg0   0:5) (Arg1   0:5)+
g g
(Arg0   0:5) (Arg1   0:5))
b b
DOT3 RGBA 4 ((Arg0   0:5) (Arg1   0:5)+
r r
(Arg0   0:5) (Arg1   0:5)+
g g
(Arg0   0:5) (Arg1   0:5))
b b
COMBINE ALPHA Texture Function
REPLACE Arg0
MODULATE Arg0Arg1
ADD Arg0 +Arg1
ADD SIGNED Arg0 +Arg1  0:5
INTERPOLATE Arg0Arg2 +Arg1 (1 Arg2)
SUBTRACT Arg0 Arg1
Table 3.26: COMBINE texture functions. The scalar expression computed for the
DOT3 RGB andDOT3 RGBA functions is placed into each of the 3 (RGB) or 4 (RGBA)
components of the output. The result generated from COMBINE ALPHA is ignored
forDOT3 RGBA.
Version 3.0 (September 23, 2008)3.9. TEXTURING 224
SRCn RGB OPERANDn RGB Argument
TEXTURE SRC COLOR C
s
ONE MINUS SRC COLOR 1 C
s
SRC ALPHA A
s
ONE MINUS SRC ALPHA 1 A
s
n
TEXTUREn SRC COLOR C
s
n
ONE MINUS SRC COLOR 1 C
s
n
SRC ALPHA A
s
n
ONE MINUS SRC ALPHA 1 A
s
CONSTANT SRC COLOR C
c
ONE MINUS SRC COLOR 1 C
c
SRC ALPHA Ac
ONE MINUS SRC ALPHA 1 A
c
PRIMARY COLOR SRC COLOR C
f
ONE MINUS SRC COLOR 1 C
f
SRC ALPHA A
f
ONE MINUS SRC ALPHA 1 A
f
PREVIOUS SRC COLOR C
p
ONE MINUS SRC COLOR 1 C
p
SRC ALPHA A
p
ONE MINUS SRC ALPHA 1 A
p
Table 3.27: Arguments forCOMBINE RGB functions.
SRCn ALPHA OPERANDn ALPHA Argument
TEXTURE SRC ALPHA A
s
ONE MINUS SRC ALPHA 1 A
s
n
TEXTUREn SRC ALPHA A
s
n
ONE MINUS SRC ALPHA 1 A
s
CONSTANT SRC ALPHA A
c
ONE MINUS SRC ALPHA 1 A
c
PRIMARY COLOR SRC ALPHA A
f
ONE MINUS SRC ALPHA 1 A
f
PREVIOUS SRC ALPHA A
p
ONE MINUS SRC ALPHA 1 A
p
Table 3.28: Arguments forCOMBINE ALPHA functions.
Version 3.0 (September 23, 2008)3.9. TEXTURING 225
Depth Texture Comparison Mode
If the currently bound texture’s base internal format is DEPTH COMPONENT or
DEPTH STENCIL, then TEXTURE COMPARE MODE, TEXTURE COMPARE FUNC and
DEPTH TEXTURE MODE control the output of the texture unit as described below.
Otherwise, the texture unit operates in the normal manner and texture comparison
is bypassed.
LetD be the depth texture value andD be the reference value, de?ned as
t ref
follows:
 For ?xed-function, non-cubemap texture lookups,D is the interpolatedr
ref
texture coordinate.
 For ?xed-function, cubemap texture lookups,D is the interpolatedq tex-
ref
ture coordinate.
 For texture lookups generated by an OpenGL Shading Language lookup
function,D is the reference value for depth comparisons provided by the
ref
lookup function.
If the texture’s internal format indicates a ?xed-point depth texture, then D
t
and D are clamped to the range [0; 1]; otherwise no clamping is performed.
ref
Then the effective texture value is computed as follows:
If the value ofTEXTURE COMPARE MODE isNONE, then
r =D
t
If the value ofTEXTURE COMPARE MODE is COMPARE REF TO TEXTURE, then
r depends on the texture comparison function as shown in table 3.29.
The resulting r is assigned to R , L , I , or A if the value of
t t t t
DEPTH TEXTURE MODE is respectively RED,LUMINANCE,INTENSITY, orALPHA.
If the value of TEXTURE MAG FILTER is not NEAREST, or the value of
TEXTURE MIN FILTER is not NEAREST or NEAREST MIPMAP NEAREST, then r
may be computed by comparing more than one depth texture value to the texture
reference value. The details of this are implementation-dependent, but r should
be a value in the range [0; 1] which is proportional to the number of comparison
passes or failures.
3.9.15 sRGB Texture Color Conversion
If the currently bound texture’s internal format is one of SRGB, SRGB8,
SRGB ALPHA, SRGB8 ALPHA8, SLUMINANCE ALPHA, SLUMINANCE8 ALPHA8,
Version 3.0 (September 23, 2008)3.9. TEXTURING 226
Texture Comparison Function Computed resultr
(
1:0; D D
ref t
LEQUAL r =
0:0; D >D
t
ref
(
1:0; D D
ref t
GEQUAL r =
0:0; D <D
ref t
(
1:0; D <D
t
ref
LESS r =
0:0; D D
ref t
(
1:0; D >D
ref t
GREATER r =
0:0; D D
ref t
(
1:0; D =D
ref t
EQUAL r =
0:0; D =6 D
ref t
(
1:0; D 6=D
ref t
NOTEQUAL r =
0:0; D =D
ref t
ALWAYS r = 1:0
NEVER r = 0:0
Table 3.29: Depth texture comparison functions.
SLUMINANCE, SLUMINANCE8, COMPRESSED SRGB, COMPRESSED SRGB ALPHA,
COMPRESSED SLUMINANCE, or COMPRESSED SLUMINANCE ALPHA, the red,
green, and blue components are converted from an sRGB color space to a lin-
ear color space as part of ?ltering described in sections 3.9.7 and 3.9.8. Any alpha
component is left unchanged. Ideally, implementations should perform this color
conversion on each sample prior to ?ltering but implementations are allowed to
perform this conversion after ?ltering (though this post-?ltering approach is infe-
rior to converting from sRGB prior to ?ltering).
The conversion from an sRGB encoded component,c , to a linear component,
s
c , is as follows.
l
(
c
s
; c  0:04045
s
12:92
c =    (3.26)
l 2:4
c +0:055
s
; c > 0:04045
s
1:055
Assumec is the sRGB component in the range [0; 1].
s
Version 3.0 (September 23, 2008)3.9. TEXTURING 227
3.9.16 Shared Exponent Texture Color Conversion
If the currently bound texture’s internal format is RGB9 E5, the red, green, blue,
and shared bits are converted to color components (prior to ?ltering) using shared
exponent decoding. The componentred ,green ,blue , andexp values (see
s s s shared
section 3.9.1) are treated as unsigned integers and are converted tored,green, and
blue as follows:
exp  B
shared
red =red 2
s
exp  B
shared
green =green 2
s
exp  B
shared
blue =blue 2
s
3.9.17 Texture Application
Texturing is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constants TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, or TEXTURE CUBE MAP to enable the one-, two, three-dimensional,
or cube map texture, respectively. If both two- and one-dimensional textures are
enabled, the two-dimensional texture is used. If the three-dimensional and either
of the two- or one-dimensional textures is enabled, the three-dimensional texture
is used. If the cube map texture and any of the three-, two-, or one-dimensional
textures is enabled, then cube map texturing is used.
If all texturing is disabled, a rasterized fragment is passed on unaltered to the
next stage of the GL (although its texture coordinates may be discarded). Other-
wise, a texture value is found according to the parameter values of the currently
bound texture image of the appropriate dimensionality using the rules given in sec-
tions 3.9.6 through 3.9.8. This texture value is used along with the incoming frag-
ment in computing the texture function indicated by the currently bound texture
environment. The result of this function replaces the incoming fragment’s primary
R, G, B, and A values. These are the color values passed to subsequent operations.
Other data associated with the incoming fragment remain unchanged, except that
the texture coordinates may be discarded.
Note that the texture value may containR,G,B,A,L,I, orD components,
but it does not contain an S component. If the texture’s base internal format is
DEPTH STENCIL, for the purposes of texture application it is as if the base internal
format wereDEPTH COMPONENT.
Each texture unit is enabled and bound to texture objects independently from
the other texture units. Each texture unit follows the precedence rules for one-, two-
, three-dimensional, and cube map textures. Thus texture units can be performing
Version 3.0 (September 23, 2008)3.10. COLORSUM 228
texture mapping of different dimensionalities simultaneously. Each unit has its
own enable and binding states.
Each texture unit is paired with an environment function, as shown in ?g-
ure 3.11. The second texture function is computed using the texture value from
the second texture, the fragment resulting from the ?rst texture function computa-
tion and the second texture unit’s environment function. If there is a third texture,
the fragment resulting from the second texture function is combined with the third
texture value using the third texture unit’s environment function and so on. The tex-
ture unit selected by ActiveTexture determines which texture unit’s environment
is modi?ed by TexEnv calls.
If the value ofTEXTURE ENV MODE isCOMBINE, the texture function associated
with a given texture unit is computed using the values speci?ed by SRCn RGB,
SRCn ALPHA,OPERANDn RGB andOPERANDn ALPHA. IfTEXTUREn is speci?ed as
SRCn RGB or SRCn ALPHA, the texture value from texture unit n will be used in
computing the texture function for this texture unit.
Texturing is enabled and disabled individually for each texture unit. If texturing
is disabled for one of the units, then the fragment resulting from the previous unit
is passed unaltered to the following unit. Individual texture units beyond those
speci?ed byMAX TEXTURE UNITS are always treated as disabled.
If a texture unit is disabled or has an invalid or incomplete texture (as de?ned
in section 3.9.10) bound to it, then blending is disabled for that texture unit. If the
texture environment for a given enabled texture unit references a disabled texture
unit, or an invalid or incomplete texture that is bound to another unit, then the
results of texture blending are unde?ned.
The required state, per texture unit, is four bits indicating whether each of one-,
two-, three-dimensional, or cube map texturing is enabled or disabled. In the intial
state, all texturing is disabled for all texture units.
3.10 Color Sum
At the beginning of color sum, a fragment has two RGBA colors: a primary color
c (which texturing, if enabled, may have modi?ed) and a secondary colorc .
pri sec
If color sum is enabled, the R, G, and B components of these two colors are
summed to produce a single post-texturing RGBA colorc. The A component ofc
is taken from the A component ofc ; the A component ofc is unused. If color
pri sec
sum is disabled, thenc is assigned toc. If fragment color clamping is enabled,
pri
the components ofc are then clamped to the range [0; 1].
Color sum is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constantCOLOR SUM. If lighting is enabled
Version 3.0 (September 23, 2008)3.10. COLORSUM 229
C
f
TE
0
CT
TE
0
1
CT
1 TE
2
CT
C’
TE
2
f
3
CT
3
C  = fragment primary color input to texturing
f 
C’ = fragment color output from texturing
  
f
CT = texture color from texture lookup i
i
TE = texture environment i 
i
Figure 3.11. Multitexture pipeline. Four texture units are shown; however, multi-
texturing may support a different number of units depending on the implementation.
The input fragment color is successively combined with each texture according to
the state of the corresponding texture environment, and the resulting fragment color
passed as input to the next texture unit in the pipeline.
Version 3.0 (September 23, 2008)3.11. FOG 230
and if a vertex shader is not active, the color sum stage is always applied, ignoring
the value ofCOLOR SUM.
The state required is a single bit indicating whether color sum is enabled or
disabled. In the initial state, color sum is disabled.
Color sum has no effect in color index mode, or if a fragment shader is active.
3.11 Fog
If enabled, fog blends a fog color with a rasterized fragment’s post-texturing color
using a blending factorf. Fog is enabled and disabled with the Enable and Disable
commands using the symbolic constantFOG.
This factorf is computed according to one of three equations:
f = exp( dc); (3.27)
2
f = exp( (dc) ); or (3.28)
e c
f = (3.29)
e s
If a vertex shader is active, or if the fog source, as de?ned below, is FOG COORD,
thenc is the interpolated value of the fog coordinate for this fragment. Otherwise,
if the fog source is FRAGMENT DEPTH, thenc is the eye-coordinate distance from
the eye, (0; 0; 0; 1) in eye coordinates, to the fragment center. The equation and the
fog source, along with eitherd ore ands, is speci?ed with
void Fogfifg(enum pname,T param );
void Fogfifgv(enum pname,T params );
If pname is FOG MODE, then param must be, or params must point to an inte-
ger that is one of the symbolic constants EXP, EXP2, or LINEAR, in which case
equation 3.27, 3.28, or 3.29, respectively, is selected for the fog calculation (if,
when 3.29 is selected,e =s, results are unde?ned). If pname isFOG COORD SRC,
then param must be, or params must point to an integer that is one of the sym-
bolic constants FRAGMENT DEPTH or FOG COORD. If pname is FOG DENSITY,
FOG START, or FOG END, then param is or params points to a value that is d, s,
or e, respectively. If d is speci?ed less than zero, the error INVALID VALUE re-
sults.
An implementation may choose to approximate the eye-coordinate distance
from the eye to each fragment center byjzj. Further,f need not be computed at
e
Version 3.0 (September 23, 2008)3.12. FRAGMENTSHADERS 231
each fragment, but may be computed at each vertex and interpolated as other data
are.
No matter which equation and approximation is used to computef, the result
is clamped to [0; 1] to obtain the ?nalf.
f is used differently depending on whether the GL is in RGBA or color index
mode. In RGBA mode, ifC represents a rasterized fragment’s R, G, or B value,
r
then the corresponding value produced by fog is
C =fC + (1 f)C :
r f
(The rasterized fragment’s A value is not changed by fog blending.) The R, G, B,
and A values ofC are speci?ed by calling Fog with pname equal toFOG COLOR;
f
in this case params points to four values comprisingC . If these are not ?oating-
f
point values, then they are converted to ?oating-point using the conversion given
in table 2.10 for signed integers. If fragment color clamping is enabled, the
components ofC andC and the resultC are clamped to the range [0; 1] before
r f
the fog blend is performed.
In color index mode, the formula for fog blending is
I =i + (1 f)i
r f
where i is the rasterized fragment’s color index and i is a single-precision
r
f
?oating-point value. (1 f)i is rounded to the nearest ?xed-point value with
f
the same number of bits to the right of the binary point asi , and the integer por-
r
n
tion ofI is masked (bitwise ANDed) with 2   1, wheren is the number of bits in
a color in the color index buffer (buffers are discussed in chapter 4). The value of
i is set by calling Fog with pname set toFOG INDEX and param being or params
f
pointing to a single value for the fog index. The integer part ofi is masked with
f
n
2   1.
The state required for fog consists of a three valued integer to select the fog
equation, three ?oating-point values d, e, and s, an RGBA fog color and a fog
color index, a two-valued integer to select the fog coordinate source, and a single
bit to indicate whether or not fog is enabled. In the initial state, fog is disabled,
FOG COORD SRC is FRAGMENT DEPTH, FOG MODE is EXP,d = 1:0,e = 1:0, and
s = 0:0;C = (0; 0; 0; 0) andi = 0.
f f
Fog has no effect if a fragment shader is active.
3.12 Fragment Shaders
The sequence of operations that are applied to fragments that result from raster-
izing a point, line segment, polygon, pixel rectangle or bitmap as described in
Version 3.0 (September 23, 2008)3.12. FRAGMENTSHADERS 232
sections 3.9 through 3.11 is a ?xed functionality method for processing such frag-
ments. Applications can more generally describe the operations that occur on such
fragments by using a fragment shader.
A fragment shader is an array of strings containing source code for the opera-
tions that are meant to occur on each fragment that results from rasterizing a point,
line segment, polygon, pixel rectangle or bitmap. The language used for fragment
shaders is described in the OpenGL Shading Language Specification.
A fragment shader only applies when the GL is in RGBA mode. Its operation
in color index mode is unde?ned.
Fragment shaders are created as described in section 2.20.1 using a type pa-
rameter of FRAGMENT SHADER. They are attached to and used in program objects
as described in section 2.20.2.
When the program object currently in use includes a fragment shader, its frag-
ment shader is considered active, and is used to process fragments. If the program
object has no fragment shader, or no program object is currently in use, the ?xed-
function fragment processing operations described in previous sections are used.
Results of rasterization are unde?ned if any of the selected draw buffers of the
draw framebuffer have an integer format and no fragment shader is active.
3.12.1 Shader Variables
Fragment shaders can access uniforms belonging to the current shader object. The
amount of storage available for fragment shader uniform variables is speci?ed by
the implementation dependent constant MAX FRAGMENT UNIFORM COMPONENTS.
This value represents the number of individual ?oating-point, integer, or boolean
values that can be held in uniform variable storage for a fragment shader. A
uniform matrix will consume no more than 4min(r;c) such values, wherer and
c are the number of rows and columns in the matrix. A link error will be generated
if an attempt is made to utilize more than the space available for fragment shader
uniform variables.
Fragment shaders can read varying variables that correspond to the attributes
of the fragments produced by rasterization. The OpenGL Shading Language Spec-
i?cation de?nes a set of built-in varying variables that can be be accessed by a
fragment shader. These built-in varying variables include the data associated with
a fragment that are used for ?xed-function fragment processing, such as the frag-
ment’s position, color, secondary color, texture coordinates, fog coordinate, and
eyez coordinate.
Additionally, when a vertex shader is active, it may de?ne one or more varying
variables (see section 2.20.3 and the OpenGL Shading Language Specification).
These values are, if not ?at shaded, interpolated across the primitive being ren-
Version 3.0 (September 23, 2008)3.12. FRAGMENTSHADERS 233
dered. The results of these interpolations are available when varying variables of
the same name are de?ned in the fragment shader.
User-de?ned varying variables are not saved in the current raster position.
When processing fragments generated by the rasterization of a pixel rectangle or
bitmap, that values of user-de?ned varying variables are unde?ned. Built-in vary-
ing variables have well-de?ned values.
A fragment shader can also write to varying out variables. Values written
to these variables are used in the subsequent per-fragment operations. Varying
out variables can be used to write ?oating-point, integer or unsigned integer val-
ues destined for buffers attached to a framebuffer object, or destined for color
buffers attached to the default framebuffer. The Shader Outputs subsection of
section 3.12.2 describes how to direct these values to buffers.
3.12.2 Shader Execution
If a fragment shader is active, the executable version of the fragment shader is used
to process incoming fragment values that are the result of point, line segment, poly-
gon, pixel rectangle or bitmap rasterization rather than the ?xed-function fragment
processing described in sections 3.9 through 3.11. In particular,
 The texture environments and texture functions described in section 3.9.13
are not applied.
 Texture application as described in section 3.9.17 is not applied.
 Color sum as described in section 3.10 is not applied.
 Fog as described in section 3.11 is not applied.
Texture Access
The Shader Only Texturing subsection of section 2.20.4 describes texture lookup
functionality accessible to a vertex shader. The texel fetch and texture size query
functionality described there also applies to fragment shaders.
When a texture lookup is performed in a fragment shader, the GL computes
the ?ltered texture value in the manner described in sections 3.9.7 and 3.9.8, and
converts it to a texture source color C according to table 3.23 (section 3.9.13).
s
The GL returns a four-component vector (R ;G ;B ;A ) to the fragment shader.
s s s s
du du dv dv dw
For the purposes of level-of-detail calculations, the derivates , , , ,
dx dy dx dy dx
dw
and may be approximated by a differencing algorithm as detailed in section 8.8
dy
of the OpenGL Shading Language speci?cation.
Version 3.0 (September 23, 2008)3.12. FRAGMENTSHADERS 234
Texture lookups involving textures with depth component data can either return
the depth data directly or return the results of a comparison with the D value
ref
(see section 3.9.14) used to perform the lookup. The comparison operation is re-
quested in the shader by using any of the shadow sampler types and in the texture
using theTEXTURE COMPARE MODE parameter. These requests must be consistent;
the results of a texture lookup are unde?ned if:
 The sampler used in a texture lookup function is not one of the shadow
sampler types, the texture object’s internal format isDEPTH COMPONENT or
DEPTH STENCIL, and theTEXTURE COMPARE MODE is notNONE.
 The sampler used in a texture lookup function is one of the shadow sam-
pler types, the texture object’s internal format is DEPTH COMPONENT or
DEPTH STENCIL, and theTEXTURE COMPARE MODE isNONE.
 The sampler used in a texture lookup function is one of the shadow sampler
types, and the texture object’s internal format is notDEPTH COMPONENT or
DEPTH STENCIL.
The stencil index texture internal component is ignored if the base internal
format isDEPTH STENCIL.
If a fragment shader uses a sampler whose associated texture object is not com-
plete, as de?ned in section 3.9.10, the texture image unit will return (R;G;B;A)
= (0; 0; 0; 1).
The number of separate texture units that can be accessed from within a
fragment shader during the rendering of a single primitive is speci?ed by the
implementation- dependent constantMAX TEXTURE IMAGE UNITS.
Shader Inputs
The OpenGL Shading Language speci?cation describes the values that are avail-
able as inputs to the fragment shader.
The built-in variable gl FragCoord holds the window coordinates x, y, z,
1
and for the fragment. The z component of gl FragCoord undergoes an im-
w
plied conversion to ?oating-point. This conversion must leave the values 0 and
1 invariant. Note that thisz component already has a polygon offset added in, if
1
enabled (see section 3.6.5). The value is computed from thew coordinate (see
c
w
section 2.12), which is the result of the product of the projection matrix and the
vertex’s eye coordinates.
The built-in variables gl Color and gl SecondaryColor hold the R, G, B,
and A components, respectively, of the fragment color and secondary color. If
Version 3.0 (September 23, 2008)3.12. FRAGMENTSHADERS 235
the primary color or the secondary color components are represented by the GL as
?xed-point values, they undergo an implied conversion to ?oating-point. This con-
version must leave the values 0 and 1 invariant. Floating-point color components
(resulting from a disabled vertex color clamp) are unmodi?ed.
The built-in variablegl FrontFacing is set toTRUE if the fragment is gener-
ated from a front facing primitive, andFALSE otherwise. For fragments generated
from polygon, triangle, or quadrilateral primitives (including ones resulting from
polygons rendered as points or lines), the determination is made by examining the
sign of the area computed by equation 2.6 of section 2.19.1 (including the possible
reversal of this sign controlled by FrontFace). If the sign is positive, fragments
generated by the primitive are front facing; otherwise, they are back facing. All
other fragments are considered front facing.
The built-in variablegl PrimitiveID is ?lled with the number of primitives
processed by the rasterizer since the last time Begin was called (directly or indi-
rectly via vertex array functions). The ?rst primitive generated after a Begin is
numbered zero, and the primitive ID counter is incremented after every individual
point, line, or polygon primitive is processed. For polygons drawn in point or line
mode, the primitive ID counter is incremented only once, even though multiple
points or lines may be drawn. ForQUADS andQUAD STRIP primitives that are de-
composed into triangles, the primitive ID is incremented after each complete quad
is processed.
The value of gl PrimitiveID is unde?ned for fragments generated by
POLYGON primitives or from DrawPixels or Bitmap commands. Additionally,
gl PrimitiveID is only de?ned under the same conditions thatgl VertexID is
de?ned, as described under “Shader Inputs” in section 2.20.4.
Shader Outputs
The OpenGL Shading Language speci?cation describes the values that may be
output by a fragment shader. These outputs are split into two categories, user-
de?ned varying out variables and built-in variables. The built-in variables are
gl FragColor, gl FragData[n], and gl FragDepth. If fragment color
clamping is enabled and the color buffer has a ?xed- or ?oating-point format,
the ?nal fragment color, fragment data, or varying out variable values written by
a fragment shader are clamped to the range [0; 1] and are optionally converted to
?xed-point as described in section 2.19.9. Only user-de?ned varying out variables
declared as a ?oating-point type are clamped and may be converted. If fragment
color clamping is disabled, or the color buffer has an integer format, the ?nal
fragment color, fragment data, or varying out variable values are not modi?ed. For
?xed-point depth buffers, the ?nal fragment depth written by a fragment shader is
Version 3.0 (September 23, 2008)3.12. FRAGMENTSHADERS 236
?rst clamped to [0; 1] and then converted to ?xed-point as if it were a windowz
value (see section 2.12.1). For ?oating-point depth buffers, conversion is not per-
formed but clamping is. Note that the depth range computation is not applied here,
only the conversion to ?xed-point.
Color values written by a fragment shader may be ?oating-point, signed inte-
ger, or unsigned integer. If the color buffer has a ?xed-point format, color values
are assumed to be ?oating-point and are converted to ?xed-point as described in
section 2.19.9; otherwise no type conversion is applied. If the values written by the
fragment shader do not match the format(s) of the corresponding color buffer(s),
the result is unde?ned.
Writing to gl FragColor speci?es the fragment color (color number
zero) that will be used by subsequent stages of the pipeline. Writing to
gl FragData[n] speci?es the value of fragment color number n. Any colors,
or color components, associated with a fragment that are not written by the frag-
ment shader are unde?ned. A fragment shader may not statically assign values
to more than one ofgl FragColor,gl FragData, and any user-de?ned varying
out variable. In this case, a compile or link error will result. A shader statically
assigns a value to a variable if, after pre-processing, it contains a statement that
would write to the variable, whether or not run-time ?ow of control will cause that
statement to be executed.
Writing to gl FragDepth speci?es the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value to
gl FragDepth, then the depth value generated during rasterization is used by sub-
sequent stages of the pipeline. Otherwise, the value assigned togl FragDepth is
used, and is unde?ned for any fragments where statements assigning a value to
gl FragDepth are not executed. Thus, if a shader statically assigns a value to
gl FragDepth, then it is responsible for always writing it.
The binding of a user-de?ned varying out variable to a fragment color number
can be speci?ed explicitly. The command
void BindFragDataLocation(uint program,
uint colorNumber,const char *name );
speci?es that the varying out variable name in program should be bound to frag-
ment color colorNumber when the program is next linked. If name was bound
previously, its assigned binding is replaced with colorNumber. name must be
a null-terminated string. The error INVALID VALUE is generated if colorNum-
ber is equal or greater than MAX DRAW BUFFERS. BindFragDataLocation has no
effect until the program is linked. In particular, it doesn’t modify the bindings
of varying out variables in a program that has already been linked. The error
INVALID OPERATION is generated if name starts with the reservedgl pre?x.
Version 3.0 (September 23, 2008)3.13. ANTIALIASINGAPPLICATION 237
When a program is linked, any varying out variables without a binding spec-
i?ed through BindFragDataLocation will automatically be bound to fragment
colors by the GL. Such bindings can be queried using the command GetFrag-
DataLocation. LinkProgram will fail if the assigned binding of a varying out
variable would cause the GL to reference a non-existant fragment color number
(one greater than or equal to MAX DRAW BUFFERS). LinkProgram will also fail
if more than one varying out variable is bound to the same number. This type of
aliasing is not allowed.
BindFragDataLocation may be issued before any shader objects are attached
to a program object. Hence it is allowed to bind any name (except a name starting
with gl ) to a color number, including a name that is never used as a varying out
variable in any fragment shader object. Assigned bindings for variables that do not
exist are ignored.
After a program object has been linked successfully, the bindings of varying
out variable names to color numbers can be queried. The command
int GetFragDataLocation(uint program,const char
*name );
returns the number of the fragment color to which the varying out variable
name was bound when the program object program was last linked. name must
be a null-terminated string. If program has not been successfully linked, the error
INVALID OPERATION is generated. If name is not a varying out variable, or if an
error occurs, -1 will be returned.
3.13 Antialiasing Application
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. In RGBA
mode, the value is multiplied by the fragment’s alpha (A) value to yield a ?nal
alpha value. In color index mode, the value is used to set the low order bits of
the color index value as described in section 3.3. The coverage value is applied
separately to each fragment color.
3.14 Multisample Point Fade
Finally, if multisampling is enabled and the rasterized fragment results from a point
primitive, then the computed fade factor from equation 3.2 is applied to the frag-
ment. In RGBA mode, the fade factor is multiplied by the fragment’s alpha value
Version 3.0 (September 23, 2008)3.14. MULTISAMPLEPOINTFADE 238
to yield a ?nal alpha value. In color index mode, the fade factor has no effect. The
fade factor is applied separately to each fragment color.
Version 3.0 (September 23, 2008)Chapter 4
Per-Fragment Operations and the
Framebuffer
The framebuffer, whether it is the default framebuffer or a framebuffer object (see
section 2.1), consists of a set of pixels arranged as a two-dimensional array. For
purposes of this discussion, each pixel in the framebuffer is simply a set of some
number of bits. The number of bits per pixel may vary depending on the GL im-
plementation, the type of framebuffer selected, and parameters speci?ed when the
framebuffer was created. Creation and management of the default framebuffer is
outside the scope of this speci?cation, while creation and management of frame-
buffer objects is described in detail in section 4.4.
Corresponding bits from each pixel in the framebuffer are grouped together
into a bitplane; each bitplane contains a single bit from each pixel. These bitplanes
are grouped into several logical buffers. These are the color, depth, stencil, and
accumulation buffers. The color buffer actually consists of a number of buffers,
and these color buffers serve related but slightly different purposes depending on
whether the GL is bound to the default framebuffer or a framebuffer object.
For the default framebuffer, the color buffers are the front left buffer, the front
right buffer, the back left buffer, the back right buffer, and some number of aux-
iliary buffers. Typically the contents of the front buffers are displayed on a color
monitor while the contents of the back buffers are invisible. (Monoscopic contexts
display only the front left buffer; stereoscopic contexts display both the front left
and the front right buffers.) The contents of the auxiliary buffers are never visible.
All color buffers must have the same number of bitplanes, although an implemen-
tation or context may choose not to provide right buffers, back buffers, or auxiliary
buffers at all. Further, an implementation or context may not provide depth, sten-
cil, or accumulation buffers. If no default framebuffer is associated with the GL
239240
context, the framebuffer is incomplete except when a framebuffer object is bound
(see sections 4.4.1 and 4.4.4).
Framebuffer objects are not visible, and do not have any of the color buffers
present in the default framebuffer. Instead, the buffers of an framebuffer object
are speci?ed by attaching individual textures or renderbuffers (see section 4.4) to
a set of attachment points. A framebuffer object has an array of color buffer at-
tachment points, numbered zero throughn, a depth buffer attachment point, and
a stencil buffer attachment point. In order to be used for rendering, a framebuffer
object must be complete, as described in section 4.4.4. Not all attachments of a
framebuffer object need to be populated.
Each pixel in a color buffer consists of either a single unsigned integer color
index or up to four color components. The four color components are named R,
G, B, and A, in that order; color buffers are not required to have all four color
components. R, G, B, and A components may be represented as unsigned ?xed-
point, ?oating-point, signed integer, or unsigned integer values; all components
must have the same representation. Each pixel in a depth buffer consists of a single
unsigned integer value in the format described in section 2.12.1 or a ?oating-point
value. Each pixel in a stencil buffer consists of a single unsigned integer value.
Each pixel in an accumulation buffer consists of up to four color components ?xed-
point values. If an accumulation buffer is present, it must have at least as many
bitplanes per component as in the color buffers.
The number of bitplanes in the color, depth, stencil, and accumulation buffers
is dependent on the currently bound framebuffer. For the default framebuffer, the
number of bitplanes is ?xed. For framebuffer objects, the number of bitplanes
in a given logical buffer may change if the image attached to the corresponding
attachment point changes.
The GL has two active framebuffers; the draw framebuffer is the destination
for rendering operations, and the read framebuffer is the source for readback op-
erations. The same framebuffer may be used for both drawing and reading. Sec-
tion 4.4.2 describes the mechanism for controlling framebuffer usage.
1
The default framebuffer is initially used as the draw and read framebuffer ,
and the initial state of all provided bitplanes is unde?ned. The format and en-
coding of buffers in the draw and read framebuffers can be queried as described in
section 6.1.3.
1
The window system binding API may allow associating a GL context with two separate “default
framebuffers” provided by the window system as the draw and read framebuffers, but if so, both
default framebuffers are referred to by the name zero at their respective binding points.
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 241
Fragment
Alpha
Pixel
Scissor
+
Test
Ownership
Test
(RGBA Only)
Associated
Test
Data
Depth buffer
Stencil 
Test
Test
Framebuffer Framebuffer
Blending To
Logicop
Dithering
(RGBA Only)
Framebuffer
Framebuffer Framebuffer
Figure 4.1. Per-fragment operations.
4.1 Per-Fragment Operations
A fragment produced by rasterization with window coordinates of (x ;y ) mod-
w w
i?es the pixel in the framebuffer at that location based on a number of parame-
ters and conditions. We describe these modi?cations and tests, diagrammed in
?gure 4.1, in the order in which they are performed. Figure 4.1 diagrams these
modi?cations and tests.
4.1.1 Pixel Ownership Test
The ?rst test is to determine if the pixel at location (x ;y ) in the framebuffer
w w
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
control the GL’s behavior, for instance, when a GL window is obscured.
If the draw framebuffer is a framebuffer object (see section 4.2.1), the pixel
ownership test always passes, since the pixels of framebuffer objects are owned by
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 242
the GL, not the window system. If the draw framebuffer is the default framebuffer,
the window system controls pixel ownership.
4.1.2 Scissor Test
The scissor test determines if (x ;y ) lies within the scissor rectangle de?ned by
w w
four values. These values are set with
void Scissor(int left,int bottom,sizei width,
sizei height );
If leftx < left+width and bottomy < bottom+height, then the scissor test
w w
passes. Otherwise, the test fails and the fragment is discarded. The test is enabled
or disabled using Enable or Disable using the constant SCISSOR TEST. When
disabled, it is as if the scissor test always passes. If either width or height is less
than zero, then the errorINVALID VALUE is generated. The state required consists
of four integer values and a bit indicating whether the test is enabled or disabled.
In the initial state,left = bottom = 0. width and height are set to the width and
height, respectively, of the window into which the GL is to do its rendering. If the
default framebuffer is bound but no default framebuffer is associated with the GL
context (see chapter 4), then width and height are initially set to zero. Initially, the
scissor test is disabled.
4.1.3 Multisample Fragment Operations
This step modi?es fragment alpha and coverage values based on the values
of SAMPLE ALPHA TO COVERAGE, SAMPLE ALPHA TO ONE, SAMPLE COVERAGE,
SAMPLE COVERAGE VALUE, and SAMPLE COVERAGE INVERT. No changes to the
fragment alpha or coverage values are made at this step if MULTISAMPLE is dis-
abled, or if the value ofSAMPLE BUFFERS is not one.
SAMPLE ALPHA TO COVERAGE, SAMPLE ALPHA TO ONE, and
SAMPLE COVERAGE are enabled and disabled by calling Enable and Disable
with cap speci?ed as one of the three token values. All three values are
queried by calling IsEnabled with cap set to the desired token value. If
SAMPLE ALPHA TO COVERAGE is enabled and the color buffer has a ?xed-point
or ?oating-point format, a temporary coverage value is generated where each
bit is determined by the alpha value at the corresponding sample location. The
temporary coverage value is then ANDed with the fragment coverage value.
Otherwise the fragment coverage value is unchanged at this point. If multiple
colors are written by a fragment shader, the alpha value of fragment color zero is
used to determine the temporary coverage value.
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 243
No speci?c algorithm is required for converting the sample alpha values to a
temporary coverage value. It is intended that the number of 1’s in the temporary
coverage be proportional to the set of alpha values for the fragment, with all 1’s
corresponding to the maximum of all alpha values, and all 0’s corresponding to
all alpha values being 0. The alpha values used to generate a coverage value are
clamped to the range [0; 1]. It is also intended that the algorithm be pseudo-random
in nature, to avoid image artifacts due to regular coverage sample locations. The
algorithm can and probably should be different at different pixel locations. If it
does differ, it should be de?ned relative to window, not screen, coordinates, so that
rendering results are invariant with respect to window position.
Next, ifSAMPLE ALPHA TO ONE is enabled, each alpha value is replaced by the
maximum representable alpha value. Otherwise, the alpha values are not changed.
Finally, if SAMPLE COVERAGE is enabled, the fragment coverage is ANDed
with another temporary coverage. This temporary coverage is generated
in the same manner as the one described above, but as a function of
the value of SAMPLE COVERAGE VALUE. The function need not be identical,
but it must have the same properties of proportionality and invariance. If
SAMPLE COVERAGE INVERT is TRUE, the temporary coverage is inverted (all bit
values are inverted) before it is ANDed with the fragment coverage.
The values of SAMPLE COVERAGE VALUE and SAMPLE COVERAGE INVERT
are speci?ed by calling
void SampleCoverage(clampf value,boolean invert );
with value set to the desired coverage value, and invert set to TRUE or FALSE.
value is clamped to [0,1] before being stored as SAMPLE COVERAGE VALUE.
SAMPLE COVERAGE VALUE is queried by calling GetFloatv with pname set to
SAMPLE COVERAGE VALUE. SAMPLE COVERAGE INVERT is queried by calling
GetBooleanv with pname set toSAMPLE COVERAGE INVERT.
4.1.4 Alpha Test
This step applies only in RGBA mode, and only if the color buffer has a ?xed-
point or ?oating-point format. In color index mode, or if the color buffer has an
integer format, proceed to the next operation.
The alpha test discards a fragment conditional on the outcome of a compari-
son between the incoming fragment’s alpha value and a constant value. If multiple
colors are written by a fragment shader, the alpha value of fragment color zero is
used to determine the result of the alpha test. The comparison is enabled or dis-
abled with the generic Enable and Disable commands using the symbolic constant
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 244
ALPHA TEST. When disabled, it is as if the comparison always passes. The test is
controlled with
void AlphaFunc(enum func,clampf ref );
func is a symbolic constant indicating the alpha test function; ref is a reference
value. When performing the alpha test, the GL will convert the reference value to
the same representation as the the fragment’s alpha value (?oating-point or ?xed-
point). For ?xed-point, the reference value is converted according to the rules given
for an A component in section 2.19.9 and the fragment’s alpha value is rounded to
the nearest integer.
The possible constants specifying the test function areNEVER,ALWAYS,LESS,
LEQUAL, EQUAL, GEQUAL, GREATER, or NOTEQUAL, meaning pass the fragment
never, always, if the fragment’s alpha value is less than, less than or equal to,
equal to, greater than or equal to, greater than, or not equal to the reference value,
respectively.
The required state consists of the ?oating-point reference value, an eight-
valued integer indicating the comparison function, and a bit indicating if the com-
parison is enabled or disabled. The initial state is for the reference value to be 0
and the function to beALWAYS. Initially, the alpha test is disabled.
4.1.5 Stencil Test
The stencil test conditionally discards a fragment based on the outcome of a com-
parison between the value in the stencil buffer at location (x ;y ) and a reference
w w
value. The test is enabled or disabled with the Enable and Disable commands,
using the symbolic constant STENCIL TEST. When disabled, the stencil test and
associated modi?cations are not made, and the fragment is always passed.
The stencil test is controlled with
void StencilFunc(enum func,int ref,uint mask );
void StencilFuncSeparate(enum face,enum func,int ref,
uint mask );
void StencilOp(enum sfail,enum dpfail,enum dppass );
void StencilOpSeparate(enum face,enum sfail,enum dpfail,
enum dppass );
There are two sets of stencil-related state, the front stencil state set and the back
stencil state set. Stencil tests and writes use the front set of stencil state when pro-
cessing fragments rasterized from non-polygon primitives (points, lines, bitmaps,
image rectangles) and front-facing polygon primitives while the back set of stencil
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 245
state is used when processing fragments rasterized from back-facing polygon prim-
itives. For the purposes of stencil testing, a primitive is still considered a polygon
even if the polygon is to be rasterized as points or lines due to the current poly-
gon mode. Whether a polygon is front- or back-facing is determined in the same
manner used for two-sided lighting and face culling (see sections 2.19.1 and 3.6.1).
StencilFuncSeparate and StencilOpSeparate take a face argument which can
beFRONT,BACK, orFRONT AND BACK and indicates which set of state is affected.
StencilFunc and StencilOp set front and back stencil state to identical values.
StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is used
in the unsigned stencil comparison. Stencil comparison operations and queries
s
of ref clamp its value to the range [0; 2   1], wheres is the number of bits in the
stencil buffer attached to the draw framebuffer. Thes least signi?cant bits of mask
are bitwise ANDed with both the reference and the stored stencil value, and the
resulting masked values are those that participate in the comparison controlled by
func. func is a symbolic constant that determines the stencil comparison function;
the eight symbolic constants areNEVER,ALWAYS,LESS,LEQUAL,EQUAL,GEQUAL,
GREATER, orNOTEQUAL. Accordingly, the stencil test passes never, always, and if
the masked reference value is less than, less than or equal to, equal to, greater than
or equal to, greater than, or not equal to the masked stored value in the stencil
buffer.
StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
are KEEP, ZERO, REPLACE, INCR, DECR, INVERT, INCR WRAP, and DECR WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wise inverting it, incrementing without saturation, and decrementing without satu-
ration.
For purposes of increment and decrement, the stencil bits are considered as an
unsigned integer. Incrementing or decrementing with saturation clamps the stencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
value results in 0, and decrementing 0 results in the maximum representable value.
The same symbolic values are given to indicate the stencil action if the depth
buffer test (see section 4.1.6) fails (dpfail), or if it passes (dppass).
If the stencil test fails, the incoming fragment is discarded. The state required
consists of the most recent values passed to StencilFunc or StencilFuncSeparate
and to StencilOp or StencilOpSeparate, and a bit indicating whether stencil test-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 246
back stencil reference value are both zero, the front and back stencil comparison
functions are both ALWAYS, and the front and back stencil mask are both all ones.
Initially, all three front and back stencil operations areKEEP.
If there is no stencil buffer, no stencil modi?cation can occur, and it is as if the
stencil tests always pass, regardless of any calls to StencilFunc.
4.1.6 Depth Buffer Test
The depth buffer test discards the incoming fragment if a depth comparison fails.
The comparison is enabled or disabled with the generic Enable and Disable com-
mands using the symbolic constant DEPTH TEST. When disabled, the depth com-
parison and subsequent possible updates to the depth buffer value are bypassed and
the fragment is passed to the next operation. The stencil value, however, is modi-
?ed as indicated below as if the depth buffer test passed. If enabled, the comparison
takes place and the depth buffer and stencil value may subsequently be modi?ed.
The comparison is speci?ed with
void DepthFunc(enum func );
This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s z value is less than, less
w
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (x ;y )
w w
coordinates.
If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (x ;y ) coordinates is updated according to the function
w w
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (x ;y )
w w
location is set to the fragment’sz value. In this case the stencil value is updated
w
according to the function currently in effect for depth buffer test success.
The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
isLESS and the test is disabled.
If there is no depth buffer, it is as if the depth buffer test always passes.
4.1.7 Occlusion Queries
Occlusion queries use query objects to track the number of fragments or samples
that pass the depth test. An occlusion query can be started and ?nished by calling
BeginQuery and EndQuery, respectively, with a target ofSAMPLES PASSED.
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 247
When an occlusion query is started, the samples-passed count maintained by
the GL is set to zero. When an occlusion query is active, the samples-passed
count is incremented for each fragment that passes the depth test. If the value
of SAMPLE BUFFERS is 0, then the samples-passed count is incremented by 1 for
each fragment. If the value of SAMPLE BUFFERS is 1, then the samples-passed
count is incremented by the number of samples whose coverage bit is set. How-
ever, implementations, at their discretion, may instead increase the samples-passed
count by the value ofSAMPLES if any sample in the fragment is covered.
When an occlusion query ?nishes and all fragments generated by commands
issued prior to EndQuery have been generated, the samples-passed count is written
to the corresponding query object as the query result value, and the query result for
that object is marked as available.
n
If the samples-passed count over?ows (exceeds the value 2   1, wheren is
the number of bits in the samples-passed count), its value becomes unde?ned. It is
recommended, but not required, that implementations handle this over?ow case by
n
saturating at 2   1 and incrementing no further.
The necessary state is a single bit indicating whether an occlusion query is
active, the identi?er of the currently active occlusion query, and a counter keeping
track of the number of samples that have passed.
4.1.8 Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(x ;y ) location.
w w
Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions, and a constant blend color to obtain a new set of R, G, B, and A values,
as described below.
If the color buffer is ?xed-point, the components of the source and destination
values and blend factors are clamped to [0; 1] prior to evaluating the blend equation.
If the color buffer is ?oating-point, no clamping occurs. The resulting four values
are sent to the next operation.
Blending is dependent on the incoming fragment’s alpha value and that of the
corresponding currently stored pixel. Blending applies only in RGBA mode; and
only if the color buffer has a ?xed-point or ?oating-point format. In color index
mode, or if the color buffer has an integer format, proceed to the next operation.
Blending is enabled or disabled for an individual draw buffer with the com-
mands
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 248
void Enablei(enum target,uint index );
void Disablei(enum target,uint index );
target is the symbolic constant BLEND and index is an integer i specifying the
draw buffer associated with the symbolic constant DRAW BUFFERi. If the color
buffer associated with DRAW BUFFERi is one of FRONT, BACK, LEFT, RIGHT, or
FRONT AND BACK (specifying multiple color buffers), then the state enabled or dis-
abled is applicable for all of the buffers. Blending can be enabled or disabled for
all draw buffers using Enable or Disable with the symbolic constant BLEND. If
blending is disabled for a particular draw buffer, or if logical operation on color
values is enabled (section 4.1.11), proceed to the next operation.
An INVALID VALUE error is generated if index is greater than the value of
MAX DRAW BUFFERS minus one.
If multiple fragment colors are being written to multiple buffers (see sec-
tion 4.2.1), blending is computed and applied separately for each fragment color
and the corresponding buffer.
Blend Equation
Blending is controlled by the blend equations, de?ned by the commands
void BlendEquation(enum mode );
void BlendEquationSeparate(enum modeRGB,
enum modeAlpha );
BlendEquationSeparate argument modeRGB determines the RGB blend func-
tion while modeAlpha determines the alpha blend equation. BlendEqua-
tion argument mode determines both the RGB and alpha blend equations.
modeRGB and modeAlpha must each be one of FUNC ADD, FUNC SUBTRACT,
FUNC REVERSE SUBTRACT,MIN, orMAX.
Fixed-point destination (framebuffer) components are taken to be ?xed-point
values represented according to the scheme in section 2.19.9 (Final Color Pro-
cessing). Constant color components, ?oating-point destination components, and
source (fragment) components are taken to be ?oating point values. If source com-
ponents are represented internally by the GL as ?xed-point values, they are also
interpreted according to section 2.19.9.
Prior to blending, each ?xed-point color component undergoes an implied con-
version to ?oating-point. This conversion must leave the values 0 and 1 invariant.
Blending computations are treated as if carried out in ?oating-point.
If FRAMEBUFFER SRGB is enabled and
the value of FRAMEBUFFER ATTACHMENT COLOR ENCODING for the framebuffer
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 249
attachment corresponding to the destination buffer isSRGB (see section 6.1.3), the
R, G, and B destination color values (after conversion from ?xed-point to ?oating-
point) are considered to be encoded for the sRGB color space and hence must be
linearized prior to their use in blending. Each R, G, and B component is converted
in the same fashion described for sRGB texture components in section 3.9.15.
If FRAMEBUFFER SRGB is disabled or the value of
FRAMEBUFFER ATTACHMENT COLOR ENCODING is not SRGB, no linearization is
performed.
The resulting linearized R, G, and B and unmodi?ed A values are recombined
as the destination color used in blending computations.
Table 4.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
In the table, the s subscript on a color component abbreviation (R, G, B, or
A) refers to the source color component for an incoming fragment, thed subscript
on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and thec subscript on a color component
abbreviation refers to the constant blend color component. A color component ab-
breviation without a subscript refers to the new color component resulting from
blending. Additionally,S ,S ,S , andS are the red, green, blue, and alpha com-
r g b a
ponents of the source weighting factors determined by the source blend function,
and D , D , D , and D are the red, green, blue, and alpha components of the
r g a
b
destination weighting factors determined by the destination blend function. Blend
functions are described below.
Blend Functions
The weighting factors used by the blend equation are determined by the blend
functions. Blend functions are speci?ed with the commands
void BlendFuncSeparate(enum srcRGB,enum dstRGB,
enum srcAlpha,enum dstAlpha );
void BlendFunc(enum src,enum dst );
BlendFuncSeparate arguments srcRGB and dstRGB determine the source and
destination RGB blend functions, respectively, while srcAlpha and dstAlpha deter-
mine the source and destination alpha blend functions. BlendFunc argument src
determines both RGB and alpha source functions, while dst determines both RGB
and alpha destination functions.
The possible source and destination blend functions and their corresponding
computed blend factors are summarized in table 4.2.
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 250
Mode RGB Components Alpha Component
FUNC ADD R =R S +R D A =A S +A D
s r d r s a d a
G =G S +G D
s g d g
B =B S +B D
s b d b
FUNC SUBTRACT R =R S  R D A =A S  A D
s r d r s a d a
G =G S  G D
s g d g
B =B S  B D
s b d b
FUNC REVERSE SUBTRACT R =R D  R S A =A D  A S
d r s r d a s a
G =G D  G S
g s g
d
B =B D  B S
d b s b
MIN R = min(R ;R ) A = min(A ;A )
s d s d
G = min(G ;G )
s
d
B = min(B ;B )
s d
MAX R = max(R ;R ) A = max(A ;A )
s d s d
G = max(G ;G )
s
d
B = max(B ;B )
s d
Table 4.1: RGB and alpha blend equations.
Blend Color
The constant colorC to be used in blending is speci?ed with the command
c
void BlendColor(clampf red,clampf green,clampf blue,
clampf alpha );
The constant color can be used in both the source and destination blending
functions
The state required for blending is two integers for the RGB and alpha blend
equations, four integers indicating the source and destination RGB and alpha
blending functions, four ?oating-point values to store the RGBA constant blend
color, and a bit indicating whether blending is enabled or disabled for each of the
MAX DRAW BUFFERS draw buffers.
The initial blend equations for RGB and alpha are bothFUNC ADD. The initial
blending functions are ONE for the source RGB and alpha functions and ZERO
for the destination RGB and alpha functions. The initial constant blend color is
(R; G; B; A) = (0; 0; 0; 0). Initially, blending is disabled for all draw buffers.
The value of the blend enable for draw bufferi can be queried by calling IsEn-
abledi with targetBLEND and indexi. The value of the blend enable for draw buffer
zero may also be queried by calling IsEnabled with valueBLEND.
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 251
Function RGB Blend Factors Alpha Blend Factor
(S ;S ;S ) or (D ;D ;D ) S orD
r g r g a a
b b
ZERO (0; 0; 0) 0
ONE (1; 1; 1) 1
SRC COLOR (R ;G ;B ) A
s s s s
ONE MINUS SRC COLOR (1; 1; 1)  (R ;G ;B ) 1 A
s s s s
DST COLOR (R ;G ;B ) A
d d d d
ONE MINUS DST COLOR (1; 1; 1)  (R ;G ;B ) 1 A
d d d d
SRC ALPHA (A ;A ;A ) A
s s s s
ONE MINUS SRC ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
s s s s
DST ALPHA (A ;A ;A ) A
d d d d
ONE MINUS DST ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
d d d d
CONSTANT COLOR (R ;G ;B ) A
c c c c
ONE MINUS CONSTANT COLOR (1; 1; 1)  (R ;G ;B ) 1 A
c c c c
CONSTANT ALPHA (A ;A ;A ) A
c c c c
ONE MINUS CONSTANT ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
c c c c
1 2
SRC ALPHA SATURATE (f;f;f) 1
Table 4.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1
SRC ALPHA SATURATE is valid only for source RGB and alpha blending func-
tions.
2
f = min(A ; 1 A ).
s d
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 252
Blending occurs once for each color buffer currently enabled for blending and
for writing (section 4.2.1) using each buffer’s color forC . If a color buffer has no
d
A value, thenA is taken to be 1.
d
4.1.9 sRGB Conversion
If FRAMEBUFFER SRGB is enabled and the value of
FRAMEBUFFER ATTACHMENT COLOR ENCODING for the framebuffer attach-
ment corresponding to the destination buffer isSRGB (see section 6.1.3), the R, G,
and B values after blending are converted into the non-linear sRGB color space by
computing
8
>
0:0; c  0
> l
>
>
<
12:92c; 0<c < 0:0031308
l l
c = (4.1)
s
0:41666
>
1:055c   0:055; 0:0031308c < 1
> l
l
>
>
:
1:0; c  1
l
wherec is the R, G, or B element andc is the result (effectively converted into an
l s
sRGB color space).
If FRAMEBUFFER SRGB is disabled or the value of
FRAMEBUFFER ATTACHMENT COLOR ENCODING is notSRGB, then
c =c:
s l
The resulting c values for R, G, and B, and the unmodi?ed A form a new
s
RGBA color value. If the color buffer is ?xed-point, each component is clamped to
the range [0; 1] and then converted to a ?xed-point value in the manner described
in section 2.19.9. The resulting four values are sent to the subsequent dithering
operation.
4.1.10 Dithering
Dithering selects between two representable color values or indices. A repre-
sentable value is a value that has an exact representation in the color buffer. In
RGBA mode dithering selects, for each color component, either the largest posi-
tive representable color value (for that particular color component) that is less than
or equal to the incoming color component value,c, or the smallest negative repre-
sentable color value that is greater than or equal toc. The selection may depend on
thex andy coordinates of the pixel, as well as on the exact value ofc. If one of
w w
the two values does not exist, then the selection defaults to the other value.
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 253
In color index mode dithering selects either the largest representable index that
is less than or equal to the incoming color value, c, or the smallest representable
index that is greater than or equal toc. If one of the two indices does not exist, then
the selection defaults to the other value.
Many dithering selection algorithms are possible, but an individual selection
must depend only on the incoming color index or component value and the frag-
ment’sx andy window coordinates. If dithering is disabled, then each incoming
color componentc is replaced with the largest positive representable color value
(for that particular component) that is less than or equal toc, or by the smallest
negative representable value, if no representable value is less than or equal toc; a
color index is rounded to the nearest representable index value.
Dithering is enabled with Enable and disabled with Disable using the symbolic
constant DITHER. The state required is thus a single bit. Initially, dithering is
enabled.
4.1.11 Logical Operation
Finally, a logical operation is applied between the incoming fragment’s color or
index values and the color or index values stored at the corresponding location in
the framebuffer. The result replaces the values in the framebuffer at the fragment’s
(x ;y ) coordinates. If the selected draw buffers refer to the same framebuffer-
w w
attachable image more than once, then the values stored in that image are unde-
?ned.
The logical operation on color indices is enabled or disabled with Enable or
Disable using the symbolic constant INDEX LOGIC OP. (For compatibility with
GL version 1.0, the symbolic constant LOGIC OP may also be used.) The logical
operation on color values is enabled or disabled with Enable or Disable using
the symbolic constant COLOR LOGIC OP. If the logical operation is enabled for
color values, it is as if blending were disabled, regardless of the value ofBLEND. If
multiple fragment colors are being written to multiple buffers (see section 4.2.1),
the logical operation is computed and applied separately for each fragment color
and the corresponding buffer.
Logical operation has no effect on a ?oating-point destination color buffer.
However, if logical operation is enabled, blending is still disabled.
The logical operation is selected by
void LogicOp(enum op );
op is a symbolic constant; the possible constants and corresponding operations are
enumerated in table 4.3. In this table,s is the value of the incoming fragment andd
Version 3.0 (September 23, 2008)4.1. PER-FRAGMENTOPERATIONS 254
Argument value Operation
CLEAR 0
AND s^d
AND REVERSE s^:d
COPY s
AND INVERTED :s^d
NOOP d
XOR s xord
OR s_d
NOR :(s_d)
EQUIV :(s xord)
INVERT :d
OR REVERSE s_:d
COPY INVERTED :s
OR INVERTED :s_d
NAND :(s^d)
SET all 1’s
Table 4.3: Arguments to LogicOp and their corresponding operations.
is the value stored in the framebuffer. The numeric values assigned to the symbolic
constants are the same as those assigned to the corresponding symbolic values in
the X window system.
Logical operations are performed independently for each color index buffer
that is selected for writing, or for each red, green, blue, and alpha value of each
color buffer that is selected for writing. The required state is an integer indicating
the logical operation, and two bits indicating whether the logical operation is en-
abled or disabled. The initial state is for the logic operation to be given by COPY,
and to be disabled.
4.1.12 Additional Multisample Fragment Operations
If the DrawBuffer mode isNONE, no change is made to any multisample or color
buffer. Otherwise, fragment processing is as described below.
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, the
alpha test, stencil test, depth test, blending, dithering, and logical operations are
performed for each pixel sample, rather than just once for each fragment. Failure
of the alpha, stencil, or depth test results in termination of the processing of that
sample, rather than discarding of the fragment. All operations are performed on the
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 255
color, depth, and stencil values stored in the multisample buffer (to be described
in a following section). The contents of the color buffers are not modi?ed at this
point.
Stencil, depth, blending, and dithering operations are performed for a pixel
sample only if that sample’s fragment coverage bit is a value of 1. If the corre-
sponding coverage bit is 0, no operations are performed for that sample.
If MULTISAMPLE is disabled, and the value of SAMPLE BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
because the fragment coverage must be set to full coverage. Further optimization is
allowed, however. An implementation may choose to identify a centermost sample,
and to perform alpha, stencil, and depth tests on only that sample. Regardless of
the outcome of the stencil test, all multisample buffer stencil sample values are set
to the appropriate new stencil value. If the depth test passes, all multisample buffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
value of the incoming fragment. Otherwise, no change is made to any multisample
buffer color or depth value.
After all operations have been completed on the multisample buffer, the sample
values for each color in the multisample buffer are combined to produce a single
color value, and that value is written into the corresponding color buffers selected
by DrawBuffer or DrawBuffers. An implementation may defer the writing of the
color buffers until a later time, but the state of the framebuffer must behave as if
the color buffers were updated as each fragment was processed. The method of
combination is not speci?ed, though a simple average computed independently for
each color component is recommended.
4.2 Whole Framebuffer Operations
The preceding sections described the operations that occur as individual fragments
are sent to the framebuffer. This section describes operations that control or affect
the whole framebuffer.
4.2.1 Selecting a Buffer for Writing
The ?rst such operation is controlling the color buffers into which each of the
fragment color values is written. This is accomplished with either DrawBuffer or
DrawBuffers.
The command
void DrawBuffer(enum buf );
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 256
de?nes the set of color buffers to which fragment color zero is written. buf
must be one of the values from tables 4.4 or 4.5. In addition, accept-
able values for buf depend on whether the GL is using the default frame-
buffer (i.e., DRAW FRAMEBUFFER BINDING is zero), or a framebuffer object (i.e.,
DRAW FRAMEBUFFER BINDING is non-zero). In the initial state, the GL is bound
to the default framebuffer. For more information about framebuffer objects, see
section 4.4.
If the GL is bound to the default framebuffer, then buf must be one of the values
listed in table 4.4, which summarizes the constants and the buffers they indicate.
In this case, buf is a symbolic constant specifying zero, one, two, or four buffers
for writing. These constants refer to the four potentially visible buffers (front left,
front right, back left, and back right), and to the auxiliary buffers. Arguments
other than AUXi that omit reference to LEFT or RIGHT refer to both left and right
buffers. Arguments other than AUXi that omit reference to FRONT or BACK refer
to both front and back buffers. AUXi enables drawing only to auxiliary buffer i.
EachAUXi adheres toAUXi =AUX0 +i, andi must be in the range 0 to the value of
AUX BUFFERS minus one.
If the GL is bound to a framebuffer object, buf must be one of the values
listed in table 4.5, which summarizes the constants and the buffers they indi-
cate. In this case, buf is a symbolic constant specifying a single color buffer for
writing. Specifying COLOR ATTACHMENTi enables drawing only to the image at-
tached to the framebuffer at COLOR ATTACHMENTi. Each COLOR ATTACHMENTi
adheres toCOLOR ATTACHMENTi =COLOR ATTACHMENT0 +i. The intial value of
DRAW BUFFER for framebuffer objects isCOLOR ATTACHMENT0.
If the GL is bound to the default framebuffer and DrawBuffer is supplied with
a constant (other thanNONE) that does not indicate any of the color buffers allocated
to the GL context, the errorINVALID OPERATION results.
If the GL is bound to a framebuffer object and buf is one of the con-
stants from table 4.4, then the error INVALID OPERATION results. If buf
is COLOR ATTACHMENTm and m is greater than or equal to the value of
MAX COLOR ATTACHMENTS, then the errorINVALID VALUE results.
If DrawBuffer is supplied with a constant that is legal for neither the default
framebuffer nor a framebuffer object, then the errorINVALID ENUM results.
DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
The command
void DrawBuffers(sizei n,const enum *bufs );
de?nes the draw buffers to which all fragment colors are written. n speci?es the
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 257
Symbolic Front Front Back Back Aux
Constant Left Right Left Right i
NONE
FRONT LEFT 
FRONT RIGHT 
BACK LEFT 
BACK RIGHT 
FRONT  
BACK  
LEFT  
RIGHT  
FRONT AND BACK    
AUXi 
Table 4.4: Arguments to DrawBuffer(s) and ReadBuffer when the context is
bound to a default framebuffer, and the buffers they indicate.
Symbolic Constant Meaning
NONE No buffer
COLOR ATTACHMENTi (see caption) Output fragment color to image attached
at color attachment pointi
Table 4.5: Arguments to DrawBuffer(s) and ReadBuffer when the
context is bound to a framebuffer object, and the buffers they indi-
cate. i in COLOR ATTACHMENTi may range from zero to the value of
MAX COLOR ATTACHMENTS - 1.
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 258
Symbolic Front Front Back Back Aux
Constant Left Right Left Right i
NONE
FRONT LEFT 
FRONT RIGHT 
BACK LEFT 
BACK RIGHT 
AUXi 
Table 4.6: Arguments to DrawBuffers when the context is bound to the default
framebuffer, and the buffers they indicate.
number of buffers in bufs. bufs is a pointer to an array of symbolic constants
specifying the buffer to which each fragment color is written.
Each buffer listed in bufs must be one of the values from tables 4.5 or 4.6.
Otherwise, an INVALID ENUM error is generated. Further, acceptable values
for the constants in bufs depend on whether the GL is using the default frame-
buffer (i.e., DRAW FRAMEBUFFER BINDING is zero), or a framebuffer object (i.e.,
DRAW FRAMEBUFFER BINDING is non-zero). For more information about frame-
buffer objects, see section 4.4.
If the GL is bound to the default framebuffer, then each of the constants must
be one of the values listed in table 4.6.
If the GL is bound to an framebuffer object, then each of the constants must be
one of the values listed in table 4.5.
In both cases, the draw buffers being de?ned correspond in order to the re-
spective fragment colors. The draw buffer for fragment colors beyond n is set to
NONE.
The maximum number of draw buffers is implementation dependent and must
be at least 1. The number of draw buffers supported can be queried by calling Get-
Integerv with the symbolic constant MAX DRAW BUFFERS. An INVALID VALUE
error is generated if n is greater thanMAX DRAW BUFFERS.
Except for NONE, a buffer may not appear more then once in the array
pointed to by bufs. Specifying a buffer more then once will result in the error
INVALID OPERATION.
If ?xed-function fragment shading is being performed, DrawBuffers speci?es
a set of draw buffers into which the fragment color is written.
If a fragment shader writes to gl FragColor, DrawBuffers speci?es a set
of draw buffers into which the single fragment color de?ned by gl FragColor
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 259
is written. If a fragment shader writes to gl FragData, or a user-de?ned vary-
ing out variable, DrawBuffers speci?es a set of draw buffers into which each of
the multiple output colors de?ned by these variables are separately written. If a
fragment shader writes to none of gl FragColor, gl FragData, nor any user-
de?ned varying out variables, the values of the fragment colors following shader
execution are unde?ned, and may differ for each fragment color.
For both the default framebuffer and framebuffer objects, the constantsFRONT,
BACK,LEFT,RIGHT, andFRONT AND BACK are not valid in the bufs array passed to
DrawBuffers, and will result in the error INVALID OPERATION. This restriction
is because these constants may themselves refer to multiple buffers, as shown in
table 4.4.
If the GL is bound to the default framebuffer and DrawBuffers is supplied with
a constant (other thanNONE) that does not indicate any of the color buffers allocated
to the GL context by the window system, the errorINVALID OPERATION will be
generated.
If the GL is bound to a framebuffer object and DrawBuffers is supplied with a
constant from table 4.6, orCOLOR ATTACHMENTm wherem is greater than or equal
to the value of MAX COLOR ATTACHMENTS, then the error INVALID OPERATION
results.
Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequent pixel color value writes to affect the indicated buffers.
SpecifyingNONE as the draw buffer for a fragment color will inhibit that frag-
ment color from being written to any buffer.
Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
The type of context is selected at GL initialization.
The state required to handle color buffer selection for each framebuffer is
an integer for each supported fragment color. For the default framebuffer, in the
initial state the draw buffer for fragment color zero isBACK if there is a back buffer;
FRONT if there is no back buffer; and NONE no default framebuffer is associated
with the context. For framebuffer objects, in the initial state the draw buffer for
fragment color zero isCOLOR ATTACHMENT0. For both the default framebuffer and
framebuffer objects, the initial state of draw buffers for fragment colors other then
zero isNONE.
The value of the draw buffer selected for fragment colori can be queried by
calling GetIntegerv with the symbolic constantDRAW BUFFERi. DRAW BUFFER is
equivalent toDRAW BUFFER0.
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 260
4.2.2 Fine Control of Buffer Updates
Writing of bits to each of the logical framebuffers after all per-fragment operations
have been performed may be masked. The commands
void IndexMask(uint mask );
void ColorMask(boolean r,boolean g,boolean b,
boolean a );
void ColorMaski(uint buf,boolean r,boolean g,
boolean b,boolean a );
control writes to the active draw buffers.
The least signi?cantn bits of mask, wheren is the number of bits in a color
index buffer, specify a mask. Where a 1 appears in this mask, the corresponding
bit in the color index buffer (or buffers) is written; where a 0 appears, the bit is not
written. This mask applies only in color index mode.
In RGBA mode, ColorMask and ColorMaski are used to mask the writing
of R, G, B and A values to the draw buffer or buffers. ColorMaski sets the
mask for a particular draw buffer. The mask for DRAW BUFFERi is modi?ed by
passingi as the parameter buf. r, g, b, and a indicate whether R, G, B, or A values,
respectively, are written or not (a value of TRUE means that the corresponding
value is written). The mask speci?ed by r, g, b, and a is applied to the color buffer
associated with DRAW BUFFERi. If DRAW BUFFERi is one of FRONT, BACK, LEFT,
RIGHT, or FRONT AND BACK (specifying multiple color buffers) then the mask is
applied to all of the buffers.
ColorMask sets the mask for all draw buffers to the same values as speci?ed
by r, g, b, and a.
An INVALID VALUE error is generated if index is greater than the value of
MAX DRAW BUFFERS minus one.
In the initial state, all bits (in color index mode) and all color values (in RGBA
mode) are enabled for writing for all draw buffers.
The value of the color writemask for draw bufferi can be queried by calling
GetBooleani v with targetCOLOR WRITEMASK and indexi. The value of the color
writemask for draw buffer zero may also be queried by calling GetBooleanv with
valueCOLOR WRITEMASK.
The depth buffer can be enabled or disabled for writingz values using
w
void DepthMask(boolean mask );
If mask is non-zero, the depth buffer is enabled for writing; otherwise, it is disabled.
In the initial state, the depth buffer is enabled for writing.
The commands
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 261
void StencilMask(uint mask );
void StencilMaskSeparate(enum face,uint mask );
control the writing of particular bits into the stencil planes.
The least signi?cants bits of mask comprise an integer mask (s is the number
of bits in the stencil buffer), just as for IndexMask. The face parameter of Stencil-
MaskSeparate can be FRONT, BACK, or FRONT AND BACK and indicates whether
the front or back stencil mask state is affected. StencilMask sets both front and
back stencil mask state to identical values.
Fragments generated by front facing primitives use the front mask and frag-
ments generated by back facing primitives use the back mask (see section 4.1.5).
The clear operation always uses the front stencil write mask when clearing the
stencil buffer.
The state required for the various masking operations is three integers and a
bit: an integer for color indices, an integer for the front and back stencil values,
and a bit for depth values. A set of four bits is also required indicating which color
components of an RGBA value should be written. In the initial state, the integer
masks are all ones, as are the bits controlling depth value and RGBA component
writing.
Fine Control of Multisample Buffer Updates
When the value ofSAMPLE BUFFERS is one, ColorMask, DepthMask, and Sten-
cilMask or StencilMaskSeparate control the modi?cation of values in the multi-
sample buffer. The color mask has no effect on modi?cations to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffers enabled by DrawBuffer.
4.2.3 Clearing the Buffers
The GL provides a means for setting portions of every pixel in a particular buffer
to the same value. The argument to
void Clear(bitfield buf );
is the bitwise OR of a number of values indicating which buffers are
to be cleared. The values are COLOR BUFFER BIT, DEPTH BUFFER BIT,
STENCIL BUFFER BIT, andACCUM BUFFER BIT, indicating the buffers currently
enabled for color writing, the depth buffer, the stencil buffer, and the accumulation
buffer (see below), respectively. The value to which each buffer is cleared depends
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 262
on the setting of the clear value for that buffer. If the mask is not a bitwise OR of
the speci?ed values, then the errorINVALID VALUE is generated.
void ClearColor(clampf r,clampf g,clampf b,
clampf a );
sets the clear value for ?xed- and ?oating-point color buffers in RGBA mode. The
speci?ed components are stored as ?oating-point values.
The command
void ClearIndex(float index );
sets the clear color index. index is converted to a ?xed-point value with unspeci?ed
precision to the left of the binary point; the integer part of this value is then masked
m
with 2   1, wherem is the number of bits in a color index value stored in the
framebuffer.
The command
void ClearDepth(clampd d );
sets the depth value used when clearing the depth buffer. d is clamped to the
range [0; 1]. When clearing a ?xed-point depth buffer,d is converted to ?xed-point
according to the rules for a windowz value given in section 2.12.1. No conversion
is applied when clearing a ?oating-point depth buffer.
The command
void ClearStencil(int s );
takes a single integer argument that is the value to which to clear the stencil buffer.
s is masked to the number of bitplanes in the stencil buffer.
The command
void ClearAccum(float r,float g,float b,float a );
takes four ?oating-point arguments that are the values, in order, to which to set the
R, G, B, and A values of the accumulation buffer (see the next section). These
values are clamped to the range [ 1; 1] when they are speci?ed.
When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, and dithering. The masking
operations described in section 4.2.2 are also applied. If a buffer is not present,
then a Clear directed at that buffer has no effect. Fixed-point RGBA color buffers
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 263
are cleared to color values derived by clamping each component of the clear color
to [0; 1] and converting to ?xed-point according to the rules of section 2.19.9. The
result of clearing integer color buffers is unde?ned.
The state required for clearing is a clear value for each of the color buffer, the
depth buffer, the stencil buffer, and the accumulation buffer. Initially, the RGBA
color clear value is (0; 0; 0; 0), the clear color index is 0, and the stencil buffer and
accumulation buffer clear values are all 0. The depth buffer clear value is initially
1.0.
Individual buffers of the currently bound draw framebuffer may be cleared with
the command
void ClearBufferfif uigv(enum buffer,int drawbuffer,
const T *value );
where buffer and drawbuffer identify a buffer to clear, and value speci?es the value
or values to clear it to.
If buffer isCOLOR, a particular draw bufferDRAW BUFFERi is speci?ed by pass-
ing i as the parameter drawbuffer, and value points to a four-element vector spec-
ifying the R, G, B, and A color to clear that draw buffer to. If the draw buffer
is one of FRONT, BACK, LEFT, RIGHT, or FRONT AND BACK, identifying multiple
buffers, each selected buffer is cleared to the same value. The ClearBufferfv,
ClearBufferiv, and ClearBufferuiv commands should be used to clear ?xed-
and ?oating-point, signed integer, and unsigned integer color buffers respectively.
Clamping and conversion for ?xed-point color buffers are performed in the same
fashion as ClearColor.
If buffer is DEPTH, drawbuffer must be zero, and value points to the single
depth value to clear the depth buffer to. Clamping and type conversion for ?xed-
point depth buffers are performed in the same fashion as ClearDepth. Only Clear-
Bufferfv should be used to clear depth buffers.
If buffer is STENCIL, drawbuffer must be zero, and value points to the single
stencil value to clear the stencil buffer to. Masking and type conversion are
performed in the same fashion as ClearStencil. Only ClearBufferiv should be
used to clear stencil buffers.
The command
void ClearBuffer?(enum buffer,int drawbuffer,
float depth,int stencil );
clears both depth and stencil buffers of the currently bound draw framebuffer.
buffer must be DEPTH STENCIL and drawbuffer must be zero. depth and sten-
cil are the values to clear the depth and stencil buffers to, respectively. Clamping
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 264
and type conversion of depth for ?xed-point depth buffers is performed in the same
fashion as ClearDepth. Masking of stencil for stencil buffers is performed in the
same fashion as ClearStencil. ClearBuffer? is equivalent to clearing the depth
and stencil buffers separately, but may be faster when a buffer of internal format
DEPTH STENCIL is being cleared.
The result of ClearBuffer is unde?ned if no conversion between the type of
the speci?ed value and the type of the buffer being cleared is de?ned (for example,
if ClearBufferiv is called for a ?xed- or ?oating-point buffer, or if ClearBufferfv
is called for a signed or unsigned integer buffer). This is not an error.
When ClearBuffer is called, the same per-fragment and masking operations
de?ned for Clear are applied.
Errors
ClearBufferfif uigv generates anINVALID ENUM error if buffer is notCOLOR,
DEPTH, orSTENCIL. ClearBuffer? generates anINVALID ENUM error if buffer is
notDEPTH STENCIL.
ClearBuffer generates anINVALID VALUE error if buffer isCOLOR and draw-
buffer is less than zero, or greater than the value ofMAX DRAW BUFFERS minus one;
or if buffer isDEPTH,STENCIL, orDEPTH STENCIL and drawbuffer is not zero.
ClearBuffer generates anINVALID OPERATION error if buffer isCOLOR and
the GL is in color index mode.
Clearing the Multisample Buffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as speci?ed by the Clear mask bit COLOR BUFFER BIT and
the DrawBuffer mode. If the DrawBuffer mode isNONE, the color samples of the
multisample buffer cannot be cleared using Clear.
If the Clear mask bitsDEPTH BUFFER BIT orSTENCIL BUFFER BIT are set,
then the corresponding depth or stencil samples, respectively, are cleared.
The ClearBuffer commands also clear color, depth, or stencil samples of mul-
tisample buffers corresponding to the speci?ed buffer.
4.2.4 The Accumulation Buffer
Each portion of a pixel in the accumulation buffer consists of four values: one for
each of R, G, B, and A. The accumulation buffer is controlled exclusively through
the use of
void Accum(enum op,float value );
Version 3.0 (September 23, 2008)4.2. WHOLEFRAMEBUFFEROPERATIONS 265
(except for clearing it). op is a symbolic constant indicating an accumulation buffer
operation, and value is a ?oating-point value to be used in that operation. The
possible operations areACCUM,LOAD,RETURN,MULT, andADD.
When the scissor test is enabled (section 4.1.2), then only those pixels within
the current scissor box are updated by any Accum operation; otherwise, all pixels
in the window are updated. The accumulation buffer operations apply identically
to every affected pixel, so we describe the effect of each operation on an individ-
ual pixel. Accumulation buffer values are taken to be signed values in the range
[ 1; 1]. Using ACCUM obtains R, G, B, and A components from the buffer cur-
rently selected for reading (section 4.3.2). If the color buffer is ?xed-point, each
component is considered as a ?xed-point value in [0; 1] (see section 2.19.9) and is
converted to ?oating-point. Each result is then multiplied by value. The results
of this multiplication are then added to the corresponding color component cur-
rently in the accumulation buffer, and the resulting color value replaces the current
accumulation buffer color value.
The LOAD operation has the same effect as ACCUM, but the computed values
replace the corresponding accumulation buffer components rather than being added
to them.
The RETURN operation takes each color value from the accumulation buffer,
multiplies each of the R, G, B, and A components by value. If fragment color
clamping is enabled, the results are then clamped to the range [0; 1]. The result-
ing color value is placed in the buffers currently enabled for color writing as if
it were a fragment produced from rasterization, except that the only per-fragment
operations that are applied (if enabled) are the pixel ownership test, the scissor test
(section 4.1.2), and dithering (section 4.1.10). Color masking (section 4.2.2) is also
applied.
TheMULT operation multiplies each R, G, B, and A in the accumulation buffer
by value and then returns the scaled color components to their corresponding ac-
cumulation buffer locations. ADD is the same asMULT except that value is added to
each of the color components.
The color components operated on by Accum must be clamped only if the
operation is RETURN. In this case, a value sent to the enabled color buffers is ?rst
clamped to [0; 1]. Otherwise, results are unde?ned if the result of an operation on
a color component is out of the range [ 1; 1].
If there is no accumulation buffer; if the DRAW FRAMEBUFFER and
READ FRAMEBUFFER bindings (see section 4.4.4) do not refer to the same
object; or if the GL is in color index mode, Accum generates the error
INVALID OPERATION.
No state (beyond the accumulation buffer itself) is required for accumulation
buffering.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 266
4.3 Drawing, Reading, and Copying Pixels
Pixels may be written to and read from the framebuffer using the DrawPixels and
ReadPixels commands. CopyPixels can be used to copy a block of pixels from
one portion of the framebuffer to another.
4.3.1 Writing to the Stencil or Depth/Stencil Buffers
The operation of DrawPixels was described in section 3.7.4, except if the format
argument was STENCIL INDEX or DEPTH STENCIL. In this case, all operations
described for DrawPixels take place, but window (x;y) coordinates, each with
the corresponding stencil index, or depth value and stencil index, are produced in
lieu of fragments. Each coordinate-data pair is sent directly to the per-fragment
operations, bypassing the texture, fog, and antialiasing application stages of raster-
ization. Each pair is then treated as a fragment for purposes of the pixel ownership
and scissor tests; all other per-fragment operations are bypassed. Finally, each
stencil index is written to its indicated location in the framebuffer, subject to the
current front stencil mask (set with StencilMask or StencilMaskSeparate). If a
depth component is present, and the setting of DepthMask is notFALSE, it is also
written to the framebuffer; the setting of DepthTest is ignored.
The error INVALID OPERATION results if the format argument is
STENCIL INDEX and there is no stencil buffer, or if format is DEPTH STENCIL
and there is not both a depth buffer and a stencil buffer.
4.3.2 Reading Pixels
The method for reading pixels from the framebuffer and placing them in pixel pack
buffer or client memory is diagrammed in ?gure 4.2. We describe the stages of the
pixel reading process in the order in which they occur.
Initially, zero is bound for the PIXEL PACK BUFFER, indicating that image
read and query commands such as ReadPixels return pixels results into client
memory pointer parameters. However, if a non-zero buffer object is bound as the
current pixel pack buffer, then the pointer parameter is treated as an offset into the
designated buffer object.
Pixels are read using
void ReadPixels(int x,int y,sizei width,sizei height,
enum format,enum type,void *data );
The arguments after x and y to ReadPixels correspond to those of DrawPixels.
The pixel storage modes that apply to ReadPixels and other commands that query
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 267
RGBA pixel color index pixel
data in data in
convert
to float
                                                             
                                                             
                                                             
Pixel Transfer
                                                             
scale shift
                          Operations                                   
and bias and offset
                                                             
                                                             
                                                             
RGBA to RGBA index to RGBA index to index 
                                                             
lookup lookup lookup
                                                             
                                                             
                                                             
                                                             
color table 
                                                             
lookup
                                                             
                                                             
                                                             
post
convolution color table 
                                                             
color matrix
scale and bias lookup
                                                             
                                                             
                                                             
                                                             
post color table histogram
                                                             
convolution lookup
                                                             
                                                             
                                                             
color matrix minmax
                                                             
scale and bias
                                                             
                                                             
                                                             
                                                             
                                                             
convert
Pixel Storage
        RGB to L                                                     
Operations
                                                             
                                                             
                                                             
mask to
clamp
                                                             
n
to [0,1] (2 ? 1)
                                                             
                                                             
                                                             
                                                             
pack
                                                             
                                                             
byte, short, int, or float pixel
data stream (index or component)
Figure 4.2. Operation of ReadPixels. Operations in dashed boxes may be enabled
or disabled, except in the case of ”convert RGB to L”, which is only applied when
reading color data in luminosity formats. RGBA and color index pixel paths are
shown; depth and stencil pixel paths are not shown.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 268
Parameter Name Type Initial Value Valid Range
PACK SWAP BYTES boolean FALSE TRUE/FALSE
PACK LSB FIRST boolean FALSE TRUE/FALSE
PACK ROW LENGTH integer 0 [0;1)
PACK SKIP ROWS integer 0 [0;1)
PACK SKIP PIXELS integer 0 [0;1)
PACK ALIGNMENT integer 4 1,2,4,8
PACK IMAGE HEIGHT integer 0 [0;1)
PACK SKIP IMAGES integer 0 [0;1)
Table 4.7: PixelStore parameters pertaining to ReadPixels, GetColorTable, Get-
ConvolutionFilter, GetSeparableFilter, GetHistogram, GetMinmax, GetPoly-
gonStipple, and GetTexImage.
images (see section 6.1) are summarized in table 4.7.
ReadPixels generates an INVALID OPERATION error
if READ FRAMEBUFFER BINDING (see section 4.4) is non-zero, the read frame-
buffer is framebuffer complete, and the value of SAMPLE BUFFERS for the read
framebuffer is greater than zero.
Obtaining Pixels from the Framebuffer
If the format isDEPTH COMPONENT, then values are obtained from the depth buffer.
If there is no depth buffer, the errorINVALID OPERATION occurs.
If there is a multisample buffer (the value of SAMPLE BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
choose any function of the depth sample values at each pixel.
If the format is DEPTH STENCIL, then values are taken from both the depth
buffer and the stencil buffer. If there is no depth buffer or if there is no sten-
cil buffer, then the error INVALID OPERATION occurs. If the type parameter is
notUNSIGNED INT 24 8 or FLOAT 32 UNSIGNED INT 24 8 REV, then the error
INVALID ENUM occurs.
If there is a multisample buffer, then values are obtained from the depth and
stencil samples in this buffer. It is recommended that the depth and stencil values of
the centermost sample be used, though implementations may choose any function
of the depth and stencil sample values at each pixel.
If the format isSTENCIL INDEX, then values are taken from the stencil buffer;
again, if there is no stencil buffer, the errorINVALID OPERATION occurs.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 269
If there is a multisample buffer, then values are obtained from the stencil sam-
ples in this buffer. It is recommended that the stencil value of the centermost sam-
ple be used, though implementations may choose any function of the stencil sample
values at each pixel.
For all other formats, the read buffer from which values are obtained is one of
the color buffers; the selection of color buffer is controlled with ReadBuffer.
The command
void ReadBuffer(enum src );
takes a symbolic constant as argument. src must be one of the values from ta-
bles 4.4 or 4.5. Otherwise, an INVALID ENUM error is generated. Further, the
acceptable values for src depend on whether the GL is using the default frame-
buffer (i.e., READ FRAMEBUFFER BINDING is zero), or a framebuffer object (i.e.,
READ FRAMEBUFFER BINDING is non-zero). For more information about frame-
buffer objects, see section 4.4.
If the object bound to READ FRAMEBUFFER BINDING is not framebuffer
complete (as de?ned in section 4.4.4), then ReadPixels generates the error
INVALID FRAMEBUFFER OPERATION. If ReadBuffer is supplied with a constant
that is neither legal for the default framebuffer, nor legal for a framebuffer object,
then the errorINVALID ENUM results.
WhenREAD FRAMEBUFFER BINDING is zero, i.e. the default framebuffer, src
must be one of the values listed in table 4.4, including NONE. FRONT AND BACK,
FRONT, and LEFT refer to the front left buffer, BACK refers to the back left buffer,
andRIGHT refers to the front right buffer. The other constants correspond directly
to the buffers that they name. If the requested buffer is missing, then the error
INVALID OPERATION is generated. For the default framebuffer, the initial setting
for ReadBuffer isFRONT if there is no back buffer andBACK otherwise.
When the GL is using a framebuffer object, src must be one of the values listed
in table 4.5, including NONE. In a manner analogous to how the DRAW BUFFERs
state is handled, specifyingCOLOR ATTACHMENTi enables reading from the image
attached to the framebuffer atCOLOR ATTACHMENTi. For framebuffer objects, the
initial setting for ReadBuffer isCOLOR ATTACHMENT0.
ReadPixels generates an INVALID OPERATION error if it attempts to select a
color buffer whileREAD BUFFER isNONE.
ReadPixels obtains values from the selected buffer from each pixel with lower
left hand corner at (x +i;y +j) for 0  i < width and 0  j < height;
this pixel is said to be the ith pixel in the jth row. If any of these pixels lies
outside of the window allocated to the current GL context, or outside of the image
attached to the currently bound framebuffer object, then the values obtained for
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 270
those pixels are unde?ned. When READ FRAMEBUFFER BINDING is zero, values
are also unde?ned for individual pixels that are not owned by the current context.
Otherwise, ReadPixels obtains values from the selected buffer, regardless of how
those values were placed there.
If the GL is in RGBA mode, and format is one ofRED,GREEN,BLUE,ALPHA,
RG, RGB, RGBA, BGR, BGRA, LUMINANCE, or LUMINANCE ALPHA, then red, green,
blue, and alpha values are obtained from the selected buffer at each pixel loca-
tion. If the framebuffer does not support alpha values then the A that is obtained
is 1.0. If format is COLOR INDEX and the GL is in RGBA mode then the error
INVALID OPERATION occurs. If the GL is in color index mode, and format is not
DEPTH COMPONENT, DEPTH STENCIL, orSTENCIL INDEX, then the color index
is obtained at each pixel location.
If format is an integer format and the color buffer is not an integer format;
if the color buffer is an integer format and format is not an integer format; or
if format is an integer format and type is FLOAT or HALF FLOAT, the error
INVALID OPERATION occurs.
When READ FRAMEBUFFER BINDING is non-zero, the red, green, blue, and
alpha values are obtained by ?rst reading the internal component values of the
corresponding value in the image attached to the selected logical buffer. Inter-
nal components are converted to an RGBA color by taking each R, G, B, and A
component present according to the base internal format of the buffer (as shown
in table 3.15). If G, B, or A values are not present in the internal format, they are
taken to be zero, zero, and one respectively.
Conversion of RGBA values
This step applies only if the GL is in RGBA mode, and then only if format is not
STENCIL INDEX, DEPTH COMPONENT, or DEPTH STENCIL. The R, G, B, and A
values form a group of elements. For a ?xed-point color buffer, each element is
taken to be a ?xed-point value in [0; 1] withm bits, wherem is the number of bits
in the corresponding color component of the selected buffer (see section 2.19.9).
For an integer or ?oating-point color buffer, the elements are unmodi?ed.
Conversion of Depth values
This step applies only if format is DEPTH COMPONENT or DEPTH STENCIL and
the depth buffer uses a ?xed-point representation. An element is taken to be a
?xed-point value in [0; 1] withm bits, wherem is the number of bits in the depth
buffer (see section 2.12.1). No conversion is necessary if the depth buffer uses a
?oating-point representation.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 271
Pixel Transfer Operations
This step is actually the sequence of steps that was described separately in sec-
tion 3.7.5. After the processing described in that section is completed, groups are
processed as described in the following sections.
Conversion to L
This step applies only to RGBA component groups. If the format is either
LUMINANCE orLUMINANCE ALPHA, a value L is computed as
L =R +G +B
where R, G, and B are the values of the R, G, and B components. The single
computed L component replaces the R, G, and B components in the group.
Final Conversion
For an index, if the type is not FLOAT or HALF FLOAT, ?nal conversion consists
of masking the index with the value given in table 4.8; if the type is FLOAT or
HALF FLOAT, then the integer index is converted to a GLfloat orhalf, data
value.
For a ?oating-point RGBA color, if type is not one of
FLOAT, UNSIGNED INT 5 9 9 9 REV, or UNSIGNED INT 10F 11F 11F REV; if
CLAMP READ COLOR is TRUE; or if CLAMP READ COLOR is FIXED ONLY and the
selected color buffer is a ?xed-point buffer, each component is ?rst clamped to
[0; 1]. Then the appropriate conversion formula from table 4.9 is applied to the
component.
In the special case of calling ReadPixels with type of
UNSIGNED INT 10F 11F 11F REV and format ofRGB, conversion is performed as
follows: the returned data are packed into a series ofuint values. The red, green,
and blue components are converted to unsigned 11-bit ?oating-point, unsigned 11-
bit ?oating-point, and unsigned 10-bit ?oating point as described in sections 2.1.3
and 2.1.4. The resulting red 11 bits, green 11 bits, and blue 10 bits are then packed
as the 1st, 2nd, and 3rd components of the UNSIGNED INT 10F 11F 11F REV
format as shown in table 3.11.
In the special case of calling ReadPixels with type
of UNSIGNED INT 5 9 9 9 REV and format RGB, the conversion is performed as
follows: the returned data are packed into a series ofuint values. The red, green,
and blue components are converted tored ,green ,blue , andexp integers
s s s
shared
as described in section 3.9.1 when internalformat is RGB9 E5. Thered ,green ,
s s
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 272
type Parameter Index Mask
8
UNSIGNED BYTE 2   1
BITMAP 1
7
BYTE 2   1
16
UNSIGNED SHORT 2   1
15
SHORT 2   1
32
UNSIGNED INT 2   1
31
INT 2   1
8
UNSIGNED INT 24 8 2   1
8
FLOAT 32 UNSIGNED INT 24 8 REV 2   1
Table 4.8: Index masks used by ReadPixels. Floating point data are not masked.
blue , andexp are then packed as the 1st, 2nd, 3rd, and 4th components of
s shared
theUNSIGNED INT 5 9 9 9 REV format as shown in table 3.11.
For an integer RGBA color, each component is clamped to the representable
range of type.
Placement in Pixel Pack Buffer or Client Memory
If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), data is an offset into the pixel pack buffer and
the pixels are packed into the buffer relative to this offset; otherwise, data is a
pointer to a block client memory and the pixels are packed into the client memory
relative to the pointer. If a pixel pack buffer object is bound and packing the pixel
data according to the pixel pack storage state would access memory beyond the size
of the pixel pack buffer’s memory size, an INVALID OPERATION error results. If
a pixel pack buffer object is bound and data is not evenly divisible by the number
of basic machine units needed to store in memory the corresponding GL data type
from table 3.5 for the type parameter, anINVALID OPERATION error results.
Groups of elements are placed in memory just as they are taken from memory
for DrawPixels. That is, theith group of thejth row (corresponding to theith pixel
in thejth row) is placed in memory just where theith group of thejth row would
be taken from for DrawPixels. See Unpacking under section 3.7.4. The only
difference is that the storage mode parameters whose names begin withPACK are
used instead of those whose names begin with UNPACK . If the format is RED,
GREEN, BLUE, ALPHA, or LUMINANCE, only the corresponding single element is
written. Likewise if the format is RG, LUMINANCE ALPHA, RGB, or BGR, only the
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 273
type Parameter GL Data Type Component
Conversion Formula
8
UNSIGNED BYTE ubyte c = (2   1)f
8
(2 1)f 1
BYTE byte c =
2
16
UNSIGNED SHORT ushort c = (2   1)f
16
(2  1)f 1
SHORT short c =
2
32
UNSIGNED INT uint c = (2   1)f
32
(2  1)f 1
INT int c =
2
HALF FLOAT half c =f
FLOAT float c =f
N
UNSIGNED BYTE 3 3 2 ubyte c = (2   1)f
N
UNSIGNED BYTE 2 3 3 REV ubyte c = (2   1)f
N
UNSIGNED SHORT 5 6 5 ushort c = (2   1)f
N
UNSIGNED SHORT 5 6 5 REV ushort c = (2   1)f
N
UNSIGNED SHORT 4 4 4 4 ushort c = (2   1)f
N
UNSIGNED SHORT 4 4 4 4 REV ushort c = (2   1)f
N
UNSIGNED SHORT 5 5 5 1 ushort c = (2   1)f
N
UNSIGNED SHORT 1 5 5 5 REV ushort c = (2   1)f
N
UNSIGNED INT 8 8 8 8 uint c = (2   1)f
N
UNSIGNED INT 8 8 8 8 REV uint c = (2   1)f
N
UNSIGNED INT 10 10 10 2 uint c = (2   1)f
N
UNSIGNED INT 2 10 10 10 REV uint c = (2   1)f
N
UNSIGNED INT 24 8 uint c = (2   1)f
UNSIGNED INT 10F 11F 11F REV uint Special
UNSIGNED INT 5 9 9 9 REV uint Special
FLOAT 32 UNSIGNED INT 24 8 REV float c =f (depth only)
Table 4.9: Reversed component conversions, used when component data are being
returned to client memory. Color, normal, and depth components are converted
from the internal ?oating-point representation (f) to a datum of the speci?ed GL
data type (c) using the speci?ed equation. All arithmetic is done in the internal
?oating point format. These conversions apply to component data returned by GL
query commands and to components of pixel data returned to client memory. The
equations remain the same even if the implemented ranges of the GL data types are
greater than the minimum required ranges. (See table 2.2.) Equations withN as
the exponent are performed for each bit?eld of the packed data type, withN set to
the number of bits in the bit?eld.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 274
corresponding two or three elements are written. Otherwise all the elements of
each group are written.
4.3.3 Copying Pixels
The command
void CopyPixels(int x,int y,sizei width,sizei height,
enum type );
transfers a rectangle of pixel values from one region of the read framebuffer to
another in the draw framebuffer. Pixel copying is diagrammed in ?gure 4.3.
type is a symbolic constant that must be one of COLOR, STENCIL, DEPTH, or
DEPTH STENCIL, indicating that the values to be transferred are colors, stencil
values, depth values, or depth/stencil values, respectively. The ?rst four arguments
have the same interpretation as the corresponding arguments to ReadPixels.
Values are obtained from the framebuffer, converted (if appropriate), then sub-
jected to the pixel transfer operations described in section 3.7.5, just as if Read-
Pixels were called with the corresponding arguments. If the type is STENCIL
or DEPTH, then it is as if the format for ReadPixels were STENCIL INDEX or
DEPTH COMPONENT, respectively. If the type is DEPTH STENCIL, then it is as
if the format for ReadPixels were speci?ed as described in table 4.10. If the type
isCOLOR, then if the GL is in RGBA mode, it is as if the format wereRGBA, while
if the GL is in color index mode, it is as if the format wereCOLOR INDEX.
The groups of elements so obtained are then written to the framebuffer just as
if DrawPixels had been givenwidth andheight, beginning with ?nal conversion
of elements. The effective format is the same as that already described.
Finally, the behavior of several GL operations is speci?ed as if the argu-
ments were passed to CopyPixels. These operations include CopyTexImage*,
CopyTexSubImage*, CopyColorTable, CopyColorSubTable, and CopyConvo-
lutionFilter*. An INVALID FRAMEBUFFER OPERATION error will be generated
if an attempt is made to execute one of these operations, or CopyPixels, while
the object bound toREAD FRAMEBUFFER BINDING (see section 4.4) is not frame-
buffer complete (as de?ned in section 4.4.4). AnINVALID OPERATION error will
be generated if the object bound toREAD FRAMEBUFFER BINDING is framebuffer
complete and the value ofSAMPLE BUFFERS is greater than zero.
CopyPixels will generate anINVALID FRAMEBUFFER OPERATION error if the
object bound toDRAW FRAMEBUFFER BINDING (see section 4.4) is not framebuffer
complete.
If the read buffer contains integer or unsigned integer components, an
INVALID OPERATION error is generated.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 275
RGBA pixel color index pixel
data from framebuffer data from framebuffer
convert
to float
                                                             
                                                             
                        Pixel Transfer                                     
scale shift
                                                             
Operations
and bias and offset
                                                             
                                                             
                                                             
RGBA to RGBA index to RGBA index to index 
                                                             
lookup lookup lookup
                                                             
                                                             
                                                             
                                                             
color table 
                                                             
lookup
                                                             
                                                             
                                                             
post
convolution color table 
                                                             
color matrix
scale and bias lookup
                                                             
                                                             
                                                             
                                                             
post
color table histogram
                                                             
convolution
lookup
                                                             
                                                             
                                                             
color matrix minmax
                                                             
scale and bias
                                                             
                                                             
mask to
final
clamp
n
conversion
to [0,1] (2 ? 1)
RGBA pixel color index pixel
data out data out
Figure 4.3. Operation of CopyPixels. Operations in dashed boxes may be enabled
or disabled. Index-to-RGBA lookup is currently never performed. RGBA and color
index pixel paths are shown; depth and stencil pixel paths are not shown.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 276
DEPTH BITS STENCIL BITS format
zero zero DEPTH STENCIL
zero non-zero DEPTH COMPONENT
non-zero zero STENCIL INDEX
non-zero non-zero DEPTH STENCIL
Table 4.10: Effective ReadPixels format forDEPTH STENCIL CopyPixels opera-
tion.
Blitting Pixel Rectangles
The command
void BlitFramebuffer(int srcX0,int srcY0,int srcX1,
int srcY1,int dstX0,int dstY0,int dstX1,int dstY1,
bitfield mask,enum ?lter );
transfers a rectangle of pixel values from one region of the read framebuffer to an-
other in the draw framebuffer. There are some important distinctions from Copy-
Pixels, as described below.
mask is the bitwise OR of a number of values indicating which buffers are
to be copied. The values are COLOR BUFFER BIT, DEPTH BUFFER BIT, and
STENCIL BUFFER BIT, which are described in section 4.2.3. The pixels corre-
sponding to these buffers are copied from the source rectangle bounded by the lo-
cations (srcX0;srcY 0) and (srcX1;srcY 1) to the destination rectangle bounded
by the locations (dstX0;dstY 0) and (dstX1;dstY 1). The lower bounds of the
rectangle are inclusive, while the upper bounds are exclusive.
When the color buffer is transferred, values are taken from the read buffer of the
read framebuffer and written to each of the draw buffers of the draw framebuffer,
just as with CopyPixels.
The actual region taken from the read framebuffer is limited to the intersection
of the source buffers being transferred, which may include the color buffer selected
by the read buffer, the depth buffer, and/or the stencil buffer depending on mask.
The actual region written to the draw framebuffer is limited to the intersection of
the destination buffers being written, which may include multiple draw buffers,
the depth buffer, and/or the stencil buffer depending on mask. Whether or not the
source or destination regions are altered due to these limits, the scaling and offset
applied to pixels being transferred is performed as though no such limits were
present.
Version 3.0 (September 23, 2008)4.3. DRAWING,READING,ANDCOPYINGPIXELS 277
If the source and destination rectangle dimensions do not match, the source
image is stretched to ?t the destination rectangle. ?lter must be LINEAR or
NEAREST, and speci?es the method of interpolation to be applied if the image is
stretched. LINEAR ?ltering is allowed only for the color buffer; if mask includes
DEPTH BUFFER BIT orSTENCIL BUFFER BIT, and ?lter is notNEAREST, no copy
is performed and an INVALID OPERATION error is generated. If the source and
destination dimensions are identical, no ?ltering is applied. If either the source or
destination rectangle speci?es a negative width or height (X1<X0 orY 1<Y 0),
the image is reversed in the corresponding direction. If both the source and des-
tination rectangles specify a negative width or height for the same direction, no
reversal is performed. If a linear ?lter is selected and the rules of LINEAR sam-
pling would require sampling outside the bounds of a source buffer, it is as though
CLAMP TO EDGE texture sampling were being performed. If a linear ?lter is se-
lected and sampling would be required outside the bounds of the speci?ed source
region, but within the bounds of a source buffer, the implementation may choose
to clamp while sampling or not.
If the source and destination buffers are identical, and the source and destina-
tion rectangles overlap, the result of the blit operation is unde?ned.
Blit operations bypass the fragment pipeline. The only fragment operations
which affect a blit are the pixel ownership test and the scissor test.
If a buffer is speci?ed in mask and does not exist in both the read and draw
framebuffers, the corresponding bit is silently ignored.
If the color formats of the read and draw buffers do not match, and mask in-
cludes COLOR BUFFER BIT, pixel groups are converted to match the destination
format as in CopyPixels. However, no pixel transfer operations are applied,
and clamping behaves as if CLAMP FRAGMENT COLOR is set to FIXED ONLY. For-
mat conversion is not supported for all data types. If the read buffer contains
?oating-point values and any draw buffer does not contain ?oating-point values,
or if the read buffer contains non-?oating-point values and any draw buffer con-
tains ?oating-point values, anINVALID OPERATION error is generated.
Calling BlitFramebuffer will result in an
INVALID FRAMEBUFFER OPERATION error if the objects bound to
DRAW FRAMEBUFFER BINDING and READ FRAMEBUFFER BINDING are not
framebuffer complete (section 4.4.4).
Calling BlitFramebuffer will result in anINVALID OPERATION error if mask
includes DEPTH BUFFER BIT or STENCIL BUFFER BIT, and the source and des-
tination depth and stencil buffer formats do not match.
If SAMPLE BUFFERS for the read framebuffer is greater than zero and
SAMPLE BUFFERS for the draw framebuffer is zero, the samples corresponding
to each pixel location in the source are converted to a single sample before being
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 278
written to the destination.
If SAMPLE BUFFERS for the read framebuffer is zero and SAMPLE BUFFERS
for the draw framebuffer is greater than zero, the value of the source sample is
replicated in each of the destination samples.
If SAMPLE BUFFERS for either the read framebuffer or draw framebuffer is
greater than zero, no copy is performed and anINVALID OPERATION error is gen-
erated if the dimensions of the source and destination rectangles provided to Blit-
Framebuffer are not identical, if the formats of the read and draw framebuffers
are not identical, or if the values ofSAMPLES for the read and draw buffers are not
identical.
If SAMPLE BUFFERS for both the read and draw framebuffers are greater than
zero, and the values ofSAMPLES for the read and draw framebuffers are identical,
the samples are copied without modi?cation from the read framebuffer to the draw
framebuffer. Otherwise, no copy is performed and anINVALID OPERATION error
is generated. Note that the samples in the draw buffer are not guaranteed to be at
the same sample location as the read buffer, so rendering using this newly created
buffer can potentially have geometry cracks or incorrect antialiasing. This may
occur if the sizes of the framebuffers do not match, if the formats differ, or if
the source and destination rectangles are not de?ned with the same (X0;Y 0) and
(X1;Y 1) bounds.
4.3.4 Pixel Draw/Read State
The state required for pixel operations consists of the parameters that are set with
PixelStore, PixelTransfer, and PixelMap. This state has been summarized in
tables 3.1, 3.2, and 3.3. Additional state includes the current raster position (sec-
tion 2.18), an integer indicating the current setting of ReadBuffer, and a three-
valued integer controlling clamping during ?nal conversion. For the default
framebuffer, in the initial state the read buffer is BACK if there is a back buffer;
FRONT if there is no back buffer; andNONE if no default framebuffer is associated
with the context. The initial value of read color clamping is FIXED ONLY. State
set with PixelStore is GL client state.
4.4 Framebuffer Objects
As described in chapter 1 and section 2.1, the GL renders into (and reads values
from) a framebuffer. GL de?nes two classes of framebuffers: window system-
provided and application-created.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 279
Initially, the GL uses the default framebuffer. The storage, dimensions, allo-
cation, and format of the images attached to this framebuffer are managed entirely
by the window system. Consequently, the state of the default framebuffer, includ-
ing its images, can not be changed by the GL, nor can the default framebuffer be
deleted by the GL.
The routines described in the following sections, however, can be used to cre-
ate, destroy, and modify the state and attachments of framebuffer objects.
Framebuffer objects encapsulate the state of a framebuffer in a similar man-
ner to the way texture objects encapsulate the state of a texture. In particular, a
framebuffer object encapsulates state necessary to describe a collection of color,
depth, and stencil logical buffers (accumulation and auxiliary buffers are not al-
lowed). For each logical buffer, a framebuffer-attachable image can be attached
to the framebuffer to store the rendered output for that logical buffer. Examples
of framebuffer-attachable images include texture images and renderbuffer images.
Renderbuffers are described further in section 4.4.2
By allowing the images of a renderbuffer to be attached to a framebuffer, the
GL provides a mechanism to support off-screen rendering. Further, by allowing the
images of a texture to be attached to a framebuffer, the GL provides a mechanism
to support render to texture.
4.4.1 Binding and Managing Framebuffer Objects
The default framebuffer for rendering and readback operations is provided by the
window system. In addition, named framebuffer objects can be created and oper-
ated upon. The namespace for framebuffer objects is the unsigned integers, with
zero reserved by the GL for the default framebuffer.
A framebuffer object is created by binding a name returned by GenFrame-
buffers (see below) toDRAW FRAMEBUFFER orREAD FRAMEBUFFER. The binding
is effected by calling
void BindFramebuffer(enum target,uint framebuffer );
with target set to the desired framebuffer target and framebuffer set to the frame-
buffer object name. The resulting framebuffer object is a new state vector, com-
prising all the state values listed in table 6.28, as well as one set of the state values
listed in table 6.29 for each attachment point of the framebuffer, set to the same
initial values. There are MAX COLOR ATTACHMENTS color attachment points, plus
one each for the depth and stencil attachment points.
BindFramebuffer may also be used to bind an existing framebuffer object
to DRAW FRAMEBUFFER and/or READ FRAMEBUFFER. If the bind is successful no
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 280
change is made to the state of the bound framebuffer object, and any previous
binding to target is broken.
BindFramebuffer fails and an INVALID OPERATION error is generated if
framebuffer is not zero or a name returned from a previous call to GenFrame-
buffers, or if such a name has since been deleted with DeleteFramebuffers.
If a framebuffer object is bound to DRAW FRAMEBUFFER or
READ FRAMEBUFFER, it becomes the target for rendering or readback op-
erations, respectively, until it is deleted or another framebuffer is bound to
the corresponding bind point. Calling BindFramebuffer with target set to
FRAMEBUFFER binds framebuffer to both the draw and read targets.
While a framebuffer object is bound, GL operations on the target to which it
is bound affect the images attached to the bound framebuffer object, and queries
of the target to which it is bound return state from the bound object. Queries of
the values speci?ed in tables 6.51 and 6.31 are derived from the framebuffer object
bound toDRAW FRAMEBUFFER.
The initial state ofDRAW FRAMEBUFFER andREAD FRAMEBUFFER refers to the
default framebuffer. In order that access to the default framebuffer is not lost, it is
treated as a framebuffer object with the name of zero. The default framebuffer
is therefore rendered to and read from while zero is bound to the corresponding
targets. On some implementations, the properties of the default framebuffer can
change over time (e.g., in response to window system events such as attaching the
context to a new window system drawable.)
Framebuffer objects (those with a non-zero name) differ from the default
framebuffer in a few important ways. First and foremost, unlike the default frame-
buffer, framebuffer objects have modi?able attachment points for each logical
buffer in the framebuffer. Framebuffer-attachable images can be attached to and
detached from these attachment points, which are described further in section 4.4.2.
Also, the size and format of the images attached to framebuffer objectss are con-
trolled entirely within the GL interface, and are not affected by window system
events, such as pixel format selection, window resizes, and display mode changes.
Additionally, when rendering to or reading from an application created-
framebuffer object,
 The pixel ownership test always succeeds. In other words, framebuffer ob-
jects own all of their pixels.
 There are no visible color buffer bitplanes. This means there is no color
buffer corresponding to the back, front, left, or right color bitplanes.
 The only color buffer bitplanes are the ones de?ned by the frame-
buffer attachment points named COLOR ATTACHMENT0 through
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 281
COLOR ATTACHMENTn.
 The only depth buffer bitplanes are the ones de?ned by the framebuffer at-
tachment pointDEPTH ATTACHMENT.
 The only stencil buffer bitplanes are the ones de?ned by the framebuffer
attachment pointSTENCIL ATTACHMENT.
 There are no accumulation buffer bitplanes, so the value of
the implementation-dependent state variables ACCUM RED BITS,
ACCUM GREEN BITS, ACCUM BLUE BITS, and ACCUM ALPHA BITS
are all zero.
 There are no AUX buffer bitplanes, so the value of the implementation-
dependent state variableAUX BUFFERS is zero.
 If the attachment sizes are not all identical, rendering will be limited to the
largest area that can ?t in all of the attachments (an intersection of rectangles
having a lower left of (0; 0) and an upper right of (width;height) for each
attachment).
 If the attachment sizes are not all identical, the values of pixels outside the
common intersection area after rendering are unde?ned.
Framebuffer objects are deleted by calling
void DeleteFramebuffers(sizei n,uint *framebuffers );
framebuffers contains n names of framebuffer objects to be deleted. After a
framebuffer object is deleted, it has no attachments, and its name is again un-
used. If a framebuffer that is currently bound to one or more of the targets
DRAW FRAMEBUFFER or READ FRAMEBUFFER is deleted, it is as though Bind-
Framebuffer had been executed with the corresponding target and framebuffer
zero. Unused names in framebuffers are silently ignored, as is the value zero.
The command
void GenFramebuffers(sizei n,uint *ids );
returns n previously unused framebuffer object names in ids. These names are
marked as used, for the purposes of GenFramebuffers only, but they acquire state
and type only when they are ?rst bound, just as if they were unused.
The names bound to the draw and read framebuffer bindings can be queried by
calling GetIntegerv with the symbolic constants DRAW FRAMEBUFFER BINDING
and READ FRAMEBUFFER BINDING, respectively. FRAMEBUFFER BINDING is
equivalent toDRAW FRAMEBUFFER BINDING.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 282
4.4.2 Attaching Images to Framebuffer Objects
Framebuffer-attachable images may be attached to, and detached from, framebuffer
objects. In contrast, the image attachments of the default framebuffer may not be
changed by the GL.
A single framebuffer-attachable image may be attached to multiple framebuffer
objects, potentially avoiding some data copies, and possibly decreasing memory
consumption.
For each logical buffer, a framebuffer object stores a set of state which de?nes
the logical buffer’s attachment point. The attachment point state contains enough
information to identify the single image attached to the attachment point, or to
indicate that no image is attached. The per-logical buffer attachment point state is
listed in table 6.29
There are two types of framebuffer-attachable images: the image of a render-
buffer object, and an image of a texture object.
Renderbuffer Objects
A renderbuffer is a data storage object containing a single image of a renderable
internal format. GL provides the methods described below to allocate and delete a
renderbuffer’s image, and to attach a renderbuffer’s image to a framebuffer object.
The name space for renderbuffer objects is the unsigned integers, with zero
reserved for the GL. A renderbuffer object is created by binding a name returned
by GenRenderbuffers (see below) toRENDERBUFFER. The binding is effected by
calling
void BindRenderbuffer(enum target,uint renderbuffer );
with target set to RENDERBUFFER and renderbuffer set to the renderbuffer object
name. If renderbuffer is not zero, then the resulting renderbuffer object is a new
state vector, initialized with a zero-sized memory buffer, and comprising the state
values listed in table 6.31. Any previous binding to target is broken.
BindRenderbuffer may also be used to bind an existing renderbuffer object.
If the bind is successful, no change is made to the state of the newly bound render-
buffer object, and any previous binding to target is broken.
While a renderbuffer object is bound, GL operations on the target to which it
is bound affect the bound renderbuffer object, and queries of the target to which a
renderbuffer object is bound return state from the bound object.
The name zero is reserved. A renderbuffer object cannot be created with the
name zero. If renderbuffer is zero, then any previous binding to target is broken
and the target binding is restored to the initial state.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 283
In the initial state, the reserved name zero is bound toRENDERBUFFER. There is
no renderbuffer object corresponding to the name zero, so client attempts to modify
or query renderbuffer state for the targetRENDERBUFFER while zero is bound will
generate GL errors, as described in section 6.1.3.
The current RENDERBUFFER binding can be determined by calling GetInte-
gerv with the symbolic constantRENDERBUFFER BINDING.
BindRenderbuffer fails and an INVALID OPERATION error is generated if
renderbuffer is not a name returned from a previous call to GenRenderbuffers, or
if such a name has since been deleted with DeleteRenderbuffers.
Renderbuffer objects are deleted by calling
void DeleteRenderbuffers(sizei n,const
uint *renderbuffers );
where renderbuffers contains n names of renderbuffer objects to be deleted. After
a renderbuffer object is deleted, it has no contents, and its name is again unused. If
a renderbuffer that is currently bound toRENDERBUFFER is deleted, it is as though
BindRenderbuffer had been executed with the target RENDERBUFFER and name
of zero. Additionally, special care must be taken when deleting a renderbuffer if
the image of the renderbuffer is attached to a framebuffer object (see section 4.4.2).
Unused names in renderbuffers are silently ignored, as is the value zero.
The command
void GenRenderbuffers(sizei n,uint *renderbuffers );
returns n previously unused renderbuffer object names in renderbuffers. These
names are marked as used, for the purposes of GenRenderbuffers only, but they
acquire renderbuffer state only when they are ?rst bound, just as if they were un-
used.
The command
void RenderbufferStorageMultisample(enum target,
sizei samples,enum internalformat,sizei width,
sizei height );
establishes the data storage, format, dimensions, and number of samples of a ren-
derbuffer object’s image. target must be RENDERBUFFER. internalformat must
be color-renderable, depth-renderable, or stencil-renderable (as de?ned in sec-
tion 4.4.4). width and height are the dimensions in pixels of the renderbuffer. If
either width or height is greater than MAX RENDERBUFFER SIZE, or if samples is
greater thanMAX SAMPLES, then the errorINVALID VALUE is generated. If the GL
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 284
Sized Base S
Internal Format Internal Format bits
STENCIL INDEX1 STENCIL INDEX 1
STENCIL INDEX4 STENCIL INDEX 4
STENCIL INDEX8 STENCIL INDEX 8
STENCIL INDEX16 STENCIL INDEX 16
Table 4.11: Correspondence of sized internal formats to base internal formats for
formats that can be used only with renderbuffers.
is unable to create a data store of the requested size, the error OUT OF MEMORY is
generated.
Upon success, RenderbufferStorageMultisample deletes any existing data
store for the renderbuffer image and the contents
of the data store after calling RenderbufferStorageMultisample are unde?ned.
RENDERBUFFER WIDTH is set to width, RENDERBUFFER HEIGHT is set to height,
andRENDERBUFFER INTERNAL FORMAT is set to internalformat.
If samples is zero, then RENDERBUFFER SAMPLES is set to zero. Otherwise
samples represents a request for a desired minimum number of samples. Since dif-
ferent implementations may support different sample counts for multisampled ren-
dering, the actual number of samples allocated for the renderbuffer image is imple-
mentation dependent. However, the resulting value forRENDERBUFFER SAMPLES
is guaranteed to be greater than or equal to samples and no more than the next
larger sample count supported by the implementation.
A GL implementation may vary its allocation of internal component resolution
based on any RenderbufferStorage parameter (except target), but the allocation
and chosen internal format must not be a function of any other state and cannot be
changed once they are established.
The command
void RenderbufferStorage(enum target,enum internalformat,
sizei width,sizei height );
is equivalent to calling RenderbufferStorageMultisample with samples equal to
zero.
Required Renderbuffer Formats
Implementations are required to support the same internal formats for renderbuffers
as the required formats for textures enumerated in section 3.9.1, with the exception
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 285
of the color formats labelled “texture-only”. Requesting one of these internal for-
mats for a renderbuffer will allocate exactly the internal component sizes and types
shown for that format in tables 3.16- 3.18.
Implementations must support creation of renderbuffers in these required for-
mats with up to the value ofMAX SAMPLES multisamples.
Attaching Renderbuffer Images to a Framebuffer
A renderbuffer can be attached as one of the logical buffers of the currently bound
framebuffer object by calling
void FramebufferRenderbuffer(enum target,
enum attachment,enum renderbuffertarget,
uint renderbuffer );
target must be DRAW FRAMEBUFFER, READ FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW FRAMEBUFFER. An INVALID OPERATION
error is generated if the value of the corresponding binding is zero. attachment
should be set to one of the attachment points of the framebuffer listed in table 4.12.
renderbuffertarget must be RENDERBUFFER and renderbuffer should be set to
the name of the renderbuffer object to be attached to the framebuffer. render-
buffer must be either zero or the name of an existing renderbuffer object of type
renderbuffertarget, otherwise an INVALID OPERATION error is generated. If ren-
derbuffer is zero, then the value of renderbuffertarget is ignored.
If renderbuffer is not zero and if FramebufferRenderbuffer is success-
ful, then the renderbuffer named renderbuffer will be used as the logi-
cal buffer identi?ed by attachment of the framebuffer currently bound to
target. The value of FRAMEBUFFER ATTACHMENT OBJECT TYPE for the
speci?ed attachment point is set to RENDERBUFFER and the value of
FRAMEBUFFER ATTACHMENT OBJECT NAME is set to renderbuffer. All other state
values of the attachment point speci?ed by attachment are set to their default values
listed in table 6.29. No change is made to the state of the renderbuffer object and
any previous attachment to the attachment logical buffer of the framebuffer object
bound to framebuffer target is broken. If the attachment is not successful, then
no change is made to the state of either the renderbuffer object or the framebuffer
object.
Calling FramebufferRenderbuffer with the renderbuffer name zero will de-
tach the image, if any, identi?ed by attachment, in the framebuffer currently bound
to target. All state values of the attachment point speci?ed by attachment in the
object bound to target are set to their default values listed in table 6.29.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 286
Setting attachment to the value DEPTH STENCIL ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to renderbuffer, which should have base internal formatDEPTH STENCIL.
If a renderbuffer object is deleted while its image is attached to one or more
attachment points in the currently bound framebuffer, then it is as if Framebuf-
ferRenderbuffer had been called, with a renderbuffer of 0, for each attachment
point to which this image was attached in the currently bound framebuffer. In
other words, this renderbuffer image is ?rst detached from all attachment points in
the currently bound framebuffer. Note that the renderbuffer image is speci?cally
not detached from any non-bound framebuffers. Detaching the image from any
non-bound framebuffers is the responsibility of the application.
Name of attachment
COLOR ATTACHMENTi (see caption)
DEPTH ATTACHMENT
STENCIL ATTACHMENT
DEPTH STENCIL ATTACHMENT
Table 4.12: Framebuffer attachment points. i in COLOR ATTACHMENTi may range
from zero to the value ofMAX COLOR ATTACHMENTS - 1.
Attaching Texture Images to a Framebuffer
GL supports copying the rendered contents of the framebuffer into the images of
a texture object through the use of the routines CopyTexImage* and CopyTex-
SubImage*. Additionally, GL supports rendering directly into the images of a
texture object.
To render directly into a texture image, a speci?ed image from a texture object
can be attached as one of the logical buffers of the currently bound framebuffer ob-
ject by calling one of the following routines, depending on the type of the texture:
void FramebufferTexture1D(enum target,enum attachment,
enum textarget,uint texture,int level );
void FramebufferTexture2D(enum target,enum attachment,
enum textarget,uint texture,int level );
void FramebufferTexture3D(enum target,enum attachment,
enum textarget,uint texture,int level,int layer );
In all three routines, target must be
DRAW FRAMEBUFFER, READ FRAMEBUFFER, orFRAMEBUFFER.FRAMEBUFFER is
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 287
equivalent to DRAW FRAMEBUFFER. An INVALID OPERATION error is generated
if the value of the corresponding binding is zero. attachment must be one of the
attachment points of the framebuffer listed in table 4.12.
If texture is zero, the image identi?ed by attachment, if any, will be detached
from the framebuffer currently bound to target. textarget, level, and layer are
ignored. All state values of the attachment point speci?ed by attachment are set to
their default values listed in table 6.29.
If texture is not zero, then texture must either name an existing texture
object with an target of textarget, or texture must name an existing cube
map texture and textarget must be one of TEXTURE CUBE MAP POSITIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP POSITIVE Z,
TEXTURE CUBE MAP NEGATIVE X, TEXTURE CUBE MAP NEGATIVE Y, or
TEXTURE CUBE MAP NEGATIVE Z. Otherwise, an INVALID OPERATION error is
generated.
level speci?es the mipmap level of the texture image to be attached to the
framebuffer.
If textarget is TEXTURE 3D, then level must be greater than or equal to zero
and less than or equal tolog of the value ofMAX 3D TEXTURE SIZE. If textarget
2
is one of TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP POSITIVE Z, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP NEGATIVE Y, or TEXTURE CUBE MAP NEGATIVE Z, then
level must be greater than or equal to zero and less than or equal to log of the
2
value of MAX CUBE MAP TEXTURE SIZE. For all other values of textarget, level
must be greater than or equal to zero and no larger than log of the value of
2
MAX TEXTURE SIZE. Otherwise, anINVALID VALUE error is generated.
layer speci?es the layer of a 2-dimensional image within a 3-dimensional tex-
ture. An INVALID VALUE error is generated if layer is larger than the value of
MAX 3D TEXTURE SIZE-1.
For FramebufferTexture1D, if texture is not zero, then textarget must be
TEXTURE 1D.
For FramebufferTexture2D, if texture is not zero, then textarget must be one
of TEXTURE 2D, TEXTURE CUBE MAP POSITIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP POSITIVE Z,
TEXTURE CUBE MAP NEGATIVE X, TEXTURE CUBE MAP NEGATIVE Y, or
TEXTURE CUBE MAP NEGATIVE Z.
For FramebufferTexture3D, if texture is not zero, then textarget must be
TEXTURE 3D.
If texture is not zero, and if FramebufferTexture* is success-
ful, then the speci?ed texture image will be used as the logical buffer
identi?ed by attachment of the framebuffer currently bound to tar-
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 288
get. The value of FRAMEBUFFER ATTACHMENT OBJECT TYPE for
the speci?ed attachment point is set to TEXTURE and the value of
FRAMEBUFFER ATTACHMENT OBJECT NAME is set to texture. Additionally,
the value of FRAMEBUFFER ATTACHMENT TEXTURE LEVEL for the named at-
tachment point is set to level. If texture is a cube map texture, then the value
of FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE for the named at-
tachment point is set to textarget. If texture is a 3D texture, then the value of
FRAMEBUFFER ATTACHMENT TEXTURE LAYER for the named attachment point is
set to layer. All other state values of the attachment point speci?ed by attachment
are set to their default values listed in table 6.29. No change is made to the state of
the texture object, and any previous attachment to the attachment logical buffer of
the framebuffer object bound to framebuffer target is broken. If the attachment is
not successful, then no change is made to the state of either the texture object or
the framebuffer object.
Setting attachment to the value DEPTH STENCIL ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to texture. texture must have base internal formatDEPTH STENCIL, or the
depth and stencil framebuffer attachments will be incomplete (see section 4.4.4).
The command
void FramebufferTextureLayer(enum target,
enum attachment,uint texture,int level,int layer );
operates identically to FramebufferTexture3D, except that it attaches a single
layer of a three-dimensional texture or a one- or two-dimensional array texture.
layer is an integer indicating the layer number, and is treated identically to the
layer parameter in FramebufferTexture3D. The error INVALID VALUE is gener-
ated if layer is negative. The error INVALID OPERATION is generated if texture
is non-zero and is not the name of a three dimensional texture or one- or two-
dimensional array texture. Unlike FramebufferTexture3D, no textarget parameter
is accepted.
If texture is non-zero and the command does not result in an er-
ror, the framebuffer attachment state corresponding to attachment is
updated as in the other FramebufferTexture commands, except that
FRAMEBUFFER ATTACHMENT TEXTURE LAYER is set to layer.
If a texture object is deleted while its image is attached to one or more attach-
ment points in the currently bound framebuffer, then it is as if FramebufferTex-
ture* had been called, with a texture of zero, for each attachment point to which
this image was attached in the currently bound framebuffer. In other words, this
texture image is ?rst detached from all attachment points in the currently bound
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 289
framebuffer. Note that the texture image is speci?cally not detached from any
other framebuffer objects. Detaching the texture image from any other framebuffer
objects is the responsibility of the application.
4.4.3 Rendering When an Image of a Bound Texture Object is Also
Attached to the Framebuffer
The mechanisms for attaching textures to a framebuffer object do not prevent a
one- or two-dimensional texture level, a face of a cube map texture level, or a layer
of a two-dimensional array or three-dimensional texture from being attached to the
draw framebuffer while the same texture is bound to a texture unit. While any of
these conditions hold, texturing operations accessing that image will produce un-
de?ned results, as described at the end of section 3.9.7. Conditions resulting in
such unde?ned behavior are de?ned in more detail below. Such unde?ned textur-
ing operations are likely to leave the ?nal results of the shader or ?xed-function
fragment processing operations unde?ned, and should be avoided.
Special precautions need to be taken to avoid attaching a texture image to the
currently bound framebuffer while the texture object is currently bound and en-
abled for texturing. Doing so could lead to the creation of a feedback loop between
the writing of pixels by the GL’s rendering operations and the simultaneous reading
of those same pixels when used as texels in the currently bound texture. In this sce-
nario, the framebuffer will be considered framebuffer complete (see section 4.4.4),
but the values of fragments rendered while in this state will be unde?ned. The
values of texture samples may be unde?ned as well, as described at the end of the
Scale Factor and Level of Detail subsection of section 3.9.7.
Speci?cally, the values of rendered fragments are unde?ned if all of the fol-
lowing conditions are true:
 an image from texture object T is attached to the currently bound framebuffer
at attachment point A
 the texture object T is currently bound to a texture unit U, and
 the current ?xed-function texture state or programmable vertex and/or frag-
ment processing state makes it possible (see below) to sample from the tex-
ture object T bound to texture unit U
while either of the following conditions are true:
 the value of TEXTURE MIN FILTER for texture object T is NEAREST or
LINEAR, and the value of FRAMEBUFFER ATTACHMENT TEXTURE LEVEL
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 290
for attachment point A is equal to the value of TEXTURE BASE LEVEL for
the texture object T
 the value of TEXTURE MIN FILTER for texture ob-
ject T is one of NEAREST MIPMAP NEAREST, NEAREST MIPMAP LINEAR,
LINEAR MIPMAP NEAREST, or LINEAR MIPMAP LINEAR, and the value
of FRAMEBUFFER ATTACHMENT TEXTURE LEVEL for attachment point
A is within the the range speci?ed by the current values of
TEXTURE BASE LEVEL toq, inclusive, for the texture object T. (q is de?ned
in the Mipmapping discussion of section 3.9.7).
For the purpose of this discussion, it is possible to sample from the texture
object T bound to texture unit U if any of the following are true:
 Programmable fragment processing is disabled and the target of texture ob-
ject T is enabled according to the texture target precedence rules of sec-
tion 3.9.17
 The active fragment or vertex shader contains any instructions that might
sample from the texture object T bound to U, even if those instructions might
only be executed conditionally.
Note that if TEXTURE BASE LEVEL and TEXTURE MAX LEVEL exclude any
levels containing image(s) attached to the currently bound framebuffer, then the
above conditions will not be met (i.e., the above rule will not cause the values of
rendered fragments to be unde?ned.)
4.4.4 Framebuffer Completeness
A framebuffer must be framebuffer complete to effectively be used as the draw or
read framebuffer of the GL.
The default framebuffer is always complete if it exists; however, if no default
framebuffer exists (no window system-provided drawable is associated with the
GL context), it is deemed to be incomplete.
A framebuffer object is said to be framebuffer complete if all of its attached
images, and all framebuffer parameters required to utilize the framebuffer for ren-
dering and reading, are consistently de?ned and meet the requirements de?ned
below. The rules of framebuffer completeness are dependent on the properties of
the attached images, and on certain implementation dependent restrictions.
The internal formats of the attached images can affect the completeness of
the framebuffer, so it is useful to ?rst de?ne the relationship between the internal
format of an image and the attachment points to which it can be attached.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 291
 The following base internal formats from table 3.15 are color-renderable:
ALPHA, RED, RG, RGB, and RGBA. The sized internal formats from ta-
ble 3.16 that have a color-renderable base internal format are also color-
renderable. No other formats, including compressed internal formats, are
color-renderable.
 An internal format is depth-renderable if it is DEPTH COMPONENT or
one of the formats from table 3.18 whose base internal format is
DEPTH COMPONENT or DEPTH STENCIL. No other formats are depth-
renderable.
 An internal format is stencil-renderable if it is STENCIL INDEX or
DEPTH STENCIL, if it is one of the STENCIL INDEX formats from ta-
ble 4.11, or if it is one of the formats from table 3.18 whose base internal
format isDEPTH STENCIL. No other formats are stencil-renderable.
Framebuffer Attachment Completeness
If the value ofFRAMEBUFFER ATTACHMENT OBJECT TYPE for the framebuffer at-
tachment point attachment is notNONE, then it is said that a framebuffer-attachable
image, named image, is attached to the framebuffer at the attachment point. image
is identi?ed by the state in attachment as described in section 4.4.2.
The framebuffer attachment point attachment is said to be framebuffer attach-
ment complete if the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE for at-
tachment is NONE (i.e., no image is attached), or if all of the following conditions
are true:
 image is a component of an existing object with the name speci?ed by
FRAMEBUFFER ATTACHMENT OBJECT NAME, and of the type speci?ed by
FRAMEBUFFER ATTACHMENT OBJECT TYPE.
 The width and height of image are non-zero.
 If FRAMEBUFFER ATTACHMENT OBJECT TYPE is TEXTURE and
FRAMEBUFFER ATTACHMENT OBJECT NAME names a three-dimensional
texture, then FRAMEBUFFER ATTACHMENT TEXTURE LAYER must be
smaller than the depth of the texture.
 If FRAMEBUFFER ATTACHMENT OBJECT TYPE is TEXTURE
and FRAMEBUFFER ATTACHMENT OBJECT NAME names
a one- or two-dimensional array texture, then
FRAMEBUFFER ATTACHMENT TEXTURE LAYER must be smaller than
the number of layers in the texture.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 292
 If attachment is COLOR ATTACHMENTi, then image must have a color-
renderable internal format.
 If attachment is DEPTH ATTACHMENT, then image must have a depth-
renderable internal format.
 If attachment is STENCIL ATTACHMENT, then image must have a stencil-
renderable internal format.
Whole Framebuffer Completeness
Each rule below is followed by an error token enclosed inf bracketsg. The
meaning of these errors is explained below and under “Effects of Framebuffer
Completeness on Framebuffer Operations” later in section 4.4.4.
The framebuffer object target is said to be framebuffer complete if all the
following conditions are true:
 target is the default framebuffer, and the default framebuffer exists.
fFRAMEBUFFER UNDEFINEDg
 All framebuffer attachment points are framebuffer attachment complete.
fFRAMEBUFFER INCOMPLETE ATTACHMENTg
 There is at least one image attached to the framebuffer.
fFRAMEBUFFER INCOMPLETE MISSING ATTACHMENTg
 The value ofFRAMEBUFFER ATTACHMENT OBJECT TYPE must not beNONE
for any color attachment point(s) named byDRAW BUFFERi.
fFRAMEBUFFER INCOMPLETE DRAW BUFFERg
 If READ BUFFER is not NONE, then the value of
FRAMEBUFFER ATTACHMENT OBJECT TYPE must not be NONE for the
color attachment point named byREAD BUFFER.
fFRAMEBUFFER INCOMPLETE READ BUFFERg
 The combination of internal formats of the attached images does not violate
an implementation-dependent set of restrictions.
fFRAMEBUFFER UNSUPPORTEDg
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 293
 The value ofRENDERBUFFER SAMPLES is the same for all attached render-
buffers; and, if the attached images are a mix of renderbuffers and textures,
the value ofRENDERBUFFER SAMPLES is zero for all attached renderbuffers.
fFRAMEBUFFER INCOMPLETE MULTISAMPLEg
The token in brackets after each clause of the framebuffer completeness rules
speci?es the return value of CheckFramebufferStatus (see below) that is gen-
erated when that clause is violated. If more than one clause is violated, it is
implementation-dependent which value will be returned by CheckFramebuffer-
Status.
Performing any of the following actions may change whether the framebuffer
is considered complete or incomplete:
 Binding to a different framebuffer with BindFramebuffer.
 Attaching an image to the framebuffer with FramebufferTexture* or
FramebufferRenderbuffer.
 Detaching an image from the framebuffer with FramebufferTexture* or
FramebufferRenderbuffer.
 Changing the internal format of a texture image that is attached to the frame-
buffer by calling CopyTexImage* or CompressedTexImage*.
 Changing the internal format of a renderbuffer that is attached to the frame-
buffer by calling RenderbufferStorage.
 Deleting, with DeleteTextures or DeleteRenderbuffers, an object contain-
ing an image that is attached to a framebuffer object that is bound to the
framebuffer.
 Changing the read buffer or one of the draw buffers.
 Associating a different window system-provided drawable, or no drawable,
with the default framebuffer using a window system binding API such as
those described in section 1.7.2.
Although the GL de?nes a wide variety of internal formats for framebuffer-
attachable images, such as texture images and renderbuffer images, some imple-
mentations may not support rendering to particular combinations of internal for-
mats. If the combination of formats of the images attached to a framebuffer object
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 294
are not supported by the implementation, then the framebuffer is not complete un-
der the clause labeledFRAMEBUFFER UNSUPPORTED.
Implementations are required to support certain combinations of framebuffer
internal formats as described under “Required Framebuffer Formats” in sec-
tion 4.4.4.
Because of the implementation-dependent clause of the framebuffer complete-
ness test in particular, and because framebuffer completeness can change when the
set of attached images is modi?ed, it is strongly advised, though not required, that
an application check to see if the framebuffer is complete prior to rendering. The
status of the framebuffer object currently bound to target can be queried by calling
enum CheckFramebufferStatus(enum target );
target must beDRAW FRAMEBUFFER,READ FRAMEBUFFER, orFRAMEBUFFER.
FRAMEBUFFER is equivalent toDRAW FRAMEBUFFER. If CheckFramebufferSta-
tus is called within a Begin/End pair, anINVALID OPERATION error is generated.
If CheckFramebufferStatus generates an error, zero is returned.
Otherwise, a value is returned that identi?es whether or not the framebuffer
bound to target is complete, and if not complete the value identi?es one of the
rules of framebuffer completeness that is violated. If the framebuffer is complete,
thenFRAMEBUFFER COMPLETE is returned.
The values of SAMPLE BUFFERS and SAMPLES are derived from the
attachments of the currently bound framebuffer object. If the cur-
rent DRAW FRAMEBUFFER BINDING is not framebuffer complete, then both
SAMPLE BUFFERS and SAMPLES are unde?ned. Otherwise, SAMPLES is equal to
the value of RENDERBUFFER SAMPLES for the attached images (which all must
have the same value forRENDERBUFFER SAMPLES). Further,SAMPLE BUFFERS is
one ifSAMPLES is non-zero. Otherwise,SAMPLE BUFFERS is zero.
Required Framebuffer Formats
Implementations must support framebuffer objects with up to
MAX COLOR ATTACHMENTS color attachments, a depth attachment, and a
stencil attachment. Each color attachment may be in any of the required color
formats for textures and renderbuffers described in sections 3.9.1 and 4.4.2. The
depth attachment may be in any of the required depth or combined depth+stencil
formats described in those sections, and the stencil attachment may be in any of
the required combined depth+stencil formats.
There must be at least one default framebuffer format allowing creation of a
default framebuffer supporting front-buffered rendering.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 295
Effects of Framebuffer Completeness on Framebuffer Operations
Attempting to render to or read from a framebuffer which is not framebuffer com-
plete will generate an INVALID FRAMEBUFFER OPERATION error. This means
that rendering commands such as Begin, RasterPos, any command that per-
forms an implicit Begin, as well as commands that read the framebuffer such
as ReadPixels, CopyTexImage, and CopyTexSubImage, will generate the error
INVALID FRAMEBUFFER OPERATION if called while the framebuffer is not frame-
buffer complete.
4.4.5 Effects of Framebuffer State on Framebuffer Dependent Values
The values of the state variables listed in table 6.51 may change when a change is
made toDRAW FRAMEBUFFER BINDING, to the state of the currently bound frame-
buffer object, or to an image attached to the currently bound framebuffer object.
WhenDRAW FRAMEBUFFER BINDING is zero, the values of the state variables
listed in table 6.51 are implementation de?ned.
When DRAW FRAMEBUFFER BINDING is non-zero, if the currently bound
framebuffer object is not framebuffer complete, then the values of the state vari-
ables listed in table 6.51 are unde?ned.
When DRAW FRAMEBUFFER BINDING is non-zero and the currently bound
framebuffer object is framebuffer complete, then the values of the state variables
listed in table 6.51 are completely determined byDRAW FRAMEBUFFER BINDING,
the state of the currently bound framebuffer object, and the state of the images
attached to the currently bound framebuffer object. The values of RED BITS,
GREEN BITS, BLUE BITS, and ALPHA BITS are de?ned only if all color attach-
ments of the draw framebuffer have identical formats, in which case the color
component depths of color attachment zero are returned. The values returned for
DEPTH BITS andSTENCIL BITS are the depth or stencil component depth of the
corresponding attachment of the draw framebuffer, respectively. The actual sizes
of the color, depth, or stencil bit planes can be obtained by querying an attachment
point using GetFramebufferAttachmentParameteriv, or querying the object at-
tached to that point. If the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE
at a particular attachment point isRENDERBUFFER, the sizes may be determined by
calling GetRenderbufferParameteriv as described in section 6.1.3. If the value
of FRAMEBUFFER ATTACHMENT OBJECT TYPE at a particular attachment point is
TEXTURE, the sizes may be determined by calling GetTexParameter, as described
in section 6.1.3.
Version 3.0 (September 23, 2008)4.4. FRAMEBUFFEROBJECTS 296
4.4.6 Mapping between Pixel and Element in Attached Image
When DRAW FRAMEBUFFER BINDING is non-zero, an operation that writes to the
framebuffer modi?es the image attached to the selected logical buffer, and an oper-
ation that reads from the framebuffer reads from the image attached to the selected
logical buffer.
If the attached image is a renderbuffer image, then the window coordinates
(x ;y ) corresponds to the value in the renderbuffer image at the same coordi-
w w
nates.
If the attached image is a texture image, then the window coordinates (x ;y )
w w
correspond to the texel (i;j;k) from ?gure 3.10 as follows:
i = (x  b)
w
j = (y  b)
w
k = (layer b)
where b is the texture image’s border width and layer is the value of
FRAMEBUFFER ATTACHMENT TEXTURE LAYER for the selected logical buffer. For
a two-dimensional texture,k andlayer are irrelevant; for a one-dimensional tex-
ture,j,k, andlayer are irrelevant.
(x ;y ) corresponds to a border texel ifx ,y , orlayer is less than the border
w w w w
width, or ifx ,y , orlayer is greater than or equal to the border width plus the
w w
width, height, or depth, respectively, of the texture image.
Conversion to Framebuffer-Attachable Image Components
When an enabled color value is written to the framebuffer while the draw frame-
buffer binding is non-zero, for each draw buffer the R, G, B, and A values are
converted to internal components as described in table 3.15, according to the ta-
ble row corresponding to the internal format of the framebuffer-attachable image
attached to the selected logical buffer, and the resulting internal components are
written to the image attached to logical buffer. The masking operations described
in section 4.2.2 are also effective.
Conversion to RGBA Values
When a color value is read or is used as the source of a logical operation or blending
while the read framebuffer binding is non-zero, the components of the framebuffer-
attachable image that is attached to the logical buffer selected by READ BUFFER
are ?rst converted to R, G, B, and A values according to table 3.23 and the internal
format of the attached image.
Version 3.0 (September 23, 2008)Chapter 5
Special Functions
This chapter describes additional GL functionality that does not ?t easily into any
of the preceding chapters. This functionality consists of evaluators (used to model
curves and surfaces), selection (used to locate rendered primitives on the screen),
feedback (which returns GL results before rasterization), display lists (used to des-
ignate a group of GL commands for later execution by the GL), ?ushing and ?n-
ishing (used to synchronize the GL command stream), and hints.
5.1 Evaluators
Evaluators provide a means to use a polynomial or rational polynomial mapping
to produce vertex, normal, and texture coordinates, and colors. The values so pro-
duced are sent on to further stages of the GL as if they had been provided directly
by the client. Transformations, lighting, primitive assembly, rasterization, and per-
pixel operations are not affected by the use of evaluators.
k
Consider theR -valued polynomialp(u) de?ned by
n
X
n
p(u) = B (u)R (5.1)
i
i
i=0
k
withR 2R and
i
 
n
n i n i
B (u) = u (1 u) ;
i
i
  
n
0
theith Bernstein polynomial of degreen (recall that 0  1 and  1). Each
0
R is a control point. The relevant command is
i
void Map1ffdg(enum target,Tu ,Tu ,int stride,
1 2
int order,T points );
2975.1. EVALUATORS 298
target k Values
MAP1 VERTEX 3 3 x,y,z vertex coordinates
MAP1 VERTEX 4 4 x,y,z,w vertex coordinates
MAP1 INDEX 1 color index
MAP1 COLOR 4 4 R, G, B, A
MAP1 NORMAL 3 x,y,z normal coordinates
MAP1 TEXTURE COORD 1 1 s texture coordinate
MAP1 TEXTURE COORD 2 2 s,t texture coordinates
MAP1 TEXTURE COORD 3 3 s,t,r texture coordinates
MAP1 TEXTURE COORD 4 4 s,t,r,q texture coordinates
Table 5.1: Values speci?ed by the target to Map1. Values are given in the order in
which they are taken.
target is a symbolic constant indicating the range of the de?ned polynomial. Its
possible values, along with the evaluations that each indicates, are given in ta-
ble 5.1. order is equal ton + 1; The errorINVALID VALUE is generated iforder
is less than one or greater than MAX EVAL ORDER. points is a pointer to a set of
n + 1 blocks of storage. Each block begins withk single-precision ?oating-point
or double-precision ?oating-point values, respectively. The rest of the block may
be ?lled with arbitrary data. Table 5.1 indicates howk depends on target and what
thek values represent in each case.
stride is the number of single- or double-precision values (as appropriate) in
each block of storage. The error INVALID VALUE results if stride is less than
k. The order of the polynomial, order, is also the number of blocks of storage
containing control points.
u andu give two ?oating-point values that de?ne the endpoints of the pre-
1 2
0
image of the map. When a valueu is presented for evaluation, the formula used
is
0
u u
1
0 0
p (u ) =p( ):
u  u
2 1
The errorINVALID VALUE results ifu =u .
1 2
Map2 is analogous to Map1, except that it describes bivariate polynomials of
the form
n m
XX
n m
p(u;v) = B (u)B (v)R :
ij
i j
i=0 j=0
The form of the Map2 command is
Version 3.0 (September 23, 2008)5.1. EVALUATORS 299
Integers Reals
Vertices
[u ,u ]
k Normals
1 2 [0,1]
EvalMesh
B R
Ax+b ?
i i
Texture Coordinates
[0,1]
EvalPoint l
[v ,v ]
1 2
Colors
MapGrid Map
EvalCoord
Figure 5.1. Map Evaluation.
void Map2ffdg(enum target,Tu ,Tu ,int ustride,
1 2
int uorder,Tv ,Tv ,int vstride,int vorder,T points );
1 2
target is a range type selected from the same group as is used for Map1, ex-
cept that the string MAP1 is replaced with MAP2. points is a pointer to (n +
1)(m + 1) blocks of storage (uorder = n + 1 and vorder = m + 1; the er-
ror INVALID VALUE is generated if either uorder or vorder is less than one or
greater thanMAX EVAL ORDER). The values comprisingR are located
ij
(ustride)i + (vstride)j
values (either single- or double-precision ?oating-point, as appropriate) past the
?rst value pointed to by points. u ,u ,v , andv de?ne the pre-image rectangle
1 2 1 2
0 0
of the map; a domain point (u;v ) is evaluated as
0 0
u u v  v
1 1
0 0 0
p (u;v ) =p( ; ):
u  u v  v
2 1 2 1
The evaluation of a de?ned map is enabled or disabled with Enable and
Disable using the constant corresponding to the map as described above. The
evaluator map generates only coordinates for texture unit TEXTURE0. The error
INVALID VALUE results if eitherustride orvstride is less thank, or ifu is equal
1
tou2, or ifv is equal tov . If the value of ACTIVE TEXTURE is not TEXTURE0,
1 2
calling Mapf12g generates the errorINVALID OPERATION.
Figure 5.1 describes map evaluation schematically; an evaluation of enabled
maps is effected in one of two ways. The ?rst way is to use
void EvalCoordf12gffdg(T arg );
void EvalCoordf12gffdgv(T arg );
Version 3.0 (September 23, 2008)5.1. EVALUATORS 300
EvalCoord1 causes evaluation of the enabled one-dimensional maps. The argu-
0
ment is the value (or a pointer to the value) that is the domain coordinate,u . Eval-
Coord2 causes evaluation of the enabled two-dimensional maps. The two values
0 0
specify the two domain coordinates,u andv , in that order.
When one of the EvalCoord commands is issued, all currently enabled maps
of the indicated dimension are evaluated. Then, for each enabled map, it is as if a
corresponding GL command were issued with the resulting coordinates, with one
important difference. The difference is that when an evaluation is performed, the
GL uses evaluated values instead of current values for those evaluations that are
enabled (otherwise, the current values are used). The order of the effective com-
mands is immaterial, except that Vertex (for vertex coordinate evaluation) must be
issued last. Use of evaluators has no effect on the current color, normal, or texture
coordinates. If ColorMaterial is enabled, evaluated color values affect the result
of the lighting equation as if the current color was being modi?ed, but no change
is made to the tracking lighting parameters or to the current color.
No command is effectively issued if the corresponding map (of the indicated
dimension) is not enabled. If more than one evaluation is enabled for a particu-
lar dimension (e.g. MAP1 TEXTURE COORD 1 andMAP1 TEXTURE COORD 2), then
only the result of the evaluation of the map with the highest number of coordinates
is used.
Finally, if eitherMAP2 VERTEX 3 orMAP2 VERTEX 4 is enabled, then the nor-
mal to the surface is computed. Analytic computation, which sometimes yields
normals of length zero, is one method which may be used. If automatic normal
generation is enabled, then this computed normal is used as the normal associated
with a generated vertex. Automatic normal generation is controlled with Enable
and Disable with the symbolic constantAUTO NORMAL. If automatic normal gener-
ation is disabled, then a corresponding normal map, if enabled, is used to produce
a normal. If neither automatic normal generation nor a normal map are enabled,
then no normal is sent with a vertex resulting from an evaluation (the effect is that
the current normal is used).
ForMAP VERTEX 3, letq =p. ForMAP VERTEX 4, letq = (x=w;y=w;z=w),
where (x;y;z;w) =p. Then let
@q @q
m =  :
@u @v
Then the generated analytic normal, n, is given by n = m if a vertex shader is
m
active, or else byn = .
kmk
The second way to carry out evaluations is to use a set of commands that pro-
vide for ef?cient speci?cation of a series of evenly spaced values to be mapped.
This method proceeds in two steps. The ?rst step is to de?ne a grid in the domain.
Version 3.0 (September 23, 2008)5.1. EVALUATORS 301
This is done using
0 0
void MapGrid1ffdg(intn,Tu ,Tu );
1 2
for a one-dimensional map or
0 0 0
void MapGrid2ffdg(intn ,Tu ,Tu ,intn ,Tv ,
u v
1 2 1
0
Tv );
2
0 0
for a two-dimensional map. In the case of MapGrid1 u and u describe an
1 2
interval, while n describes the number of partitions of the interval. The error
0 0
INVALID VALUE results if n 0. For MapGrid2, (u ;v ) speci?es one two-
1 1
0 0
dimensional point and (u ;v ) speci?es another.n gives the number of partitions
u
2 2
0 0 0 0
betweenu andu , andn gives the number of partitions betweenv andv . If
v
1 2 1 2
eithern  0 orn  0, then the errorINVALID VALUE occurs.
u v
Once a grid is de?ned, an evaluation on a rectangular subset of that grid may
be carried out by calling
void EvalMesh1(enum mode,intp ,intp );
1 2
mode is eitherPOINT orLINE. The effect is the same as performing the following
0 0 0
code fragment, with u = (u  u )=n:
2 1
Begin(type);
fori =p top step 1:0
1 2
0 0
EvalCoord1(i u + u );
*
1
End();
where EvalCoord1f or EvalCoord1d is substituted for EvalCoord1 as appro-
priate. If mode is POINT, then type is POINTS; if mode is LINE, then type is
LINE STRIP. The one requirement is that if eitheri = 0 ori = n, then the value
0 0 0 0
computed fromi u +u is preciselyu oru , respectively.
1 1 2
The corresponding commands for two-dimensional maps are
void EvalMesh2(enum mode,intp ,intp ,intq ,
1 2 1
intq );
2
mode must beFILL,LINE, orPOINT. When mode isFILL, then these commands
0 0 0 0 0 0
are equivalent to the following, with u = (u  u )=n and v = (v  v )=m:
2 1 2 1
Version 3.0 (September 23, 2008)5.1. EVALUATORS 302
fori =q toq   1 step 1:0
1 2
Begin(QUAD STRIP);
forj =p top step 1:0
1 2
0 0 0 0
EvalCoord2(j u + u , i v + v );
* *
1 1
0 0 0 0
EvalCoord2(j u + u , (i + 1) v + v );
* *
1 1
End();
If mode isLINE, then a call to EvalMesh2 is equivalent to
fori =q toq step 1:0
1 2
Begin(LINE STRIP);
forj =p top step 1:0
1 2
0 0 0 0
EvalCoord2(j u + u , i v + v );
* *
1 1
End();;
fori =p top step 1:0
1 2
Begin(LINE STRIP);
forj =q toq step 1:0
1 2
0 0 0 0
EvalCoord2(i u + u , j v + v );
* *
1 1
End();
If mode isPOINT, then a call to EvalMesh2 is equivalent to
Begin(POINTS);
fori =q toq step 1:0
1 2
forj =p top step 1:0
1 2
0 0 0 0
EvalCoord2(j u + u , i v + v );
* *
1 1
End();
0 0 0 0
Again, in all three cases, there is the requirement that 0u +u =u ,nu +
1 1
0 0 0 0 0 0 0 0
u =u , 0 v +v =v , andm v +v =v .
1 2 1 1 1 2
An evaluation of a single point on the grid may also be carried out:
void EvalPoint1(intp );
Calling it is equivalent to the command
0 0
EvalCoord1(p * u +u );
1
0 0
with u andu de?ned as above.
1
void EvalPoint2(intp,intq );
is equivalent to the command
Version 3.0 (September 23, 2008)5.2. SELECTION 303
0 0 0 0
EvalCoord2(p u + u , q v + v );
* *
1 1
The state required for evaluators potentially consists of 9 one-dimensional map
speci?cations and 9 two-dimensional map speci?cations, as well as corresponding
?ags for each speci?cation indicating which are enabled. Each map speci?cation
consists of one or two orders, an appropriately sized array of control points, and a
set of two values (for a one-dimensional map) or four values (for a two-dimensional
map) to describe the domain. The maximum possible order, for eitheru orv, is
implementation dependent (one maximum applies to bothu andv), but must be at
least 8. Each control point consists of between one and four ?oating-point values
(depending on the type of the map). Initially, all maps have order 1 (making them
constant maps). All vertex coordinate maps produce the coordinates (0; 0; 0; 1)
(or the appropriate subset); all normal coordinate maps produce (0; 0; 1); RGBA
maps produce (1; 1; 1; 1); color index maps produce 1.0; and texture coordinate
maps produce (0; 0; 0; 1). In the initial state, all maps are disabled. A ?ag indi-
cates whether or not automatic normal generation is enabled for two-dimensional
maps. In the initial state, automatic normal generation is disabled. Also required
are two ?oating-point values and an integer number of grid divisions for the one-
dimensional grid speci?cation and four ?oating-point values and two integer grid
divisions for the two-dimensional grid speci?cation. In the initial state, the bounds
of the domain interval for 1-D is 0 and 1:0, respectively; for 2-D, they are (0; 0)
and (1:0; 1:0), respectively. The number of grid divisions is 1 for 1-D and 1 in
both directions for 2-D. If any evaluation command is issued when no vertex map
is enabled for the map dimension being evaluated, nothing happens.
5.2 Selection
Selection is used to determine which primitives are drawn into some region of a
window. The region is de?ned by the current model-view and perspective matrices.
Selection works by returning an array of integer-valued names. This array
represents the current contents of the name stack. This stack is controlled with the
commands
void InitNames(void );
void PopName(void );
void PushName(uint name );
void LoadName(uint name );
InitNames empties (clears) the name stack. PopName pops one name off the top
of the name stack. PushName causes name to be pushed onto the name stack.
Version 3.0 (September 23, 2008)5.2. SELECTION 304
LoadName replaces the value on the top of the stack with name. Loading a name
onto an empty stack generates the errorINVALID OPERATION. Popping a name off
of an empty stack generatesSTACK UNDERFLOW; pushing a name onto a full stack
generates STACK OVERFLOW. The maximum allowable depth of the name stack is
implementation dependent but must be at least 64.
In selection mode, framebuffer updates as described in chapter 4 are not per-
formed. The GL is placed in selection mode with
int RenderMode(enum mode );
mode is a symbolic constant: one of RENDER, SELECT, or FEEDBACK. RENDER is
the default, corresponding to rendering as described until now. SELECT speci?es
selection mode, and FEEDBACK speci?es feedback mode (described below). Use
of any of the name stack manipulation commands while the GL is not in selection
mode has no effect.
Selection is controlled using
void SelectBuffer(sizei n,uint *buffer );
buffer is a pointer to an array of unsigned integers (called the selection array) to be
potentially ?lled with names, and n is an integer indicating the maximum number
of values that can be stored in that array. Placing the GL in selection mode before
SelectBuffer has been called results in an error of INVALID OPERATION as does
calling SelectBuffer while in selection mode.
In selection mode, if a point, line, polygon, or the valid coordinates produced
by a RasterPos command intersects the clip volume (section 2.17) then this prim-
itive (or RasterPos command) causes a selection hit. WindowPos commands al-
ways generate a selection hit, since the resulting raster position is always valid.
In the case of polygons, no hit occurs if the polygon would have been culled, but
selection is based on the polygon itself, regardless of the setting of PolygonMode.
When in selection mode, whenever a name stack manipulation command is exe-
cuted or RenderMode is called and there has been a hit since the last time the stack
was manipulated or RenderMode was called, then a hit record is written into the
selection array.
A hit record consists of the following items in order: a non-negative integer
giving the number of elements on the name stack at the time of the hit, a minimum
depth value, a maximum depth value, and the name stack with the bottommost el-
ement ?rst. The minimum and maximum depth values are the minimum and max-
imum taken over all the window coordinatez values of each (post-clipping) vertex
of each primitive that intersects the clipping volume since the last hit record was
Version 3.0 (September 23, 2008)5.3. FEEDBACK 305
written. The minimum and maximum (each of which lies in the range [0; 1]) are
32
each multiplied by 2  1 and rounded to the nearest unsigned integer to obtain the
values that are placed in the hit record. No depth offset arithmetic (section 3.6.5)
is performed on these values.
Hit records are placed in the selection array by maintaining a pointer into that
array. When selection mode is entered, the pointer is initialized to the beginning
of the array. Each time a hit record is copied, the pointer is updated to point at
the array element after the one into which the topmost element of the name stack
was stored. If copying the hit record into the selection array would cause the total
number of values to exceed n, then as much of the record as ?ts in the array is
written and an over?ow ?ag is set.
Selection mode is exited by calling RenderMode with an argument value other
than SELECT. When called while in selection mode, RenderMode returns the
number of hit records copied into the selection array and resets the SelectBuffer
pointer to its last speci?ed value. Values are not guaranteed to be written into the
selection array until RenderMode is called. If the selection array over?ow ?ag
was set, then RenderMode returns 1 and clears the over?ow ?ag. The name
stack is cleared and the stack pointer reset whenever RenderMode is called.
The state required for selection consists of the address of the selection array
and its maximum size, the name stack and its associated pointer, a minimum and
maximum depth value, and several ?ags. One ?ag indicates the current Render-
Mode value. In the initial state, the GL is in the RENDER mode. Another ?ag is
used to indicate whether or not a hit has occurred since the last name stack ma-
nipulation. This ?ag is reset upon entering selection mode and whenever a name
stack manipulation takes place. One ?nal ?ag is required to indicate whether the
maximum number of copied names would have been exceeded. This ?ag is reset
upon entering selection mode. This ?ag, the address of the selection array, and its
maximum size are GL client state.
5.3 Feedback
The GL is placed in feedback mode by calling RenderMode with FEEDBACK.
When in feedback mode, framebuffer updates as described in chapter 4 are not
performed. Instead, information about primitives that would have otherwise been
rasterized is returned to the application via the feedback buffer.
Feedback is controlled using
void FeedbackBuffer(sizei n,enum type,float *buffer );
Version 3.0 (September 23, 2008)5.3. FEEDBACK 306
buffer is a pointer to an array of ?oating-point values into which feedback informa-
tion will be placed, and n is a number indicating the maximum number of values
that can be written to that array. type is a symbolic constant describing the informa-
tion to be fed back for each vertex (see ?gure 5.2). The errorINVALID OPERATION
results if the GL is placed in feedback mode before a call to FeedbackBuffer has
been made, or if a call to FeedbackBuffer is made while in feedback mode.
While in feedback mode, each primitive that would be rasterized (or bitmap
or call to DrawPixels or CopyPixels, if the raster position is valid) generates a
block of values that get copied into the feedback array. If doing so would cause
the number of entries to exceed the maximum, the block is partially written so as
to ?ll the array (if there is any room left at all). The ?rst block of values gener-
ated after the GL enters feedback mode is placed at the beginning of the feedback
array, with subsequent blocks following. Each block begins with a code indicat-
ing the primitive type, followed by values that describe the primitive’s vertices and
associated data. Entries are also written for bitmaps and pixel rectangles. Feed-
back occurs after polygon culling (section 3.6.1) and PolygonMode interpretation
of polygons (section 3.6.4) has taken place. It may also occur after polygons with
more than three edges are broken up into triangles (if the GL implementation ren-
ders polygons by performing this decomposition).x,y, andz coordinates returned
by feedback are window coordinates; ifw is returned, it is in clip coordinates. No
depth offset arithmetic (section 3.6.5) is performed on the z values. In the case
of bitmaps and pixel rectangles, the coordinates returned are those of the current
raster position.
The texture coordinates and colors returned are those resulting from the clip-
ping operations described in section 2.19.8. Only coordinates for texture unit
TEXTURE0 are returned even for implementations which support multiple texture
units. The colors returned are the primary colors.
The ordering rules for GL command interpretation also apply in feedback
mode. Each command must be fully interpreted and its effects on both GL state
and the values to be written to the feedback buffer completed before a subsequent
command may be executed.
Feedback mode is exited by calling RenderMode with an argument value other
than FEEDBACK. When called while in feedback mode, RenderMode returns the
number of values placed in the feedback array and resets the feedback array pointer
to be buffer. The return value never exceeds the maximum number of values passed
to FeedbackBuffer.
If writing a value to the feedback buffer would cause more values to be written
than the speci?ed maximum number of values, then the value is not written and an
over?ow ?ag is set. In this case, RenderMode returns 1 when it is called, after
which the over?ow ?ag is reset. While in feedback mode, values are not guaranteed
Version 3.0 (September 23, 2008)5.4. DISPLAYLISTS 307
Type coordinates color texture total values
2D x,y – – 2
3D x,y,z – – 3
3D COLOR x,y,z k – 3 +k
3D COLOR TEXTURE x,y,z k 4 7 +k
4D COLOR TEXTURE x,y,z,w k 4 8 +k
Table 5.2: Correspondence of feedback type to number of values per vertex.k is 1
in color index mode and 4 in RGBA mode.
to be written into the feedback buffer before RenderMode is called.
Figure 5.2 gives a grammar for the array produced by feedback. Each primitive
is indicated with a unique identifying value followed by some number of vertices.
A vertex is fed back as some number of ?oating-point values determined by the
feedback type. Table 5.2 gives the correspondence between feedback buffer and
the number of values returned for each vertex.
The command
void PassThrough(float token );
may be used as a marker in feedback mode. token is returned as if it were a prim-
itive; it is indicated with its own unique identifying value. The ordering of any
PassThrough commands with respect to primitive speci?cation is maintained by
feedback. PassThrough may not occur between Begin and End. It has no effect
when the GL is not in feedback mode.
The state required for feedback is the pointer to the feedback array, the maxi-
mum number of values that may be placed there, and the feedback type. An over-
?ow ?ag is required to indicate whether the maximum allowable number of feed-
back values has been written; initially this ?ag is cleared. These state variables are
GL client state. Feedback also relies on the same mode ?ag as selection to indicate
whether the GL is in feedback, selection, or normal rendering mode.
5.4 Display Lists
A display list is simply a group of GL commands and arguments that has been
stored for subsequent execution. The GL may be instructed to process a particular
display list (possibly repeatedly) by providing a number that uniquely speci?es it.
Doing so causes the commands within the list to be executed just as if they were
given normally. The only exception pertains to commands that rely upon client
Version 3.0 (September 23, 2008)5.4. DISPLAYLISTS 308
feedback-list:
feedback-item feedback-list pixel-rectangle:
feedback-item DRAW PIXEL TOKEN vertex
COPY PIXEL TOKEN vertex
feedback-item: passthrough:
point PASS THROUGH TOKENf
line-segment
polygon vertex:
bitmap 2D:
pixel-rectangle f f
passthrough 3D:
f f f
point: 3D COLOR:
POINT TOKEN vertex f f f color
line-segment: 3D COLOR TEXTURE:
LINE TOKEN vertex vertex f f f color tex
LINE RESET TOKEN vertex vertex 4D COLOR TEXTURE:
polygon: f f f f color tex
POLYGON TOKENn polygon-spec
polygon-spec: color:
polygon-spec vertex f f f f
vertex vertex vertex f
bitmap:
BITMAP TOKEN vertex tex:
f f f f
Figure 5.2: Feedback syntax.f is a ?oating-point number.n is a ?oating-point in-
teger giving the number of vertices in a polygon. The symbols ending with TOKEN
are symbolic ?oating-point constants. The labels under the “vertex” rule show the
different data returned for vertices depending on the feedback type. LINE TOKEN
and LINE RESET TOKEN are identical except that the latter is returned only when
the line stipple is reset for that line segment.
Version 3.0 (September 23, 2008)5.4. DISPLAYLISTS 309
state. When such a command is accumulated into the display list (that is, when
issued, not when executed), the client state in effect at that time applies to the com-
mand. Only server state is affected when the command is executed. As always,
pointers which are passed as arguments to commands are dereferenced when the
command is issued. (Vertex array pointers are dereferenced when the commands
ArrayElement, DrawArrays, DrawElements, or DrawRangeElements are ac-
cumulated into a display list.)
A display list is begun by calling
void NewList(uint n,enum mode );
n is a positive integer to which the display list that follows is assigned, and mode is a
symbolic constant that controls the behavior of the GL during display list creation.
If mode is COMPILE, then commands are not executed as they are placed in the
display list. If mode is COMPILE AND EXECUTE then commands are executed as
they are encountered, then placed in the display list. If n = 0, then the error
INVALID VALUE is generated.
After calling NewList all subsequent GL commands are placed in the display
list (in the order the commands are issued) until a call to
void EndList(void );
occurs, after which the GL returns to its normal command execution state. It is
only when EndList occurs that the speci?ed display list is actually associated with
the index indicated with NewList. The error INVALID OPERATION is generated
if EndList is called without a previous matching NewList, or if NewList is called
a second time before calling EndList. The error OUT OF MEMORY is generated if
EndList is called and the speci?ed display list cannot be stored because insuf?cient
memory is available. In this case GL implementations of revision 1.1 or greater
insure that no change is made to the previous contents of the display list, if any,
and that no other change is made to the GL state, except for the state changed by
execution of GL commands when the display list mode isCOMPILE AND EXECUTE.
Once de?ned, a display list is executed by calling
void CallList(uint n );
n gives the index of the display list to be called. This causes the commands saved
in the display list to be executed, in order, just as if they were issued without using
a display list. Ifn = 0, then the errorINVALID VALUE is generated.
The command
Version 3.0 (September 23, 2008)5.4. DISPLAYLISTS 310
void CallLists(sizei n,enum type,void *lists );
provides an ef?cient means for executing a number of display lists. n is an in-
teger indicating the number of display lists to be called, and lists is a pointer
that points to an array of offsets. Each offset is constructed as determined by
lists as follows. First, type may be one of the constants BYTE, UNSIGNED BYTE,
SHORT,UNSIGNED SHORT,INT,UNSIGNED INT, orFLOAT indicating that the ar-
ray pointed to by lists is an array of bytes, unsigned bytes, shorts, unsigned shorts,
integers, unsigned integers, or ?oats, respectively. In this case each offset is found
by simply converting each array element to an integer (?oating point values are
truncated to negative in?nity). Further, type may be one of 2 BYTES, 3 BYTES,
or 4 BYTES, indicating that the array contains sequences of 2, 3, or 4 unsigned
bytes, in which case each integer offset is constructed according to the following
algorithm:
offset 0
fori = 1 tob
offset offset shifted left 8 bits
offset offset +byte
advance to next byte in the array
b is 2, 3, or 4, as indicated by type. Ifn = 0, CallLists does nothing.
Each of the n constructed offsets is taken in order and added to a display list
base to obtain a display list number. For each number, the indicated display list is
executed. The base is set by calling
void ListBase(uint base );
to specify the offset.
Indicating a display list index that does not correspond to any display list has no
effect. CallList or CallLists may appear inside a display list. (If the mode supplied
to NewList is COMPILE AND EXECUTE, then the appropriate lists are executed,
but the CallList or CallLists, rather than those lists’ constituent commands, is
placed in the list under construction.) To avoid the possibility of in?nite recursion
resulting from display lists calling one another, an implementation dependent limit
is placed on the nesting level of display lists during display list execution. This
limit must be at least 64.
Two commands are provided to manage display list indices.
uint GenLists(sizei s );
Version 3.0 (September 23, 2008)5.5. COMMANDSNOTUSABLEINDISPLAYLISTS 311
returns an integern such that the indicesn;:::;n+s 1 are previously unused (i.e.
there ares previously unused display list indices starting atn). GenLists also has
the effect of creating an empty display list for each of the indicesn;:::;n +s  1,
so that these indices all become used. GenLists returns 0 if there is no group ofs
contiguous previously unused display list indices, or ifs = 0.
boolean IsList(uint list );
returnsTRUE if list is the index of some display list.
A contiguous group of display lists may be deleted by calling
void DeleteLists(uint list,sizei range );
where list is the index of the ?rst display list to be deleted and range is the number
of display lists to be deleted. All information about the display lists is lost, and the
indices become unused. Indices to which no display list corresponds are ignored.
Ifrange = 0, nothing happens.
5.5 Commands Not Usable In Display Lists
Certain commands, when called while compiling a display list, are not compiled
into the display list but are executed immediately. These commands fall in several
categories including
Display lists: GenLists and DeleteLists.
Render modes: FeedbackBuffer, SelectBuffer, and RenderMode.
Vertex arrays: ClientActiveTexture, ColorPointer, EdgeFlagPointer, Fog-
CoordPointer, IndexPointer, InterleavedArrays, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexAttribPointer, VertexAttribIPointer,
VertexPointer, GenVertexArrays, DeleteVertexArrays, and BindVertexArray.
Client state: EnableClientState, DisableClientState, EnableVertexAttrib-
Array, DisableVertexAttribArray, PushClientAttrib, and PopClientAttrib.
Pixels and textures: PixelStore, ReadPixels, GenTextures, DeleteTextures,
AreTexturesResident, and GenerateMipmap.
Occlusion queries: GenQueries and DeleteQueries.
Vertex buffer objects: GenBuffers, DeleteBuffers, BindBuffer, BindBuffer-
Range, BindBufferBase, TransformFeedbackVaryings, BufferData, Buffer-
SubData, MapBuffer, MapBufferRange, FlushBufferRange, and Unmap-
Buffer.
Framebuffer and renderbuffer objects: GenFramebuffers, Bind-
Framebuffer, DeleteFramebuffers, CheckFramebufferStatus, GenRender-
buffers, BindRenderbuffer, DeleteRenderbuffers, RenderbufferStorage,
Version 3.0 (September 23, 2008)5.6. FLUSHANDFINISH 312
RenderbufferStorageMultisample, FramebufferTexture1D, FramebufferTex-
ture2D, FramebufferTexture3D, FramebufferTextureLayer, Framebuffer-
Renderbuffer, and BlitFramebuffer.
Program and shader objects: CreateProgram, CreateShader, DeletePro-
gram, DeleteShader, AttachShader, DetachShader, BindAttribLocation,
BindFragDataLocation, CompileShader, ShaderSource, LinkProgram, and
ValidateProgram.
GL command stream management: Finish, and Flush.
Other queries: All query commands whose names begin with Get and Is (see
chapter 6).
GL commands that source data from buffer objects dereference the buffer ob-
ject data in question at display list compile time, rather than encoding the buffer
ID and buffer offset into the display list. Only GL commands that are executed
immediately, rather than being compiled into a display list, are permitted to use a
buffer object as a data sink.
TexImage3D, TexImage2D, TexImage1D, Histogram,
and ColorTable are executed immediately when called with
the corresponding proxy arguments PROXY TEXTURE 3D or
PROXY TEXTURE 2D ARRAY; PROXY TEXTURE 2D PROXY TEXTURE 1D ARRAY,
or PROXY TEXTURE CUBE MAP; PROXY TEXTURE 1D; PROXY HISTOGRAM;
and PROXY COLOR TABLE, PROXY POST CONVOLUTION COLOR TABLE, or
PROXY POST COLOR MATRIX COLOR TABLE.
When a program object is in use, a display list may be executed whose vertex
attribute calls do not match up exactly with what is expected by the vertex shader
contained in that program object. Handling of this mismatch is described in sec-
tion 2.20.3.
Display lists require one bit of state to indicate whether a GL command should
be executed immediately or placed in a display list. In the initial state, commands
are executed immediately. If the bit indicates display list creation, an index is
required to indicate the current display list being de?ned. Another bit indicates,
during display list creation, whether or not commands should be executed as they
are compiled into the display list. One integer is required for the current ListBase
setting; its initial value is zero. Finally, state must be maintained to indicate which
integers are currently in use as display list indices. In the initial state, no indices
are in use.
5.6 Flush and Finish
The command
Version 3.0 (September 23, 2008)5.7. HINTS 313
void Flush(void );
indicates that all commands that have previously been sent to the GL must complete
in ?nite time.
The command
void Finish(void );
forces all previous GL commands to complete. Finish does not return until all
effects from previously issued commands on GL client and server state and the
framebuffer are fully realized.
5.7 Hints
Certain aspects of GL behavior, when there is room for variation, may be controlled
with hints. A hint is speci?ed using
void Hint(enum target,enum hint );
target is a symbolic constant indicating the behavior to be controlled, and hint is a
symbolic constant indicating what type of behavior is desired. The possible targets
are described in table 5.3; for each target, hint must be one ofFASTEST, indicating
that the most ef?cient option should be chosen;NICEST, indicating that the highest
quality option should be chosen; and DONT CARE, indicating no preference in the
matter.
For the texture compression hint, a hint ofFASTEST indicates that texture im-
ages should be compressed as quickly as possible, while NICEST indicates that
the texture images be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, and NICEST should
be used if the compression results are to be retrieved by GetCompressedTexIm-
age (section 6.1.4) for reuse.
The interpretation of hints is implementation dependent. An implementation
may ignore them entirely.
The initial value of all hints isDONT CARE.
Version 3.0 (September 23, 2008)5.7. HINTS 314
Target Hint description
PERSPECTIVE CORRECTION HINT Quality of parameter interpolation
POINT SMOOTH HINT Point sampling quality
LINE SMOOTH HINT Line sampling quality
POLYGON SMOOTH HINT Polygon sampling quality
FOG HINT Fog quality
(calculated per-pixel or per-vertex)
GENERATE MIPMAP HINT Quality and performance of
automatic mipmap level generation
TEXTURE COMPRESSION HINT Quality and performance of
texture image compression
FRAGMENT SHADER DERIVATIVE HINT Derivative accuracy for fragment
processing built-in functions
dFdx,dFdy andfwidth
Table 5.3: Hint targets and descriptions.
Version 3.0 (September 23, 2008)Chapter 6
State and State Requests
The state required to describe the GL machine is enumerated in section 6.2. Most
state is set through the calls described in previous chapters, and can be queried
using the calls described in section 6.1.
6.1 Querying GL State
6.1.1 Simple Queries
Much of the GL state is completely identi?ed by symbolic constants. The values
of these state variables can be obtained using a set of Get commands. There are
four commands for obtaining simple state variables:
void GetBooleanv(enum value,boolean *data );
void GetIntegerv(enum value,int *data );
void GetFloatv(enum value,float *data );
void GetDoublev(enum value,double *data );
The commands obtain boolean, integer, ?oating-point, or double-precision state
variables. value is a symbolic constant indicating the state variable to return. data
is a pointer to a scalar or array of the indicated type in which to place the returned
data.
Indexed simple state variables are queried with the commands
void GetBooleani v(enum target,uint index,
boolean *data );
void GetIntegeri v(enum target,uint index,int *data );
3156.1. QUERYINGGLSTATE 316
target is the name of the indexed state and index is the index of the particular
element being queried. data is a pointer to a scalar or array of the indicated type in
which to place the returned data. An INVALID VALUE error is generated if index
is outside the valid range for the indexed state target.
Finally,
boolean IsEnabled(enum value );
can be used to determine if value is currently enabled (as with Enable) or disabled,
and
boolean IsEnabledi(enum target,uint index );
can be used to determine if the indexed state corresponding to target and index is
enabled or disabled. AnINVALID VALUE error is generated if index is outside the
valid range for the indexed state target.
6.1.2 Data Conversions
If a Get command is issued that returns value types different from the type of the
value being obtained, a type conversion is performed. If GetBooleanv is called,
a ?oating-point or integer value converts to FALSE if and only if it is zero (oth-
erwise it converts to TRUE). If GetIntegerv (or any of the Get commands below)
is called, a boolean value is interpreted as either 1 or 0, and a ?oating-point value
is rounded to the nearest integer, unless the value is an RGBA color component,
a DepthRange value, a depth buffer clear value, or a normal coordinate. In these
cases, the Get command converts the ?oating-point value to an integer accord-
ing to the INT entry of table 4.9; a value not in [ 1; 1] converts to an unde?ned
value. If GetFloatv is called, a boolean value is interpreted as either 1:0 or 0:0, an
integer is coerced to ?oating-point, and a double-precision ?oating-point value is
converted to single-precision. Analogous conversions are carried out in the case of
GetDoublev. If a value is so large in magnitude that it cannot be represented with
the requested type, then the nearest value representable using the requested type is
returned.
Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f. Similarly, points for evaluator maps are returned in the order that
they appeared when passed to Map1. Map2 returnsR in the [(uorder)i +j]th
ij
block of values (see page 298 fori,j, uorder, andR ).
ij
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 317
Matrices may be queried and returned in transposed form by calling Get-
Booleanv, GetIntegerv, GetFloatv, and GetDoublev with pname set to
one of TRANSPOSE MODELVIEW MATRIX, TRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX, orTRANSPOSE COLOR MATRIX. The effect of
GetFloatv(TRANSPOSE MODELVIEW MATRIX,m);
is the same as the effect of the command sequence
GetFloatv(MODELVIEW MATRIX,m);
T
m =m ;
Similar conversions occur when queryingTRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX, andTRANSPOSE COLOR MATRIX.
If fragment color clamping is enabled, querying of the texture border color,
texture environment color, fog color, alpha test reference value, blend color, and
RGBA clear color will clamp the corresponding state values to [0; 1] before return-
ing them. This behavior provides compatibility with previous versions of the GL
that clamped these values when speci?ed.
Most texture state variables are quali?ed by the value of ACTIVE TEXTURE
to determine which server texture state vector is queried. Client tex-
ture state variables such as texture coordinate array pointers are qual-
i?ed by the value of CLIENT ACTIVE TEXTURE. Tables 6.5, 6.6, 6.12,
6.19, 6.22, and 6.47 indicate those state variables which are quali?ed by
ACTIVE TEXTURE or CLIENT ACTIVE TEXTURE during state queries. Queries
of texture state variables corresponding to texture coordinate processing
units (namely, TexGen state and enables, and matrices) will generate an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equal to MAX TEXTURE COORDS. All other texture state queries will result in an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equal toMAX COMBINED TEXTURE IMAGE UNITS.
Vertex array state variables are quali?ed by the value of
VERTEX ARRAY BINDING to determine which vertex array object is queried.
Tables 6.6 through 6.9 de?ne the set of state stored in a vertex array object.
6.1.3 Enumerated Queries
Other commands exist to obtain state variables that are identi?ed by a category
(clip plane, light, material, etc.) as well as a symbolic constant. These are
void GetClipPlane(enum plane,double eqn[4] );
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 318
void GetLightfifgv(enum light,enum value,T data );
void GetMaterialfifgv(enum face,enum value,T data );
void GetTexEnvfifgv(enum env,enum value,T data );
void GetTexGenfifdgv(enum coord,enum value,T data );
void GetTexParameterfifgv(enum target,enum value,
T data );
void GetTexParameterIfi uigv(enum target,enum value,
T data );
void GetTexLevelParameterfifgv(enum target,int lod,
enum value,T data );
void GetPixelMapfui us fgv(enum map,T data );
void GetMapfifdgv(enum map,enum value,T data );
GetLightiv, GetMaterialiv, GetTexEnviv, GetTexGeniv, and GetTexparame-
teriv convert ?oating point state to integer values in the same manner as GetInte-
gerv (see section 6.1.2).
GetClipPlane always returns four double-precision values in eqn; these are the
coef?cients of the plane equation of plane in eye coordinates (these coordinates are
those that were computed when the plane was speci?ed).
GetLight places information about value (a symbolic constant) for light (also a
symbolic constant) in data. POSITION orSPOT DIRECTION returns values in eye
coordinates (again, these are the coordinates that were computed when the position
or direction was speci?ed).
GetMaterial, GetTexGen, GetTexEnv, and GetTexParameter are simi-
lar to GetLight, placing information about value for the target indicated by
their ?rst argument into data. The face argument to GetMaterial must be ei-
ther FRONT or BACK, indicating the front or back material, respectively. The
env argument to GetTexEnv must be either POINT SPRITE, TEXTURE ENV, or
TEXTURE FILTER CONTROL. The coord argument to GetTexGen must be one of
S, T, R, or Q. For GetTexGen, EYE LINEAR coef?cients are returned in the eye
coordinates that were computed when the plane was speci?ed; OBJECT LINEAR
coef?cients are returned in object coordinates.
GetTexParameter parameter target may be one of TEXTURE 1D,
TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, or
TEXTURE CUBE MAP, indicating the currently bound one-, two-, three-dimensional,
one- or two-dimensional array, or cube map texture object. GetTexLevelParam-
eter parameter target may be one of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
TEXTURE 1D ARRAY, TEXTURE 2D ARRAY, TEXTURE CUBE MAP POSITIVE X,
TEXTURE CUBE MAP NEGATIVE X, TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP NEGATIVE Y, TEXTURE CUBE MAP POSITIVE Z,
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 319
TEXTURE CUBE MAP NEGATIVE Z, PROXY TEXTURE 1D, PROXY TEXTURE 2D,
PROXY TEXTURE 3D, PROXY TEXTURE 1D ARRAY, PROXY TEXTURE 2D ARRAY,
or PROXY TEXTURE CUBE MAP, indicating the one-, two-, or three-dimensional
texture, the one- or two-dimensional array texture, one of the six distinct 2D im-
ages making up the cube map texture object, or the one-, two-, three-dimensional,
one- or two-dimensional array, or cube map proxy state vector. Note that
TEXTURE CUBE MAP is not a valid target parameter for GetTexLevelParameter,
because it does not specify a particular cube map face. value is a symbolic value
indicating which texture parameter is to be obtained. For GetTexParameter,
value must be either TEXTURE RESIDENT, or one of the symbolic values in
table 3.20. Querying valueTEXTURE BORDER COLOR with GetTexParameterIiv
or GetTexParameterIuiv returns the border color values as signed integers or
unsigned integers, respectively; otherwise the values are returned as described in
section 6.1.2. If the border color is queried with a type that does not match the
original type with which it was speci?ed, the result is unde?ned. The lod argument
to GetTexLevelParameter determines which level-of-detail’s state is returned. If
the lod argument is less than zero or if it is larger than the maximum allowable
level-of-detail then the errorINVALID VALUE occurs.
For texture images with uncompressed internal formats, queries of
value of TEXTURE RED TYPE, TEXTURE GREEN TYPE, TEXTURE BLUE TYPE,
TEXTURE ALPHA TYPE, TEXTURE LUMINANCE TYPE, TEXTURE DEPTH TYPE,
and TEXTURE INTENSITY TYPE return the data type used to store the compo-
nent. Types NONE, UNSIGNED NORMALIZED, FLOAT, INT, and UNSIGNED INT
respectively indicate missing, unsigned normalized integer, ?oating-point, signed
unnormalized integer, and unsigned unnormalized integer components. Queries
of value of TEXTURE RED SIZE, TEXTURE GREEN SIZE, TEXTURE BLUE SIZE,
TEXTURE ALPHA SIZE, TEXTURE LUMINANCE SIZE,
TEXTURE INTENSITY SIZE, TEXTURE DEPTH SIZE,
TEXTURE STENCIL SIZE, andTEXTURE SHARED SIZE return the actual resolu-
tions of the stored image array components, not the resolutions speci?ed when the
image array was de?ned. For texture images with a compressed internal format, the
resolutions returned specify the component resolution of an uncompressed internal
format that produces an image of roughly the same quality as the compressed im-
age in question. Since the quality of the implementation’s compression algorithm
is likely data-dependent, the returned component sizes should be treated only as
rough approximations.
Querying value TEXTURE COMPRESSED IMAGE SIZE returns the
size (in ubytes) of the compressed texture image that would be
returned by GetCompressedTexImage (section 6.1.4). Querying
TEXTURE COMPRESSED IMAGE SIZE is not allowed on texture images with
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 320
an uncompressed internal format or on proxy targets and will result in an
INVALID OPERATION error if attempted.
Queries of value TEXTURE WIDTH, TEXTURE HEIGHT, TEXTURE DEPTH, and
TEXTURE BORDER return the width, height, depth, and border as speci?ed when
the image array was created. The internal format of the image array is queried
as TEXTURE INTERNAL FORMAT, or as TEXTURE COMPONENTS for compatibility
with GL version 1.0.
For GetPixelMap, the map must be a map name from table 3.3. For GetMap,
map must be one of the map types described in section 5.1, and value must be
one of ORDER, COEFF, or DOMAIN. The GetPixelMapfv, GetPixelMapuiv, and
GetPixelMapusv commands write all the values in the named pixel map to data.
GetPixelMapuiv and GetPixelMapusv convert ?oating point pixel map values
to integers according to the UNSIGNED INT and UNSIGNED SHORT entries, re-
spectively, of table 4.9. If a pixel pack buffer is bound (as indicated by a non-
zero value of PIXEL PACK BUFFER BINDING), data is an offset into the pixel
pack buffer; otherwise, data is a pointer to client memory. All pixel storage
and pixel transfer modes are ignored when returning a pixel map. n machine
units are written where n is the size of the pixel map times the size of FLOAT,
UNSIGNED INT, or UNSIGNED SHORT respectively in basic machine units. If a
pixel pack buffer object is bound and data + n is greater than the size of the
pixel buffer, anINVALID OPERATION error results. If a pixel pack buffer object is
bound and data is not evenly divisible by the number of basic machine units needed
to store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT respectively,
anINVALID OPERATION error results.
6.1.4 Texture Queries
The command
void GetTexImage(enum tex,int lod,enum format,
enum type,void *img );
is used to obtain texture images. It is somewhat different from the other get com-
mands; tex is a symbolic value indicating which texture (or texture face in the case
of a cube map texture target name) is to be obtained. TEXTURE 1D,TEXTURE 2D,
TEXTURE 3D, TEXTURE 1D ARRAY, and TEXTURE 2D ARRAY indicate a one-,
two-, or three-dimensional or one- or two-dimensional array texture respec-
tively. TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP NEGATIVE Y,
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 321
TEXTURE CUBE MAP POSITIVE Z, and TEXTURE CUBE MAP NEGATIVE Z indi-
cate the respective face of a cube map texture. lod is a level-of-detail number,
format is a pixel format from table 3.6, type is a pixel type from table 3.5.
Calling GetTexImage with a color format (one ofRED,GREEN,BLUE,ALPHA,
RG, RGB, BGR, RGBA, BGRA, LUMINANCE, or LUMINANCE ALPHA) when the base
internal format of the texture image is not a color format; with a format of
DEPTH COMPONENT when the base internal format is not DEPTH COMPONENT or
DEPTH STENCIL; or with a format ofDEPTH STENCIL when the base internal for-
mat is notDEPTH STENCIL, causes the errorINVALID OPERATION.
GetTexImage obtains component groups from a texture image with the indi-
cated level-of-detail. If format is a color format then the components are assigned
among R, G, B, and A according to table 6.1, starting with the ?rst group in the
?rst row, and continuing by obtaining groups in order from each row and proceed-
ing from the ?rst row to the last, and from the ?rst image to the last for three-
dimensional textures. One- and two-dimensional array textures are treated as two-
and three-dimensional images, respectively, where the layers are treated as rows or
images. If format is DEPTH COMPONENT, then each depth component is assigned
with the same ordering of rows and images. If format is DEPTH STENCIL, then
each depth component and each stencil index is assigned with the same ordering
of rows and images.
These groups are then packed and placed in client or pixel buffer object
memory. If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), img is an offset into the pixel pack buffer; other-
wise, img is a pointer to client memory. No pixel transfer operations are performed
on this image, but pixel storage modes that are applicable to ReadPixels are ap-
plied.
For three-dimensional and two-dimensional array textures, pixel storage oper-
ations are applied as if the image were two-dimensional, except that the additional
pixel storage state values PACK IMAGE HEIGHT and PACK SKIP IMAGES are ap-
plied. The correspondence of texels to memory locations is as de?ned for TexIm-
age3D in section 3.9.1.
The row length, number of rows, image depth, and number of images are de-
termined by the size of the texture image (including any borders). Calling GetTex-
Image with lod less than zero or larger than the maximum allowable causes the
error INVALID VALUE. Calling GetTexImage with a format of COLOR INDEX or
STENCIL INDEX causes the error INVALID ENUM. If a pixel pack buffer object is
bound and packing the texture image into the buffer’s memory would exceed the
size of the buffer, an INVALID OPERATION error results. If a pixel pack buffer
object is bound and img is not evenly divisible by the number of basic machine
units needed to store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 322
Base Internal Format R G B A
ALPHA 0 0 0 A
i
LUMINANCE (or1) L 0 0 1
i
LUMINANCE ALPHA (or2) L 0 0 A
i i
INTENSITY I 0 0 1
i
RED R 0 0 1
i
RG R G 0 1
i i
RGB (or3) R G B 1
i i i
RGBA (or4) R G B A
i i i i
Table 6.1: Texture, table, and ?lter return values. R , G , B , A , L , andI are
i i i i i i
components of the internal format that are assigned to pixel values R, G, B, and A.
If a requested pixel value is not present in the internal format, the speci?ed constant
value is used.
respectively, anINVALID OPERATION error results.
The command
void GetCompressedTexImage(enum target,int lod,
void *img );
is used to obtain texture images stored in compressed form. The parameters tar-
get, lod, and img are interpreted in the same manner as in GetTexImage. When
called, GetCompressedTexImage writesnubytes of compressed image data to
the pixel pack buffer or client memory pointed to by img, wheren is the value of
TEXTURE COMPRESSED IMAGE SIZE for the texture. The compressed image data
is formatted according to the de?nition of the texture’s internal format. All pixel
storage and pixel transfer modes are ignored when returning a compressed texture
image.
Calling GetCompressedTexImage with an lod value less than zero or greater
than the maximum allowable causes anINVALID VALUE error. Calling GetCom-
pressedTexImage with a texture image stored with an uncompressed internal for-
mat causes an INVALID OPERATION error. If a pixel pack buffer object is bound
andimg +n is greater than the size of the buffer, anINVALID OPERATION error
results.
The command
boolean IsTexture(uint texture );
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 323
returnsTRUE if texture is the name of a texture object. If texture is zero, or is a non-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexture returnsFALSE. A name returned by GenTextures, but not yet bound, is
not the name of a texture object.
6.1.5 Stipple Query
The command
void GetPolygonStipple(void *pattern );
obtains the polygon stipple. The pattern is packed into pixel pack buffer or client
memory according to the procedure given in section 4.3.2 for ReadPixels; it is as
if the height and width passed to that command were both equal to 32, the type
wereBITMAP, and the format wereCOLOR INDEX.
6.1.6 Color Matrix Query
The scale and bias variables are queried using GetFloatv with pname set
to the appropriate variable name. The top matrix on the color matrix
stack is returned by GetFloatv called with pname set to COLOR MATRIX or
TRANSPOSE COLOR MATRIX. The depth of the color matrix stack, and the maxi-
mum depth of the color matrix stack, are queried with GetIntegerv, setting pname
toCOLOR MATRIX STACK DEPTH andMAX COLOR MATRIX STACK DEPTH respec-
tively.
6.1.7 Color Table Query
The current contents of a color table are queried using
void GetColorTable(enum target,enum format,enum type,
void *table );
target must be one of the regular color table names listed in table 3.4. format and
type accept the same values as do the corresponding parameters of GetTexImage,
except that a format of DEPTH COMPONENT causes the error INVALID ENUM. The
one-dimensional color table image is returned to pixel pack buffer or client memory
starting at table. No pixel transfer operations are performed on this image, but pixel
storage modes that are applicable to ReadPixels are performed. Color components
that are requested in the speci?ed format, but which are not included in the internal
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 324
format of the color lookup table, are returned as zero. The assignments of internal
color components to the components requested by format are described in table 6.1.
The functions
void GetColorTableParameterfifgv(enum target,
enum pname,T params );
are used for integer and ?oating point query.
target must be one of the regular or proxy color table names listed in
table 3.4. pname is one of COLOR TABLE SCALE, COLOR TABLE BIAS,
COLOR TABLE FORMAT, COLOR TABLE WIDTH, COLOR TABLE RED SIZE,
COLOR TABLE GREEN SIZE, COLOR TABLE BLUE SIZE,
COLOR TABLE ALPHA SIZE, COLOR TABLE LUMINANCE SIZE, or
COLOR TABLE INTENSITY SIZE. The value of the speci?ed parameter is
returned in params.
6.1.8 Convolution Query
The current contents of a convolution ?lter image are queried with the command
void GetConvolutionFilter(enum target,enum format,
enum type,void *image );
target must be CONVOLUTION 1D or CONVOLUTION 2D. format and type accept
the same values as do the corresponding parameters of GetTexImage, except
that a format of DEPTH COMPONENT causes the error INVALID ENUM. The one-
dimensional or two-dimensional images is returned to pixel pack buffer or client
memory starting at image. Pixel processing and component mapping are identical
to those of GetTexImage.
The current contents of a separable ?lter image are queried using
void GetSeparableFilter(enum target,enum format,
enum type,void *row,void *column,void *span );
target must be SEPARABLE 2D. format and type accept the same values as do the
corresponding parameters of GetTexImage. The row and column images are re-
turned to pixel pack buffer or client memory starting at row and column respec-
tively. span is currently unused. Pixel processing and component mapping are
identical to those of GetTexImage.
The functions
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 325
void GetConvolutionParameterfifgv(enum target,
enum pname,T params );
are used for integer and ?oating point query. target must be
CONVOLUTION 1D, CONVOLUTION 2D, or SEPARABLE 2D. pname is
one of CONVOLUTION BORDER COLOR, CONVOLUTION BORDER MODE,
CONVOLUTION FILTER SCALE, CONVOLUTION FILTER BIAS,
CONVOLUTION FORMAT, CONVOLUTION WIDTH, CONVOLUTION HEIGHT,
MAX CONVOLUTION WIDTH, or MAX CONVOLUTION HEIGHT. The value of the
speci?ed parameter is returned in params.
6.1.9 Histogram Query
The current contents of the histogram table are queried using
void GetHistogram(enum target,boolean reset,
enum format,enum type,void values );
*
target must beHISTOGRAM. type and format accept the same values as do the corre-
sponding parameters of GetTexImage, except that a format ofDEPTH COMPONENT
causes the errorINVALID ENUM. The one-dimensional histogram table image is re-
turned to pixel pack buffer or client memory starting at type. Pixel processing and
component mapping are identical to those of GetTexImage, except that instead of
applying the Final Conversion pixel storage mode, component values are simply
clamped to the range of the target data type.
If reset is TRUE, then all counters of all elements of the histogram are reset to
zero. Counters are reset whether returned or not.
No counters are modi?ed if reset isFALSE.
Calling
void ResetHistogram(enum target );
resets all counters of all elements of the histogram table to zero. target must be
HISTOGRAM.
It is not an error to reset or query the contents of a histogram table with zero
entries.
The functions
void GetHistogramParameterfifgv(enum target,
enum pname,T params );
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 326
are used for integer and ?oating point query. target must be HISTOGRAM or
PROXY HISTOGRAM. pname is one of HISTOGRAM FORMAT, HISTOGRAM WIDTH,
HISTOGRAM RED SIZE, HISTOGRAM GREEN SIZE, HISTOGRAM BLUE SIZE,
HISTOGRAM ALPHA SIZE, or HISTOGRAM LUMINANCE SIZE. pname may be
HISTOGRAM SINK only for target HISTOGRAM. The value of the speci?ed
parameter is returned in params.
6.1.10 Minmax Query
The current contents of the minmax table are queried using
void GetMinmax(enum target,boolean reset,enum format,
enum type,void values );
*
target must be MINMAX. type and format accept the same values as do the corre-
sponding parameters of GetTexImage, except that a format ofDEPTH COMPONENT
causes the error INVALID ENUM. A one-dimensional image of width 2 is returned
to pixel pack buffer or client memory starting at values. Pixel processing and com-
ponent mapping are identical to those of GetTexImage.
If reset is TRUE, then each minimum value is reset to the maximum repre-
sentable value, and each maximum value is reset to the minimum representable
value. All values are reset, whether returned or not.
No values are modi?ed if reset isFALSE.
Calling
void ResetMinmax(enum target );
resets all minimum and maximum values of target to to their maximum and mini-
mum representable values, respectively, target must beMINMAX.
The functions
void GetMinmaxParameterfifgv(enum target,enum pname,
T params );
are used for integer and ?oating point query. target must be MINMAX. pname is
MINMAX FORMAT or MINMAX SINK. The value of the speci?ed parameter is re-
turned in params.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 327
6.1.11 Pointer and String Queries
The command
void GetPointerv(enum pname,void **params );
obtains the pointer or pointers named pname in the array params.
The possible values for pname are SELECTION BUFFER POINTER
and FEEDBACK BUFFER POINTER, which respectively return
the pointers set with SelectBuffer and FeedbackBuffer; and
VERTEX ARRAY POINTER, NORMAL ARRAY POINTER, COLOR ARRAY POINTER,
SECONDARY COLOR ARRAY POINTER, INDEX ARRAY POINTER,
TEXTURE COORD ARRAY POINTER, FOG COORD ARRAY POINTER, and
EDGE FLAG ARRAY POINTER, which respectively return the corresponding
value stored in the currently bound vertex array object. Each pname returns a
single pointer value.
String queries return pointers to UTF-8 encoded, NULL-terminated static
1
strings describing properties of the current GL context . The command
ubyte *GetString(enum name );
accepts name values of VENDOR, RENDERER, VERSION,
SHADING LANGUAGE VERSION, and EXTENSIONS. The format of the RENDERER
and VENDOR strings is implementation dependent. The EXTENSIONS string con-
tains a space separated list of extension names (the extension names themselves do
not contain any spaces). TheVERSION andSHADING LANGUAGE VERSION strings
are laid out as follows:
<version number><space><vendor-speci?c information>
The version number is either of the form major number.minor number or ma-
jor number.minor number.release number, where the numbers all have one or
more digits. The release number and vendor speci?c information are optional.
However, if present, then they pertain to the server and their format and contents
are implementation dependent.
GetString returns the version number (in the VERSION string) and the exten-
sion names (in the EXTENSIONS string) that can be supported by the current GL
1
Applications making copies of these static strings should never use a ?xed-length buffer, because
the strings may grow unpredictably between releases, resulting in buffer over?ow when copying.
This is particularly true of theEXTENSIONS string, which has become extremely long in some
GL implementations.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 328
context. Thus, if the client and server support different versions and/or extensions,
a compatible version and list of extensions is returned.
The GL version may also be queried by calling GetIntegerv with values
MAJOR VERSION and MINOR VERSION, which respectively return the same val-
ues as major number and minor number in the VERSION string, and value
CONTEXT FLAGS, which returns a set of ?ags de?ning additional proper-
ties of a context. If CONTEXT FLAG FORWARD COMPATIBLE BIT is set in
CONTEXT FLAGS, then the context is a forward-compatible context as de?ned in
appendix E, and the deprecated features described in that appendix are not sup-
ported; otherwise the context is a full context, and all features described in the
speci?cation are supported.
Indexed strings are queried with the command
ubyte *GetStringi(enum name,uint index );
target is the name of the indexed state and index is the index of the particular ele-
ment being queried. target may only beEXTENSIONS, indicating that the extension
name corresponding to theindexth supported extension should be returned.index
may range from zero to the value of NUM EXTENSIONS minus one. All extension
names, and only the extension names returned in GetString(EXTENSIONS) will be
returned as individual names, but there is no de?ned relationship between the order
in which names appear in the non-indexed string and the order in which the appear
in the indexed query. There is also no de?ned relationship between any particu-
lar extension name and theindex values; an extension name may correspond to a
differentindex in different GL contexts and/or implementations.
An INVALID VALUE error is generated if index is outside the valid range for
the indexed state target.
6.1.12 Asynchronous Queries
The command
boolean IsQuery(uint id );
returnsTRUE if id is the name of a query object. If id is zero, or if id is a non-zero
value that is not the name of a query object, IsQuery returnsFALSE.
Information about a query target can be queried with the command
void GetQueryiv(enum target,enum pname,int *params );
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 329
target identi?es the query target, and must
be one of SAMPLES PASSED for occlusion queries or PRIMITIVES GENERATED
andTRANSFORM FEEDBACK PRIMITIVES WRITTEN for primitive queries.
If pname isCURRENT QUERY, the name of the currently active query for target, or
zero if no query is active, will be placed in params.
If pname isQUERY COUNTER BITS, the implementation-dependent number of
bits used to hold the query result for target will be placed in params. The number
of query counter bits may be zero, in which case the counter contains no useful
information.
For primitive queries (PRIMITIVES GENERATED and
TRANSFORM FEEDBACK PRIMITIVES WRITTEN) if the number of bits is
non-zero, the minimum number of bits allowed is 32.
For occlusion queries (SAMPLES PASSED), if the number of bits is non-zero,
the minimum number of bits allowed is a function of the implementation’s max-
imum viewport dimensions (MAX VIEWPORT DIMS). The counter must be able to
represent at least two overdraws for every pixel in the viewport. The formula to
compute the allowable minimum value (wheren is the minimum number of bits)
is
n = minf32;dlog (maxViewportWidthmaxViewportHeight 2)eg:
2
The state of a query object can be queried with the commands
void GetQueryObjectiv(uint id,enum pname,
int *params );
void GetQueryObjectuiv(uint id,enum pname,
uint *params );
If id is not the name of a query object, or if the query object named by id is currently
active, then anINVALID OPERATION error is generated.
If pname isQUERY RESULT, then the query object’s result value is returned as
a single integer in params. If the value is so large in magnitude that it cannot be
represented with the requested type, then the nearest value representable using the
requested type is returned. If the number of query counter bits for target is zero,
then the result is returned as a single integer with the value zero.
There may be an indeterminate delay before the above query returns. If pname
is QUERY RESULT AVAILABLE, FALSE is returned if such a delay would be re-
quired; otherwiseTRUE is returned. It must always be true that if any query object
returns a result available of TRUE, all queries of the same type issued prior to that
query must also returnTRUE.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 330
Querying the state for any given query object forces that occlusion query to
complete within a ?nite amount of time.
If multiple queries are issued using the same object name prior to calling Get-
QueryObject[u]iv, the result and availability information returned will always be
from the last query issued. The results from any queries before the last one will be
lost if they are not retrieved before starting a new query on the same target and id.
6.1.13 Buffer Object Queries
The command
boolean IsBuffer(uint buffer );
returnsTRUE if buffer is the name of an buffer object. If buffer is zero, or if buffer is
a non-zero value that is not the name of an buffer object, IsBuffer returnsFALSE.
The command
void GetBufferParameteriv(enum target,enum pname,
int *data );
returns information about a bound buffer object. target must
be one of ARRAY BUFFER, ELEMENT ARRAY BUFFER, PIXEL PACK BUFFER, or
PIXEL UNPACK BUFFER. pname must be one of the buffer object parameters in
table 2.6, other thanBUFFER MAP POINTER. The value of the speci?ed parameter
of the buffer object bound to target is returned in data.
The command
void GetBufferSubData(enum target,intptr offset,
sizeiptr size,void *data );
queries the data contents of a buffer object. target is ARRAY BUFFER,
ELEMENT ARRAY BUFFER, PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER.
offset and size indicate the range of data in the buffer object that is to be queried, in
terms of basic machine units. data speci?es a region of client memory, size basic
machine units in length, into which the data is to be retrieved.
An error is generated if GetBufferSubData is executed for a buffer object that
is currently mapped.
While the data store of a buffer object is mapped, the pointer to the data store
can be queried by calling
void GetBufferPointerv(enum target,enum pname,
void **params );
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 331
with target set to ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER and pname set to
BUFFER MAP POINTER. The single buffer map pointer is returned in *params.
GetBufferPointerv returns the NULL pointer value if the buffer’s data store is not
currently mapped, or if the requesting client did not map the buffer object’s data
store, and the implementation is unable to support mappings on multiple clients.
To query which buffer objects are bound to the array of
transform feedback binding points and will be used when trans-
form feedback is active, call GetIntegeri v with param set to
TRANSFORM FEEDBACK BUFFER BINDING. index must be in the range zero
to the value of MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS - 1. The name
of the buffer object bound to index is returned in values. If no buffer object is
bound for index, zero is returned in values.
To query the starting offset or size of the range of each
buffer object binding used for transform feedback, call GetInte-
geri v with param set to TRANSFORM FEEDBACK BUFFER START or
TRANSFORM FEEDBACK BUFFER SIZE respectively. index must be in the
range 0 to the value of MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS - 1. If
the parameter (starting offset or size) was not speci?ed when the buffer object was
bound, zero is returned. If no buffer object is bound to index, -1 is returned.
6.1.14 Vertex Array Object Queries
The command
boolean IsVertexArray(uint array );
returns TRUE if array is the name of a vertex array object previously returned by
GenVertexArrays. If array is zero, or a non-zero value that is not the name of a
vertex array object, IsVertexArray returns FALSE. No error is generated if array
is not a valid vertex array object name.
6.1.15 Shader and Program Queries
State stored in shader or program objects can be queried by commands that ac-
cept shader or program object names. These commands will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object, and INVALID OPERATION if the provided name identi?es an object
of the other type. If an error is generated, variables used to hold return values are
not modi?ed.
The command
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 332
boolean IsShader(uint shader );
returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
error is generated if shader is not a valid shader object name.
The command
void GetShaderiv(uint shader,enum pname,int *params );
returns properties of the shader object named shader in params. The parameter
value to return is speci?ed by pname.
If pname is SHADER TYPE, VERTEX SHADER is returned if shader is a ver-
tex shader object, and FRAGMENT SHADER is returned if shader is a fragment
shader object. If pname is DELETE STATUS, TRUE is returned if the shader
has been ?agged for deletion and FALSE is returned otherwise. If pname is
COMPILE STATUS, TRUE is returned if the shader was last compiled successfully,
and FALSE is returned otherwise. If pname is INFO LOG LENGTH, the length of
the info log, including a null terminator, is returned. If there is no info log, zero
is returned. If pname isSHADER SOURCE LENGTH, the length of the concatenation
of the source strings making up the shader source, including a null terminator, is
returned. If no source has been de?ned, zero is returned.
The command
boolean IsProgram(uint program );
returns TRUE if program is the name of a program object. If program is zero,
or a non-zero value that is not the name of a program object, IsProgram returns
FALSE. No error is generated if program is not a valid program object name.
The command
void GetProgramiv(uint program,enum pname,
int *params );
returns properties of the program object named program in params. The parameter
value to return is speci?ed by pname.
If pname isDELETE STATUS,TRUE is returned if the program has been ?agged
for deletion, and FALSE is returned otherwise. If pname is LINK STATUS, TRUE
is returned if the program was last compiled successfully, and FALSE is returned
otherwise. If pname isVALIDATE STATUS,TRUE is returned if the last call to Val-
idateProgram with program was successful, andFALSE is returned otherwise. If
pname isINFO LOG LENGTH, the length of the info log, including a null terminator,
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 333
is returned. If there is no info log, 0 is returned. If pname isATTACHED SHADERS,
the number of objects attached is returned. If pname isACTIVE ATTRIBUTES, the
number of active attributes in program is returned. If no active attributes exist,
0 is returned. If pname is ACTIVE ATTRIBUTE MAX LENGTH, the length of the
longest active attribute name, including a null terminator, is returned. If no ac-
tive attributes exist, 0 is returned. If pname is ACTIVE UNIFORMS, the number of
active uniforms is returned. If no active uniforms exist, 0 is returned. If pname
isACTIVE UNIFORM MAX LENGTH, the length of the longest active uniform name,
including a null terminator, is returned. If no active uniforms exist, 0 is returned.
If pname is TRANSFORM FEEDBACK BUFFER MODE, the buffer mode used when
transform feedback is active is returned. It can be one of SEPARATE ATTRIBS
or INTERLEAVED ATTRIBS. If pname is TRANSFORM FEEDBACK VARYINGS, the
number of varying variables to capture in transform feedback mode for the pro-
gram is returned. If pname isTRANSFORM FEEDBACK VARYING MAX LENGTH, the
length of the longest varying name speci?ed to be used for transform feedback,
including a null terminator, is returned. If no varyings are used for transform feed-
back, zero is returned.
The command
void GetAttachedShaders(uint program,sizei maxCount,
sizei *count,uint *shaders );
returns the names of shader objects attached to program in shaders. The actual
number of shader names written into shaders is returned in count. If no shaders are
attached, count is set to zero. If count is NULL then it is ignored. The maximum
number of shader names that may be written into shaders is speci?ed by maxCount.
The number of objects attached to program is given by can be queried by calling
GetProgramiv withATTACHED SHADERS.
A string that contains information about the last compilation attempt on a
shader object or last link or validation attempt on a program object, called the
info log, can be obtained with the commands
void GetShaderInfoLog(uint shader,sizei bufSize,
sizei *length,char *infoLog );
void GetProgramInfoLog(uint program,sizei bufSize,
sizei *length,char *infoLog );
These commands return the info log string in infoLog. This string will be null
terminated. The actual number of characters written into infoLog, excluding the
null terminator, is returned in length. If length isNULL, then no length is returned.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 334
The maximum number of characters that may be written into infoLog, including
the null terminator, is speci?ed by bufSize. The number of characters in the info
log can be queried with GetShaderiv or GetProgramiv withINFO LOG LENGTH.
If shader is a shader object, the returned info log will either be an empty string
or it will contain information about the last compilation attempt for that object. If
program is a program object, the returned info log will either be an empty string or
it will contain information about the last link attempt or last validation attempt for
that object.
The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
info logs.
The command
void GetShaderSource(uint shader,sizei bufSize,
sizei *length,char *source );
returns in source the string making up the source code for the shader object shader.
The string source will be null terminated. The actual number of characters written
into source, excluding the null terminator, is returned in length. If length isNULL,
no length is returned. The maximum number of characters that may be written into
source, including the null terminator, is speci?ed by bufSize. The string source is
a concatenation of the strings passed to the GL using ShaderSource. The length
of this concatenation is given bySHADER SOURCE LENGTH, which can be queried
with GetShaderiv.
The commands
void GetVertexAttribdv(uint index,enum pname,
double *params );
void GetVertexAttribfv(uint index,enum pname,
float *params );
void GetVertexAttribiv(uint index,enum pname,
int *params );
void GetVertexAttribIiv(uint index,enum pname,
int *params );
void GetVertexAttribIuiv(uint index,enum pname,
uint *params );
obtain the vertex attribute state named by pname for the generic vertex attribute
numbered index and places the information in the array params. pname must be
one of
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 335
VERTEX ATTRIB ARRAY BUFFER BINDING, VERTEX ATTRIB ARRAY ENABLED,
VERTEX ATTRIB ARRAY SIZE, VERTEX ATTRIB ARRAY STRIDE,
VERTEX ATTRIB ARRAY TYPE, VERTEX ATTRIB ARRAY NORMALIZED,
VERTEX ATTRIB ARRAY INTEGER, or CURRENT VERTEX ATTRIB. Note that all
the queries exceptCURRENT VERTEX ATTRIB return values stored in the currently
bound vertex array object (the value ofVERTEX ARRAY BINDING). If the zero ob-
ject is bound, these values are client state. The errorINVALID VALUE is generated
if index is greater than or equal toMAX VERTEX ATTRIBS.
All butCURRENT VERTEX ATTRIB return information about generic vertex at-
tribute arrays. The enable state of a generic vertex attribute array is set by the
command EnableVertexAttribArray and cleared by DisableVertexAttribArray.
The size, stride, type, normalized ?ag, and unconverted integer ?ag are set by the
commands VertexAttribPointer and VertexAttribIPointer. The normalized ?ag
is always set to FALSE by VertexAttribIPointer. The unconverted integer ?ag is
always set toFALSE by VertexAttribPointer andTRUE by VertexAttribIPointer.
The queryCURRENT VERTEX ATTRIB returns the current value for the generic
attribute index. GetVertexAttribdv and GetVertexAttribfv read and return the
current attribute values as ?oating-point values; GetVertexAttribiv reads them
as ?oating-point values and converts them to integer values; GetVertexAttribIiv
reads and returns them as integers; GetVertexAttribIuiv reads and returns them
as unsigned integers. The results of the query are unde?ned if the current attribute
values are read using one data type but were speci?ed using a different one. The
error INVALID OPERATION is generated if index is zero, as there is no current
value for generic attribute zero.
The command
void GetVertexAttribPointerv(uint index,enum pname,
void **pointer );
obtains the pointer named pname for the vertex attribute numbered in-
dex and places the information in the array pointer. pname must be
VERTEX ATTRIB ARRAY POINTER. The value returned is queried from the cur-
rently bound vertex array object. If the zero object is bound, the value is queried
from client state. AnINVALID VALUE error is generated if index is greater than or
equal to the value ofMAX VERTEX ATTRIBS.
The commands
void GetUniformfv(uint program,int location,
float *params );
void GetUniformiv(uint program,int location,
int *params );
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 336
void GetUniformuiv(uint program,int location,
uint *params );
return the value or values of the uniform at location location for program object
program in the array params. The type of the uniform at location determines the
number of values returned. The error INVALID OPERATION is generated if pro-
gram has not been linked successfully, or if location is not a valid location for
program. In order to query the values of an array of uniforms, a GetUniform*
command needs to be issued for each array element. If the uniform queried is a
matrix, the values of the matrix are returned in column major order. If an error
occurred, the return parameter params will be unmodi?ed.
6.1.16 Framebuffer Object Queries
The command
boolean IsFramebuffer(uint framebuffer );
returnsTRUE if framebuffer is the name of an framebuffer object. If framebuffer is
zero, or if framebuffer is a non-zero value that is not the name of an framebuffer
object, IsFramebuffer returnFALSE.
The command
void GetFramebufferAttachmentParameteriv(enum target,
enum attachment,enum pname,int *params );
returns information about attachments of a bound framebuffer object. target must
beDRAW FRAMEBUFFER, READ FRAMEBUFFER, orFRAMEBUFFER.FRAMEBUFFER
is equivalent toDRAW FRAMEBUFFER.
If the default framebuffer is bound to target, then attachment must be one of
FRONT LEFT, FRONT RIGHT, BACK LEFT, BACK RIGHT, or AUXi, identifying a
color buffer; DEPTH, identifying the depth buffer; or STENCIL, identifying the
stencil buffer.
If a framebuffer object is bound to target, then attachment must be one of the
attachment points of the framebuffer listed in table 4.12.
If attachment is DEPTH STENCIL ATTACHMENT, and different objects are
bound to the depth and stencil attachment points of target, the query will fail and
generate an INVALID OPERATION error. If the same object is bound to both at-
tachment points, information about that object will be returned.
Upon successful return from GetFramebufferAttachmentParameteriv, if
pname is FRAMEBUFFER ATTACHMENT OBJECT TYPE, then param will contain
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 337
one of NONE, FRAMEBUFFER DEFAULT, TEXTURE, or RENDERBUFFER, identify-
ing the type of object which contains the attached image. Other values accepted
for pname depend on the type of object, as described below.
If the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE is NONE,
no framebuffer is bound to target. In this case querying pname
FRAMEBUFFER ATTACHMENT OBJECT NAME will return zero, and all other
queries will generate anINVALID OPERATION error.
If the value ofFRAMEBUFFER ATTACHMENT OBJECT TYPE is notNONE, these
queries apply to all other framebuffer types:
 If pname is FRAMEBUFFER ATTACHMENT RED SIZE,
FRAMEBUFFER ATTACHMENT GREEN SIZE,
FRAMEBUFFER ATTACHMENT BLUE SIZE,FRAMEBUFFER ATTACHMENT ALPHA SIZE,
FRAMEBUFFER ATTACHMENT DEPTH SIZE, or
FRAMEBUFFER ATTACHMENT STENCIL SIZE, then param will con-
tain the number of bits in the corresponding red, green, blue, alpha, depth,
or stencil component of the speci?ed attachment. Zero is returned if the
requested component is not present in attachment.
 If pname is FRAMEBUFFER ATTACHMENT COMPONENT TYPE, param will
contain the format of components of the speci?ed attachment, one ofFLOAT,
INT, UNSIGNED INT, UNSIGNED NORMALIZED, or INDEX for ?oating-
point, signed integer, unsigned integer, unsigned ?xed-point, or index com-
ponents respectively. Only color buffers may have index or integer compo-
nents.
 If pname is FRAMEBUFFER ATTACHMENT COLOR ENCODING, param will
contain the encoding of components of the speci?ed attachment, one of
LINEAR or SRGB for linear or sRGB-encoded components, respectively.
Only color buffer components may be sRGB-encoded; such components
are treated as described in sections 4.1.8 and 4.1.9. For the default frame-
buffer, color encoding is determined by the implementation. For framebuffer
objects, components are sRGB-encoded if the internal format of a color
attachment is one of the color-renderable SRGB formats described in sec-
tion 3.9.15.
If the value of FRAMEBUFFER ATTACHMENT OBJECT TYPE is
RENDERBUFFER, then
 If pname is FRAMEBUFFER ATTACHMENT OBJECT NAME, params will con-
tain the name of the renderbuffer object which contains the attached image.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 338
If the value ofFRAMEBUFFER ATTACHMENT OBJECT TYPE isTEXTURE, then
 If pname is FRAMEBUFFER ATTACHMENT OBJECT NAME, then params will
contain the name of the texture object which contains the attached image.
 If pname is FRAMEBUFFER ATTACHMENT TEXTURE LEVEL, then params
will contain the mipmap level of the texture object which contains the at-
tached image.
 If pname is FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE and
the texture object named FRAMEBUFFER ATTACHMENT OBJECT NAME is a
cube map texture, then params will contain the cube map face of the cube-
map texture object which contains the attached image. Otherwise params
will contain the value zero.
 If pname is FRAMEBUFFER ATTACHMENT TEXTURE LAYER and the tex-
ture object named FRAMEBUFFER ATTACHMENT OBJECT NAME is a three-
dimensional texture or a one- or two-dimensional array texture, then params
will contain the number of the texture layer which contains the attached im-
age. Otherwise params will contain the value zero.
Any combinations of framebuffer type and pname not described above will
generate anINVALID ENUM error.
6.1.17 Renderbuffer Object Queries
The command
boolean IsRenderbuffer(uint renderbuffer );
returns TRUE if renderbuffer is the name of a renderbuffer object. If renderbuffer
is zero, or if renderbuffer is a non-zero value that is not the name of a renderbuffer
object, IsRenderbuffer returnFALSE.
The command
void GetRenderbufferParameteriv(enum target,enum pname,
int params );
*
returns information about a bound renderbuffer object. target must be
RENDERBUFFER and pname must be one of the symbolic values in table 6.31. If
the renderbuffer currently bound to target is zero, then an INVALID OPERATION
error is generated.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 339
Upon successful return from GetRenderbufferParameteriv,
if pname is RENDERBUFFER WIDTH, RENDERBUFFER HEIGHT,
RENDERBUFFER INTERNAL FORMAT, or RENDERBUFFER SAMPLES, then params
will contain the width in pixels, height in pixels, internal format, or number of
samples, respectively, of the image of the renderbuffer currently bound to target.
If pname is RENDERBUFFER RED SIZE, RENDERBUFFER GREEN SIZE,
RENDERBUFFER BLUE SIZE, RENDERBUFFER ALPHA SIZE,
RENDERBUFFER DEPTH SIZE, or RENDERBUFFER STENCIL SIZE, then params
will contain the actual resolutions, (not the resolutions speci?ed when the image
array was de?ned), for the red, green, blue, alpha depth, or stencil components,
respectively, of the image of the renderbuffer currently bound to target.
Otherwise, anINVALID ENUM error is generated.
6.1.18 Saving and Restoring State
Besides providing a means to obtain the values of state variables, the GL also
provides a means to save and restore groups of state variables. The PushAttrib,
PushClientAttrib, PopAttrib and PopClientAttrib commands are used for this
purpose. The commands
void PushAttrib(bitfield mask );
void PushClientAttrib(bitfield mask );
take a bitwise OR of symbolic constants indicating which groups of state variables
to push onto an attribute stack. PushAttrib uses a server attribute stack while
PushClientAttrib uses a client attribute stack. Each constant refers to a group
of state variables. The classi?cation of each variable into a group is indicated
in the following tables of state variables. The error STACK OVERFLOW is gener-
ated if PushAttrib or PushClientAttrib is executed while the corresponding stack
depth is MAX ATTRIB STACK DEPTH or MAX CLIENT ATTRIB STACK DEPTH re-
spectively. Bits set in mask that do not correspond to an attribute group are ignored.
The special mask valuesALL ATTRIB BITS andCLIENT ALL ATTRIB BITS may
be used to push all stackable server and client state, respectively.
The commands
void PopAttrib(void );
void PopClientAttrib(void );
reset the values of those state variables that were saved with the last corresponding
PushAttrib or PopClientAttrib. Those not saved remain unchanged. The er-
rorSTACK UNDERFLOW is generated if PopAttrib or PopClientAttrib is executed
while the respective stack is empty.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 340
Table 6.2 shows the attribute groups with their corresponding symbolic con-
stant names and stacks.
When PushAttrib is called with TEXTURE BIT set, the priorities, border col-
ors, ?lter modes, wrap modes, and other state of the currently bound texture objects
(see table 6.20), as well as the current texture bindings and enables, are pushed onto
the attribute stack. (Unbound texture objects are not pushed or restored.) When an
attribute set that includes texture information is popped, the bindings and enables
are ?rst restored to their pushed values, then the bound texture object’s parameters
are restored to their pushed values.
Operations on attribute groups push or pop texture state within that group for
all texture units. When state for a group is pushed, all state corresponding to
TEXTURE0 is pushed ?rst, followed by state corresponding to TEXTURE1, and so
on up to and including the state corresponding to TEXTUREk wherek + 1 is the
value of MAX TEXTURE UNITS. When state for a group is popped, texture state is
restored in the opposite order that it was pushed, starting with state corresponding
to TEXTUREk and ending with TEXTURE0. Identical rules are observed for client
texture state push and pop operations. Matrix stacks are never pushed or popped
with PushAttrib, PushClientAttrib, PopAttrib, or PopClientAttrib.
The depth of each attribute stack is implementation dependent but must be at
least 16. The state required for each attribute stack is potentially 16 copies of each
state variable, 16 masks indicating which groups of variables are stored in each
stack entry, and an attribute stack pointer. In the initial state, both attribute stacks
are empty.
In the tables that follow, a type is indicated for each variable. Table 6.3 ex-
plains these types. The type actually identi?es all state associated with the indi-
cated description; in certain cases only a portion of this state is returned. This
is the case with all matrices, where only the top entry on the stack is returned;
with clip planes, where only the selected clip plane is returned, with parameters
describing lights, where only the value pertaining to the selected light is returned;
with textures, where only the selected texture or texture parameter is returned; and
with evaluator maps, where only the selected map is returned. Finally, a “–” in the
attribute column indicates that the indicated value is not included in any attribute
group (and thus can not be pushed or popped with PushAttrib, PushClientAttrib,
PopAttrib, or PopClientAttrib).
TheM andm entries for initial minmax table values represent the maximum
and minimum possible representable values, respectively.
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 341
Stack Attribute Constant
server accum-buffer ACCUM BUFFER BIT
server color-buffer COLOR BUFFER BIT
server current CURRENT BIT
server depth-buffer DEPTH BUFFER BIT
server enable ENABLE BIT
server eval EVAL BIT
server fog FOG BIT
server hint HINT BIT
server lighting LIGHTING BIT
server line LINE BIT
server list LIST BIT
server multisample MULTISAMPLE BIT
server pixel PIXEL MODE BIT
server point POINT BIT
server polygon POLYGON BIT
server polygon-stipple POLYGON STIPPLE BIT
server scissor SCISSOR BIT
server stencil-buffer STENCIL BUFFER BIT
server texture TEXTURE BIT
server transform TRANSFORM BIT
server viewport VIEWPORT BIT
server ALL ATTRIB BITS
client vertex-array CLIENT VERTEX ARRAY BIT
client pixel-store CLIENT PIXEL STORE BIT
client select can’t be pushed or pop’d
client feedback can’t be pushed or pop’d
client CLIENT ALL ATTRIB BITS
Table 6.2: Attribute groups
Version 3.0 (September 23, 2008)6.1. QUERYINGGLSTATE 342
Type code Explanation
B Boolean
BMU Basic machine units
C Color (?oating-point R, G, B, and A values)
CI Color index (?oating-point index value)
T Texture coordinates (?oating-point (s;t;r;q) val-
ues)
N Normal coordinates (?oating-point (x;y;z) val-
ues)
V Vertex, including associated data
Z Integer
+
Z Non-negative integer
Z ,Z k-valued integer (k indicatesk is minimum)
k k
R Floating-point number
+
R Non-negative ?oating-point number
[a;b]
R Floating-point number in the range [a;b]
k
R k-tuple of ?oating-point numbers
P Position ((x;y;z;w) ?oating-point coordinates)
D Direction ((x;y;z) ?oating-point coordinates)
4
M 4 4 ?oating-point matrix
S NULL-terminated string
I Image
A Attribute stack entry, including mask
Y Pointer (data type unspeci?ed)
ntype n copies of typetype (n indicatesn is minimum)
Table 6.3: State Variable Types
Version 3.0 (September 23, 2008)6.2. STATETABLES 343
6.2 State Tables
The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of GetBooleanv,
GetIntegerv, GetFloatv, or GetDoublev are listed with just one of these com-
mands – the one that is most appropriate given the type of the data to be returned.
These state variables cannot be obtained using IsEnabled. However, state vari-
ables for which IsEnabled is listed as the query command can also be obtained
using GetBooleanv, GetIntegerv, GetFloatv, and GetDoublev. State variables
for which any other command is listed as the query command can be obtained only
by using that command.
State table entries which are required only by the imaging subset (see sec-
tion 3.7.2) are typeset against a gray background .
Version 3.0 (September 23, 2008)6.2. STATETABLES 344
6
Table 6.4. GL Internal begin-end state variables (inaccessible)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
– Z – 0 2.6.1 –
11
When = 0, indicates begin/end ob-
ject
– V – – 2.6.1 –
Previous vertex in Begin/End line
– B – – 2.6.1 –
Indicates if line-vertex is the ?rst
– V – – 2.6.1 –
First vertex of a Begin/End line
loop
+
– Z – – 3.5 –
Line stipple counter
– nV – – 2.6.1 –
Vertices inside of Begin/End poly-
gon
+
– Z – – 2.6.1 –
Number of polygon-vertices
– 2V – – 2.6.1 –
Previous two vertices in a Be-
gin/End triangle strip
– Z – – 2.6.1 –
3
Number of vertices so far in triangle
strip: 0, 1, or more
– Z – – 2.6.1 –
2
Triangle strip A/B vertex pointer
– 3V – – 2.6.1 –
Vertices of the quad under construc-
tion
– Z – – 2.6.1 –
4
Number of vertices so far in quad
strip: 0, 1, 2, or more6.2. STATETABLES 345
Table 6.5. Current Values and Associated Data
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
CURRENT COLOR C GetFloatv 1,1,1,1 2.7 current
Current color
CURRENT SECONDARY COLOR C GetFloatv 0,0,0,1 2.7 current
Current secondary color
CURRENT INDEX CI GetIntegerv 1 2.7 current
Current color index
CURRENT TEXTURE COORDS 2T GetFloatv 0,0,0,1 2.7 current
Current texture coordinates
CURRENT NORMAL N GetFloatv 0,0,1 2.7 current
Current normal
CURRENT FOG COORD R GetFloatv 0 2.7 current
Current fog coordinate
– C – - 2.6 –
Color associated with last vertex
– CI – - 2.6 –
Color index associated with last ver-
tex
– T – - 2.6 –
Texture coordinates associated with
last vertex
4
CURRENT RASTER POSITION R GetFloatv 0,0,0,1 2.18 current
Current raster position
+
CURRENT RASTER DISTANCE R GetFloatv 0 2.18 current
Current raster distance
CURRENT RASTER COLOR C GetFloatv 1,1,1,1 2.18 current
Color associated with raster position
CURRENT RASTER SECONDARY COLOR C GetFloatv 0,0,0,1 2.18 current
Secondary color associated with
raster position
CURRENT RASTER INDEX CI GetIntegerv 1 2.18 current
Color index associated with raster
position
CURRENT RASTER TEXTURE COORDS 2T GetFloatv 0,0,0,1 2.18 current
Texture coordinates associated with
raster position
CURRENT RASTER POSITION VALID B GetBooleanv TRUE 2.18 current
Raster position valid bit
EDGE FLAG B GetBooleanv TRUE 2.6.2 current
Edge ?ag6.2. STATETABLES 346
Table 6.6. Vertex Array Object State
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
VERTEX ARRAY B IsEnabled FALSE 2.8 vertex-array
Vertex array enable
+
VERTEX ARRAY SIZE Z GetIntegerv 4 2.8 vertex-array
Coordinates per vertex
VERTEX ARRAY TYPE Z GetIntegerv FLOAT 2.8 vertex-array
4
Type of vertex coordinates
+
VERTEX ARRAY STRIDE Z GetIntegerv 0 2.8 vertex-array
Stride between vertices
VERTEX ARRAY POINTER Y GetPointerv 0 2.8 vertex-array
Pointer to the vertex array
NORMAL ARRAY B IsEnabled FALSE 2.8 vertex-array
Normal array enable
NORMAL ARRAY TYPE Z GetIntegerv FLOAT 2.8 vertex-array
5
Type of normal coordinates
+
NORMAL ARRAY STRIDE Z GetIntegerv 0 2.8 vertex-array
Stride between normals
NORMAL ARRAY POINTER Y GetPointerv 0 2.8 vertex-array
Pointer to the normal array
FOG COORD ARRAY B IsEnabled FALSE 2.8 vertex-array
Fog coord array enable
FOG COORD ARRAY TYPE Z GetIntegerv FLOAT 2.8 vertex-array
2
Type of fog coord components
+
FOG COORD ARRAY STRIDE Z GetIntegerv 0 2.8 vertex-array
Stride between fog coords
FOG COORD ARRAY POINTER Y GetPointerv 0 2.8 vertex-array
Pointer to the fog coord array
COLOR ARRAY B IsEnabled FALSE 2.8 vertex-array
Color array enable
+
COLOR ARRAY SIZE Z GetIntegerv 4 2.8 vertex-array
Color components per vertex
COLOR ARRAY TYPE Z GetIntegerv FLOAT 2.8 vertex-array
8
Type of color components
+
COLOR ARRAY STRIDE Z GetIntegerv 0 2.8 vertex-array
Stride between colors
COLOR ARRAY POINTER Y GetPointerv 0 2.8 vertex-array
Pointer to the color array6.2. STATETABLES 347
Table 6.7. Vertex Array Object State (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
SECONDARY COLOR ARRAY B FALSE 2.8 vertex-array
IsEnabled Secondary color array
enable
+
SECONDARY COLOR ARRAY SIZE Z 3 2.8 vertex-array
GetIntegerv Secondary color compo-
nents per vertex
SECONDARY COLOR ARRAY TYPE Z FLOAT 2.8 vertex-array
8
GetIntegerv Type of secondary color
components
+
SECONDARY COLOR ARRAY STRIDE Z 0 2.8 vertex-array
GetIntegerv Stride between sec-
ondary colors
SECONDARY COLOR ARRAY POINTER Y 0 2.8 vertex-array
GetPointerv Pointer to the secondary
color array
INDEX ARRAY B FALSE 2.8 vertex-array
IsEnabled Index array enable
INDEX ARRAY TYPE Z FLOAT 2.8 vertex-array
4
GetIntegerv Type of indices
+
INDEX ARRAY STRIDE Z 0 2.8 vertex-array
GetIntegerv Stride between indices
INDEX ARRAY POINTER Y 0 2.8 vertex-array
GetPointerv Pointer to the index array
TEXTURE COORD ARRAY 2B FALSE 2.8 vertex-array
IsEnabled Texture coordinate array
enable
+
TEXTURE COORD ARRAY SIZE 2Z 4 2.8 vertex-array
GetIntegerv Coordinates per element
TEXTURE COORD ARRAY TYPE 2Z FLOAT 2.8 vertex-array
4
GetIntegerv Type of texture coordi-
nates
+
TEXTURE COORD ARRAY STRIDE 2Z 0 2.8 vertex-array
GetIntegerv Stride between texture
coordinates
TEXTURE COORD ARRAY POINTER 2Y 0 2.8 vertex-array
GetPointerv Pointer to the texture co-
ordinate array6.2. STATETABLES 348
Table 6.8. Vertex Array Object State (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
VERTEX ATTRIB ARRAY ENABLED 16B FALSE 2.8 vertex-array
GetVertexAttribiv Vertex attrib array enable
VERTEX ATTRIB ARRAY SIZE 16Z 4 2.8 vertex-array
GetVertexAttribiv Vertex attrib array size
+
VERTEX ATTRIB ARRAY STRIDE 16Z 0 2.8 vertex-array
GetVertexAttribiv Vertex attrib array stride
VERTEX ATTRIB ARRAY TYPE 16Z FLOAT 2.8 vertex-array
4
GetVertexAttribiv Vertex attrib array type
VERTEX ATTRIB ARRAY NORMALIZED 16B FALSE 2.8 vertex-array
GetVertexAttribiv Vertex attrib array nor-
malized
VERTEX ATTRIB ARRAY INTEGER 16B FALSE 2.8 vertex-array
GetVertexAttribiv Vertex attrib array has
unconverted integers
VERTEX ATTRIB ARRAY POINTER 16Y NULL 2.8 vertex-array
GetVertex- Vertex attrib array
AttribPointerv pointer
EDGE FLAG ARRAY B FALSE 2.8 vertex-array
IsEnabled Edge ?ag array enable
+
EDGE FLAG ARRAY STRIDE Z 0 2.8 vertex-array
GetIntegerv Stride between edge ?ags
EDGE FLAG ARRAY POINTER Y 0 2.8 vertex-array
GetPointerv Pointer to the edge ?ag
array6.2. STATETABLES 349
Table 6.9. Vertex Array Object State (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
VERTEX ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Vertex array buffer bind-
ing
+
NORMAL ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Normal array buffer
binding
+
COLOR ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Color array buffer bind-
ing
+
INDEX ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Index array buffer bind-
ing
+
TEXTURE COORD ARRAY BUFFER BINDING 2Z 0 2.9 vertex-array
GetIntegerv Texcoord array buffer
binding
+
EDGE FLAG ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Edge ?ag array buffer
binding
+
SECONDARY COLOR ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Secondary color array
buffer binding
+
FOG COORD ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Fog coordinate array
buffer binding
+
ELEMENT ARRAY BUFFER BINDING Z 0 2.9.3 vertex-array
GetIntegerv Element array buffer
binding
+
VERTEX ATTRIB ARRAY BUFFER BINDING 16Z 0 2.9 vertex-array
GetVertexAttribiv Attribute array buffer
binding
+
VERTEX ARRAY BINDING Z 0 2.10 vertex-array
GetIntegerv Current vertex array ob-
ject binding6.2. STATETABLES 350
Table 6.10. Vertex Array Data (not in Vertex Array objects)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
CLIENT ACTIVE TEXTURE Z TEXTURE0 2.7 vertex-array
2
GetIntegerv Client active texture unit
selector
+
ARRAY BUFFER BINDING Z 0 2.9 vertex-array
GetIntegerv Current buffer binding6.2. STATETABLES 351
Table 6.11. Buffer Object State
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
– nBMU GetBufferSubData - 2.9 -
buffer data
+
BUFFER SIZE nZ GetBufferParameteriv 0 2.9 -
Buffer data size
9
BUFFER USAGE nZ GetBufferParameteriv STATIC DRAW 2.9 -
Buffer usage pattern
3
BUFFER ACCESS nZ GetBufferParameteriv READ WRITE 2.9 -
Buffer access ?ag
+
BUFFER ACCESS FLAGS nZ GetBufferParameteriv 0 2.9 -
Extended buffer access ?ag
BUFFER MAPPED nB GetBufferParameteriv FALSE 2.9 -
Buffer map ?ag
BUFFER MAP POINTER nY GetBufferPointerv NULL 2.9 -
Mapped buffer pointer
+
BUFFER MAP OFFSET nZ GetBufferPointerv 0 2.9 -
Start of mapped buffer range
+
BUFFER MAP LENGTH nZ GetBufferPointerv 0 2.9 -
Size of mapped buffer range6.2. STATETABLES 352
Table 6.12. Transformation state
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
4
2M GetFloatv Identity 3.7.3 –
COLOR MATRIX Color matrix stack
(TRANSPOSE COLOR MATRIX)
4
32M GetFloatv Identity 2.12.2 –
MODELVIEW MATRIX Model-view matrix stack
(TRANSPOSE MODELVIEW MATRIX)
4
2M GetFloatv Identity 2.12.2 –
PROJECTION MATRIX Projection matrix stack
(TRANSPOSE PROJECTION MATRIX)
4
22M GetFloatv Identity 2.12.2 –
TEXTURE MATRIX Texture matrix stack
(TRANSPOSE TEXTURE MATRIX)
4Z GetIntegerv see 2.12.1 2.12.1 viewport
VIEWPORT Viewport origin & extent
+
2R GetFloatv 0,1 2.12.1 viewport
DEPTH RANGE Depth range near & far
+
Z GetIntegerv 1 3.7.3 –
COLOR MATRIX STACK DEPTH Color matrix stack
pointer
+
Z GetIntegerv 1 2.12.2 –
MODELVIEW STACK DEPTH Model-view matrix stack
pointer
+
Z GetIntegerv 1 2.12.2 –
PROJECTION STACK DEPTH Projection matrix stack
pointer
+
2Z GetIntegerv 1 2.12.2 –
TEXTURE STACK DEPTH Texture matrix stack
pointer
Z GetIntegerv MODELVIEW 2.12.2 transform
4
MATRIX MODE Current matrix mode
B IsEnabled FALSE 2.12.3 transform/enable
NORMALIZE Current normal normal-
ization on/off
B IsEnabled FALSE 2.12.3 transform/enable
RESCALE NORMAL Current normal rescaling
on/off
4
6R GetClipPlane 0,0,0,0 2.17 transform
CLIP PLANEi User clipping plane coef-
?cients
6B IsEnabled FALSE 2.17 transform/enable
CLIP PLANEi ith user clipping plane
enabled6.2. STATETABLES 353
Table 6.13. Coloring
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
FOG COLOR C GetFloatv 0,0,0,0 3.11 fog
Fog color
FOG INDEX CI GetFloatv 0 3.11 fog
Fog index
FOG DENSITY R GetFloatv 1.0 3.11 fog
Exponential fog density
FOG START R GetFloatv 0.0 3.11 fog
Linear fog start
FOG END R GetFloatv 1.0 3.11 fog
Linear fog end
FOG MODE Z GetIntegerv EXP 3.11 fog
3
Fog mode
FOG B IsEnabled FALSE 3.11 fog/enable
True if fog enabled
FOG COORD SRC Z GetIntegerv FRAGMENT DEPTH 3.11 fog
2
Source of coordinate for fog calcu-
lation
COLOR SUM B IsEnabled FALSE 3.10 fog/enable
True if color sum enabled
+
SHADE MODEL Z GetIntegerv SMOOTH 2.19.7 lighting
ShadeModel setting
CLAMP VERTEX COLOR Z GetIntegerv TRUE 2.19.6 lighting/enable
3
Vertex color clamping
CLAMP FRAGMENT COLOR Z GetIntegerv FIXED ONLY 3.8 color-buffer/enable
3
Fragment color clamping
CLAMP READ COLOR Z GetIntegerv FIXED ONLY 4.2 color-buffer/enable
3
Read color clamping6.2. STATETABLES 354
Table 6.14. Lighting (see also table 2.11 for defaults)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
LIGHTING B IsEnabled FALSE 2.19.1 lighting/enable
True if lighting is
enabled
COLOR MATERIAL B IsEnabled FALSE 2.19.3 lighting/enable
True if color
tracking is en-
abled
COLOR MATERIAL PARAMETER Z GetIntegerv AMBIENT AND DIFFUSE 2.19.3 lighting
5
Material prop-
erties tracking
current color
COLOR MATERIAL FACE Z GetIntegerv FRONT AND BACK 2.19.3 lighting
3
Face(s) affected
by color tracking
AMBIENT 2C GetMaterialfv (0.2,0.2,0.2,1.0) 2.19.1 lighting
Ambient material
color
DIFFUSE 2C GetMaterialfv (0.8,0.8,0.8,1.0) 2.19.1 lighting
Diffuse material
color
SPECULAR 2C GetMaterialfv (0.0,0.0,0.0,1.0) 2.19.1 lighting
Specular material
color
EMISSION 2C GetMaterialfv (0.0,0.0,0.0,1.0) 2.19.1 lighting
Emissive mat.
color
SHININESS 2R GetMaterialfv 0.0 2.19.1 lighting
Specular expo-
nent of material
LIGHT MODEL AMBIENT C GetFloatv (0.2,0.2,0.2,1.0) 2.19.1 lighting
Ambient scene
color
LIGHT MODEL LOCAL VIEWER B GetBooleanv FALSE 2.19.1 lighting
Viewer is local
LIGHT MODEL TWO SIDE B GetBooleanv FALSE 2.19.1 lighting
Use two-sided
lighting
LIGHT MODEL COLOR CONTROL Z GetIntegerv SINGLE COLOR 2.19.1 lighting
2
Color control6.2. STATETABLES 355
Table 6.15. Lighting (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
AMBIENT 8C GetLightfv (0.0,0.0,0.0,1.0) 2.19.1 lighting
Ambient intensity of lighti
DIFFUSE 8C GetLightfv see table 2.11 2.19.1 lighting
Diffuse intensity of lighti
SPECULAR 8C GetLightfv see table 2.11 2.19.1 lighting
Specular intensity of lighti
POSITION 8P GetLightfv (0.0,0.0,1.0,0.0) 2.19.1 lighting
Position of lighti
+
CONSTANT ATTENUATION 8R GetLightfv 1.0 2.19.1 lighting
Constant atten. factor
+
LINEAR ATTENUATION 8R GetLightfv 0.0 2.19.1 lighting
Linear atten. factor
+
QUADRATIC ATTENUATION 8R GetLightfv 0.0 2.19.1 lighting
Quadratic atten. factor
SPOT DIRECTION 8D GetLightfv (0.0,0.0,-1.0) 2.19.1 lighting
Spotlight direction of lighti
+
SPOT EXPONENT 8R GetLightfv 0.0 2.19.1 lighting
Spotlight exponent of lighti
+
SPOT CUTOFF 8R GetLightfv 180.0 2.19.1 lighting
Spot. angle of lighti
LIGHTi 8B IsEnabled FALSE 2.19.1 lighting/enable
True if lighti enabled
COLOR INDEXES 2 3R GetMaterialfv 0,1,1 2.19.1 lighting
a , d , and s for color index
m m m
lighting6.2. STATETABLES 356
Table 6.16. Rasterization
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
POINT SIZE R GetFloatv 1.0 3.4 point
Point size
POINT SMOOTH B IsEnabled FALSE 3.4 point/enable
Point antialiasing on
POINT SPRITE B IsEnabled FALSE 3.4 point/enable
Point sprite enable
+
POINT SIZE MIN R GetFloatv 0.0 3.4 point
Attenuated minimum point size
+ 1
POINT SIZE MAX R GetFloatv 3.4 point
1
Attenuated maximum point size.
Max. of the impl. dependent max.
aliased and smooth point sizes.
+
POINT FADE THRESHOLD SIZE R GetFloatv 1.0 3.4 point
Threshold for alpha attenuation
+
POINT DISTANCE ATTENUATION 3R GetFloatv 1,0,0 3.4 point
Attenuation coef?cients
POINT SPRITE COORD ORIGIN Z GetIntegerv UPPER LEFT 3.4 point
2
Origin orientation for point sprites
+
LINE WIDTH R GetFloatv 1.0 3.5 line
Line width
LINE SMOOTH B IsEnabled FALSE 3.5 line/enable
Line antialiasing on
+
LINE STIPPLE PATTERN Z GetIntegerv 1’s 3.5.2 line
Line stipple
+
LINE STIPPLE REPEAT Z GetIntegerv 1 3.5.2 line
Line stipple repeat
LINE STIPPLE B IsEnabled FALSE 3.5.2 line/enable
Line stipple enable6.2. STATETABLES 357
Table 6.17. Rasterization (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
CULL FACE B IsEnabled FALSE 3.6.1 polygon/enable
Polygon culling enabled
CULL FACE MODE Z GetIntegerv BACK 3.6.1 polygon
3
Cull front/back facing polygons
FRONT FACE Z GetIntegerv CCW 3.6.1 polygon
2
Polygon frontface CW/CCW indica-
tor
POLYGON SMOOTH B IsEnabled FALSE 3.6 polygon/enable
Polygon antialiasing on
POLYGON MODE 2Z GetIntegerv FILL 3.6.4 polygon
3
Polygon rasterization mode (front &
back)
POLYGON OFFSET FACTOR R GetFloatv 0 3.6.5 polygon
Polygon offset factor
POLYGON OFFSET UNITS R GetFloatv 0 3.6.5 polygon
Polygon offset units
POLYGON OFFSET POINT B IsEnabled FALSE 3.6.5 polygon/enable
Polygon offset enable for POINT
mode rasterization
POLYGON OFFSET LINE B IsEnabled FALSE 3.6.5 polygon/enable
Polygon offset enable for LINE
mode rasterization
POLYGON OFFSET FILL B IsEnabled FALSE 3.6.5 polygon/enable
Polygon offset enable for FILL
mode rasterization
– I GetPolygonStipple 1’s 3.6 polygon-stipple
Polygon stipple
POLYGON STIPPLE B IsEnabled FALSE 3.6.2 polygon/enable
Polygon stipple enable6.2. STATETABLES 358
Table 6.18. Multisampling
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
MULTISAMPLE B IsEnabled TRUE 3.3.1 multisample/enable
Multisample rasterization
SAMPLE ALPHA TO COVERAGE B IsEnabled FALSE 4.1.3 multisample/enable
Modify coverage from alpha
SAMPLE ALPHA TO ONE B IsEnabled FALSE 4.1.3 multisample/enable
Set alpha to maximum
SAMPLE COVERAGE B IsEnabled FALSE 4.1.3 multisample/enable
Mask to modify coverage
+
SAMPLE COVERAGE VALUE R GetFloatv 1 4.1.3 multisample
Coverage mask value
SAMPLE COVERAGE INVERT B GetBooleanv FALSE 4.1.3 multisample
Invert coverage mask value6.2. STATETABLES 359
Table 6.19. Textures (state per texture unit and binding point)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
23B IsEnabled FALSE 3.9.17 texture/enable
TEXTURE xD True if xD texturing is
enabled;x is1,2, or3
2B IsEnabled FALSE 3.9.13 texture/enable
TEXTURE CUBE MAP True if cube map textur-
ing is enabled
+
23Z GetIntegerv 0 3.9.12 texture
TEXTURE BINDING xD Texture object bound to
TEXTURE xD
+
23Z GetIntegerv 0 3.9.12 texture
TEXTURE BINDING 1D ARRAY Texture object bound to
TEXTURE 1D ARRAY
+
23Z GetIntegerv 0 3.9.12 texture
TEXTURE BINDING 2D ARRAY Texture object bound to
TEXTURE 2D ARRAY
+
2Z GetIntegerv 0 3.9.11 texture
TEXTURE BINDING CUBE MAP Texture object bound to
TEXTURE CUBE MAP
nI GetTexImage see 3.9 3.9 –
TEXTURE xD xD texture image at l.o.d.
i
nI GetTexImage see 3.9.1 3.9.1 –
TEXTURE CUBE MAP POSITIVE X +x face cube map tex-
ture image at l.o.d.i
nI GetTexImage see 3.9.1 3.9.1 –
TEXTURE CUBE MAP NEGATIVE X  x face cube map tex-
ture image at l.o.d.i
nI GetTexImage see 3.9.1 3.9.1 –
TEXTURE CUBE MAP POSITIVE Y +y face cube map texture
image at l.o.d.i
nI GetTexImage see 3.9.1 3.9.1 –
TEXTURE CUBE MAP NEGATIVE Y  y face cube map texture
image at l.o.d.i
nI GetTexImage see 3.9.1 3.9.1 –
TEXTURE CUBE MAP POSITIVE Z +z face cube map texture
image at l.o.d.i
nI GetTexImage see 3.9.1 3.9.1 –
TEXTURE CUBE MAP NEGATIVE Z  z face cube map texture
image at l.o.d.i6.2. STATETABLES 360
Table 6.20. Textures (state per texture object)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
nC GetTexParameter 0,0,0,0 3.9 texture
TEXTURE BORDER COLOR Border color
nZ GetTexParameter see 3.9 3.9.7 texture
6
TEXTURE MIN FILTER Minification function
nZ GetTexParameter see 3.9 3.9.8 texture
2
TEXTURE MAG FILTER Magnification function
nZ GetTexParameter REPEAT 3.9.7 texture
5
TEXTURE WRAP S Texcoords wrap mode
nZ GetTexParameter REPEAT 3.9.7 texture
5
TEXTURE WRAP T Texcoord t wrap mode
(2D, 3D, cube map tex-
tures only)
nZ GetTexParameter REPEAT 3.9.7 texture
5
TEXTURE WRAP R Texcoord r wrap mode
(3D textures only)
[0;1]
nR GetTexParameterfv 1 3.9.12 texture
TEXTURE PRIORITY Texture object priority
nB GetTexParameteriv see 3.9.12 3.9.12 texture
TEXTURE RESIDENT Texture residency
nR GetTexParameterfv -1000 3.9 texture
TEXTURE MIN LOD Minimum level of detail
nR GetTexParameterfv 1000 3.9 texture
TEXTURE MAX LOD Maximum level of detail
+
nZ GetTexParameterfv 0 3.9 texture
TEXTURE BASE LEVEL Base texture array
+
nZ GetTexParameterfv 1000 3.9 texture
TEXTURE MAX LEVEL Max. texture array level
nR GetTexParameterfv 0.0 3.9.7 texture
TEXTURE LOD BIAS Texture level of detail
bias (bias )
texobj
nZ GetTexParameteriv LUMINANCE 3.9.5 texture
3
DEPTH TEXTURE MODE Depth texture mode
nZ GetTexParameteriv NONE 3.9.14 texture
2
TEXTURE COMPARE MODE Comparison mode
nZ GetTexParameteriv LEQUAL 3.9.14 texture
8
TEXTURE COMPARE FUNC Comparison function
nB GetTexParameter FALSE 3.9.7 texture
GENERATE MIPMAP Automatic mipmap gen-
eration enabled6.2. STATETABLES 361
Table 6.21. Textures (state per texture image)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
nZ GetTexLevelParameter 0 3.9 –
TEXTURE WIDTH Speci?ed width
+
nZ GetTexLevelParameter 0 3.9 –
TEXTURE HEIGHT Speci?ed height (2D/3D)
+
nZ GetTexLevelParameter 0 3.9 –
TEXTURE DEPTH Speci?ed depth (3D)
+
nZ GetTexLevelParameter 0 3.9 –
TEXTURE BORDER Speci?ed border width
nZ GetTexLevelParameter 1 3.9 –
68
TEXTURE INTERNAL FORMAT Internal format
(TEXTURE COMPONENTS)
+
n 8Z GetTexLevelParameter 0 3.9 –
TEXTURE x SIZE Component resolution (x
is RED, GREEN, BLUE,
ALPHA, LUMINANCE,
INTENSITY, DEPTH,
orSTENCIL)
+
nZ GetTexLevelParameter 0 3.9 –
TEXTURE SHARED SIZE Shared exponent ?eld
resolution
nZ GetTexLevelParameter NONE 6.1.3 –
5
TEXTURE x TYPE Component type (x is
RED, GREEN, BLUE,
ALPHA, LUMINANCE,
INTENSITY, or
DEPTH)
nB GetTexLevelParameter FALSE 3.9.3 -
TEXTURE COMPRESSED True if image has a com-
pressed internal format
+
nZ GetTexLevelParameter 0 3.9.3 -
TEXTURE COMPRESSED IMAGE SIZE size (inubytes) of com-
pressed image6.2. STATETABLES 362
Table 6.22. Texture Environment and Generation
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
COORD REPLACE 2B GetTexEnviv FALSE 3.4 point
Coordinate replacement enable
ACTIVE TEXTURE Z GetIntegerv TEXTURE0 2.7 texture
2
Active texture unit selector
TEXTURE ENV MODE 2Z GetTexEnviv MODULATE 3.9.13 texture
6
Texture application function
TEXTURE ENV COLOR 2C GetTexEnvfv 0,0,0,0 3.9.13 texture
Texture environment color
TEXTURE LOD BIAS 2R GetTexEnvfv 0.0 3.9.7 texture
Texture level of detail bias
bias
texunit
TEXTURE GEN x 24B IsEnabled FALSE 2.12.4 texture/enable
Texgen enabled (x is S, T, R, or Q)
4
EYE PLANE 24R GetTexGenfv see 2.12.4 2.12.4 texture
Texgen plane equation coef?cients
(for S, T, R, and Q)
4
OBJECT PLANE 24R GetTexGenfv see 2.12.4 2.12.4 texture
Texgen object linear coef?cients
(for S, T, R, and Q)
TEXTURE GEN MODE 24Z GetTexGeniv EYE LINEAR 2.12.4 texture
5
Function used for texgen (for S, T,
R, and Q
COMBINE RGB 2Z GetTexEnviv MODULATE 3.9.13 texture
8
RGB combiner function
COMBINE ALPHA 2Z GetTexEnviv MODULATE 3.9.13 texture
6
Alpha combiner function6.2. STATETABLES 363
Table 6.23. Texture Environment and Generation (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
SRC0 RGB 2Z GetTexEnviv TEXTURE 3.9.13 texture
3
RGB source 0
SRC1 RGB 2Z GetTexEnviv PREVIOUS 3.9.13 texture
3
RGB source 1
SRC2 RGB 2Z GetTexEnviv CONSTANT 3.9.13 texture
3
RGB source 2
SRC0 ALPHA 2Z GetTexEnviv TEXTURE 3.9.13 texture
3
Alpha source 0
SRC1 ALPHA 2Z GetTexEnviv PREVIOUS 3.9.13 texture
3
Alpha source 1
SRC2 ALPHA 2Z GetTexEnviv CONSTANT 3.9.13 texture
3
Alpha source 2
OPERAND0 RGB 2Z GetTexEnviv SRC COLOR 3.9.13 texture
4
RGB operand 0
OPERAND1 RGB 2Z GetTexEnviv SRC COLOR 3.9.13 texture
4
RGB operand 1
OPERAND2 RGB 2Z GetTexEnviv SRC ALPHA 3.9.13 texture
4
RGB operand 2
OPERAND0 ALPHA 2Z GetTexEnviv SRC ALPHA 3.9.13 texture
2
Alpha operand 0
OPERAND1 ALPHA 2Z GetTexEnviv SRC ALPHA 3.9.13 texture
2
Alpha operand 1
OPERAND2 ALPHA 2Z GetTexEnviv SRC ALPHA 3.9.13 texture
2
Alpha operand 2
3
RGB SCALE 2R GetTexEnvfv 1.0 3.9.13 texture
RGB post-combiner scaling
3
ALPHA SCALE 2R GetTexEnvfv 1.0 3.9.13 texture
Alpha post-combiner scaling6.2. STATETABLES 364
Table 6.24. Pixel Operations
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
SCISSOR TEST B IsEnabled FALSE 4.1.2 scissor/enable
Scissoring enabled
SCISSOR BOX 4Z GetIntegerv see 4.1.2 4.1.2 scissor
Scissor box
ALPHA TEST B IsEnabled FALSE 4.1.4 color-buffer/enable
Alpha test enabled
ALPHA TEST FUNC Z GetIntegerv ALWAYS 4.1.4 color-buffer
8
Alpha test function
+
ALPHA TEST REF R GetIntegerv 0 4.1.4 color-buffer
Alpha test reference value
STENCIL TEST B IsEnabled FALSE 4.1.5 stencil-buffer/enable
Stenciling enabled
STENCIL FUNC Z GetIntegerv ALWAYS 4.1.5 stencil-buffer
8
Front stencil function
+
STENCIL VALUE MASK Z GetIntegerv 1’s 4.1.5 stencil-buffer
Front stencil mask
+
STENCIL REF Z GetIntegerv 0 4.1.5 stencil-buffer
Front stencil reference value
STENCIL FAIL Z GetIntegerv KEEP 4.1.5 stencil-buffer
8
Front stencil fail action
STENCIL PASS DEPTH FAIL Z GetIntegerv KEEP 4.1.5 stencil-buffer
8
Front stencil depth buffer fail action
STENCIL PASS DEPTH PASS Z GetIntegerv KEEP 4.1.5 stencil-buffer
8
Front stencil depth buffer pass ac-
tion
STENCIL BACK FUNC Z GetIntegerv ALWAYS 4.1.5 stencil-buffer
8
Back stencil function
+
STENCIL BACK VALUE MASK Z GetIntegerv 1’s 4.1.5 stencil-buffer
Back stencil mask
+
STENCIL BACK REF Z GetIntegerv 0 4.1.5 stencil-buffer
Back stencil reference value
STENCIL BACK FAIL Z GetIntegerv KEEP 4.1.5 stencil-buffer
8
Back stencil fail action
STENCIL BACK PASS DEPTH FAIL Z GetIntegerv KEEP 4.1.5 stencil-buffer
8
Back stencil depth buffer fail action
STENCIL BACK PASS DEPTH PASS Z GetIntegerv KEEP 4.1.5 stencil-buffer
8
Back stencil depth buffer pass action6.2. STATETABLES 365
Table 6.25. Pixel Operations (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
B IsEnabled FALSE 4.1.6 depth-buffer/enable
DEPTH TEST Depth buffer enabled
Z GetIntegerv LESS 4.1.6 depth-buffer
8
DEPTH FUNC Depth buffer test func-
tion
1B IsEnabledi FALSE 4.1.8 color-buffer/enable
BLEND Blending enabled for
draw bufferi
Z GetIntegerv ONE 4.1.8 color-buffer
15
BLEND SRC RGB (v1.3:BLEND SRC) Blending source RGB
function
Z GetIntegerv ONE 4.1.8 color-buffer
15
BLEND SRC ALPHA Blending source A func-
tion
Z GetIntegerv ZERO 4.1.8 color-buffer
14
BLEND DST RGB (v1.3:BLEND DST) Blending dest. RGB
function
Z GetIntegerv ZERO 4.1.8 color-buffer
14
BLEND DST ALPHA Blending dest. A func-
tion
Z GetIntegerv FUNC ADD 4.1.8 color-buffer
5
BLEND EQUATION RGB RGB blending equation
(v1.5: BLEND EQUATION)
Z GetIntegerv FUNC ADD 4.1.8 color-buffer
5
BLEND EQUATION ALPHA Alpha blending equation
C GetFloatv 0,0,0,0 4.1.8 color-buffer
BLEND COLOR Constant blend color
B IsEnabled FALSE 4.1.8 color-buffer/enable
FRAMEBUFFER SRGB sRGB update and blend-
ing enable
B IsEnabled TRUE 4.1.10 color-buffer/enable
DITHER Dithering enabled
B IsEnabled FALSE 4.1.11 color-buffer/enable
INDEX LOGIC OP (v1.0:LOGIC OP) Index logic op enabled
B IsEnabled FALSE 4.1.11 color-buffer/enable
COLOR LOGIC OP Color logic op enabled
Z GetIntegerv COPY 4.1.11 color-buffer
16
LOGIC OP MODE Logic op function6.2. STATETABLES 366
Table 6.26. Framebuffer Control
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
INDEX WRITEMASK Z GetIntegerv 1’s 4.2.2 color-buffer
Color index
writemask
COLOR WRITEMASK 14B GetBooleani v (TRUE,TRUE,TRUE,TRUE) 4.2.2 color-buffer
Color write en-
ables (R,G,B,A)
for draw bufferi
DEPTH WRITEMASK B GetBooleanv TRUE 4.2.2 depth-buffer
Depth buffer en-
abled for writing
+
STENCIL WRITEMASK Z GetIntegerv 1’s 4.2.2 stencil-buffer
Front stencil
buffer writemask
+
STENCIL BACK WRITEMASK Z GetIntegerv 1’s 4.2.2 stencil-buffer
Back stencil
buffer writemask
COLOR CLEAR VALUE C GetFloatv 0,0,0,0 4.2.3 color-buffer
Color buffer clear
value (RGBA
mode)
INDEX CLEAR VALUE CI GetFloatv 0 4.2.3 color-buffer
Color buffer clear
value (color index
mode)
+
DEPTH CLEAR VALUE R GetIntegerv 1 4.2.3 depth-buffer
Depth buffer clear
value
+
STENCIL CLEAR VALUE Z GetIntegerv 0 4.2.3 stencil-buffer
Stencil clear
value
+
ACCUM CLEAR VALUE 4R GetFloatv 0 4.2.3 accum-buffer
Accumulation
buffer clear value6.2. STATETABLES 367
Table 6.27. Framebuffer (state per target binding point)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
DRAW FRAMEBUFFER BINDING Z GetIntegerv 0 4.4.1 –
framebuffer object bound to
DRAW FRAMEBUFFER
+
READ FRAMEBUFFER BINDING Z GetIntegerv 0 4.4.1 –
framebuffer object bound to
READ FRAMEBUFFER6.2. STATETABLES 368
Table 6.28. Framebuffer (state per framebuffer object)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
DRAW BUFFERi 1Z GetIntegerv see 4.2.1 4.2.1 color-buffer
11
Draw buffer selected for color out-
puti
READ BUFFER Z GetIntegerv see 4.3.2 4.3.2 pixel
11
Read source buffer6.2. STATETABLES 369
Table 6.29. Framebuffer (state per attachment point)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
Z 4.4.2 –
FRAMEBUFFER ATTACHMENT- GetFramebuffer- NONE Type of image attached
OBJECT TYPE Attachment- to framebuffer attach-
Parameteriv ment point
Z 4.4.2 –
FRAMEBUFFER ATTACHMENT- GetFramebuffer- 0 Name of object at-
OBJECT NAME Attachment- tached to framebuffer
Parameteriv attachment point
Z 4.4.2 –
FRAMEBUFFER ATTACHMENT- GetFramebuffer- 0 Mipmap level of texture
TEXTURE LEVEL Attachment- image attached, if object
Parameteriv attached is texture
+
Z 4.4.2 –
FRAMEBUFFER ATTACHMENT- GetFramebuffer- TEXTURE CUBE- Cubemap face of texture
TEXTURE CUBE MAP FACE Attachment- MAP POSITIVE X image attached, if object
Parameteriv attached is cubemap tex-
ture
Z 4.4.2 –
FRAMEBUFFER ATTACHMENT- GetFramebuffer- 0 Layer of texture image
TEXTURE LAYER Attachment- attached, if object at-
Parameteriv tached is 3D texture
Z 6.1.3 –
2
FRAMEBUFFER ATTACHMENT- GetFramebuffer- - Encoding of components
COLOR ENCODING Attachment- in the attached image
Parameteriv
Z 6.1.3 –
4
FRAMEBUFFER ATTACHMENT- GetFramebuffer- - Data type of components
COMPONENT TYPE Attachment- in the attached image
Parameteriv
+
Z 6.1.3 –
FRAMEBUFFER ATTACHMENT- GetFramebuffer- - Size in bits of attached
x SIZE Attachment- image’s x component; x
Parameteriv is RED, GREEN, BLUE,
ALPHA, DEPTH, or
STENCIL6.2. STATETABLES 370
Table 6.30. Renderbuffer (state per target and binding point)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
RENDERBUFFER BINDING Z GetIntegerv 0 4.4.2 –
renderbuffer object bound to
RENDERBUFFER6.2. STATETABLES 371
Table 6.31. Renderbuffer (state per renderbuffer object)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
RENDERBUFFER WIDTH Z GetRenderbufferParameteriv 0 4.4.2 –
Width of renderbuffer
+
RENDERBUFFER HEIGHT Z GetRenderbufferParameteriv 0 4.4.2 –
Height of renderbuffer
+
RENDERBUFFER INTERNAL FORMAT Z GetRenderbufferParameteriv RGBA 4.4.2 –
Internal format of renderbuffer
+
RENDERBUFFER RED SIZE Z GetRenderbufferParameteriv 0 4.4.2 –
Size in bits of renderbuffer image’s
red component
+
RENDERBUFFER GREEN SIZE Z GetRenderbufferParameteriv 0 4.4.2 –
Size in bits of renderbuffer image’s
green component
+
RENDERBUFFER BLUE SIZE Z GetRenderbufferParameteriv 0 4.4.2 –
Size in bits of renderbuffer image’s
blue component
+
RENDERBUFFER ALPHA SIZE Z GetRenderbufferParameteriv 0 4.4.2 –
Size in bits of renderbuffer image’s
alpha component
+
RENDERBUFFER DEPTH SIZE Z GetRenderbufferParameteriv 0 4.4.2 –
Size in bits of renderbuffer image’s
depth component
+
RENDERBUFFER STENCIL SIZE Z GetRenderbufferParameteriv 0 4.4.2 –
Size in bits of renderbuffer image’s
stencil component
+
RENDERBUFFER SAMPLES Z GetRenderbufferParameteriv 0 4.4.2 –
Number of samples6.2. STATETABLES 372
Table 6.32. Pixels
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
UNPACK SWAP BYTES B GetBooleanv FALSE 3.7.1 pixel-store
Value ofUNPACK SWAP BYTES
UNPACK LSB FIRST B GetBooleanv FALSE 3.7.1 pixel-store
Value ofUNPACK LSB FIRST
+
UNPACK IMAGE HEIGHT Z GetIntegerv 0 3.7.1 pixel-store
Value ofUNPACK IMAGE HEIGHT
+
UNPACK SKIP IMAGES Z GetIntegerv 0 3.7.1 pixel-store
Value ofUNPACK SKIP IMAGES
+
UNPACK ROW LENGTH Z GetIntegerv 0 3.7.1 pixel-store
Value ofUNPACK ROW LENGTH
+
UNPACK SKIP ROWS Z GetIntegerv 0 3.7.1 pixel-store
Value ofUNPACK SKIP ROWS
+
UNPACK SKIP PIXELS Z GetIntegerv 0 3.7.1 pixel-store
Value ofUNPACK SKIP PIXELS
+
UNPACK ALIGNMENT Z GetIntegerv 4 3.7.1 pixel-store
Value ofUNPACK ALIGNMENT
PACK SWAP BYTES B GetBooleanv FALSE 4.3.2 pixel-store
Value ofPACK SWAP BYTES
PACK LSB FIRST B GetBooleanv FALSE 4.3.2 pixel-store
Value ofPACK LSB FIRST
+
PACK IMAGE HEIGHT Z GetIntegerv 0 4.3.2 pixel-store
Value ofPACK IMAGE HEIGHT
+
PACK SKIP IMAGES Z GetIntegerv 0 4.3.2 pixel-store
Value ofPACK SKIP IMAGES
+
PACK ROW LENGTH Z GetIntegerv 0 4.3.2 pixel-store
Value ofPACK ROW LENGTH
+
PACK SKIP ROWS Z GetIntegerv 0 4.3.2 pixel-store
Value ofPACK SKIP ROWS
+
PACK SKIP PIXELS Z GetIntegerv 0 4.3.2 pixel-store
Value ofPACK SKIP PIXELS
+
PACK ALIGNMENT Z GetIntegerv 4 4.3.2 pixel-store
Value ofPACK ALIGNMENT
+
PIXEL PACK BUFFER BINDING Z GetIntegerv 0 4.3.2 pixel-store
Pixel pack buffer binding
+
PIXEL UNPACK BUFFER BINDING Z GetIntegerv 0 6.1.13 pixel-store
Pixel unpack buffer binding6.2. STATETABLES 373
Table 6.33. Pixels (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
MAP COLOR B GetBooleanv FALSE 3.7.3 pixel
True if colors are mapped
MAP STENCIL B GetBooleanv FALSE 3.7.3 pixel
True if stencil values are mapped
INDEX SHIFT Z GetIntegerv 0 3.7.3 pixel
Value ofINDEX SHIFT
INDEX OFFSET Z GetIntegerv 0 3.7.3 pixel
Value ofINDEX OFFSET
x SCALE R GetFloatv 1 3.7.3 pixel
Value of x SCALE; x is RED,
GREEN,BLUE,ALPHA, orDEPTH
x BIAS R GetFloatv 0 3.7.3 pixel
Value ofx BIAS6.2. STATETABLES 374
Table 6.34. Pixels (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
COLOR TABLE B FALSE 3.7.3 pixel/enable
IsEnabled True if color table lookup
is done
POST CONVOLUTION COLOR TABLE B FALSE 3.7.3 pixel/enable
IsEnabled True if post convolu-
tion color table lookup is
done
POST COLOR MATRIX COLOR TABLE B FALSE 3.7.3 pixel/enable
IsEnabled True if post color ma-
trix color table lookup is
done
COLOR TABLE I empty 3.7.3 –
GetColorTable Color table
POST CONVOLUTION COLOR TABLE I empty 3.7.3 –
GetColorTable Post convolution color
table
POST COLOR MATRIX COLOR TABLE I empty 3.7.3 –
GetColorTable Post color matrix color
table
COLOR TABLE FORMAT 2 3Z RGBA 3.7.3 –
42
GetColorTable- Color tables’ internal im-
Parameteriv age format
+
COLOR TABLE WIDTH 2 3Z 0 3.7.3 –
GetColorTable- Color tables’ speci?ed
Parameteriv width
+
COLOR TABLE x SIZE 6 2 3Z 0 3.7.3 –
GetColorTable- Color table compo-
Parameteriv nent resolution; x is
RED, GREEN, BLUE,
ALPHA, LUMINANCE,
orINTENSITY
4
COLOR TABLE SCALE 3R 1,1,1,1 3.7.3 pixel
GetColorTable- Scale factors applied to
Parameterfv color table entries
4
COLOR TABLE BIAS 3R 0,0,0,0 3.7.3 pixel
GetColorTable- Bias factors applied to
Parameterfv color table entries6.2. STATETABLES 375
Table 6.35. Pixels (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
CONVOLUTION 1D B FALSE 3.7.3 pixel/enable
IsEnabled True if 1D convolution is
done
CONVOLUTION 2D B FALSE 3.7.3 pixel/enable
IsEnabled True if 2D convolution is
done
SEPARABLE 2D B FALSE 3.7.3 pixel/enable
IsEnabled True if separable 2D con-
volution is done
CONVOLUTION xD 2I empty 3.7.3 –
GetConvolution- Convolution ?lters;x is 1
Filter or 2
SEPARABLE 2D 2I empty 3.7.3 –
GetSeparable- Fil- Separable convolution
ter ?lter
CONVOLUTION BORDER COLOR 3C 0,0,0,0 3.7.5 pixel
GetConvolution- Convolution border color
Parameterfv
CONVOLUTION BORDER MODE 3Z REDUCE 3.7.5 pixel
4
GetConvolution- Convolution border
Parameteriv mode
4
CONVOLUTION FILTER SCALE 3R 1,1,1,1 3.7.3 pixel
GetConvolution- Scale factors applied to
Parameterfv convolution ?lter entries
4
CONVOLUTION FILTER BIAS 3R 0,0,0,0 3.7.3 pixel
GetConvolution- Bias factors applied to
Parameterfv convolution ?lter entries
CONVOLUTION FORMAT 3Z RGBA 3.7.5 –
42
GetConvolution- Convolution ?lter inter-
Parameteriv nal format
+
CONVOLUTION WIDTH 3Z 0 3.7.5 –
GetConvolution- Convolution ?lter width
Parameteriv
+
CONVOLUTION HEIGHT 2Z 0 3.7.5 –
GetConvolution- Convolution ?lter height
Parameteriv6.2. STATETABLES 376
Table 6.36. Pixels (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
POST CONVOLUTION x SCALE R 1 3.7.3 pixel
GetFloatv Component scale factors
after convolution; x is
RED, GREEN, BLUE, or
ALPHA
POST CONVOLUTION x BIAS R 0 3.7.3 pixel
GetFloatv Component bias factors
after convolution
POST COLOR MATRIX x SCALE R 1 3.7.3 pixel
GetFloatv Component scale factors
after color matrix
POST COLOR MATRIX x BIAS R 0 3.7.3 pixel
GetFloatv Component bias factors
after color matrix
HISTOGRAM B FALSE 3.7.3 pixel/enable
IsEnabled True if histogramming is
enabled
HISTOGRAM I empty 3.7.3 –
GetHistogram Histogram table
+
HISTOGRAM WIDTH 2Z 0 3.7.3 –
GetHistogram- Histogram table width
Parameteriv
HISTOGRAM FORMAT 2Z RGBA 3.7.3 –
42
GetHistogram- Histogram table internal
Parameteriv format
+
HISTOGRAM x SIZE 5 2Z 0 3.7.3 –
GetHistogram- Histogram table compo-
Parameteriv nent resolution;x isRED,
GREEN, BLUE, ALPHA,
orLUMINANCE
HISTOGRAM SINK B FALSE 3.7.3 –
GetHistogram- True if histogramming
Parameteriv consumes pixel groups6.2. STATETABLES 377
Table 6.37. Pixels (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
MINMAX B FALSE 3.7.3 pixel/enable
IsEnabled True if minmax is en-
abled
n
MINMAX R (M,M,M,M),(m,m,m,m) 3.7.3 –
GetMinmax Minmax table
MINMAX FORMAT Z RGBA 3.7.3 –
42
GetMinmax- Minmax table internal
Parameteriv format
MINMAX SINK B FALSE 3.7.3 –
GetMinmax- True if minmax con-
Parameteriv sumes pixel groups
ZOOM X R 1.0 3.7.4 pixel
GetFloatv x zoom factor
ZOOM Y R 1.0 3.7.4 pixel
GetFloatv y zoom factor
x 8 32R 0’s 3.7.3 –
GetPixelMap RGBA PixelMap trans-
lation tables; x is a map
name from table 3.3
x 2 32Z 0’s 3.7.3 –
GetPixelMap Index PixelMap transla-
tion tables; x is a map
name from table 3.3
+
x SIZE Z 1 3.7.3 –
GetIntegerv Size of tablex6.2. STATETABLES 378
Table 6.38. Evaluators (GetMap takes a map name)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
ORDER 9Z GetMapiv 1 5.1 –
8
1d map order
ORDER 9 2Z GetMapiv 1,1 5.1 –
8
2d map orders
n
COEFF 9 8R GetMapfv see 5.1 5.1 –
1d control points
n
COEFF 9 88R GetMapfv see 5.1 5.1 –
2d control points
DOMAIN 9 2R GetMapfv see 5.1 5.1 –
1d domain endpoints
DOMAIN 9 4R GetMapfv see 5.1 5.1 –
2d domain endpoints
MAP1 x 9B IsEnabled FALSE 5.1 eval/enable
1d map enables:x is map type
MAP2 x 9B IsEnabled FALSE 5.1 eval/enable
2d map enables:x is map type
MAP1 GRID DOMAIN 2R GetFloatv 0,1 5.1 eval
1d grid endpoints
MAP2 GRID DOMAIN 4R GetFloatv 0,1;0,1 5.1 eval
2d grid endpoints
+
MAP1 GRID SEGMENTS Z GetFloatv 1 5.1 eval
1d grid divisions
+
MAP2 GRID SEGMENTS 2Z GetFloatv 1,1 5.1 eval
2d grid divisions
AUTO NORMAL B IsEnabled FALSE 5.1 eval/enable
True if automatic normal generation
enabled6.2. STATETABLES 379
Table 6.39. Shader Object State
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
SHADER TYPE Z GetShaderiv - 2.20.1 –
2
Type of shader (vertex or fragment)
DELETE STATUS B GetShaderiv FALSE 2.20.1 –
Shader ?agged for deletion
COMPILE STATUS B GetShaderiv FALSE 2.20.1 –
Last compile succeeded
- S GetShaderInfoLog empty string 6.1.15 –
Info log for shader objects
+
INFO LOG LENGTH Z GetShaderiv 0 6.1.15 –
Length of info log
- S GetShaderSource empty string 2.20.1 –
Source code for a shader
+
SHADER SOURCE LENGTH Z GetShaderiv 0 6.1.15 –
Length of source code6.2. STATETABLES 380
Table 6.40. Program Object State
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
Z GetIntegerv 0 2.20.2 –
CURRENT PROGRAM Name of current program
object
B GetProgramiv FALSE 2.20.2 –
DELETE STATUS Program object deleted
B GetProgramiv FALSE 2.20.2 –
LINK STATUS Last link attempt suc-
ceeded
B GetProgramiv FALSE 2.20.2 –
VALIDATE STATUS Last validate attempt suc-
ceeded
+
Z GetProgramiv 0 6.1.15 –
ATTACHED SHADERS Number of attached
shader objects
+
0Z GetAttachedShaders empty 6.1.15 –
- Shader objects attached
S GetProgramInfoLog empty 6.1.15 –
- Info log for program ob-
ject
+
Z GetProgramiv 0 2.20.3 –
INFO LOG LENGTH Length of info log
+
Z GetProgramiv 0 2.20.3 –
ACTIVE UNIFORMS Number of active uni-
forms
0Z GetUniformLocation – 6.1.15 –
- Location of active uni-
forms
+
0Z GetActiveUniform – 2.20.3 –
- Size of active uniform
+
0Z GetActiveUniform – 2.20.3 –
- Type of active uniform
0char GetActiveUniform empty 2.20.3 –
- Name of active uniform
+
Z GetProgramiv 0 6.1.15 –
ACTIVE UNIFORM MAX LENGTH Maximum active uniform
name length
512R GetUniform 0 2.20.3 –
Uniform value
+
Z GetProgramiv 0 2.20.3 –
ACTIVE ATTRIBUTES Number of active at-
tributes6.2. STATETABLES 381
Table 6.41. Program Object State (cont.)
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
0Z 2.20.3 –
- GetAttribLocation – Location of active
generic attribute
+
0Z 2.20.3 –
- GetActiveAttrib – Size of active at-
tribute
+
0Z 2.20.3 –
- GetActiveAttrib – Type of active at-
tribute
0char 2.20.3 –
- GetActiveAttrib empty Name of active at-
tribute
+
Z 6.1.15 –
ACTIVE ATTRIBUTE MAX LENGTH GetProgramiv 0 Maximum active at-
tribute name length
Z 6.1.15 –
2
TRANSFORM FEEDBACK- GetProgramiv INTERLEAVED- Transform feedback
BUFFER MODE ATTRIBS mode for the program
+
Z 6.1.15 –
TRANSFORM FEEDBACK- GetProgramiv 0 Number of varyings
VARYINGS to stream to buffer
object(s)
+
Z 6.1.15 –
TRANSFORM FEEDBACK- GetProgramiv 0 Maximum transform
VARYING MAX LENGTH feedback varying
name length
+
Z 2.20.3 –
- GetTransform- - Size of each trans-
FeedbackVarying form feedback vary-
ing variable
+
Z 2.20.3 –
- GetTransform- - Type of each trans-
FeedbackVarying form feedback vary-
ing variable
+
0 char 2.20.3 –
- GetTransform- - Name of each trans-
FeedbackVarying form feedback vary-
ing variable6.2. STATETABLES 382
Table 6.42. Vertex Shader State
Version 3.0 (September 23, 2008)
Get
Initial
Get value Type Command Value Description Sec. Attribute
VERTEX PROGRAM TWO SIDE B IsEnabled FALSE 2.19.1 enable
Two-sided color mode
CURRENT VERTEX ATTRIB 16R4 GetVertexAttribfv 0,0,0,1 2.7 current
Generic vertex attribute
VERTEX PROGRAM POINT SIZE B IsEnabled FALSE 3.4 enable
Point size mode6.2. STATETABLES 383
Table 6.43. Query Object State
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
QUERY RESULT Z GetQueryObjectuiv 0 6.1.12 –
Query object result
QUERY RESULT AVAILABLE B GetQueryObjectiv FALSE 6.1.12 –
Is the query object result available?6.2. STATETABLES 384
Table 6.44. Transform Feedback State
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
TRANSFORM FEEDBACK BUFFER BINDING Z GetIntegerv 0 6.1.13 –
Buffer object bound to
generic bind point for
transform feedback
+
TRANSFORM FEEDBACK BUFFER BINDING nxZ GetIntegeri v 0 6.1.13 –
Buffer object bound to
each transform feedback
attribute stream
+
TRANSFORM FEEDBACK BUFFER START nxZ GetIntegeri v 0 6.1.13 –
Start offset of binding
range for each transform
feedback attrib. stream
+
TRANSFORM FEEDBACK BUFFER SIZE nZ GetIntegeri v 0 6.1.13 –
Size of binding range for
each transform feedback
attrib. stream
+
MAX TRANSFORM FEEDBACK INTERLEAVED COMPONENTS Z GetIntegerv 64 2.15 –
Max number of compo-
nents to write to a single
buffer in interleaved mode
+
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS Z GetIntegerv 4 2.15 –
Max number of separate at-
tributes or vayings that can
be captured in transform
feedback
+
MAX TRANSFORM FEEDBACK SEPARATE COMPONENTS Z GetIntegerv 4 2.15 –
Max number of compo-
nents per attribute or vary-
ing in separate mode6.2. STATETABLES 385
Table 6.45. Hints
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
PERSPECTIVE CORRECTION HINT Z GetIntegerv DONT CARE 5.7 hint
3
Perspective correction hint
POINT SMOOTH HINT Z GetIntegerv DONT CARE 5.7 hint
3
Point smooth hint
LINE SMOOTH HINT Z GetIntegerv DONT CARE 5.7 hint
3
Line smooth hint
POLYGON SMOOTH HINT Z GetIntegerv DONT CARE 5.7 hint
3
Polygon smooth hint
FOG HINT Z GetIntegerv DONT CARE 5.7 hint
3
Fog hint
GENERATE MIPMAP HINT Z GetIntegerv DONT CARE 5.7 hint
3
Mipmap generation hint
TEXTURE COMPRESSION HINT Z GetIntegerv DONT CARE 5.7 hint
3
Texture compression quality hint
FRAGMENT SHADER DERIVATIVE HINT Z GetIntegerv DONT CARE 5.7 hint
3
Fragment shader derivative accu-
racy hint6.2. STATETABLES 386
Table 6.46. Implementation Dependent Values
Version 3.0 (September 23, 2008)
Get Minimum
Get value Type Command Value Description Sec. Attribute
+
MAX LIGHTS Z GetIntegerv 8 2.19.1 –
Maximum number of lights
+
MAX CLIP PLANES Z GetIntegerv 6 2.17 –
Maximum number of user clipping
planes
+
MAX COLOR MATRIX STACK DEPTH Z GetIntegerv 2 3.7.3 –
Maximum color matrix stack depth
+
MAX MODELVIEW STACK DEPTH Z GetIntegerv 32 2.12.2 –
Maximum model-view stack depth
+
MAX PROJECTION STACK DEPTH Z GetIntegerv 2 2.12.2 –
Maximum projection matrix stack
depth
+
MAX TEXTURE STACK DEPTH Z GetIntegerv 2 2.12.2 –
Maximum number depth of texture
matrix stack
+
SUBPIXEL BITS Z GetIntegerv 4 3 –
Number of bits of subpixel precision
in screenx andy
w w
+
MAX 3D TEXTURE SIZE Z GetIntegerv 256 3.9.1 –
Maximum 3D texture image dimen-
sion
+
MAX TEXTURE SIZE Z GetIntegerv 1024 3.9.1 –
Maximum 2D/1D texture image di-
mension
+
MAX ARRAY TEXTURE LAYERS Z GetIntegerv 256 3.9.1 –
Maximum number of layers for tex-
ture arrays
+
MAX TEXTURE LOD BIAS R GetFloatv 2.0 3.9.7 –
Maximum absolute texture level of
detail bias
+
MAX CUBE MAP TEXTURE SIZE Z GetIntegerv 1024 3.9.1 –
Maximum cube map texture image
dimension
+
MAX RENDERBUFFER SIZE Z GetIntegerv 1024 4.4.2 –
Maximum width and height of ren-
derbuffers6.2. STATETABLES 387
Table 6.47. Implementation Dependent Values (cont.)
Version 3.0 (September 23, 2008)
Get Minimum
Get value Type Command Value Description Sec. Attribute
+
Z 32 3.7.3 –
MAX PIXEL MAP TABLE GetIntegerv Maximum size of a Pix-
elMap translation table
+
Z 64 5.2 –
MAX NAME STACK DEPTH GetIntegerv Maximum selection name
stack depth
+
Z 64 5.4 –
MAX LIST NESTING GetIntegerv Maximum display list call
nesting
+
Z 8 5.1 –
MAX EVAL ORDER GetIntegerv Maximum evaluator poly-
nomial order
+
2Z see 2.12.1 2.12.1 –
MAX VIEWPORT DIMS GetIntegerv Maximum viewport
dimensions
+
Z 16 6 –
MAX ATTRIB STACK DEPTH GetIntegerv Maximum depth of the
server attribute stack
+
Z 16 6 –
MAX CLIENT ATTRIB STACK DEPTH GetIntegerv Maximum depth of the
client attribute stack
+
3Z 32 3.7.3 –
– - Max. size of a color table
+
Z 32 3.7.3 –
– - Max. size of the histogram
table
+
2R 1,1 3.4 –
ALIASED POINT SIZE RANGE GetFloatv Range (lo to hi) of aliased
point sizes
+
2R 1,1 3.4 –
SMOOTH POINT SIZE RANGE GetFloatv Range (lo to hi) of an-
(v1.1: POINT SIZE RANGE) tialiased point sizes
+
R – 3.4 –
SMOOTH POINT SIZE GRANULARITY GetFloatv Antialiased point size
(v1.1: POINT SIZE GRANULARITY) granularity6.2. STATETABLES 388
Table 6.48. Implementation Dependent Values (cont.)
Version 3.0 (September 23, 2008)
Get Minimum
Get value Type Command Value Description Sec. Attribute
+
2R 1,1 3.5 –
ALIASED LINE WIDTH RANGE GetFloatv Range (lo to hi) of aliased
line widths
+
2R 1,1 3.5 –
SMOOTH LINE WIDTH RANGE GetFloatv Range (lo to hi) of an-
(v1.1: LINE WIDTH RANGE) tialiased line widths
+
R – 3.5 –
SMOOTH LINE WIDTH GRANULARITY GetFloatv Antialiased line width
(v1.1: LINE WIDTH GRANULARITY) granularity
+
3Z 3 4.3 –
MAX CONVOLUTION WIDTH GetConvolution- Maximum width of con-
Parameteriv volution ?lter
+
2Z 3 4.3 –
MAX CONVOLUTION HEIGHT GetConvolution- Maximum height of con-
Parameteriv volution ?lter
+
Z – 2.8 –
MAX ELEMENTS INDICES GetIntegerv Recommended
max. number of
DrawRangeElements
indices
+
Z – 2.8 –
MAX ELEMENTS VERTICES GetIntegerv Recommended
max. number of
DrawRangeElements
vertices
0Z - 3.9.3 –
COMPRESSED TEXTURE FORMATS GetIntegerv Enumerated compressed
texture formats
Z 0 3.9.3 –
NUM COMPRESSED TEXTURE FORMATS GetIntegerv Number of compressed
texture formats6.2. STATETABLES 389
Table 6.49. Implementation Dependent Values (cont.)
Version 3.0 (September 23, 2008)
Get Minimum
Get value Type Command Value Description Sec. Attribute
+
2Z see 6.1.12 6.1.12 –
QUERY COUNTER BITS GetQueryiv Asynchronous query
counter bits
0S – 6.1.11 –
EXTENSIONS GetStringi Supported individual ex-
tension names
+
Z – 6.1.11 –
NUM EXTENSIONS GetIntegerv Number of individual ex-
tension names
+
Z – 6.1.11 –
MAJOR VERSION GetIntegerv Major version number
supported
+
Z – 6.1.11 –
MINOR VERSION GetIntegerv Minor version number
supported
+
Z – 6.1.11 –
CONTEXT FLAGS GetIntegerv Context full/forward-
compatible ?ag
S – 6.1.11 –
EXTENSIONS GetString Supported extension
names
S – 6.1.11 –
RENDERER GetString Renderer string
S – 6.1.11 –
SHADING LANGUAGE VERSION GetString Shading Language ver-
sion supported
S – 6.1.11 –
VENDOR GetString Vendor string
S – 6.1.11 –
VERSION GetString OpenGL version sup-
ported6.2. STATETABLES 390
Table 6.50. Implementation Dependent Values (cont.)
Version 3.0 (September 23, 2008)
Get Minimum
Get value Type Command Value Description Sec. Attribute
+
Z 2 2.6 –
MAX TEXTURE UNITS GetIntegerv Number of ?xed-
function texture units
+
Z 16 2.7 –
MAX VERTEX ATTRIBS GetIntegerv Number of active vertex
attributes
+
Z 1024 2.20.3 –
MAX VERTEX UNIFORM COMPONENTS GetIntegerv Number of components
for vertex shader uniform
variables
+
Z 64 2.20.3 –
MAX VARYING COMPONENTS GetIntegerv Number of components
for varying variables
+
Z 16 2.20.4 –
MAX COMBINED TEXTURE IMAGE UNITS GetIntegerv Total number of texture
units accessible by the
GL
+
Z 16 2.20.4 –
MAX VERTEX TEXTURE IMAGE UNITS GetIntegerv Number of texture image
units accessible by a ver-
tex shader
+
Z 16 2.20.4 –
MAX TEXTURE IMAGE UNITS GetIntegerv Number of texture image
units accessible by frag-
ment processing
+
Z 8 2.7 –
MAX TEXTURE COORDS GetIntegerv Number of texture coor-
dinate sets
+
Z 1024 3.12.1 –
MAX FRAGMENT UNIFORM COMPONENTS GetIntegerv Number of components
for frag. shader uniform
variables
Z -8 2.20.4 –
MIN PROGRAM TEXEL OFFSET GetIntegerv Manimum texel offset al-
lowed in lookup
Z 7 2.20.4 –
MAX PROGRAM TEXEL OFFSET GetIntegerv Maximum texel offset al-
lowed in lookup6.2. STATETABLES 391
Table 6.51. Framebuffer Dependent Values
Version 3.0 (September 23, 2008)
Get Minimum
Get value Type Command Value Description Sec. Attribute
+
AUX BUFFERS Z GetIntegerv 0 4.2.1 –
Number of auxiliary buffers
+
MAX DRAW BUFFERS Z GetIntegerv 8* 4.2.1 –
Maximum number of active draw
buffers
RGBA MODE B GetBooleanv – 2.7 –
True if color buffers store RGBA
INDEX MODE B GetBooleanv – 2.7 –
True if color buffers store indexes
DOUBLEBUFFER B GetBooleanv – 4.2.1 –
True if front & back buffers exist
STEREO B GetBooleanv – 6 –
True if left & right buffers exist
+
SAMPLE BUFFERS Z GetIntegerv 0 3.3.1 –
Number of multisample buffers
+
SAMPLES Z GetIntegerv 0 3.3.1 –
Coverage mask size
+
MAX COLOR ATTACHMENTS Z GetIntegerv 8 4.4.2 –
Maximum number of FBO attach-
ment points for color buffers
+
MAX SAMPLES Z GetIntegerv 4 4.4.2 –
Maximum number of samples sup-
ported for multisampling
+
x BITS Z GetIntegerv - 4 –
Number of bits in x color buffer
component. x is one of RED,
GREEN,BLUE,ALPHA, orINDEX
+
DEPTH BITS Z GetIntegerv - 4 –
Number of depth buffer planes
+
STENCIL BITS Z GetIntegerv - 4 –
Number of stencil planes
+
ACCUM x BITS Z GetIntegerv - 4 –
Number of bits in x accumula-
tion buffer component (x is RED,
GREEN,BLUE, orALPHA6.2. STATETABLES 392
Table 6.52. Miscellaneous
Version 3.0 (September 23, 2008)
Get Initial
Get value Type Command Value Description Sec. Attribute
+
LIST BASE Z GetIntegerv 0 5.4 list
Setting of ListBase
+
LIST INDEX Z GetIntegerv 0 5.4 –
Number of display list under con-
struction; 0 if none
+
LIST MODE Z GetIntegerv 0 5.4 –
Mode of display list under construc-
tion; unde?ned if none
– 16A – empty 6 –
Server attribute stack
+
ATTRIB STACK DEPTH Z GetIntegerv 0 6 –
Server attribute stack pointer
– 16A – empty 6 –
Client attribute stack
+
CLIENT ATTRIB STACK DEPTH Z GetIntegerv 0 6 –
Client attribute stack pointer
+
NAME STACK DEPTH Z GetIntegerv 0 5.2 –
Name stack depth
RENDER MODE Z GetIntegerv RENDER 5.2 –
3
RenderMode setting
SELECTION BUFFER POINTER Y GetPointerv 0 5.2 select
Selection buffer pointer
+
SELECTION BUFFER SIZE Z GetIntegerv 0 5.2 select
Selection buffer size
FEEDBACK BUFFER POINTER Y GetPointerv 0 5.3 feedback
Feedback buffer pointer
+
FEEDBACK BUFFER SIZE Z GetIntegerv 0 5.3 feedback
Feedback buffer size
FEEDBACK BUFFER TYPE Z GetIntegerv 2D 5.3 feedback
5
Feedback type
– nZ GetError 0 2.5 –
8
Current error code(s)
– nB – FALSE 2.5 –
True if there is a corresponding error
B – FALSE 4.1.7 –
Occlusion query active
+
CURRENT QUERY 3Z GetQueryiv 0 6.1.12 –
Active query object namesAppendix A
Invariance
The OpenGL speci?cation is not pixel exact. It therefore does not guarantee an ex-
act match between images produced by different GL implementations. However,
the speci?cation does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
vide justi?cation for those cases that require exact matches.
A.1 Repeatability
The obvious and most fundamental case is repeated issuance of a series of GL com-
mands. For any given GL and framebuffer state vector, and for any GL command,
the resulting GL and framebuffer state must be identical whenever the command is
executed on that initial GL and framebuffer state.
One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatability is testability.
Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirable to ensure useful operation.
393A.2. MULTI-PASSALGORITHMS 394
A.2 Multi-pass Algorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:
 “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
ferent color or using the XOR logical operation.
 Using stencil operations to compute capping planes.
On the other hand, invariance rules can greatly increase the complexity of high-
performance implementations of the GL. Even the weak repeatability requirement
signi?cantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
to be identical, something that may be very dif?cult to achieve (for example, if the
hardware does ?oating-point operations with different precision than the software).
What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.
A.3 Invariance Rules
For a given instantiation of an OpenGL rendering context:
Rule 1 For any given GL and framebuffer state vector, and for any given GL com-
mand, the resulting GL and framebuffer state must be identical each time the com-
mand is executed on that initial GL and framebuffer state.
Rule 2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):
Required:
 Framebuffer contents (all bitplanes)
 The color buffers enabled for writing
 The values of matrices other than the top-of-stack matrices
Version 3.0 (September 23, 2008)A.3. INVARIANCERULES 395
 Scissor parameters (other than enable)
 Writemasks (color, index, depth, stencil)
 Clear values (color, index, depth, stencil, accumulation)
 Current values (color, index, normal, texture coords, edge?ag)
 Current raster color, index and texture coordinates.
 Material properties (ambient, diffuse, specular, emission, shininess)
Strongly suggested:
 Matrix mode
 Matrix stack depths
 Alpha test parameters (other than enable)
 Stencil parameters (other than enable)
 Depth test parameters (other than enable)
 Blend parameters (other than enable)
 Logical operation parameters (other than enable)
 Pixel storage and transfer state
 Evaluator state (except as it affects the vertex data generated by the
evaluators)
 Polygon offset parameters (other than enables, and except as they affect
the depth values of fragments)
Corollary 1 Fragment generation is invariant with respect to the state values
marked with in Rule 2.
Corollary 2 The window coordinates (x, y, and z) of generated fragments are also
invariant with respect to
Required:
 Current values (color, color index, normal, texture coords, edge?ag)
 Current raster color, color index, and texture coordinates
 Material properties (ambient, diffuse, specular, emission, shininess)
Rule 3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it (the parameters that control the alpha
test, for instance, are the alpha test enable, the alpha test function, and the alpha
test reference value).
Version 3.0 (September 23, 2008)A.4. WHATALLTHISMEANS 396
Corollary 3 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.
Rule 4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ’the same shader’ means a
program object that is populated with the same source strings, which are compiled
and then linked, possibly multiple times, and which program object is then executed
using the same GL state vector.
Rule 5 All fragment shaders that either conditionally or unconditionally assign
gl FragCoord.z to gl FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl FragDepth actually is
done.
A.4 What All This Means
Hardware accelerated GL implementations are expected to default to software op-
eration when some GL state vectors are encountered. Even the weak repeatability
requirement means, for example, that OpenGL implementations cannot apply hys-
teresis to this swap, but must instead guarantee that a given mode vector implies
that a subsequent command always is executed in either the hardware or the soft-
ware machine.
The stronger invariance rules constrain when the switch from hardware to soft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled, but it should not be made when a change is made to the blending param-
eters.
Because ?oating point values may be represented using different formats in dif-
ferent renderers (hardware and software), many OpenGL state values may change
subtly when renderers are swapped. This is the type of state value change that Rule
1 seeks to avoid.
Version 3.0 (September 23, 2008)Appendix B
Corollaries
The following observations are derived from the body and the other appendixes of
the speci?cation. Absence of an observation from this list in no way impugns its
veracity.
1. The CURRENT RASTER TEXTURE COORDS must be maintained correctly at
all times, including periods while texture mapping is not enabled, and when
the GL is in color index mode.
2. When requested, texture coordinates returned in feedback mode are always
valid, including periods while texture mapping is not enabled, and when the
GL is in color index mode.
3. The error semantics of upward compatible OpenGL revisions may change.
Otherwise, only additions can be made to upward compatible revisions.
4. GL query commands are not required to satisfy the semantics of the Flush
or the Finish commands. All that is required is that the queried state be con-
sistent with complete execution of all previously executed GL commands.
5. Application speci?ed point size and line width must be returned as speci?ed
when queried. Implementation dependent clamping affects the values only
while they are in use.
6. Bitmaps and pixel transfers do not cause selection hits.
7. The mask speci?ed as the third argument to StencilFunc affects the operands
of the stencil comparison function, but has no direct effect on the update of
the stencil buffer. The mask speci?ed by StencilMask has no effect on the
stencil comparison function; it limits the effect of the update of the stencil
buffer.
397398
8. Polygon shading is completed before the polygon mode is interpreted. If the
shade model isFLAT, all of the points or lines generated by a single polygon
will have the same color.
9. A display list is just a group of commands and arguments, so errors generated
by commands in a display list must be generated when the list is executed.
If the list is created inCOMPILE mode, errors should not be generated while
the list is being created.
10. RasterPos does not change the current raster index from its default value
in an RGBA mode GL context. Likewise, RasterPos does not change the
current raster color from its default value in a color index GL context. Both
the current raster index and the current raster color can be queried, however,
regardless of the color mode of the GL context.
11. A material property that is attached to the current color via ColorMaterial
always takes the value of the current color. Attempts to change that material
property via Material calls have no effect.
12. Material and ColorMaterial can be used to modify the RGBA material
properties, even in a color index context. Likewise, Material can be used to
modify the color index material properties, even in an RGBA context.
13. There is no atomicity requirement for OpenGL rendering commands, even
at the fragment level.
14. Because rasterization of non-antialiased polygons is point sampled, poly-
gons that have no area generate no fragments when they are rasterized in
FILL mode, and the fragments generated by the rasterization of “narrow”
polygons may not form a continuous array.
15. OpenGL does not force left- or right-handedness on any of its coordinates
systems. Consider, however, the following conditions: (1) the object coordi-
nate system is right-handed; (2) the only commands used to manipulate the
model-view matrix are Scale (with positive scaling values only), Rotate, and
Translate; (3) exactly one of either Frustum or Ortho is used to set the pro-
jection matrix; (4) the near value is less than the far value for DepthRange.
If these conditions are all satis?ed, then the eye coordinate system is right-
handed and the clip, normalized device, and window coordinate systems are
left-handed.
16. ColorMaterial has no effect on color index lighting.
Version 3.0 (September 23, 2008)399
17. (No pixel dropouts or duplicates.) Let two polygons share an identical edge
(that is, there exist vertices A and B of an edge of one polygon, and vertices
C and D of an edge of the other polygon, and the coordinates of vertex A
(resp. B) are identical to those of vertex C (resp. D), and the state of the the
coordinate transfomations is identical when A, B, C, and D are speci?ed).
Then, when the fragments produced by rasterization of both polygons are
taken together, each fragment intersecting the interior of the shared edge is
produced exactly once.
18. OpenGL state continues to be modi?ed in FEEDBACK mode and in SELECT
mode. The contents of the framebuffer are not modi?ed.
19. The current raster position, the user de?ned clip planes, the spot directions
and the light positions for LIGHTi, and the eye planes for texgen are trans-
formed when they are speci?ed. They are not transformed during a PopAt-
trib, or when copying a context.
20. Dithering algorithms may be different for different components. In particu-
lar, alpha may be dithered differently from red, green, or blue, and an imple-
mentation may choose to not dither alpha at all.
21. For any GL and framebuffer state, and for any group of GL commands and
arguments, the resulting GL and framebuffer state is identical whether the
GL commands and arguments are executed normally or from a display list.
Version 3.0 (September 23, 2008)Appendix C
Compressed Texture Image
Formats
C.1 RGTC Compressed Texture Image Formats
Compressed texture images stored using the RGTC compressed image encodings
are represented as a collection of 4 4 texel blocks, where each block contains
64 or 128 bits of texel data. The image is encoded as a normal 2D raster image
in which each 4 4 block is treated as a single pixel. If an RGTC image has a
width or height less than four, the data corresponding to texels outside the image
are irrelevant and unde?ned.
When an RGTC image with a width of w, height of h, and block size of block-
size (8 or 16 bytes) is decoded, the corresponding image size (in bytes) is:
w h
d ed eblocksize:
4 4
When decoding an RGTC image, the block containing the texel at offset (x;y)
begins at an offset (in bytes) relative to the base of the image of:
 
w y x
blocksize d eb c +b c :
4 4 4
The data corresponding to a speci?c texel (x;y) are extracted from a 44 texel
block using a relative (x;y) value of
(x mod 4;y mod 4):
There are four distinct RGTC image formats:
400C.1. RGTCCOMPRESSEDTEXTUREIMAGEFORMATS 401
C.1.1 FormatCOMPRESSED RED RGTC1
Each 4 4 block of texels consists of 64 bits of unsigned red image data.
Each red image data block is encoded as a sequence of 8 bytes, called (in order
of increasing address):
red ;red ;bits ;bits ;bits ;bits ;bits ;bits
0 1 0 1 2 3 4 5
The 6bits bytes of the block are decoded into a 48-bit bit vector:

bits =bits +256(bits + 256 (bits + 256 (bits + 256 (bits + 256bits ))))
0 1 2 3 4 5
red and red are 8-bit unsigned integers that are unpacked to red values
0 1
RED andRED as though they were pixels with a format ofLUMINANCE and a
0 1
type ofUNSIGNED BYTE.
bits is a 48-bit unsigned integer, from which a three-bit control code is ex-
tracted for a texel at location (x;y) in the block using:
code(x;y) =bits [3 (4y +x) + 2::: 3 (4y +x) + 0]
where bit 47 is the most signi?cant and bit 0 is the least signi?cant bit.
The red valueR for a texel at location (x;y) in the block is given by:
Version 3.0 (September 23, 2008)C.1. RGTCCOMPRESSEDTEXTUREIMAGEFORMATS 402
8
>
RED ; red >red ;code(x;y) = 0
0 0 1
>
>
>
>
>RED ; red >red ;code(x;y) = 1
1 0 1
>
>
>
6RED +RED
> 0 1
> red >red ;code(x;y) = 2
0 1
>
7;
>
>
5RED +2RED
> 0 1
>
red >red ;code(x;y) = 3
0 1
>
7;
>
>
4RED +3RED
> 0 1
>
red >red ;code(x;y) = 4
0 1
>
7;
>
>
>3RED +4RED
0 1
>
red >red ;code(x;y) = 5
> 0 1
7;
>
>
>2RED +5RED
0 1
>
red >red ;code(x;y) = 6
> 0 1
7;
>
>
<RED +6RED
0 1
red >red ;code(x;y) = 7
0 1
7;
R =
>
RED ; red red ;code(x;y) = 0
> 0 0 1
>
>
>
>
RED ; red red ;code(x;y) = 1
> 1 0 1
>
>
>4RED +RED
0 1
>
red red ;code(x;y) = 2
> 0 1
5;
>
>
>
3RED +2RED
0 1
>
red red ;code(x;y) = 3
> 0 1
5;
>
>
>
2RED +3RED
0 1
>
red red ;code(x;y) = 4
>
0 1
> 5;
>
>
RED +4RED
> 0 1
> red red ;code(x;y) = 5
0 1
> 5;
>
>
>
>RED ; red red ;code(x;y) = 6
min 0 1
>
>
:
RED ; red red ;code(x;y) = 7
max 0 1
RED andRED are 0.0 and 1.0 respectively.
min max
Since the decoded texel has a red format, the resulting RGBA value for the
texel is (R; 0; 0; 1).
C.1.2 FormatCOMPRESSED SIGNED RED RGTC1
Each 4 4 block of texels consists of 64 bits of signed red image data. The red
values of a texel are extracted in the same way asCOMPRESSED RED RGTC1 except
red ,red ,RED ,RED ,RED , andRED are signed values de?ned as
0 1 0 1 min max
follows:
red andred are 8-bit signed (two’s complement) integers.
0 1
(
red
0
red > 128
0
127:0;
RED =
0
 1:0; red = 128
0
(
red
1
red > 128
1
127:0;
RED =
1
 1:0; red = 128
1
RED = 1:0
min
Version 3.0 (September 23, 2008)C.1. RGTCCOMPRESSEDTEXTUREIMAGEFORMATS 403
RED = 1:0
max
CAVEAT for signedred andred values: the expressionsred > red and
0 1 0 1
red red above are considered unde?ned (read: may vary by implementation)
0 1
whenred = 127 andred = 128. This is because ifred were remapped to
0 1 0
-127 prior to the comparison to reduce the latency of a hardware decompressor, the
expressions would reverse their logic. Encoders for the signed red-green formats
should avoid encoding blocks wherered = 127 andred = 128.
0 1
C.1.3 FormatCOMPRESSED RG RGTC2
Each 4 4 block of texels consists of 64 bits of compressed unsigned red image
data followed by 64 bits of compressed unsigned green image data.
The ?rst 64 bits of compressed red are decoded exactly like
COMPRESSED RED RGTC1 above.
The second 64 bits of compressed green are decoded exactly like
COMPRESSED RED RGTC1 above except the decoded valueR for this second block
is considered the resulting green valueG.
Since the decoded texel has a red-green format, the resulting RGBA value for
the texel is (R;G; 0; 1).
C.1.4 FormatCOMPRESSED SIGNED RG RGTC2
Each 4 4 block of texels consists of 64 bits of compressed signed red image data
followed by 64 bits of compressed signed green image data.
The ?rst 64 bits of compressed red are decoded exactly like
COMPRESSED SIGNED RED RGTC1 above.
The second 64 bits of compressed green are decoded exactly like
COMPRESSED SIGNED RED RGTC1 above except the decoded valueR for this sec-
ond block is considered the resulting green valueG.
Since this image has a red-green format, the resulting RGBA value is
(R;G; 0; 1).
Version 3.0 (September 23, 2008)Appendix D
Shared Objects and Multiple
Contexts
State that can be shared between contexts includes display lists, pixel and vertex
buffer objects, program and shader objects, and texture objects (except for the tex-
ture objects named zero).
Framebuffer and vertex array objects are not shared.
D.1 Object Deletion Behavior
After an object is deleted, its name is immediately marked unused. Caution should
be taken when deleting an object attached to a container object (such as a buffer
object attached to a vertex array object, or a renderbuffer or texture attached to a
framebuffer object), or a shared object bound in multiple contexts. Following its
deletion, the object’s name can be used by any context to create a new object, or be
returned by Gen* commands, even though the underlying object state and data may
still be referred to by container objects, or in use by contexts other than the one
in which the object was deleted. Such a container or other context may continue
using the object, and may still contain state identifying its name as being currently
bound, until such time as the container object is deleted, the attachment point of
the container object is changed to refer to another object, or another attempt to
bind or attach the name is made in that context. Since the name is marked unused,
binding the name will create a new object with the same name, and attaching the
name will generate an error. The underlying storage backing a deleted object will
not be reclaimed by the GL until all references to the object from container object
attachment points or context binding points are removed,
404Appendix E
The Deprecation Model
OpenGL 3.0 introduces a deprecation model in which certain features may be
marked as deprecated. Deprecated features are expected to be completely removed
from a future version of OpenGL. Deprecated features are summarized in sec-
tion E.1.
To aid developers in writing applications which will run on such future ver-
sions, it is possible to create an OpenGL 3.0 context which does not support dep-
recated features. Such a context is called a forward compatible context, while a
context supporting all OpenGL 3.0 features is called a full context. Forward com-
patible contexts cannot restore deprecated functionality through extensions, but
they may support additional, non-deprecated functionality through extensions.
Pro?les allow de?ning subsets of OpenGL functionality targeted to speci?c ap-
plication domains. While OpenGL 3.0 only de?nes a single pro?le, future versions
may introduce pro?les addressing domains such as workstation, gaming, and em-
bedded. Implementations are not required to support all de?ned pro?les, but must
support at least one pro?le.
To enable application control of deprecation and pro?les, new context creation
APIs have been de?ned as extensions to GLX and WGL. These APIs allow spec-
ifying a particular version, pro?le, and full or forward compatible status, and will
either create a context compatible with the request, or fail (if, for example, request-
ing an OpenGL version or pro?le not supported by the implementation),
Only the ARB may de?ne OpenGL pro?les and deprecated features.
E.1 Pro?les and Deprecated Features of OpenGL 3.0
OpenGL 3.0 de?nes a single pro?le, and all OpenGL 3.0 implementations must
support that pro?le.
405E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 406
The features deprecated in OpenGL 3.0 are summarized below, together with
the sections of the speci?cation in which they are de?ned. Functions which are
completely deprecated will generate an INVALID OPERATION error if called in
a forward-compatible context. Functions which are partially deprecated (e.g. no
longer accept some parameter values) will generate the errors appropriate for any
other unrecognized value of that parameter when a deprecated value is passed in a
forward-compatible context.
 Application-generated object names - the names of all object types, such as
buffer, query, and texture objects, must be generated using the corresponding
Gen* commands. Trying to bind an object name not returned by a Gen*
command will result in an INVALID OPERATION error. This behavior is
already the case for framebuffer, renderbuffer, and vertex array objects.
 Color index mode - No color index visuals are supplied by the window
system-binding APIs such as GLX and WGL, so the default framebuffer
is always in RGBA mode. All language and state related to color index
mode vertex, rasterization, and fragment processing behavior is removed.
COLOR INDEX formats are also deprecated.
 OpenGL Shading Language versions 1.10 and 1.20. These versions of the
shading language depend on many API features that have also been depre-
cated.
 Begin / End primitive speci?cation - Begin, End, and EdgeFlag* (sec-
tion 2.6.1); Color*, FogCoord*, Index*, Normal3*, SecondaryColor3*,
TexCoord*, Vertex* (section 2.7); and all associated state in tables 6.4
and 6.5. Vertex arrays and array drawing commands must be used to draw
primitives. However, VertexAttrib* and the current vertex attribute state
are retained in order to provide default attribute values for disabled attribute
arrays.
 Edge ?ags and ?xed-function vertex processing - ColorPointer, EdgeFlag-
Pointer, FogCoordPointer, IndexPointer, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexPointer, EnableClientState, Dis-
ableClientState, and ClientActiveTexture (section 2.8); Frustum, Loa-
dIdentity, LoadMatrix, LoadTransposeMatrix, MatrixMode, Mult-
Matrix, MultTransposeMatrix, Ortho, PopMatrix, PushMatrix, Ro-
tate, Scale, and Translate (section 2.12.2; Enable/Disable tar-
gets RESCALE NORMAL and NORMALIZE (section 2.12.3); TexGen*
and Enable/Disable targets TEXTURE GEN (section 2.12.4, Material*
*
Version 3.0 (September 23, 2008)E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 407
Light*, LightModel*, and ColorMaterial, and Enable/Disable targets
LIGHTING. VERTEX PROGRAM TWO SIDE, LIGHTi, and COLOR MATERIAL
(sections 2.19.2 and 2.19.3; and all associated ?xed-function vertex array,
multitexture, matrix and matrix stack, normal and texture coordinate, and
lighting state. A vertex shader must be de?ned in order to draw primitives.
Language referring to edge ?ags in the current speci?cation is modi?ed as
though all edge ?ags areTRUE.
Note that the FrontFace, ClampColor, and ShadeModel commands in sec-
tion 2.19 are not deprecated, as they still affect other non-deprecated func-
tionality;
 Client vertex arrays - all vertex array attribute pointers must refer to buffer
objects (section 2.9.2). The default vertex array object (the name zero) is
also deprecated. Calling VertexAttribPointer when no buffer object or no
vertex array object is bound will generate an INVALID OPERATION error,
as will calling any array drawing command when no vertex array object is
bound.
 Rectangles - Rect* (section 2.11).
 Current raster position - RasterPos* and WindowPos* (section 2.18), and
all associated state.
 Two-sided color selection (section 2.19.1) - Enable target
VERTEX PROGRAM TWO SIDE; OpenGL Shading Language builtins
gl BackColor andgl BackSecondaryColor; and all associated state.
 Non-sprite points (section 3.4) - Enable/Disable targetsPOINT SMOOTH and
POINT SPRITE, and all associated state. Point rasterization is always per-
formed as thoughPOINT SPRITE were enabled.
 Wide lines and line stipple - LineWidth is not deprecated, but values greater
than 1.0 will generate an INVALID VALUE error; LineStipple and En-
able/Disable targetLINE STIPPLE (section 3.5.2, and all associated state.
 Quadrilateral and polygon primitives - vertex array drawing modes
POLYGON, QUADS, and QUAD STRIP (section 2.6.1, related descriptions of
rasterization of non-triangle polygons in section 3.6, and all associated state.
 Separate polygon draw mode - PolygonMode face values of FRONT and
BACK; polygons are always drawn in the same mode, no matter which face
is being rasterized.
Version 3.0 (September 23, 2008)E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 408
 Polygon Stipple - PolygonStipple and Enable/Disable target
POLYGON STIPPLE (section 3.6.2, and all associated state.
 Pixel transfer modes and operations - all pixel transfer modes, including
pixel maps, shift and bias, color table lookup, color matrix, and convolu-
tion commands and state (sections 3.7.2, 3.7.3, and 3.7.5), and all associated
state and commands de?ning that state.
 Pixel drawing - DrawPixels and PixelZoom (section 3.7.4). However, the
language describing pixel rectangles in section 3.7 is retained as it is required
for TexImage* and ReadPixels.
 Bitmaps - Bitmap (section 3.8).
 Legacy OpenGL 1.0 pixel formats - the values 1, 2, 3, and 4 are no longer
accepted as internal formats by TexImage* or any other command taking an
internal format argument.
 Legacy pixel formats - all ALPHA LUMINANCE, LUMINANCE ALPHA, and
INTENSITY external and internal formats, including compressed, ?oating-
point, and integer variants (see tables 3.6, 3.15, 3.17, 3.19, 3.23, and 6.1); all
references to luminance and intensity formats elsewhere in the speci?cation,
including conversion to and from those formats; and all associated state. in-
cluding state describing the allocation or format of luminance and intensity
texture or framebuffer components.
 Depth texture mode - DEPTH TEXTURE MODE. Section 3.9.14 is to be
changed so thatr is returned to texture samplers directly, and the OpenGL
Shading Language 1.30 Specification is to be changed so that (r;r;r; 1) is
always returned from depth texture samplers in this case.
 Texture wrap modeCLAMP -CLAMP is no longer accepted as a value of tex-
ture parametersTEXTURE WRAP S,TEXTURE WRAP T, orTEXTURE WRAP R.
 Texture borders - the border value to TexImage* must always be zero, or
an INVALID VALUE error is generated (section 3.9.1); all language in sec-
tion 3.9 referring to nonzero border widths during texture image speci?cation
and texture sampling; and all associated state.
 Automatic mipmap generation - TexParameter* targetGENERATE MIPMAP
(section 3.9.7), and all associated state
Version 3.0 (September 23, 2008)E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 409
 Fixed-function fragment processing - AreTexturesResident, Pri-
oritizeTextures, and TexParameter target TEXTURE PRIORITY;
TexEnv target TEXTURE ENV, and all associated parameters; Tex-
Env target TEXTURE FILTER CONTROL, and parameter name
TEXTURE LOD BIAS; Enable targets of all dimensionalities (TEXTURE 1D,
TEXTURE 2D, TEXTURE 3D, TEXTURE 1D ARRAY, TEXTURE 2D ARRAY,
and TEXTURE CUBE MAP); Enable target COLOR SUM; Enable target FOG,
Fog, and all associated parameters; and all associated state.
 Alpha test - AlphaFunc and Enable/Disable target ALPHA TEST (sec-
tion 4.1.4), and all associated state.
 Accumulation buffers - ClearAccum, and ACCUM BUFFER BIT is not valid
as a bit in the argument to Clear (section 4.2.3); Accum (section 4.2.4); the
ACCUM BITS framebuffer state describing the size of accumulation buffer
*
components (table 6.51); and all associated state.
Window system-binding APIs such as GLX and WGL may choose to either
not expose window con?gs containing accumulation buffers, or to ignore
accumulation buffers when the default framebuffer bound to a GL context
contains them.
 Context framebuffer size queries - RED BITS, GREEN BITS, BLUE BITS,
ALPHA BITS,DEPTH BITS, andSTENCIL BITS.
 Evaluators - Map*, EvalCoord*, MapGrid*, EvalMesh*, EvalPoint*, and
all evaluator map enables in table 5.1 (section 5.1, and all associated state.
 Selection and feedback modes - RenderMode, InitNames, PopName,
PushName, LoadName, and SelectBuffer (section 5.2); FeedbackBuffer
and PassThrough (section 5.3); and all associated state.
 Display lists - NewList, EndList, CallList, CallLists, ListBase, GenLists,
IsList, and DeleteLists (section 5.4); all references to display lists and be-
havior when compiling commands into display lists elsewhere in the speci-
?cation; and all associated state.
 Hints - the PERSPECTIVE CORRECTION HINT, FOG HINT, and
GENERATE MIPMAP HINT targets to Hint (section 5.7).
 Attribute stacks - PushAttrib, PushClientAttrib, PopAttrib, PopClien-
tAt-
trib, theMAX ATTRIB STACK DEPTH,MAX CLIENT ATTRIB STACK DEPTH
Version 3.0 (September 23, 2008)E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 410
state, and the values ALL ATTRIB BITS and CLIENT ALL ATTRIB BITS
(section 6.1.18).
 Uni?ed extension string -EXTENSIONS target to GetString (section 6.1.11).
 Token names and queries - all token names and queries not otherwise men-
tioned above for deprecated state, as well as all query entry points where all
valid targets of that query are deprecated state (chapter 6 and the state tables)
Version 3.0 (September 23, 2008)Appendix F
Version 1.1
OpenGL version 1.1 is the ?rst revision since the original version 1.0 was released
on 1 July 1992. Version 1.1 is upward compatible with version 1.0, meaning that
any program that runs with a 1.0 GL implementation will also run unchanged with
a 1.1 GL implementation. Several additions were made to the GL, especially to
the texture mapping capabilities, but also to the geometry and fragment operations.
Following are brief descriptions of each addition.
F.1 Vertex Array
Arrays of vertex data may be transferred to the GL with many fewer commands
than were previously necessary. Six arrays are de?ned, one each storing vertex
positions, normal coordinates, colors, color indices, texture coordinates, and edge
?ags. The arrays may be speci?ed and enabled independently, or one of the pre-
de?ned con?gurations may be selected with a single command.
The primary goal was to decrease the number of subroutine calls required
to transfer non-display listed geometry data to the GL. A secondary goal was to
improve the ef?ciency of the transfer; especially to allow direct memory access
(DMA) hardware to be used to effect the transfer. The additions match those of
the GL EXT vertex array extension, except that static array data are not sup-
ported (because they complicated the interface, and were not being used), and the
pre-de?ned con?gurations are added (both to reduce subroutine count even further,
and to allow for ef?cient transfer of array data).
411F.2. POLYGONOFFSET 412
F.2 Polygon Offset
Depth values of fragments generated by the rasterization of a polygon may be
shifted toward or away from the origin, as an af?ne function of the window coor-
dinate depth slope of the polygon. Shifted depth values allow coplanar geometry,
especially facet outlines, to be rendered without depth buffer artifacts. They may
also be used by future shadow generation algorithms.
The additions match those of the GL EXT polygon offset extension, with
two exceptions. First, the offset is enabled separately forPOINT,LINE, andFILL
rasterization modes, all sharing a single af?ne function de?nition. (Shifting the
depth values of the outline fragments, instead of the ?ll fragments, allows the con-
tents of the depth buffer to be maintained correctly.) Second, the offset bias is
speci?ed in units of depth buffer resolution, rather than in the [0,1] depth range.
F.3 Logical Operation
Fragments generated by RGBA rendering may be merged into the framebuffer
using a logical operation, just as color index fragments are in GL version 1.0.
Blending is disabled during such operation because it is rarely desired, be-
cause many systems could not support it, and to match the semantics of the
GL EXT blend logic op extension, on which this addition is loosely based.
F.4 Texture Image Formats
Stored texture arrays have a format, known as the internal format, rather than a
simple count of components. The internal format is represented as a single enu-
merated value, indicating both the organization of the image data (LUMINANCE,
RGB, etc.) and the number of bits of storage for each image component. Clients
can use the internal format speci?cation to suggest the desired storage precision
of texture images. New base internal formats, ALPHA and INTENSITY, provide
new texture environment operations. These additions match those of a subset of
theGL EXT texture extension.
F.5 Texture Replace Environment
A common use of texture mapping is to replace the color values of generated
fragments with texture color data. This could be speci?ed only indirectly in GL
version 1.0, which required that client speci?ed “white” geometry be modulated
Version 3.0 (September 23, 2008)F.6. TEXTUREPROXIES 413
by a texture. GL version 1.1 allows such replacement to be speci?ed explicitly,
possibly improving performance. These additions match those of a subset of the
GL EXT texture extension.
F.6 Texture Proxies
Texture proxies allow a GL implementation to advertise different maximum tex-
ture image sizes as a function of some other texture parameters, especially of the
internal image format. Clients may use the proxy query mechanism to tailor their
use of texture resources at run time. The proxy interface is designed to allow such
queries without adding new routines to the GL interface. These additions match
those of a subset of the GL EXT texture extension, except that implementations
return allocation information consistent with support for complete mipmap arrays.
F.7 Copy Texture and Subtexture
Texture array data can be speci?ed from framebuffer memory, as well as from
client memory, and rectangular subregions of texture arrays can be rede?ned either
from client or framebuffer memory. These additions match those de?ned by the
GL EXT copy texture andGL EXT subtexture extensions.
F.8 Texture Objects
A set of texture arrays and their related texture state can be treated as a single
object. Such treatment allows for greater implementation ef?ciency when multi-
ple arrays are used. In conjunction with the subtexture capability, it also allows
clients to make gradual changes to existing texture arrays, rather than completely
rede?ning them. These additions match those of the GL EXT texture object
extension, with slight additions to the texture residency semantics.
F.9 Other Changes
1. Color indices may now be speci?ed as unsigned bytes.
2. Texture coordinatess, t, andr are divided byq during the rasterization of
points, pixel rectangles, and bitmaps. This division was documented only
for lines and polygons in the 1.0 version.
Version 3.0 (September 23, 2008)F.10. ACKNOWLEDGEMENTS 414
3. The line rasterization algorithm was changed so that vertical lines on pixel
borders rasterize correctly.
4. Separate pixel transfer discussions in chapter 3 and chapter 4 were combined
into a single discussion in chapter 3.
5. Texture alpha values are returned as 1.0 if there is no alpha channel in the
texture array. This behavior was unspeci?ed in the 1.0 version, and was
incorrectly documented in the reference manual.
6. Fog start and end values may now be negative.
7. Evaluated color values direct the evaluation of the lighting equation if Col-
orMaterial is enabled.
F.10 Acknowledgements
OpenGL 1.1 is the result of the contributions of many people, representing a cross
section of the computer industry. Following is a partial list of the contributors,
including the company that they represented at the time of their contribution:
Kurt Akeley, Silicon Graphics
Bill Armstrong, Evans & Sutherland
Andy Bigos, 3Dlabs
Pat Brown, IBM
Jim Cobb, Evans & Sutherland
Dick Coulter, Digital Equipment
Bruce D’Amora, GE Medical Systems
John Dennis, Digital Equipment
Fred Fisher, Accel Graphics
Chris Frazier, Silicon Graphics
Todd Frazier, Evans & Sutherland
Tim Freese, NCD
Ken Garnett, NCD
Mike Heck, Template Graphics Software
Dave Higgins, IBM
Phil Huxley, 3Dlabs
Dale Kirkland, Intergraph
Hock San Lee, Microsoft
Kevin LeFebvre, Hewlett Packard
Jim Miller, IBM
Tim Misner, SunSoft
Version 3.0 (September 23, 2008)F.10. ACKNOWLEDGEMENTS 415
Jeremy Morris, 3Dlabs
Israel Pinkas, Intel
Bimal Poddar, IBM
Lyle Ramshaw, Digital Equipment
Randi Rost, Hewlett Packard
John Schimpf, Silicon Graphics
Mark Segal, Silicon Graphics
Igor Sinyak, Intel
Jeff Stevenson, Hewlett Packard
Bill Sweeney, SunSoft
Kelvin Thompson, Portable Graphics
Neil Trevett, 3Dlabs
Linas Vepstas, IBM
Andy Vesper, Digital Equipment
Henri Warren, Megatek
Paula Womack, Silicon Graphics
Mason Woo, Silicon Graphics
Steve Wright, Microsoft
Version 3.0 (September 23, 2008)Appendix G
Version 1.2
OpenGL version 1.2, released on March 16, 1998, is the second revision since the
original version 1.0. Version 1.2 is upward compatible with version 1.1, meaning
that any program that runs with a 1.1 GL implementation will also run unchanged
with a 1.2 GL implementation.
Several additions were made to the GL, especially to texture mapping capa-
bilities and the pixel processing pipeline. Following are brief descriptions of each
addition.
G.1 Three-Dimensional Texturing
Three-dimensional textures can be de?ned and used. In-memory formats for three-
dimensional images, and pixel storage modes to support them, are also de?ned.
The additions match those of theGL EXT texture3D extension.
One important application of three-dimensional textures is rendering volumes
of image data.
G.2 BGRA Pixel Formats
BGRA extends the list of client memory color formats. Speci?cally, it provides
a component order matching ?le and framebuffer formats common on Windows
platforms. The additions match those of theGL EXT bgra extension.
416G.3. PACKEDPIXELFORMATS 417
G.3 Packed Pixel Formats
Packed pixels in client memory are represented entirely by one unsigned byte, one
unsigned short, or one unsigned integer. The ?elds with the packed pixel are not
proper machine types, but the pixel as a whole is. Thus the pixel storage modes
and their unpacking counterparts all work correctly with packed pixels.
The additions match those of theGL EXT packed pixels extension, with the
further addition of reversed component order packed formats.
G.4 Normal Rescaling
Normals may be rescaled by a constant factor derived from the model-view matrix.
Rescaling can operate faster than renormalization in many cases, while resulting in
the same unit normals.
The additions are based on theGL EXT rescale normal extension.
G.5 Separate Specular Color
Lighting calculations are modi?ed to produce a primary color consisting of emis-
sive, ambient and diffuse terms of the usual GL lighting equation, and a secondary
color consisting of the specular term. Only the primary color is modi?ed by the
texture environment; the secondary color is added to the result of texturing to pro-
duce a single post-texturing color. This allows highlights whose color is based on
the light source creating them, rather than surface properties.
The additions match those of theGL EXT separate specular color exten-
sion.
G.6 Texture Coordinate Edge Clamping
GL normally clamps such that the texture coordinates are limited to exactly the
range [0; 1]. When a texture coordinate is clamped using this algorithm, the texture
sampling ?lter straddles the edge of the texture image, taking half its sample values
from within the texture image, and the other half from the texture border. It is
sometimes desirable to clamp a texture without requiring a border, and without
using the constant border color.
A new texture clamping algorithm, CLAMP TO EDGE, clamps texture coordi-
nates at all mipmap levels such that the texture ?lter never samples a border texel.
The color returned when clamping is derived only from texels at the edge of the
texture image.
Version 3.0 (September 23, 2008)G.7. TEXTURELEVELOFDETAILCONTROL 418
The additions match those of theGL SGIS texture edge clamp extension.
G.7 Texture Level of Detail Control
Two constraints related to the texture level of detail parameter are added. One
constraint clamps  to a speci?ed ?oating point range. The other limits the se-
lection of mipmap image arrays to a subset of the arrays that would otherwise be
considered.
Together these constraints allow a large texture to be loaded and used initially
at low resolution, and to have its resolution raised gradually as more resolution is
desired or available. Image array speci?cation is necessarily integral, rather than
continuous. By providing separate, continuous clamping of the parameter, it is
possible to avoid ”popping” artifacts when higher resolution images are provided.
The additions match those of theGL SGIS texture lod extension.
G.8 Vertex Array Draw Element Range
A new form of DrawElements that provides explicit information on the range of
vertices referred to by the index set is added. Implementations can take advantage
of this additional information to process vertex data without having to scan the
index data to determine which vertices are referenced.
The additions match those of theGL EXT draw range elements extension.
G.9 Imaging Subset
The remaining new features are primarily intended for advanced image processing
applications, and may not be present in all GL implementations. The are collec-
tively referred to as the imaging subset.
G.9.1 Color Tables
A new RGBA-format color lookup mechanism is de?ned in the pixel transfer pro-
cess, providing additional lookup capabilities beyond the existing lookup. The key
difference is that the new lookup tables are treated as one-dimensional images with
internal formats, like texture images and convolution ?lter images. Thus the new
tables can operate on a subset of the components of passing pixel groups. For ex-
ample, a table with internal formatALPHA modi?es only the A component of each
pixel group, leaving the R, G, and B components unmodi?ed.
Version 3.0 (September 23, 2008)G.9. IMAGINGSUBSET 419
Three independent lookups may be performed: prior to convolution; after con-
volution and prior to color matrix transformation; after color matrix transformation
and prior to gathering pipeline statistics.
Methods to initialize the color lookup tables from the framebuffer, in addition
to the standard memory source mechanisms, are provided.
Portions of a color lookup table may be rede?ned without reinitializing the
entire table. The affected portions may be speci?ed either from client memory or
from the framebuffer.
The additions match those of the GL EXT color table and
GL EXT color subtable extensions.
G.9.2 Convolution
One- or two-dimensional convolution operations are executed following the ?rst
color table lookup in the pixel transfer process. The convolution kernels are them-
selves treated as one- and two-dimensional images, which can be loaded from ap-
plication memory or from the framebuffer.
The convolution framework is designed to accommodate three-dimensional
convolution, but that API is left for a future extension.
The additions match those of the GL EXT convolution and
GL HP convolution border modes extensions.
G.9.3 Color Matrix
A 4x4 matrix transformation and associated matrix stack are added to the pixel
transfer path. The matrix operates on RGBA pixel groups, using the equation
0
C =MC;
where
0 1
R
B C
G
B C
C =
@ A
B
A
andM is the 44 matrix on the top of the color matrix stack. After the matrix mul-
tiplication, each resulting color component is scaled and biased by a programmed
amount. Color matrix multiplication follows convolution.
The color matrix can be used to reassign and duplicate color components. It
can also be used to implement simple color space conversions.
The additions match those of theGL SGI color matrix extension.
Version 3.0 (September 23, 2008)G.10. ACKNOWLEDGEMENTS 420
G.9.4 Pixel Pipeline Statistics
Pixel operations that count occurences of speci?c color component values (his-
togram) and that track the minimum and maximum color component values (min-
max) are performed at the end of the pixel transfer pipeline. An optional mode
allows pixel data to be discarded after the histogram and/or minmax operations are
completed. Otherwise the pixel data continues on to the next operation unaffected.
The additions match those of theGL EXT histogram extension.
G.9.5 Constant Blend Color
A constant color that can be used to de?ne blend weighting factors may be de?ned.
A typical usage is blending two RGB images. Without the constant blend factor,
one image must have an alpha channel with each pixel set to the desired blend
factor.
The additions match those of theGL EXT blend color extension.
G.9.6 New Blending Equations
Blending equations other than the normal weighted sum of source and destination
components may be used.
Two of the new equations produce the minimum (or maximum) color com-
ponents of the source and destination colors. Taking the maximum is useful for
applications such as maximum projection in medical imaging.
The other two equations are similar to the default blending equation, but pro-
duce the difference of its left and right hand sides, rather than the sum. Image
differences are useful in many image processing applications.
The additions match those of the GL EXT blend minmax and
GL EXT blend subtract extensions.
G.10 Acknowledgements
OpenGL 1.2 is the result of the contributions of many people, representing a cross
section of the computer industry. Following is a partial list of the contributors,
including the company that they represented at the time of their contribution:
Kurt Akeley, Silicon Graphics
Bill Armstrong, Evans & Sutherland
Otto Berkes, Microsoft
Pierre-Luc Bisaillon, Matrox Graphics
Drew Bliss, Microsoft
Version 3.0 (September 23, 2008)G.10. ACKNOWLEDGEMENTS 421
David Blythe, Silicon Graphics
Jon Brewster, Hewlett Packard
Dan Brokenshire, IBM
Pat Brown, IBM
Newton Cheung, S3
Bill Clifford, Digital
Jim Cobb, Parametric Technology
Bruce D’Amora, IBM
Kevin Dallas, Microsoft
Mahesh Dandapani, Rendition
Daniel Daum, AccelGraphics
Suzy Deffeyes, IBM
Peter Doyle, Intel
Jay Duluk, Raycer
Craig Dunwoody, Silicon Graphics
Dave Erb, IBM
Fred Fisher, AccelGraphics / Dynamic Pictures
Celeste Fowler, Silicon Graphics
Allen Gallotta, ATI
Ken Garnett, NCD
Michael Gold, Nvidia / Silicon Graphics
Craig Groeschel, Metro Link
Jan Hardenbergh, Mitsubishi Electric
Mike Heck, Template Graphics Software
Dick Hessel, Raycer Graphics
Paul Ho, Silicon Graphics
Shawn Hopwood, Silicon Graphics
Jim Hurley, Intel
Phil Huxley, 3Dlabs
Dick Jay, Template Graphics Software
Paul Jensen, 3Dfx
Brett Johnson, Hewlett Packard
Michael Jones, Silicon Graphics
Tim Kelley, Real3D
Jon Khazam, Intel
Louis Khouw, Sun
Dale Kirkland, Intergraph
Chris Kitrick, Raycer
Don Kuo, S3
Herb Kuta, Quantum 3D
Version 3.0 (September 23, 2008)G.10. ACKNOWLEDGEMENTS 422
Phil Lacroute, Silicon Graphics
Prakash Ladia, S3
Jon Leech, Silicon Graphics
Kevin Lefebvre, Hewlett Packard
David Ligon, Raycer Graphics
Kent Lin, S3
Dan McCabe, S3
Jack Middleton, Sun
Tim Misner, Intel
Bill Mitchell, National Institute of Standards
Jeremy Morris, 3Dlabs
Gene Munce, Intel
William Newhall, Real3D
Matthew Papakipos, Nvidia / Raycer
Garry Paxinos, Metro Link
Hanspeter P?ster, Mitsubishi Electric
Richard Pimentel, Parametric Technology
Bimal Poddar, IBM / Intel
Rob Putney, IBM
Mike Quinlan, Real3D
Nate Robins, University of Utah
Detlef Roettger, Elsa
Randi Rost, Hewlett Packard
Kevin Rushforth, Sun
Richard S. Wright, Real3D
Hock San Lee, Microsoft
John Schimpf, Silicon Graphics
Stefan Seeboth, ELSA
Mark Segal, Silicon Graphics
Bob Seitsinger, S3
Min-Zhi Shao, S3
Colin Sharp, Rendition
Igor Sinyak, Intel
Bill Sweeney, Sun
William Sweeney, Sun
Nathan Tuck, Raycer
Doug Twillenger, Sun
John Tynefeld, 3dfx
Kartik Venkataraman, Intel
Andy Vesper, Digital Equipment
Version 3.0 (September 23, 2008)G.10. ACKNOWLEDGEMENTS 423
Henri Warren, Digital Equipment / Megatek
Paula Womack, Silicon Graphics
Steve Wright, Microsoft
David Yu, Silicon Graphics
Randy Zhao, S3
Version 3.0 (September 23, 2008)Appendix H
Version 1.2.1
OpenGL version 1.2.1, released on October 14, 1998, introduced ARB extensions
(see Appendix O). The only ARB extension de?ned in this version is multitex-
ture, allowing application of multiple textures to a fragment in one rendering pass.
Multitexture is based on the GL SGIS multitexture extension, simpli?ed by
removing the ability to route texture coordinate sets to arbitrary texture units.
A new corollary discussing display list and immediate mode invariance was
added to Appendix B on April 1, 1999.
424Appendix I
Version 1.3
OpenGL version 1.3, released on August 14, 2001, is the third revision since the
original version 1.0. Version 1.3 is upward compatible with earlier versions, mean-
ing that any program that runs with a 1.2, 1.1, or 1.0 GL implementation will also
run unchanged with a 1.3 GL implementation.
Several additions were made to the GL, especially texture mapping capabilities
previously de?ned by ARB extensions. Following are brief descriptions of each
addition.
I.1 Compressed Textures
Compressing texture images can reduce texture memory utilization and improve
performance when rendering textured primitives. The GL provides a framework
upon which extensions providing speci?c compressed image formats can be built,
and a set of generic compressed internal formats that allow applications to specify
that texture images should be stored in compressed form without needing to code
for speci?c compression formats (speci?c compressed formats, such as S3TC or
FXT1, are supported by extensions).
Texture compression was promoted from the
GL ARB texture compression extension.
I.2 Cube Map Textures
Cube map textures provide a new texture generation scheme for looking up textures
from a set of six two-dimensional images representing the faces of a cube. The
(str) texture coordinates are treated as a direction vector emanating from the center
of a cube. At texture generation time, the interpolated per-fragment (str) selects
425I.3. MULTISAMPLE 426
one cube face two-dimensional image based on the largest magnitude coordinate
(the major axis). A new (st) is calculated by dividing the two other coordinates
(the minor axes values) by the major axis value, and the new (st) is used to lookup
into the selected two-dimensional texture image face of the cube map.
Two new texture coordinate generation modes are provided for use in con-
junction with cube map texturing. The REFLECTION MAP mode generates tex-
ture coordinates (str) matching the vertex’s eye-space re?ection vector, useful for
environment mapping without the singularity inherent in SPHERE MAP mapping.
TheNORMAL MAP mode generates texture coordinates matching the vertex’s trans-
formed eye-space normal, useful for texture-based diffuse lighting models.
Cube mapping was promoted from theGL ARB texture cube map extension.
I.3 Multisample
Multisampling provides a antialiasing mechanism which samples all primitives
multiple times at each pixel. The color sample values are resolved to a single, dis-
playable color each time a pixel is updated, so antialiasing appears to be automatic
at the application level. Because each sample includes depth and stencil infor-
mation, the depth and stencil functions perform equivalently to the single-sample
mode.
When multisampling is supported, an additional buffer, called the multisample
buffer, is added to the framebuffer. Pixel sample values, including color, depth, and
stencil values, are stored in this buffer.
Multisampling is usually an expensive operation, so it is usually not supported
on all contexts. Applications must obtain a multisample-capable context using the
new interfaces provided by GLX 1.4 or by theWGL ARB multisample extension.
Multisampling was promoted from theGL ARB multisample extension; The
de?nition of the extension was changed slightly to support both multisampling and
supersampling implementations.
I.4 Multitexture
Multitexture adds support for multiple texture units. The capabilities of the mul-
tiple texture units are identical, except that evaluation and feedback are supported
only for texture unit 0. Each texture unit has its own state vector which includes
texture vertex array speci?cation, texture image and ?ltering parameters, and tex-
ture environment application.
The texture environments of the texture units are applied in a pipelined fashion
whereby the output of one texture environment is used as the input fragment color
Version 3.0 (September 23, 2008)I.5. TEXTUREADDENVIRONMENTMODE 427
for the next texture environment. Changes to texture client state and texture server
state are each routed through one of two selectors which control which instance of
texture state is affected.
Multitexture was promoted from theGL ARB multitexture extension.
I.5 Texture Add Environment Mode
The TEXTURE ENV MODE texture environment function ADD provides a texture
function to add incoming fragment and texture source colors.
Texture add mode was promoted from the GL ARB texture env add exten-
sion.
I.6 Texture Combine Environment Mode
The TEXTURE ENV MODE texture environment function COMBINE provides a wide
range of programmable combiner functions using the incoming fragment color,
texture source color, texture constant color, and the result of the previous texture
environment stage as possible parameters.
Combiner operations include passthrough, multiplication, addition and biased
addition, subtraction, and linear interpolation of speci?ed parameters. Different
combiner operations may be selected for RGB and A components, and the ?nal
result may be scaled by 1, 2, or 4.
Texture combine was promoted from theGL ARB texture env combine ex-
tension.
I.7 Texture Dot3 Environment Mode
The TEXTURE ENV MODE COMBINE operations also provide three-component dot
products of speci?ed parameters, with the resulting scalar value replicated into the
RGB or RGBA components of the output color. The dot product is performed
using pseudo-signed arithmetic to enable per-pixel lighting computations.
Texture DOT3 mode was promoted from theGL ARB texture env dot3 ex-
tension.
I.8 Texture Border Clamp
The texture wrap parameter CLAMP TO BORDER mode clamps texture coordinates
at all mipmap levels such that when the texture ?lter straddles an edge of the texture
Version 3.0 (September 23, 2008)I.9. TRANSPOSEMATRIX 428
image, the color returned is derived only from border texels. This behavior mirrors
the behavior of the texture edge clamp mode introduced by OpenGL 1.2.
Texture border clamp was promoted from the
GL ARB texture border clamp extension.
I.9 Transpose Matrix
New functions and tokens are added allowing application matrices stored in row
major order rather than column major order to be transferred to the implementa-
tion. This allows an application to use standard C-language 2-dimensional arrays
and have the array indices match the expected matrix row and column indexes.
These arrays are referred to as transpose matrices since they are the transpose of
the standard matrices passed to OpenGL.
Transpose matrix adds an interface for transfering data to and from the OpenGL
pipeline. It does not change any OpenGL processing or imply any changes in state
representation.
Transpose matrix was promoted from theGL ARB transpose matrix exten-
sion.
I.10 Acknowledgements
OpenGL 1.3 is the result of the contributions of many people. Following is a partial
list of the contributors, including the company that they represented at the time of
their contribution:
Adrian Muntianu, ATI
Al Reyes, 3dfx
Alain Bouchard, Matrox
Alan Commike, SGI
Alan Heirich, Compaq
Alex Herrera, SP3D
Allen Akin, VA Linux
Allen Gallotta, ATI
Alligator Descartes, Arcane
Andy Vesper, MERL
Andy Wolf, Diamond Multimedia
Axel Schildan, S3
Barthold Lichtenbelt, 3Dlabs
Benj Lipchak, Compaq
Bill Armstrong, Evans & Sutherland
Version 3.0 (September 23, 2008)I.10. ACKNOWLEDGEMENTS 429
Bill Clifford, Intel
Bill Mannel, SGI
Bimal Poddar, Intel
Bob Beretta, Apple
Brent Insko, NVIDIA
Brian Goldiez, UCF
Brian Greenstone, Apple
Brian Paul, VA Linux
Brian Sharp, GLSetup
Bruce D’Amora, IBM
Bruce Stockwell, Compaq
Chris Brady, Alt.software
Chris Frazier, Raycer
Chris Hall, 3dlabs
Chris Hecker, GLSetup
Chris Lane, Intel
Chris Thornborrow, PixelFusion
Christopher Fraser, IMG
Chuck Smith, Intelligraphics
Craig Dunwoody, SGI
Dairsie Latimer, PixelFusion
Dale Kirkland, 3Dlabs / Intergraph
Dan Brokenshire, IBM
Dan Ginsburg, ATI
Dan McCabe, S3
Dave Aronson, Microsoft
Dave Gosselin, ATI
Dave Shreiner, SGI
Dave Zenz, Dell
David Aronson, Microsoft
David Blythe, SGI
David Kirk, NVIDIA
David Story, SGI
David Yu, SGI
Deanna Hohn, 3dfx
Dick Coulter, Silicon Magic
Don Mullis, 3dfx
Eamon O Dea, PixelFusion
Edward (Chip) Hill, Pixelfusion
Eiji Obata, NEC
Version 3.0 (September 23, 2008)I.10. ACKNOWLEDGEMENTS 430
Elio Del Giudice, Matrox
Eric Young, S3
Evan Hart, ATI
Fred Fisher, 3dLabs
Garry Paxinos, Metro Link
Gary Tarolli, 3dfx
George Kyriazis, NVIDIA
Graham Connor, IMG
Herb Kuta, Quantum3D
Howard Miller, Apple
Igor Sinyak, Intel
Jack Middleton, Sun
James Bowman, 3dfx
Jan C. Hardenbergh, MERL
Jason Mitchell, ATI
Jeff Weyman, ATI
Jeffrey Newquist, 3dfx
Jens Owen, Precision Insight
Jeremy Morris, 3Dlabs
Jim Bushnell, Pyramid Peak
John Dennis, Sharp Eye
John Metcalfe, IMG
John Stauffer, Apple
John Tynan, PixelFusion
John W. Polick, NEC
Jon Khazam, Intel
Jon Leech, SGI
Jon Paul Schelter, Matrox
Karl Hilleslad, NVIDIA
Kelvin Thompson
Ken Cameron, Pixelfusion
Ken Dyke, Apple
Ken Nicholson, SGI
Kent Lin, Intel
Kevin Lefebvre, HP
Kevin Martin, VA Linux
Kurt Akeley, SGI
Les Silvern, NEC
Mahesh Dandipani, Rendition
Mark Kilgard, NVIDIA
Version 3.0 (September 23, 2008)I.10. ACKNOWLEDGEMENTS 431
Martin Amon, 3dfx
Martina Sourada, ATI
Matt Lavoie, Pixelfusion
Matt Russo, Matrox
Matthew Papakipos, NVIDIA
Michael Gold, NVIDIA
Miriam Geller, SGI
Morgan Von Essen, Metro Link
Naruki Aruga, PFU
Nathan Tuck, Raycer Graphics
Neil Trevett, 3Dlabs
Newton Cheung, S3
Nick Triantos, NVIDIA
Patrick Brown, Intel
Paul Jensen, 3dfx
Paul Keller, NVIDIA
Paul Martz, HP
Paula Womack, 3dfx
Peter Doenges, Evans & Sutherland
Peter Graffagnino, Apple
Phil Huxley, 3Dlabs
Ralf Biermann, Elsa AG
Randi Rost, 3Dlabs
Renee Rashid, Micron
Rich Johnson, HP
Richard Pimentel, PTC
Richard Schlein, Apple
Rick Hammerstone, ATI
Rik Faith, VA Linux
Rob Glidden, Sun
Rob Wheeler, 3dfx
Shari Petersen, Rendition
Shawn Hopwood, SGI
Steve Glickman, Silicon Magic
Steve McGuigan, SGI
Steve Wright, Microsoft
Stuart Anderson, Metro Link
T. C. Zhao, MERL
Teri Morrison, HP
Thomas Fox, IBM
Version 3.0 (September 23, 2008)I.10. ACKNOWLEDGEMENTS 432
Tim Kelley, Real 3D
Tom Frisinger, ATI
Victor Vedovato, Micron
Vikram Simha, MERL
Yanjun Zhang, Sun
Zahid Hussain, TI
Version 3.0 (September 23, 2008)Appendix J
Version 1.4
OpenGL version 1.4, released on July 24, 2002, is the fourth revision since the
original version 1.0. Version 1.4 is upward compatible with earlier versions, mean-
ing that any program that runs with a 1.3, 1.2, 1.1, or 1.0 GL implementation will
also run unchanged with a 1.4 GL implementation.
In addition to numerous additions to the classical ?xed-function GL pipeline
in OpenGL 1.4, the OpenGL ARB also approved the GL ARB vertex program
extension, which supports programmable vertex processing. Following are brief
descriptions of each addition to OpenGL 1.4; see Chapter O for a description of
GL ARB vertex program.
J.1 Automatic Mipmap Generation
Setting the texture parameterGENERATE MIPMAP toTRUE introduces a side effect
to any modi?cation of thelevel of a mipmap array, wherein all higher levels of
base
the mipmap pyramid are recomputed automatically by successive ?ltering of the
base level array.
Automatic
mipmap generation was promoted from the GL SGIS generate mipmap exten-
sion.
J.2 Blend Squaring
Blend squaring extends the set of supported source and destination blend functions
to permit squaring RGB and alpha values during blending. FunctionsSRC COLOR
and ONE MINUS SRC COLOR are added to the allowed source blending functions,
433J.3. CHANGESTOTHEIMAGINGSUBSET 434
andDST COLOR andONE MINUS DST COLOR are added to the allowed destination
blending functions.
Blend squaring was promoted from theGL NV blend square extension.
J.3 Changes to the Imaging Subset
The subset of blending features described by BlendEquation, BlendColor,
and the BlendFunc modes CONSTANT COLOR, ONE MINUS CONSTANT COLOR,
CONSTANT ALPHA, andONE MINUS CONSTANT ALPHA are now supported. These
feature were available only in the optional imaging subset in versions 1.2 and 1.3
of the GL.
J.4 Depth Textures and Shadows
Depth textures de?ne a new texture internal format,DEPTH, normally used to repre-
sent depth values. Applications include image-based shadow casting, displacement
mapping, and image-based rendering.
Image-based shadowing is enabled with a new texture application mode de-
?ned by the parameter TEXTURE COMPARE MODE. This mode enables comparing
texturer coordinates to depth texture values to generate a boolean result.
Depth textures and shadows were promoted from theGL ARB depth texture
andGL ARB shadow extensions.
J.5 Fog Coordinate
A new associated vertex and fragment datum, the fog coordinate may be used
in computing fog for a fragment, instead of using eye distance to the frag-
ment, by specifying the coordinate with the FogCoord commands and setting the
FOG COORDINATE SOURCE fog parameter. Fog coordinates are particularly useful
in computing more complex fog models.
Fog coordinate was promoted from theGL EXT fog coord extension.
J.6 Multiple Draw Arrays
Multiple primitives may be drawn in a single call using the MultiDrawArrays and
MultiDrawElements comments.
Multiple draw arrays was promoted from the GL EXT multi draw arrays
extension.
Version 3.0 (September 23, 2008)J.7. POINTPARAMETERS 435
J.7 Point Parameters
Point parameters de?ned by the PointParameter commands support additional
geometric characteristics of points, allowing the size of a point to be affected by
linear or quadratic distance attenuation, and increasing control of the mapping from
point size to raster point area and point transparency. This effect may be used for
distance attenuation in rendering particles or light points.
Point parameters was promoted from theGL ARB point parameters exten-
sion.
J.8 Secondary Color
The secondary color may be varied even when lighting is disabled by specifying it
as a vertex parameter with the SecondaryColor commands.
Secondary color was promoted from the GL EXT secondary color exten-
sion.
J.9 Separate Blend Functions
Blending capability is extended with BlendFuncSeparate to allow independent
setting of the RGB and alpha blend functions for blend operations that require
source and destination blend factors.
Separate blend functions was promoted from the
GL EXT blend func separate extension.
J.10 Stencil Wrap
New stencil operationsINCR WRAP andDECR WRAP allow the stencil value to wrap
around the range of stencil values instead of saturating to the minimum or maxi-
mum values on decrement or increment. Stencil wrapping is needed for algorithms
that use the stencil buffer for per-fragment inside-outside primitive computations.
Stencil wrap was promoted from theGL EXT stencil wrap extension.
J.11 Texture Crossbar Environment Mode
Texture crossbar extends the texture combine environment mode COMBINE by al-
lowing use of the texture color from different texture units as sources to the texture
combine function.
Version 3.0 (September 23, 2008)J.12. TEXTURELODBIAS 436
Texture
environment crossbar was promoted from the GL ARB texture env crossbar
extension.
J.12 Texture LOD Bias
The texture ?lter control parameter TEXTURE LOD BIAS may be set to bias the
computed parameter used in texturing for mipmap level of detail selection, pro-
viding a means to blur or sharpen textures. LOD bias may be used for depth of ?eld
and other special visual effects, as well as for some types of image processing.
Texture LOD bias was based on the GL EXT texture lod bias extension,
with the addition of a second per-texture object bias term.
J.13 Texture Mirrored Repeat
Texture mirrored repeat extends the set of texture wrap modes with the mode
MIRRORED REPEAT. This effectively de?nes a texture map twice as large as the
original texture image in which the additional half, for each mirrored texture co-
ordinate, is a mirror image of the original texture. Mirrored repeat can be used
seamless tiling of a surface.
Texture mirrored repeat was promoted from the
GL ARB texture mirrored repeat extension.
J.14 Window Raster Position
The raster position may be set directly to speci?ed window coordinates with the
WindowPos commands, bypassing the transformation applied to RasterPos. Win-
dow raster position is particularly useful for imaging and other 2D operations.
Window raster position was promoted from the GL ARB window pos exten-
sion.
J.15 Acknowledgements
OpenGL 1.4 is the result of the contributions of many people. Following is a partial
list of the contributors, including the company that they represented at the time of
their contribution. The editor especially thanks Bob Beretta and Pat Brown for
their sustained efforts in leading the GL ARB vertex program working group,
Version 3.0 (September 23, 2008)J.15. ACKNOWLEDGEMENTS 437
without which this critical extension could not have been de?ned and approved in
conjunction with OpenGL 1.4.
Kurt Akeley, NVIDIA
Allen Akin
Bill Armstrong, Evans & Sutherland
Ben Ashbaugh, Intel
Chris Bentley, ATI
Bob Beretta, Apple
Daniel Brokenshire, IBM
Pat Brown, NVIDIA
Bill Clifford, Intel
Graham Connor, Videologic
Matt Craighead, NVIDIA
Suzy Deffeyes, IBM
Jean-Luc Dery, Discreet
Kenneth Dyke, Apple
Cass Everitt, NVIDIA
Allen Gallotta, ATI
Lee Gross, IBM
Evan Hart, ATI
Chris Hecker, De?nition 6
Alan Heirich, Compaq / HP
Gareth Hughes, VA Linux
Michael I Gold, NVIDIA
Rich Johnson, HP
Mark Kilgard, NVIDIA
Dale Kirkland, 3Dlabs
David Kirk, NVIDIA
Christian Laforte, Alias—Wavefront
Luc Leblanc, Discreet
Jon Leech, SGI
Bill Licea-Kane, ATI
Barthold Lichtenbelt, 3Dlabs
Jack Middleton, Sun
Howard Miller, Apple
Jeremy Morris, 3Dlabs
Jon Paul Schelter, Matrox
Brian Paul, VA Linux / Tungsten Graphics
Bimal Poddar, Intel
Thomas Roell, Xi Graphics
Version 3.0 (September 23, 2008)J.15. ACKNOWLEDGEMENTS 438
Randi Rost, 3Dlabs
Jeremy Sandmel, ATI
John Stauffer, Apple
Nick Triantos, NVIDIA
Daniel Vogel, Epic Games
Mason Woo, World Wide Woo
Dave Zenz, Dell
Version 3.0 (September 23, 2008)Appendix K
Version 1.5
OpenGL version 1.5, released on July 29, 2003, is the ?fth revision since the orig-
inal version 1.0. Version 1.5 is upward compatible with earlier versions, meaning
that any program that runs with a 1.4, 1.3, 1.2, 1.1, or 1.0 GL implementation will
also run unchanged with a 1.5 GL implementation.
In addition to additions to the classical ?xed-function GL pipeline in OpenGL
1.5, the OpenGL ARB also approved a related set of ARB extensions including
the OpenGL Shading Language speci?cation and the GL ARB shader objects,
GL ARB vertex shader, and GL ARB fragment shader extensions through
which high-level shading language programs can be loaded and used in place of
the ?xed-function pipeline.
Following are brief descriptions of each addition to OpenGL 1.5. The low-
level and high-level shading languages are important adjuncts to the OpenGL core.
They are described in more detail in appendix O, and their corresponding ARB
extension speci?cations are available online as described in that appendix.
K.1 Buffer Objects
Buffer objects allow various types of data (especially vertex array data) to be
cached in high-performance graphics memory on the server, thereby increasing
the rate of data transfers to the GL.
Buffer objects were promoted from theGL ARB vertex buffer object ex-
tension.
439K.2. OCCLUSIONQUERIES 440
K.2 Occlusion Queries
An occlusion query is a mechanism whereby an application can query the number
of pixels (or, more precisely, samples) drawn by a primitive or group of primitives.
The primary purpose of occlusion queries is to determine the visibility of an object.
Occlusion query was promoted from the GL ARB occlusion query exten-
sion.
K.3 Shadow Functions
Texture comparison functions are generalized to support all eight binary functions
rather than justLEQUAL andGEQUAL.
Texture comparison functions were promoted from the
GL EXT shadow funcs extension.
K.4 Changed Tokens
To achieve consistency with the syntax guidelines for OpenGL function and token
names, new token names are introduced to be used in place of old, inconsistent
names. However, the old token names continue to be supported, for backwards
compatibility with code written for previous versions of OpenGL. The new names,
and the old names they replace, are shown in table K.1.
K.5 Acknowledgements
OpenGL 1.5 is the result of the contributions of many people. The editor especially
thanks the following individuals for their sustained efforts in leading ARB working
groups essential to the success of OpenGL 1.5 and of ARB extensions approved in
conjunction with OpenGL 1.5:
Matt Craighead led the working group
which created the GL ARB vertex buffer object extension and OpenGL 1.5
core feature. Kurt Akeley wrote the initial speci?cation for the group.
Daniel Ginsburg and Matt Craighead led the working group which created the
GL ARB occlusion query extension and OpenGL 1.5 core feature.
Benjamin Lipchak led the fragment program working group which created the
GL ARB fragment program extension, completing the low-level programmable
shading interface.
Bill Licea-Kane led the GL2 working group which created the high-
level programmable shading interface, including theGL ARB fragment shader,
Version 3.0 (September 23, 2008)K.5. ACKNOWLEDGEMENTS 441
New Token Name Old Token Name
FOG COORD SRC FOG COORDINATE SOURCE
FOG COORD FOG COORDINATE
CURRENT FOG COORD CURRENT FOG COORDINATE
FOG COORD ARRAY TYPE FOG COORDINATE ARRAY TYPE
FOG COORD ARRAY STRIDE FOG COORDINATE ARRAY STRIDE
FOG COORD ARRAY POINTER FOG COORDINATE ARRAY POINTER
FOG COORD ARRAY FOG COORDINATE ARRAY
FOG COORD ARRAY BUFFER BINDING FOG COORDINATE ARRAY BUFFER BINDING
SRC0 RGB SOURCE0 RGB
SRC1 RGB SOURCE1 RGB
SRC2 RGB SOURCE2 RGB
SRC0 ALPHA SOURCE0 ALPHA
SRC1 ALPHA SOURCE1 ALPHA
SRC2 ALPHA SOURCE2 ALPHA
Table K.1: New token names and the old names they replace.
GL ARB shader objects, and GL ARB vertex shader extensions and the
OpenGL Shading Language.
John Kessenich was the principal editor of the OpenGL Shading Language
speci?cation for the GL2 working group, starting from the initial glslang proposal
written by John, Dave Baldwin, and Randi Rost.
A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
Kurt Akeley, NVIDIA
Allen Akin
Chad Anson, Dell Computer
Bill Armstrong, Evans & Sutherland
Ben Ashbaugh, Intel
Dave Baldwin, 3Dlabs
Chris Bentley, ATI
Bob Beretta, Apple
David Blythe
Alain Bouchard, Matrox
Daniel Brokenshire, IBM
Pat Brown, NVIDIA
John Carmack, Id Software
Version 3.0 (September 23, 2008)K.5. ACKNOWLEDGEMENTS 442
Paul Carmichael, NVIDIA
Bob Carwell, IBM
Paul Clarke, IBM
Bill Clifford, Intel
Roger Cloud, SGI
Graham Connor, Power VR
Matt Craighead, NVIDIA
Doug Crisman, SGI
Matt Cruikshank, Vital Images
Deron Dann Johnson, Sun
Suzy Deffeyes, IBM
Steve Demlow, Vital Images
Joe Deng, SiS
Jean-Luc Dery, Discreet
Kenneth Dyke, Apple
Brian Emberling, Sun
Cass Everitt, NVIDIA
Brandon Fli?et, Intel
Allen Gallotta, ATI
Daniel Ginsburg, ATI
Steve Glanville, NVIDIA
Peter Graffagnino, Apple
Lee Gross, IBM
Rick Hammerstone, ATI
Evan Hart, ATI
Chris Hecker, De?nition 6
Alan Heirich, HP
Gareth Hughes, NVIDIA
Michael I Gold, NVIDIA
John Jarvis, Alt.software
Rich Johnson, HP
John Kessenich, 3Dlabs
Mark Kilgard, NVIDIA
Dale Kirkland, 3Dlabs
Raymond Klassen, Intel
Jason Knipe, Bioware
Jayant Kolhe, NVIDIA
Steve Koren, 3Dlabs
Bob Kuehne, SGI
Christian Laforte, Alias
Version 3.0 (September 23, 2008)K.5. ACKNOWLEDGEMENTS 443
Luc Leblanc, Discreet
Jon Leech, SGI
Kevin Lefebvre, HP
Bill Licea-Kane, ATI
Barthold Lichtenbelt, 3Dlabs
Kent Lin, Intel
Benjamin Lipchak, ATI
Rob Mace, ATI
Bill Mark, NVIDIA
Michael McCool, U. Waterloo
Jack Middleton, Sun
Howard Miller, Apple
Teri Morrison, HP / 3Dlabs
Marc Olano, SGI / U. Maryland
Jean-Francois Panisset, Discreet
Jon Paul Schelter, Matrox
Brian Paul, Tungsten Graphics
Scott Peterson, HP
Bimal Poddar, Intel
Thomas Roell, Xi Graphics
Phil Rogers, ATI
Ian Romanick, IBM
John Rosasco, Apple
Randi Rost, 3Dlabs
Matt Russo, Matrox
Jeremy Sandmel, ATI
Paul Sargent, 3Dlabs
Folker Schamel, Spinor GMBH
Michael Schulman, Sun
John Scott, Raven Software
Avinash Seetharamaiah, Intel
John Spitzer, NVIDIA
Vlad Stamate, Power VR
Michelle Stamnes, Intel
John Stauffer, Apple
Eskil Steenberg, Obsession
Bruce Stockwell, HP
Christopher Tan, IBM
Ray Tice, Avid
Pierre P. Tremblay, Discreet
Version 3.0 (September 23, 2008)K.5. ACKNOWLEDGEMENTS 444
Neil Trevett, 3Dlabs
Nick Triantos, NVIDIA
Douglas Twilleager, Sun
Shawn Underwood, SGI
Steve Urquhart, Intelligraphics
Victor Vedovato, ATI
Daniel Vogel, Epic Games
Mik Wells, Softimage
Helene Workman, Apple
Dave Zenz, Dell
Karel Zuiderveld, Vital Images
Version 3.0 (September 23, 2008)Appendix L
Version 2.0
OpenGL version 2.0, released on September 7, 2004, is the sixth revision since the
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.0 is upward compatible
with earlier versions, meaning that any program that runs with a 1.5, 1.4, 1.3, 1.2,
1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL implemen-
tation.
Following are brief descriptions of each addition to OpenGL 2.0.
L.1 Programmable Shading
The OpenGL Shading Language, and the related APIs to create, manage, and use
programmable shaders written in the Shading Language, were promoted to core
features in OpenGL 2.0. The complete list of features related to programmable
shading includes:
L.1.1 Shader Objects
Shader objects provides mechanisms necessary to manage shader and program ob-
jects. Shader objects were promoted from the GL ARB shader objects exten-
sion.
L.1.2 Shader Programs
Vertex and fragment shader programs may be written in the high-level OpenGL
Shading Language, replacing ?xed-functionality vertex and fragment process-
ing respectively. Vertex and fragment shader programs were promoted from the
GL ARB vertex shader andGL ARB fragment shader extensions.
445L.2. MULTIPLERENDERTARGETS 446
L.1.3 OpenGL Shading Language
The OpenGL Shading Language is a high-level, C-like language used to program
the vertex and fragment pipelines. The Shading Language Specification de?nes
the language proper, while OpenGL API features control how vertex and fragment
programs interact with the ?xed-function OpenGL pipeline and how applications
manage those programs.
OpenGL 2.0 implementations must support at least revision 1.10
of the OpenGL Shading Language. Implementations may query the
SHADING LANGUAGE VERSION string to determine the exact version of the
language supported. The OpenGL Shading Language was promoted from the
GL ARB shading language 100 extension (the shading language itself is
speci?ed in a companion document; due to the way it’s written, that document did
not need to be changed as a consequence of promoting programmable shading to
the OpenGL core).
L.1.4 Changes To Shader APIs
Small changes to the APIs for managing shader and program objects were made
in the process of promoting the shader extensions to the OpenGL 2.0 core. These
changes do not affect the functionality of the shader APIs, but include use of the
existinguint core GL type rather than the newhandleARB type introduced by
the extensions, and changes in some function names, for example mapping the ex-
tension function CreateShaderObjectARB into the core function CreateShader.
L.2 Multiple Render Targets
Programmable shaders may write different colors to multiple output color
buffers in a single pass. Multiple render targets was promoted from the
GL ARB draw buffers extension.
L.3 Non-Power-Of-Two Textures
The restriction of textures to power-of-two dimensions has been relaxed for
all texture targets, so that non-power-of-two textures may be speci?ed with-
out generating errors. Non-power-of-two textures was promoted from the
GL ARB texture non power of two extension.
Version 3.0 (September 23, 2008)L.4. POINTSPRITES 447
L.4 Point Sprites
Point sprites replace point texture coordinates with texture coordinates interpolated
across the point. This allows drawing points as customized textures, useful for
particle systems.
Point sprites were promoted from theGL ARB point sprite extension, with
the further addition of the POINT SPRITE COORD ORIGIN parameter controlling
the direction in which thet texture coordinate increases.
L.5 Separate Blend Equation
Blending capability is extended with BlendEquationSeparate to allow indepen-
dent setting of the RGB and alpha blend equations for blend operations.
Separate blend functions was pro-
moted from theGL EXT blend equation separate extension. Note that blend
equation LOGIC OP is not supported unless the GL EXT blend logic op exten-
sion is supported;LOGIC OP was inadvertently included in the initial release of the
OpenGL 2.0 Specification.
L.6 Separate Stencil
Separate stencil functionality may be de?ned for the front and back faces of primi-
tives, improving performance of shadow volume and Constructive Solid Geometry
rendering algorithms.
Separate stencil was based on the the
API of the GL ATI separate stencil extension, with additional state de?ned
by the similarGL EXT stencil two side extension.
L.7 Other Changes
Several minor revisions and corrections to the OpenGL 1.5 speci?cation were
made:
 In section 2.7, SecondaryColor3 was changed to set A to 1.0 (previously
0.0), so the initial GL state can be restored.
 In section 2.18, transformation was added to the list of steps not performed
by WindowPos.
Version 3.0 (September 23, 2008)L.7. OTHERCHANGES 448
 Section 3.9.1 was clari?ed to mandate that selection of texture internal for-
mat must allocate a non-zero number of bits for all components named by
the internal format, and zero bits for all other components.
 Tables 3.24 and 3.25 were generalized to multiple textures by replacingC
f
withC .
p
 In section 6.1.9, GetHistogram was clari?ed to note that the Final Conver-
sion pixel storage mode is not applied when storing histogram counts.
 TheFOG COORD ARRAY BUFFER BINDING enumerant alias was added to ta-
ble K.1.
After the initial version of the OpenGL 2.0 was released, several more minor
corrections were made in the speci?cation revision approved on October 22, 2004:
 Corrected name of the fog source from FOG COORD SRC to FOG COORD in
section 2.18.
 Corrected last parameter type in the declaration of the UniformMatrix*
commands toconst float *value, in section 2.20.3.
 Changed the end of the second paragraph of the Conversion to Fragments
subsection of section 3.7.4, to more clearly describe the set of generated
fragments.
 Changed from the olderFOG COORDINATE to the newerFOG COORD notation
in section 3.11.
 AddedPOINT SPRITE COORD ORIGIN state to table 6.16.
 Changed the description of MAX TEXTURE UNITS in table 6.48 to re?ect its
legacy status (referring to the number of ?xed-function texture units), and
moved it into table 6.49.
 Removed duplicated table entries for MAX TEXTURE IMAGE UNITS and
MAX TEXTURE COORDS from table 6.49.
 Added Victor Vedovato to the OpenGL 2.0 Acknowledgements section.
 Miscellaneous typographical corrections.
Additional minor corrections were made in the speci?cation revision approved
on February 9, 2005:
Version 3.0 (September 23, 2008)L.8. ACKNOWLEDGEMENTS 449
 Restored missing language from the depth texture extension in section 6.1.4,
allowingDEPTH COMPONENT as a format for texture readbacks.
 Added separate blend equation to the feature list in appendix L. The feature
has been in the actual OpenGL 2.0 speci?cation all along, but was omitted
from the feature list in the initial speci?cation release.
 Removed LOGIC OP from the allowed blend equations in section 4.1.8 and
table 4.1, and adjusted the type of the blend equation state in table 6.25
accordingly.
 Restored missingVERTEX ATTRIB ARRAY BUFFER BINDING state from ta-
ble 6.8.
 Miscellaneous typographical corrections.
L.8 Acknowledgements
OpenGL 2.0 is the result of the contributions of many people. The editors espe-
cially thank the ongoing work of the ARB GL2 working group, led by Bill Licea-
Kane and with speci?cations edited by John Kessenich and Barthold Lichtenbelt,
in performing work necessary to promote the OpenGL Shading Language to a core
OpenGL feature.
A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
Kurt Akeley, NVIDIA
Allen Akin
Dave Baldwin, 3Dlabs
Bob Beretta, Apple
Pat Brown, NVIDIA
Matt Craighead, NVIDIA
Suzy Deffeyes, IBM
Ken Dyke, Apple
Cass Everitt, NVIDIA
Steve Glanville, NVIDIA
Michael I. Gold, NVIDIA
Evan Hart, ATI
Phil Huxley, 3Dlabs
Deron Dann Johnson, Sun
John Kessenich, 3Dlabs
Mark Kilgard, NVIDIA
Version 3.0 (September 23, 2008)L.8. ACKNOWLEDGEMENTS 450
Dale Kirkland, 3Dlabs
Steve Koren, 3Dlabs
Jon Leech, SGI
Bill Licea-Kane, ATI
Barthold Lichtenbelt, 3Dlabs
Kent Lin, Intel
Benjamin Lipchak, ATI
Rob Mace, ATI
Michael McCool, U. Waterloo
Jack Middleton, Sun
Jeremy Morris, 3Dlabs
Teri Morrison, 3Dlabs
Marc Olano, SGI / U. Maryland
Glenn Ortner, ATI
Brian Paul, Tungsten Graphics
Bimal Poddar, Intel
Phil Rogers, ATI
Ian Romanick, IBM
Randi Rost, 3Dlabs
Jeremy Sandmel, ATI
Folker Schamel, Spinor GMBH
Geoff Stahl, Apple
Eskil Steenberg, Obsession
Neil Trevett, 3Dlabs
Victor Vedovato, ATI
Mik Wells, Softimage
Esen Yilmaz, Intel
Dave Zenz, Dell
Version 3.0 (September 23, 2008)Appendix M
Version 2.1
OpenGL version 2.1, released on August 2, 2006, is the seventh revision since the
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.1 is upward compatible
with earlier versions, meaning that any program that runs with a 2.0, 1.5, 1.4,
1.3, 1.2, 1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL
implementation.
Following are brief descriptions of each addition to OpenGL 2.1.
M.1 OpenGL Shading Language
OpenGL 2.1 implementations must support at least revision 1.20 of
the OpenGL Shading Language. Implementations may query the
SHADING LANGUAGE VERSION string to determine the exact version of the
language supported. Refer to the OpenGL Shading Language Specification for
details of the changes between revision 1.10 and 1.20.
M.2 Non-Square Matrices
Added the UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gfv commands in sec-
tion 2.20.3, allowing speci?cation of non-square uniform matrices.
M.3 Pixel Buffer Objects
Pixel buffer objects expand on the interface provided by the vertex buffer objects,
allowing buffer objects to be used with both vertex array and pixel data. This allows
451M.4. SRGBTEXTURES 452
more acceleration opportunities for OpenGL pixel commands.
When a buffer object is bound to the PIXEL PACK BUFFER target, commands
such as ReadPixels write their data into a buffer object. When a buffer object is
bound to the PIXEL UNPACK BUFFER target, commands such as DrawPixels and
TexImage2D read their data from a buffer object.
Pixel buffer objects was promoted from the GL ARB pixel buffer object
extension. The speci?cation was tightened to consistently require error be gener-
ated when read or write operations to a pixel buffer object would run past the end
of the buffer, or would be misaligned with respect to the data type being read or
written.
M.4 sRGB Textures
New uncompressed and compressed color texture formats with sRGB color com-
ponents are de?ned. The sRGB color space is based on typical (non-linear) monitor
characteristics expected in a dimly lit of?ce. It has been standardized by the Inter-
national Electrotechnical Commission (IEC) as IEC 61966-2-1. The sRGB color
space roughly corresponds to 2.2 gamma correction.
sRGB textures was promoted from the GL EXT texture sRGB extension.
Speci?c compressed sRGB internal formats de?ned by the extension were not in-
cluded in OpenGL 2.1, while the generic uncompressed and compressed formats
were retained.
M.5 Other Changes
Several minor revisions and corrections to the OpenGL 2.0 speci?cation were
made:
 Note that the information log for program objects can include both link and
validation information, in section 2.20.2.
 Noted in section 3.7.4 that there is a current raster secondary color, and added
theCURRENT RASTER SECONDARY COLOR query.
 Required perspective-correct interpolation for
all fragment attributes except depth in sections 3.5.1 and 3.6.1, effectively
makingGL PERSPECTIVE CORRECT HINT a no-op.
 Merged speci?c and generic compressed internal texture format tables into
the single table 3.19.
Version 3.0 (September 23, 2008)M.5. OTHERCHANGES 453
 Changed the type of texture wrap mode and min/mag ?lter parameters from
integer to enum in table 3.20.
 Removed mention of compressed texture depth components from sec-
tion 3.9.1, since no compressed depth formats are currently de?ned.
 Added forward reference from section 3.9.5 to section 3.9.14, which de?nes
how depth textures are actually used.
 Remove notation in table 4.1, and ?xed blend equations for
c
FUNC REVERSE SUBTRACT.
 Noted in section 6.1.18 that all texture object parameters are pushed and
popped by PushAttrib and PopAttrib when TEXTURE BIT is set in the at-
tribute mask.
 Miscellaneous typographical corrections.
Additional minor corrections were made in a speci?cation revision approved on
August 10, 2006, with a few additional ?xes and omissions corrected on December
1, 2006:
 Noted in section 2.5 that INVALID VALUE is generated for negative
sizeiptr values.
 Noted in section 2.7 that VertexAttrib* can be used to load attributes for
any supported matrix type, not just square matrices.
 Removed the description of generating multiple connected components
when clipping vertices withw values of different signs, at the end of sec-
c
tion 2.17. Implementations should not render in thew < 0 region.
c
 Added FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2, FLOAT MAT3x4,
FLOAT MAT4x2, and FLOAT MAT4x3 tokens for non-square matrix types to
GetActiveAttrib and GetActiveUniform in section 2.20.3, and expanded
the description of how attribute components are mapped to matrix elements
to match.
 Clari?ed in section 3.9.12 that the texture object passed to BindTexture must
match the speci?ed target, not just the dimensionality of target.
 Added missing TexEnv targets RGB SCALE, ALPHA SCALE, SRCn RGB,
SRCn ALPHA,OPERANDn RGB, andOPERANDn ALPHA in section 3.9.13.
Version 3.0 (September 23, 2008)M.6. ACKNOWLEDGEMENTS 454
 Noted thatPOINT SPRITE is a possible env parameter to GetTexEnv in sec-
tion 6.1.3.
 Miscellaneous typographical corrections.
Additional minor corrections (in process) were made after December 1, 2006:
 Corrected spelling ofACTIVE ATTRIBUTE MAX LENGTH in table 6.40.
 Clari?ed in section 4.1.12 that logical operations are also performed for each
sample when multisampling is active (Khronos internal bug 1022, Bill Licea-
Kane).
 Added missingQUERY RESULT andQUERY RESULT AVAILABLE to state ta-
ble 6.52.
 Speci?ed in section 3.7.3 that ?oating-point PixelMap entries are clamped
to the range [0; 1] when speci?ed (bug 3379, Mark Kilgard).
 Corrected description of type ofTEXTURE MIN LOD andTEXTURE MAX LOD
in section 3.9.11 (bug 2861, Bill Licea-Kane).
 Changed number of sets of texture state from two to four in section 3.9.11
(bug 2862, Bill Licea-Kane).
 Speci?ed in section 5.4 that ?oating-point offsets to CallLists are truncated
towards negative in?nity (bug 3379, Mark Kilgard).
 Speci?ed that the data conversion rules for integer queries of ?oating-point
state de?ned in section 6.1.2 also apply to the enumerated queries in sec-
tion 6.1.3 (bug 3379, Mark Kilgard).
 Removed DRAW BUFFER state from table 6.26 and added descriptions of
DRAW BUFFERi andDRAW BUFFER in section 4.2.1 (bug 1029, Jeff Juliano).
M.6 Acknowledgements
OpenGL 2.1 is the result of the contributions of many people. The editor especially
thanks the ongoing work of the ARB GLSL working group, led by Bill Licea-Kane
and with speci?cations edited by John Kessenich and Barthold Lichtenbelt, in up-
dating the OpenGL Shading Language to revision 1.20. Ralf Biermann, Derek Cor-
nish, Matt Craighead, and Mark Kilgard edited the EXT pixel buffer object
Version 3.0 (September 23, 2008)M.6. ACKNOWLEDGEMENTS 455
proposal later adopted and developed by the ARB Pixel Buffer Object working
group, and Mark Kilgard edited theEXT texture sRGB extension.
A partial list of other contributors, including the company that they represented
at the time of their contribution, follows:
Aaftab Munshi, ATI
Avi Shapira, Graphic Remedy
Barthold Lichtenbelt, 3Dlabs / NVIDIA
Benjamin Lipchak, ATI
Benji Bowman, Imagination Technologies
Bill Armstrong, Evans and Sutherland
Bill Licea-Kane, ATI
Bimal Poddar, Intel
Bob Beretta, Apple
Brian Paul, Tungsten Graphics
Cass Everitt, NVIDIA
Chris Dodd, NVIDIA
Chris Starkey, 3Dlabs
Dale Kirkland, 3Dlabs
Daniel Vogel, Epic Games
Dave Shreiner, SGI
Derek Cornish, NVIDIA
Eskil Steenberg, Obsession
Evan Hart, ATI
Folker Schamel, Spinor GMBH
Geoff Stahl, Apple
Howard Miller, Apple
Ian Romanick, IBM
James A. McCombe, Apple
Jeff Juliano, NVIDIA
Jeff Weyman, ATI
Jeremy Sandmel, Apple / ATI
John Kessenich, 3Dlabs / Intel
John Rosasco, Apple
John Scott
Jon Leech, SGI / Independent
Jon Trulson, Xi Graphics
Ken Severson, NVIDIA
Kenneth Dyke, Apple
Kenneth Russell, Sun
Kent Lin, Intel
Version 3.0 (September 23, 2008)M.6. ACKNOWLEDGEMENTS 456
Marc Olano, U. Maryland
Mark Kilgard, NVIDIA
Michael Gold, NVIDIA
Neeraj Srivastava, Dell
Neil Trevett, 3Dlabs / NVIDIA
Nick Burns, Apple
Pat Brown, NVIDIA
Paul Martz, SimAuthor
Paul Ramsey, Sun
Pierre Boudier, ATI
Ralf Biermann, NVIDIA
Randi Rost, 3Dlabs
Rob Mace, ATI
Robert Simpson, Bitboys / ATI
Saifuddin Fakhruddin, Intel
Shawn Underwood, SGI
Steve Demlow, Vital Images
Steve Koren, 3Dlabs
Steven Zhu, Intel
Thomas Roell, NVIDIA
Tom Lanzoni, Dell
Travis Bryson, Sun
Yaki Tebeka, Graphic Remedy
Version 3.0 (September 23, 2008)Appendix N
Version 3.0
OpenGL version 3.0, released on August 11, 2008, is the eighth revision since
the original version 1.0. When using a full 3.0 context, OpenGL 3.0 is upward
compatible with earlier versions, meaning that any program that runs with a 2.1 or
earlier GL implementation will also run unchanged with a 3.0 GL implementation.
OpenGL 3.0 context creation is done using a window system binding API, and
on most platforms a new command, de?ned by extensions introduced along with
OpenGL 3.0, must be called to create a 3.0 context. Calling the older context
creation commands will return an OpenGL 2.1 context. When using a forward
compatible context, many OpenGL 2.1 features are not supported.
Following are brief descriptions of changes and additions to OpenGL 3.0.
N.1 New Features
New features in OpenGL 3.0, including the extension or extensions if any on which
they were based, include:
 API support for the new texture lookup, texture format, and integer and un-
signed integer capabilities of the OpenGL Shading Language 1.30 speci?ca-
tion (GL EXT gpu shader4).
 Conditional rendering (GL NV conditional render).
 Fine control over mapping buffer subranges into client space and ?ushing
modi?ed data (GL APPLE flush buffer range).
 Floating-point color and depth internal formats for textures and renderbuffers
(GL ARB color buffer float, GL NV depth buffer float,
457N.2. DEPRECATIONMODEL 458
GL ARB texture float, GL EXT packed float, and
GL EXT texture shared exponent).
 Framebuffer objects (GL EXT framebuffer object).
 Half-?oat (16-bit) vertex array and pixel data formats
(GL NV half float andGL ARB half float pixel).
 Multisample stretch blit functionality (GL EXT framebuffer multisample
andGL EXT framebuffer blit).
 Non-normalized integer color internal formats for textures and renderbuffers
(GL EXT texture integer).
 One- and two-dimensional layered texture targets
(GL EXT texture array).
 Packed depth/stencil internal formats for combined depth+stencil textures
and renderbuffers (GL EXT packed depth stencil).
 Per-color-attachment blend enables and color writemasks
(GL EXT draw buffers2).
 RGTC speci?c internal compressed formats
(GL EXT texture compression rgtc).
 Single- and double-channel (R andRG) internal formats for textures and ren-
derbuffers.
 Transform feedback (GL EXT transform feedback).
 Vertex array objects (GL APPLE vertex array object).
 sRGB framebuffer mode (GL EXT framebuffer sRGB)
N.2 Deprecation Model
OpenGL 3.0 introduces a deprecation model in which certain features may be
marked as deprecated. The deprecation model is described in detail in appendix E,
together with a summary of features deprecated in OpenGL 3.0.
Version 3.0 (September 23, 2008)N.3. CHANGEDTOKENS 459
New Token Name Old Token Name
COMPARE REF TO TEXTURE COMPARE R TO TEXTURE
MAX VARYING COMPONENTS MAX VARYING FLOATS
MAX CLIP DISTANCES MAX CLIP PLANES
CLIP DISTANCEi CLIP PLANEi
Table N.1: New token names and the old names they replace.
N.3 Changed Tokens
New token names are introduced to be used in place of old, inconsistent names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table N.1.
N.4 Change Log
Minor corrections to the OpenGL 3.0 Specification were made after its initial re-
lease.
Changes in the draft of September 23, 2008:
 Changed ClearBuffer* in section 4.2.3 to use DEPTH and STENCIL
buffer names. Changed GetFramebufferAttachmentParameteriv in sec-
tion 6.1.16 to accept only DEPTH and STENCIL to identify default
framebuffer depth and stencil buffers, and only DEPTH ATTACHMENT and
STENCIL ATTACMENT to identify framebuffer object depth and stencil
buffers (bug 3744).
Changes in the draft of September 18, 2008:
 Added missing close-brace to ArrayElement pseudocode in section 2.8
(bug 3897).
 Noted in section 2.13 that BeginQuery will generate
an INVALID OPERATION error when called with an existing query object
name whose type does not match the speci?ed target (bug 3712).
 Add description of gl ClipDistance to shader outputs in section 2.20.4
and note that only one of gl ClipVertex and gl ClipDistance should
be written by a shader (bug 3898).
Version 3.0 (September 23, 2008)N.4. CHANGELOG 460
 Changed ClearBuffer* in section 4.2.3 to indirect through the draw
buffer state by specifying the buffer type and draw buffer number, rather
than the attachment name; also changed to accept DEPTH BUFFER /
DEPTH ATTACHMENT and STENCIL BUFFER / STENCIL ATTACHMENT in-
terchangeably, to reduce inconsistency between clearing the default frame-
buffer and framebuffer objects. Likewise changed GetFramebuffer-
AttachmentParameteriv in section 6.1.16 to accept DEPTH BUFFER /
DEPTH ATTACHMENT and STENCIL BUFFER / STENCIL ATTACMENT inter-
changeably (bug 3744).
 Add proper type suf?x to query commands in tables 6.8 and 6.42 (Mark
Kilgard).
 Update deprecation list in section E.1 to itemize deprecated state for two-
sided color selection and include per-texture-unit LOD bias (bug 3735).
Changes in the draft of August 28, 2008:
 Sections 2.9, 2.9.1; tables 2.6, 2.7, and 6.11 - move buffer map/unmap calls
into their own subsection and rewrite MapBuffer in terms of MapBuffer-
Range. Add buffer state BUFFER ACCESS FLAGS, BUFFER MAP OFFSET,
BUFFER MAP LENGTH. Make MapBuffer and MapBufferRange errors con-
sistent (bug 3601).
 Section 2.10 - Extend INVALID OPERATION error to any array pointer-
setting command called to specify a client array while a vertex array object
is bound, not just VertexAttrib*Pointer (bug 3696).
 Sections 2.12.1, 4.1.2, 4.2.1, and 4.3.4 - de?ne initial state when a context is
bound with no default framebuffer - null viewport and scissor region, draw
buffer = read buffer =NONE, max viewport dims = max(display size - if any,
max renderbuffer size). Viewport/scissor language added to the GLX and
WGL create context extension specs as well (bug 2941).
 Section 2.15 - de?ne “word-aligned” to be a multiple of 4 (e.g. 32 bits) (bug
3624).
 Section 5.5 - add MapBufferRange and FlushBufferRange to commands
not compiled in display lists (bug 3704).
 Section 6.1.13 - Moved GetBufferParameteriv query from section 6.1.3
and changed formal argument specifying the parameter name from value to
pname (side effect of bug 3697).
Version 3.0 (September 23, 2008)N.5. CREDITSANDACKNOWLEDGEMENTS 461
 Section 6.1.16 - Moved GetFramebufferAttachmentiv query from sec-
tion 6.1.3. Querying framebuffer attachment parameters other than object
type and name when no attachment is present is an INVALID ENUM error.
Querying texture parameters (level, cube map face, or layer) for a render-
buffer attachment is also anINVALID ENUM error (note that this was allowed
in previous versions of the extension but the return values were not speci?ed;
it should clearly be an error as are other parameters that don’t exist for the
type of attachment present). Also reorganized the description of this com-
mand quite a bit to improve readability and remove redundancy and internal
inconsistencies (bug 3697).
 Section 6.1.17 - Moved GetRenderbufferParameteriv query from sec-
tion 6.1.3 (side effect of bug 3697).
 Appendix D.1 - add language to clarify that attachments to an object affect
its reference count, and that object storage doesn’t go away until there are no
references remaining (bug 3725).
 Appendix E.1 - remove TEXTURE BORDER COLOR and CLAMP TO BORDER
mode from the deprecated feature list; they were put in by accident (bug
3750).
 Appendix N - Cite EXT texture array instead of
EXT geometry shader4 as the source of 1D/2D array texture
functionality. Fix a typo. Add change log relative to initial 3.0 spec
release.
N.5 Credits and Acknowledgements
OpenGL 3.0 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.0, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including speci?c functionality developed in the form of
new ARB extensions together with OpenGL 3.0. In addition, many people partic-
ipated in developing earlier vendor andEXT extensions on which the OpenGL 3.0
functionality is based in part; those individuals are listed in the respective extension
speci?cations in the OpenGL Extension Registry.
Aaftab Munshi, Apple
Alain Bouchard, Matrox
Version 3.0 (September 23, 2008)N.5. CREDITSANDACKNOWLEDGEMENTS 462
Alexis Mather, AMD (Chair, ARB Marketing TSG)
Andreas Wolf, AMD
Avi Shapira, Graphic Remedy
Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
Benjamin Lipchak, AMD
Benji Bowman, Imagination Technologies
Bill Licea-Kane, AMD (Chair, ARB Shading Language TSG)
Bob Beretta, Apple
Brent Insko, Intel
Brian Paul, Tungsten Graphics
Bruce Merry, ARM (Detailed speci?cation review)
Cass Everitt, NVIDIA
Chris Dodd, NVIDIA
Daniel Horowitz, NVIDIA
Daniel Koch, Transgaming (Framebuffer objects, half ?oat vertex formats, and
instanced rendering)
Daniel Omachi, Apple
Dave Shreiner, ARM
Eric Boumaour, AMD
Eskil Steenberg, Obsession
Evan Hart, NVIDIA
Folker Schamel, Spinor GMBH
Gavriel State, Transgaming
Geoff Stahl, Apple
Georg Kolling, Imagination Technologies
Gregory Prisament, NVIDIA
Guillaume Portier, HI Corp
Ian Romanick, IBM / Intel (Vertex array objects; GLX protocol)
James Helferty, Transgaming (Instanced rendering)
James Jones, NVIDIA
Jamie Gennis, NVIDIA
Jason Green, Transgaming
Jeff Bolz, NVIDIA
Jeff Juliano, NVIDIA
Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.0) TSG)
John Kessenich, Intel (OpenGL Shading Language Specification Editor; depre-
cation model)
John Rosasco, Apple
Jon Leech, Independent (Chair, ARB Ecosystem TSG; OpenGL API Speci?ca-
tion Editor; R/RG image formats and new context creation APIs)
Version 3.0 (September 23, 2008)N.5. CREDITSANDACKNOWLEDGEMENTS 463
Marc Olano, U. Maryland
Mark Callow, HI Corp
Mark Kilgard, NVIDIA (Many extensions on which OpenGL 3.0 features were
based)
Matti Paavola, Nokia
Michael Gold, NVIDIA (Framebuffer objects and instanced rendering)
Neil Trevett, NVIDIA (President, Khronos Group)
Nick Burns, Apple
Nick Haemel, AMD
Pat Brown, NVIDIA (Many extensions on which OpenGL 3.0 features were
based; detailed speci?cation review)
Paul Martz, SimAuthor
Paul Ramsey, Sun
Pierre Boudier, AMD (Floating-point depth buffers)
Rob Barris, Blizzard (Framebuffer object and map buffer range)
Robert Palmer, Symbian
Robert Simpson, AMD
Steve Demlow, Vital Images
Thomas Roell, NVIDIA
Timo Suoranta, Futuremark
Tom Longo, AMD
Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
Travis Bryson, Sun
Yaki Tebeka, Graphic Remedy
Yanjun Zhang, S3 Graphics
Zack Rusin, Tungsten Graphics
The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.
Version 3.0 (September 23, 2008)Appendix O
ARB Extensions
OpenGL extensions that have been approved by the OpenGL Architectural Review
Board (ARB) are described in this chapter. These extensions are not required to be
supported by a conformant OpenGL implementation, but are expected to be widely
available; they de?ne functionality that is likely to move into the required feature
set in a future revision of the speci?cation.
In order not to compromise the readability of the core speci?cation, ARB ex-
tensions are not integrated into the core language; instead, they are made available
online in the OpenGL Extension Registry (as are a much larger number of vendor-
speci?c extensions, as well as extensions to window system binding APIs, such as
GLX and WGL). Extensions are documented as changes to the Specification. The
Registry is available on the World Wide Web at URL
http://www.opengl.org/registry/
Brief descriptions of ARB extensions are provided below.
O.1 Naming Conventions
To distinguish ARB extensions from core OpenGL features and from vendor-
speci?c extensions, the following naming conventions are used:
 A unique name string of the form "GL ARB name" is associated with each
extension. If the extension is supported by an implementation, this string
will be present in theEXTENSIONS string described in section 6.1.11.
 All functions de?ned by the extension will have names of the form Func-
tionARB
464O.2. PROMOTINGEXTENSIONSTOCOREFEATURES 465
 All enumerants de?ned by the extension will have names of the form
NAME ARB.
 In additional to OpenGL extensions, there are also ARB extensions to the
related GLX and WGL APIs. Such extensions have name strings pre?xed by
"GLX " and "WGL " respectively. Not all GLX and WGL ARB extensions
are described here, but all such extensions are included in the registry.
O.2 Promoting Extensions to Core Features
ARB extensions can be promoted to required core features in later revisions of
OpenGL. When this occurs, the extension speci?cations are merged into the core
speci?cation. Functions and enumerants that are part of such promoted extensions
will have the ARB af?x removed.
GL implementations of such later revisions should continue to export the name
strings of promoted extensions in theEXTENSIONS string, and continue to support
the ARB-af?xed versions of functions and enumerants as a transition aid.
For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond, see appendices I, J, K, and L respectively.
O.3 Multitexture
The name string for multitexture isGL ARB multitexture. It was promoted to a
core feature in OpenGL 1.3.
O.4 Transpose Matrix
The name string for transpose matrix isGL ARB transpose matrix. It was pro-
moted to a core feature in OpenGL 1.3.
O.5 Multisample
The name string for multisample is GL ARB multisample. It was promoted to a
core feature in OpenGL 1.3.
Version 3.0 (September 23, 2008)O.6. TEXTUREADDENVIRONMENTMODE 466
O.6 Texture Add Environment Mode
The name string for texture add mode is GL ARB texture env add. It was pro-
moted to a core feature in OpenGL 1.3.
O.7 Cube Map Textures
The name string for cube mapping is GL ARB texture cube map. It was pro-
moted to a core feature in OpenGL 1.3.
O.8 Compressed Textures
The name string for compressed textures is GL ARB texture compression. It
was promoted to a core feature in OpenGL 1.3.
O.9 Texture Border Clamp
The name string for texture border clamp isGL ARB texture border clamp. It
was promoted to a core feature in OpenGL 1.3.
O.10 Point Parameters
The name string for point parameters isGL ARB point parameters. It was pro-
moted to a core features in OpenGL 1.4.
O.11 Vertex Blend
Vertex blending replaces the single model-view transformation with multiple ver-
tex units. Each unit has its own transform matrix and an associated current weight.
Vertices are transformed by all the enabled units, scaled by their respective weights,
and summed to create the eye-space vertex. Normals are similarly transformed by
the inverse transpose of the model-view matrices.
The name string for vertex blend isGL ARB vertex blend.
Version 3.0 (September 23, 2008)O.12. MATRIXPALETTE 467
O.12 Matrix Palette
Matrix palette extends vertex blending to include a palette of model-view matrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
The name string for matrix palette isGL ARB matrix palette.
O.13 Texture Combine Environment Mode
The name string for texture combine mode isGL ARB texture env combine. It
was promoted to a core feature in OpenGL 1.3.
O.14 Texture Crossbar Environment Mode
The name string for texture crossbar is GL ARB texture env crossbar. It was
promoted to a core features in OpenGL 1.4.
O.15 Texture Dot3 Environment Mode
The name string for DOT3 is GL ARB texture env dot3. It was promoted to a
core feature in OpenGL 1.3.
O.16 Texture Mirrored Repeat
The name string for texture mirrored repeat is
GL ARB texture mirrored repeat. It was promoted to a core feature in
OpenGL 1.4.
O.17 Depth Texture
The name string for depth texture isGL ARB depth texture. It was promoted to
a core feature in OpenGL 1.4.
O.18 Shadow
The name string for shadow isGL ARB shadow. It was promoted to a core feature
in OpenGL 1.4.
Version 3.0 (September 23, 2008)O.19. SHADOWAMBIENT 468
O.19 Shadow Ambient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value speci?ed by theTEXTURE COMPARE FAIL VALUE ARB texture pa-
rameter to be returned when the texture comparison fails. This may be used for
ambient lighting of shadowed fragments and other advanced lighting effects.
The name string for shadow ambient isGL ARB shadow ambient.
O.20 Window Raster Position
The name string for window raster position is GL ARB window pos. It was pro-
moted to a core feature in OpenGL 1.4.
O.21 Low-Level Vertex Programming
Application-de?ned vertex programs may be speci?ed in a new low-level program-
ming language, replacing the standard ?xed-function vertex transformation, light-
ing, and texture coordinate generation pipeline. Vertex programs enable many new
effects and are an important ?rst step towards future graphics pipelines that will be
fully programmable in an unrestricted, high-level shading language.
The name string for low-level vertex programming is
GL ARB vertex program.
O.22 Low-Level Fragment Programming
Application-de?ned fragment programs may be speci?ed in the same low-level lan-
guage as GL ARB vertex program, replacing the standard ?xed-function vertex
texturing, fog, and color sum operations.
The name string for low-level fragment programming is
GL ARB fragment program.
O.23 Buffer Objects
The name string for buffer objects is GL ARB vertex buffer object. It was
promoted to a core feature in OpenGL 1.5.
Version 3.0 (September 23, 2008)O.24. OCCLUSIONQUERIES 469
O.24 Occlusion Queries
The name string for occlusion queries is GL ARB occlusion query. It was pro-
moted to a core feature in OpenGL 1.5.
O.25 Shader Objects
The name string for shader objects isGL ARB shader objects. It was promoted
to a core feature in OpenGL 2.0.
O.26 High-Level Vertex Programming
The name string for high-level vertex programming is GL ARB vertex shader.
It was promoted to a core feature in OpenGL 2.0.
O.27 High-Level Fragment Programming
The name string for high-level fragment
programming is GL ARB fragment shader. It was promoted to a core feature
in OpenGL 2.0.
O.28 OpenGL Shading Language
The name string for the OpenGL Shading Language is
GL ARB shading language 100. The presence of this extension string in-
dicates that programs written in version 1 of the Shading Language are accepted
by OpenGL.
It was promoted to a core feature in OpenGL 2.0.
O.29 Non-Power-Of-Two Textures
The name string for non-power-of-two textures is
GL ARB texture non power of two. It was promoted to a core feature in
OpenGL 2.0.
Version 3.0 (September 23, 2008)O.30. POINTSPRITES 470
O.30 Point Sprites
The name string for point sprites isGL ARB point sprite. It was promoted to a
core feature in OpenGL 2.0.
O.31 Fragment Program Shadow
Fragment program shadow extends low-level fragment programs de?ned with
GL ARB fragment program to add shadow 1D, 2D, and 3D texture targets, and
remove the interaction withGL ARB shadow.
The name string for fragment program shadow is
GL ARB fragment program shadow.
O.32 Multiple Render Targets
The name string for multiple render targets is GL ARB draw buffers. It was
promoted to a core feature in OpenGL 2.0.
O.33 Rectangular Textures
Rectangular textures de?ne a new texture target TEXTURE RECTANGLE ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangular
textures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are are also useful for shadow maps and window-space texturing.
These textures are accessed by dimension-dependent (aka non-normalized) texture
coordinates.
Rectangular textures are a restricted version of non-power-of-two textures. The
differences are that rectangular textures are supported only for 2D; they require a
new texture target; and the new target uses non-normalizes texture coordinates
The name string for texture rectangles isGL ARB texture rectangle.
O.34 Floating-Point Color Buffers
Floating-point color buffers can represent values outside the normal [0; 1] range
of colors in the ?xed-function OpenGL pipeline. This group of related exten-
sions enables controlling clamping of vertex colors, fragment colors throughout the
pipeline, and pixel data read back to client memory, and also includes WGL and
Version 3.0 (September 23, 2008)O.35. HALF-PRECISIONFLOATINGPOINT 471
GLX extensions for creating frame buffers with ?oating-point color components
(referred to in GLX as framebuffer con?gurations, and in WGL as pixel formats).
The name strings for ?oating-point color buffers are
GL ARB color buffer float, GLX ARB fbconfig float, and
WGL ARB pixel format float.
O.35 Half-Precision Floating Point
This extension de?nes the representation of a 16-bit ?oating point data format, and
a correspondingtype argument which may be used to specify and read back pixel
and texture images stored in this format in client memory. Half-precision ?oats are
smaller than full precision ?oats, but provide a larger dynamic range than similarly
sized (short) data types.
The name string for half-precision ?oating point is
GL ARB half float pixel.
O.36 Floating-Point Textures
Floating-point textures stored in both 32- and 16-bit formats may be de?ned using
new internalformat arguments to commands which specify and read back texture
images.
The name string for ?oating-point textures isGL ARB texture float.
O.37 Pixel Buffer Objects
The buffer object interface is expanded by adding two new binding targets for
buffer objects, the pixel pack and unpack buffers. This permits buffer objects to be
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formance compared to data in client memory.
The name string for pixel buffer objects isGL ARB pixel buffer object. It
was promoted to a core feature in OpenGL 2.1.
Version 3.0 (September 23, 2008)Index
x BIAS, 139, 373 ALPHA, 139, 153, 166, 167, 179, 182,
x SCALE, 139, 373 186, 202, 203, 220–222, 225,
2D, 307, 308, 392 251, 270, 272, 291, 321, 322,
2 BYTES, 310 361, 369, 373, 374, 376, 391,
3D, 307, 308 408, 412, 418
3D COLOR, 307, 308 ALPHA12, 182
3D COLOR TEXTURE, 307, 308 ALPHA16, 182
3 BYTES, 310 ALPHA4, 182
4D COLOR TEXTURE, 307, 308 ALPHA8, 180, 182
4 BYTES, 310 ALPHA BIAS, 164
ALPHA BITS, 295, 409
1, 178, 192, 193, 215, 322, 359
ALPHA INTEGER, 153
2, 178, 192, 193, 322, 359
ALPHA SCALE, 164, 220, 453
3, 178, 192, 193, 322, 359
ALPHA TEST, 244, 409
4, 178, 192, 193, 322
AlphaFunc, 244, 409
ALWAYS, 202, 226, 244–246, 364
ACCUM, 265
AMBIENT, 82, 84
Accum, 63, 114, 264, 265, 409
AMBIENT AND DIFFUSE, 82, 84
ACCUM * BITS, 409
AND, 254
ACCUM ALPHA BITS, 281
AND INVERTED, 254
ACCUM BLUE BITS, 281
AND REVERSE, 254
ACCUM BUFFER BIT, 261, 341, 409
Antialiasing, 129
ACCUM GREEN BITS, 281
AreTexturesResident, 218, 311, 409
ACCUM RED BITS, 281
ARRAY BUFFER, 38, 40–42, 45–48,
ACTIVE ATTRIBUTE MAX LENGTH,
330, 331
94, 333, 454
ARRAY BUFFER BINDING, 46
ACTIVE ATTRIBUTES, 94, 333
ArrayElement, 24, 32–34, 46, 107, 309,
ACTIVE TEXTURE, 25, 56, 71, 219,
459
299, 317
ATTACHED SHADERS, 333
ACTIVE UNIFORM MAX LENGTH,
AttachShader, 91, 312
98, 333
AUTO NORMAL, 104, 300
ACTIVE UNIFORMS, 97, 333
AUXi, 256–258, 336
ActiveTexture, 56, 101, 228
AUX0, 256
ADD, 220, 222, 223, 265, 427
AUX BUFFERS, 256, 281
ADD SIGNED, 223
ALL ATTRIB BITS, 339, 341, 410
BACK, 81, 83, 84, 130, 131, 133, 245,
472INDEX 473
248, 256, 257, 259–261, 263, BUFFER ACCESS, 39, 41, 44
269, 278, 318, 357, 407 BUFFER ACCESS FLAGS, 39, 41, 44,
BACK LEFT, 257, 258, 336 45, 460
BACK RIGHT, 257, 258, 336 BUFFER MAP LENGTH, 39, 41, 44,
Begin, 16, 19–24, 33, 34, 49, 63, 65, 45, 460
81, 84, 87, 109, 123, 127, 130, BUFFER MAP OFFSET, 39, 41, 44, 45,
133, 235, 294, 295, 301, 302, 460
307, 406 BUFFER MAP POINTER, 39, 41, 44,
BeginConditionalRender, 63, 64 45, 330, 331
BeginQuery, 62, 67, 246, 459 BUFFER MAPPED, 39, 41, 44, 45
BeginTransformFeedback, 64–67 BUFFER SIZE, 39, 41, 42, 44, 65
BGR, 153, 270, 272, 321 BUFFER USAGE, 39, 41, 43
BGR INTEGER, 153 BufferData, 40, 41, 311
BGRA, 153, 156, 160, 270, 321, 416 BufferSubData, 41, 311
BGRA INTEGER, 153 bvec2, 100
BindAttribLocation, 95, 312 BYTE, 29, 152, 272, 273, 310
BindBuffer, 38, 47, 65, 311
C3F V3F, 36, 37
BindBufferBase, 65, 67, 311
C4F N3F V3F, 36, 37
BindBufferRange, 65–67, 311
C4UB V2F, 36, 37
BindFragDataLocation, 236, 237, 312
C4UB V3F, 36, 37
BindFramebuffer, 279–281, 293, 311
CallList, 24, 309, 310, 409
BindRenderbuffer, 282, 283, 311
CallLists, 24, 310, 409, 454
BindTexture, 56, 101, 217, 218, 453
CCW, 80, 357
BindVertexArray, 48, 311
CheckFramebufferStatus, 293, 294, 311
BITMAP, 132, 141, 144, 151, 152, 161,
CLAMP, 202, 206, 207, 408
174, 272, 323
CLAMP FRAGMENT COLOR, 162,
Bitmap, 63, 114, 174, 235, 408
277
BITMAP TOKEN, 308
CLAMP READ COLOR, 271
BLEND, 220, 222, 248, 250, 253
CLAMP TO BORDER, 202, 207, 427,
BlendColor, 250, 434
461
BlendEquation, 248, 434
CLAMP TO EDGE, 202, 207, 277, 417
BlendEquationSeparate, 248, 447
CLAMP VERTEX COLOR, 86
BlendFunc, 249, 434
ClampColor, 86, 162, 407
BlendFuncSeparate, 249, 435
CLEAR, 254
BlitFramebuffer, 276–278, 312
Clear, 63, 114, 261, 262, 264, 409
BLUE, 139, 153, 270, 272, 321, 361,
ClearAccum, 262, 409
369, 373, 374, 376, 391
ClearBuffer, 264
BLUE BIAS, 164
ClearBuffer*, 459, 460
BLUE BITS, 295, 409
ClearBufferfif uigv, 263, 264
BLUE INTEGER, 153
ClearBuffer?, 263, 264
BLUE SCALE, 164
ClearBufferfv, 263, 264
BOOL, 98
ClearBufferiv, 263, 264
BOOL VEC2, 98
ClearBufferuiv, 263
BOOL VEC3, 98
ClearColor, 262, 263
BOOL VEC4, 98
Version 3.0 (September 23, 2008)INDEX 474
ClearDepth, 262–264 COLOR TABLE FORMAT, 324
ClearIndex, 262 COLOR TABLE GREEN SIZE, 324
ClearStencil, 262–264 COLOR TABLE INTENSITY SIZE,
CLIENT ACTIVE TEXTURE, 31, 317 324
CLIENT ALL ATTRIB BITS, 339, COLOR TABLE LUMINANCE SIZE,
341, 410 324
CLIENT PIXEL STORE BIT, 341 COLOR TABLE RED SIZE, 324
CLIENT VERTEX ARRAY BIT, 341 COLOR TABLE SCALE, 141, 142, 324
ClientActiveTexture, 24, 31, 311, 406 COLOR TABLE WIDTH, 324
CLIP DISTANCEi, 459 COLOR WRITEMASK, 260
CLIP PLANEi, 68, 69, 459 ColorMask, 260, 261
CLIP PLANE0, 69 ColorMaski, 260
ClipPlane, 68 ColorMaterial, 83, 84, 300, 398, 407,
COEFF, 320 414
COLOR, 52, 56, 57, 142, 146, 147, 192, ColorPointer, 24, 29, 30, 36, 311, 406
263, 264, 274 ColorSubTable, 137, 143
Color, 24, 26, 63, 73, 84, 88, 93 ColorTable, 137, 141–144, 148, 149,
Color*, 406 171, 172, 312
Color3, 26 ColorTableParameter, 142
Color4, 26 ColorTableParameterfv, 141
Color[size][type]v, 32 Colorub, 88
COLOR ARRAY, 31, 36 Colorui, 88
COLOR ARRAY POINTER, 327 Colorus, 88
COLOR ATTACHMENTi, 256, 257, COMBINE, 220, 223, 228, 427, 435
269, 286, 292 COMBINE ALPHA, 220, 223, 224
COLOR ATTACHMENTm, 256, 259 COMBINE RGB, 220, 223, 224
COLOR ATTACHMENTn, 281 COMPARE R TO TEXTURE, 459
COLOR ATTACHMENT0, 256, 259, COMPARE REF TO TEXTURE, 202,
269, 280 225, 459
COLOR BUFFER BIT, 261, 264, 276, COMPILE, 309, 398
277, 341 COMPILE AND EXECUTE, 309, 310
COLOR INDEX, 132, 141, 144, 151, COMPILE STATUS, 90, 332
153, 165, 174, 270, 274, 321, CompileShader, 90, 312
323, 406 COMPRESSED ALPHA, 186
COLOR INDEXES, 82, 85 COMPRESSED INTENSITY, 186
COLOR LOGIC OP, 253 COMPRESSED LUMINANCE, 186
COLOR MATERIAL, 84, 407 COMPRESSED LUMINANCE ALPHA,
COLOR MATRIX, 323 186
COLOR MATRIX STACK DEPTH, COMPRESSED RED, 186
323 COMPRESSED RED RGTC1, 181,
COLOR SUM, 228, 230, 409 186, 401–403
COLOR TABLE, 141, 144, 166 COMPRESSED RG, 186
COLOR TABLE ALPHA SIZE, 324 COMPRESSED RG RGTC2, 181, 186,
COLOR TABLE BIAS, 141, 142, 324 403
COLOR TABLE BLUE SIZE, 324 COMPRESSED RGB, 186
Version 3.0 (September 23, 2008)INDEX 475
COMPRESSED RGBA, 186 ConvolutionFilter1D, 137, 145–147
COMPRESSED SIGNED RED RGTC1, ConvolutionFilter2D, 137, 144–147
181, 186, 402, 403 ConvolutionParameter, 145, 168
COMPRESSED SIGNED RG RGTC2, ConvolutionParameterfv, 144, 145, 169
181, 186, 403 ConvolutionParameteriv, 146, 169
COMPRESSED SLUMINANCE, 186, COORD REPLACE, 119, 122
226 COPY, 254, 365
COMPRESSED SLUMINANCE ALPHA, COPY INVERTED, 254
186, 226 COPY PIXEL TOKEN, 308
COMPRESSED SRGB, 186, 226 CopyColorSubTable, 143, 274
COMPRESSED SRGB ALPHA, 186, CopyColorTable, 142, 143, 274
226 CopyConvolutionFilter*, 274
COMPRESSED TEXTURE FORMATS, CopyConvolutionFilter1D, 146, 147
179 CopyConvolutionFilter2D, 146, 147
CompressedTexImage, 199 CopyPixels, 63, 114, 136, 138, 142, 146,
CompressedTexImage*, 293 147, 166, 192, 266, 274–277,
CompressedTexImage1D, 197–199 306
CompressedTexImage2D, 197–199 CopyTexImage, 295
CompressedTexImage3D, 197–199 CopyTexImage*, 274, 286, 293
CompressedTexSubImage1D, 199, 200 CopyTexImage1D, 166, 193, 194, 197,
CompressedTexSubImage2D, 199, 200 210
CompressedTexSubImage3D, 199, 200 CopyTexImage2D, 166, 192–194, 197,
CONSTANT, 222, 224, 363 210
CONSTANT ALPHA, 251, 434 CopyTexImage3D, 194
CONSTANT ATTENUATION, 82 CopyTexSubImage, 295
CONSTANT BORDER, 168, 169 CopyTexSubImage*, 197, 201, 274, 286
CONSTANT COLOR, 251, 434 CopyTexSubImage1D, 166, 193, 194,
CONTEXT FLAG FORWARD COMPATIBLE BIT, 196, 197
328 CopyTexSubImage2D, 166, 193–197
CONTEXT FLAGS, 328 CopyTexSubImage3D, 166, 193, 194,
CONVOLUTION 1D, 145, 147, 166, 196, 197
190, 324, 325 CreateProgram, 91, 312
CONVOLUTION 2D, 144–146, 166, CreateShader, 89, 312, 446
189, 324, 325 CreateShaderObjectARB, 446
CONVOLUTION BORDER COLOR, CULL FACE, 130
169, 325 CullFace, 130, 131, 135
CONVOLUTION BORDER MODE, CURRENT BIT, 341
168, 325 CURRENT FOG COORD, 441
CONVOLUTION FILTER BIAS, 144– CURRENT FOG COORDINATE, 441
146, 325 CURRENT QUERY, 329
CONVOLUTION FILTER SCALE, CURRENT RASTER SECONDARY COLOR,
144–147, 325 452
CONVOLUTION FORMAT, 325 CURRENT RASTER TEXTURE COORDS,
CONVOLUTION HEIGHT, 325 71, 397
CONVOLUTION WIDTH, 325 CURRENT TEXTURE COORDS, 25
Version 3.0 (September 23, 2008)INDEX 476
CURRENT VERTEX ATTRIB, 335 DEPTH TEXTURE MODE, 202, 215,
CW, 80 222, 225, 408
DepthFunc, 246
DECAL, 220, 221
DepthMask, 260, 261, 266
DECR, 245
DepthRange, 51, 73, 316, 398
DECR WRAP, 245, 435
DepthTest, 266
DELETE STATUS, 90, 332
DetachShader, 91, 312
DeleteBuffers, 39, 40, 311
dFdx, 314
DeleteFramebuffers, 280, 281, 311
dFdy, 314
DeleteLists, 311, 409
DIFFUSE, 82, 84
DeleteProgram, 92, 312
Disable, 56, 57, 61, 69, 75, 80, 81, 84,
DeleteQueries, 62, 311
114, 116, 118, 124, 126, 130,
DeleteRenderbuffers, 283, 293, 311
132, 135, 171, 172, 227, 228,
DeleteShader, 90, 312
230, 242–244, 246, 248, 253,
DeleteTextures, 217, 293, 311
299, 300, 406–409
DeleteVertexArrays, 48, 311
DisableClientState, 24, 31, 36, 38, 311,
DEPTH, 192, 263, 264, 274, 336, 361,
406
369, 373, 434, 459
Disablei, 248
DEPTH24 STENCIL8, 181, 185
DisableVertexAttribArray, 31, 311, 335
DEPTH32F STENCIL8, 181, 185
DITHER, 253
DEPTH ATTACHMENT, 281, 286, 292,
DOMAIN, 320
459, 460
DONT CARE, 313, 385
DEPTH BIAS, 139, 164
DOT3 RGB, 223
DEPTH BITS, 276, 295, 409
DOT3 RGBA, 223
DEPTH BUFFER, 460
DOUBLE, 29, 32
DEPTH BUFFER BIT, 261, 264, 276,
DRAW BUFFER, 256, 259, 269, 454
277, 341
DRAW BUFFERi, 248, 259, 260, 263,
DEPTH COMPONENT, 107, 141, 144,
292, 454
151, 153, 178, 179, 185, 225,
DRAW BUFFER0, 259
227, 234, 268, 270, 274, 276,
DRAW FRAMEBUFFER, 265, 279–
291, 321, 323–326, 449
281, 285–287, 294, 336, 367
DEPTH COMPONENT16, 181, 185
DRAW FRAMEBUFFER BINDING,
DEPTH COMPONENT24, 181, 185
23, 151, 174, 209, 256, 258,
DEPTH COMPONENT32, 185
274, 277, 281, 294–296
DEPTH COMPONENT32F, 181, 185
DRAW PIXEL TOKEN, 308
DEPTH SCALE, 139, 164
DrawArrays, 33, 34, 46, 48, 108, 309
DEPTH STENCIL, 107, 141, 144, 151,
DrawBuffer, 254–257, 259, 261, 264
153, 156, 160, 161, 163, 178,
DrawBuffers, 255, 256, 258, 259
179, 185, 192, 213, 225, 227,
DrawElements, 34, 35, 46–48, 65, 108,
234, 263, 264, 266, 268, 270,
309, 418
274, 276, 286, 288, 291, 321
DrawPixels, 63, 67, 114, 132, 136–138,
DEPTH STENCIL ATTACHMENT,
141, 144, 149–155, 160, 161,
286, 288, 336
163, 166, 173, 174, 177, 235,
DEPTH TEST, 246
266, 272, 274, 306, 408, 452
DrawRangeElements, 35, 46, 47, 108,
Version 3.0 (September 23, 2008)INDEX 477
309, 388 EvalMesh2, 63, 301, 302
DST ALPHA, 251 EvalPoint, 24
DST COLOR, 251, 434 EvalPoint*, 409
DYNAMIC COPY, 39, 41 EvalPoint1, 302
DYNAMIC DRAW, 39, 40 EvalPoint2, 302
DYNAMIC READ, 39, 41 EXP, 230, 231, 353
EXP2, 230
EDGE FLAG ARRAY, 31, 36
EXT pixel buffer object, 454
EDGE FLAG ARRAY POINTER, 327
EXT texture sRGB, 455
EdgeFlag, 23, 24
EXTENSIONS, 138, 327, 328, 410, 464,
EdgeFlag*, 406
465
EdgeFlagPointer, 24, 29, 30, 311, 406
EYE LINEAR, 59–61, 318, 362
EdgeFlagv, 23, 32
EYE PLANE, 59, 60
ELEMENT ARRAY BUFFER, 38, 40,
42, 45, 47, 330, 331 FALSE, 23, 39, 41, 46, 77, 79, 86, 90–
EMISSION, 82, 84 92, 99, 100, 110, 111, 119,
Enable, 56, 57, 61, 69, 75, 80, 81, 84, 137, 139, 148, 149, 161, 164,
114, 116, 118, 124, 126, 130, 172, 173, 202, 215, 218, 235,
132, 135, 171, 172, 227, 228, 243, 266, 268, 316, 323, 325,
230, 242–244, 246, 248, 253, 326, 328–332, 335, 336, 338,
299, 300, 316, 406–409 346–348, 351–362, 364, 365,
ENABLE BIT, 341 372–380, 382, 383, 392
EnableClientState, 24, 31, 36, 38, 311, FASTEST, 313
406 FEEDBACK, 304–306, 399
Enablei, 248 FEEDBACK BUFFER POINTER, 327
EnableVertexAttribArray, 31, 48, 311, FeedbackBuffer, 305, 306, 311, 327, 409
335 FILL, 133, 135, 136, 301, 357, 398, 412
End, 16, 19–24, 33, 34, 49, 63, 81, 84, Finish, 312, 313, 397
87, 123, 130, 133, 294, 301, FIXED ONLY, 86, 162, 271, 277, 278,
302, 307, 406 353
EndConditionalRender, 63, 64 FLAT, 86, 398
EndList, 309, 409 ?at, 86
EndQuery, 62, 246, 247 FLOAT, 29, 32, 36–38, 94, 98, 103, 151,
EndTransformFeedback, 64 152, 179, 270, 271, 273, 310,
EQUAL, 202, 226, 244–246 319–321, 337, 346–348
EQUIV, 254 ?oat, 93
EVAL BIT, 341 FLOAT 32 UNSIGNED INT 24 8 REV,
EvalCoord, 24, 299, 300 151, 152, 155, 156, 268, 272,
EvalCoord*, 409 273
EvalCoord1, 300–302 FLOAT MAT2, 94, 98, 103
EvalCoord1d, 301 FLOAT MAT2x3, 94, 98, 453
EvalCoord1f, 301 FLOAT MAT2x4, 94, 98, 453
EvalCoord2, 300, 302, 303 FLOAT MAT3, 94, 98, 103
EvalMesh*, 409 FLOAT MAT3x2, 94, 98, 453
EvalMesh1, 63, 301 FLOAT MAT3x4, 94, 98, 453
Version 3.0 (September 23, 2008)INDEX 478
FLOAT MAT4, 94, 98, 103 FRAGMENT DEPTH, 230, 231, 353
FLOAT MAT4x2, 94, 98, 453 FRAGMENT SHADER, 232, 332
FLOAT MAT4x3, 94, 98, 453 FRAGMENT SHADER DERIVATIVE HINT,
FLOAT VEC2, 94, 98, 103 314
FLOAT VEC3, 94, 98, 103 FRAMEBUFFER, 280, 285, 286, 294,
FLOAT VEC4, 94, 98, 103 336
Flush, 312, 313, 397 FRAMEBUFFER ATTACHMENT ALPHA SIZE,
FlushBufferRange, 311, 460 337
FlushMappedBufferRange, 43, 45 FRAMEBUFFER ATTACHMENT BLUE SIZE,
FOG, 230, 409 337
Fog, 230, 231, 409 FRAMEBUFFER ATTACHMENT COLOR ENCODING,
FOG BIT, 341 248, 249, 252, 337
FOG COLOR, 231 FRAMEBUFFER ATTACHMENT COMPONENT TYPE,
FOG COORD, 71, 230, 441, 448 337
FOG COORD ARRAY, 31, 36, 441 FRAMEBUFFER ATTACHMENT DEPTH SIZE,
FOG COORD ARRAY BUFFER BINDING, 337
441, 448 FRAMEBUFFER ATTACHMENT GREEN SIZE,
FOG COORD ARRAY POINTER, 337
327, 441 FRAMEBUFFER ATTACHMENT OBJECT NAME,
FOG COORD ARRAY STRIDE, 441 285, 288, 291, 337, 338
FOG COORD ARRAY TYPE, 441 FRAMEBUFFER ATTACHMENT OBJECT TYPE,
FOG COORD SRC, 73, 230, 231, 441, 285, 288, 291, 292, 295, 336–
448 338
FOG COORDINATE, 441, 448 FRAMEBUFFER ATTACHMENT RED SIZE,
FOG COORDINATE ARRAY, 441 337
FOG COORDINATE ARRAY BUFFER BINDING,FRAMEBUFFER ATTACHMENT STENCIL SIZE,
441 337
FOG COORDINATE ARRAY POINTER, FRAMEBUFFER ATTACHMENT
441 TEXTURE CUBE MAP
FOG COORDINATE ARRAY STRIDE, FACE, 288, 338
441 FRAMEBUFFER ATTACHMENT TEXTURE LAYER,
FOG COORDINATE ARRAY TYPE, 288, 291, 296, 338
441 FRAMEBUFFER ATTACHMENT TEXTURE LEVEL,
FOG COORDINATE SOURCE, 434, 209, 288–290, 338
441 FRAMEBUFFER BINDING, 281
FOG DENSITY, 230 FRAMEBUFFER COMPLETE, 294
FOG END, 230 FRAMEBUFFER DEFAULT, 337
FOG HINT, 314, 409 FRAMEBUFFER INCOMPLETE ATTACHMENT,
FOG INDEX, 231 292
FOG MODE, 230, 231 FRAMEBUFFER INCOMPLETE DRAW BUFFER,
FOG START, 230 292
FogCoord, 24, 25, 434 FRAMEBUFFER INCOMPLETE MISSING ATTACHMENT,
FogCoord*, 406 292
FogCoord[type]v, 32 FRAMEBUFFER INCOMPLETE MULTISAMPLE,
FogCoordPointer, 24, 29, 30, 311, 406 293
Version 3.0 (September 23, 2008)INDEX 479
FRAMEBUFFER INCOMPLETE READ BUFFER,GetActiveAttrib, 93, 94, 453
292 GetActiveUniform, 97, 98, 100, 453
FRAMEBUFFER SRGB, 248, 249, 252 GetAttachedShaders, 333
FRAMEBUFFER UNDEFINED, 292 GetAttribLocation, 94, 95
FRAMEBUFFER UNSUPPORTED, GetBooleani v, 260, 315
292, 294 GetBooleanv, 243, 260, 315–317, 343
FramebufferRenderbuffer, 285, 286, GetBufferParameteriv, 330, 460
293, 312 GetBufferPointerv, 330, 331
FramebufferTexture, 288 GetBufferSubData, 330
FramebufferTexture*, 287, 288, 293 GetClipPlane, 317, 318
FramebufferTexture1D, 286, 287, 312 GetColorTable, 144, 268, 323
FramebufferTexture2D, 286, 287, 312 GetColorTableParameter, 324
FramebufferTexture3D, 286–288, 312 GetCompressedTexImage, 198, 200,
FramebufferTextureLayer, 288, 312 313, 319, 322
FRONT, 81, 84, 130, 131, 133, 245, 248, GetConvolutionFilter, 268, 324
256, 257, 259–261, 263, 269, GetConvolutionParameter, 325
278, 318, 407 GetConvolutionParameteriv, 145
FRONT AND BACK, 81, 83, 84, 130, GetDoublev, 315–317, 343
133, 245, 248, 257, 259–261, GetError, 15
263, 269 GetFloatv, 243, 315–317, 323, 343
FRONT LEFT, 257, 258, 336 GetFragDataLocation, 237
FRONT RIGHT, 257, 258, 336 GetFramebufferAttachmentiv, 461
FrontFace, 80, 130, 235, 407 GetFramebufferAttachmentParameteriv,
Frustum, 53, 55, 398, 406 295, 336, 459, 460
ftransform, 108, 109 GetHistogram, 149, 268, 325, 448
FUNC ADD, 248, 250, 365 GetHistogramParameter, 325
FUNC REVERSE SUBTRACT, 248, GetIntegeri v, 315, 331
250, 453 GetIntegerv, 35, 116, 258, 259, 281, 283,
FUNC SUBTRACT, 248, 250 315–318, 323, 328, 343
fwidth, 314 GetLight, 318
GetLightiv, 318
Gen*, 404, 406
GetMap, 318, 320
GenBuffers, 39, 311
GetMaterial, 318
GENERATE MIPMAP, 202, 203, 212,
GetMaterialiv, 318
215, 408, 433
GetMinmax, 268, 326
GENERATE MIPMAP HINT, 314, 409
GetMinmaxParameter, 326
GenerateMipmap, 212, 311
GetPixelMap, 318, 320
GenFramebuffers, 279–281, 311
GetPixelMapfv, 320
GenLists, 310, 311, 409
GetPixelMapuiv, 320
GenQueries, 62, 311
GetPixelMapusv, 320
GenRenderbuffers, 282, 283, 311
GetPointerv, 327
GenTextures, 218, 311, 323
GetPolygonStipple, 268, 323
GenVertexArrays, 48, 311, 331
GetProgramInfoLog, 92, 333
GEQUAL, 202, 226, 244–246, 440
GetProgramiv, 91, 94, 97, 98, 103, 110,
Get, 25, 51, 71, 312, 315, 316
332–334
Version 3.0 (September 23, 2008)INDEX 480
GetQueryiv, 328 GL ARB fragment program shadow,
GetQueryObject[u]iv, 330 470
GetQueryObjectiv, 329 GL ARB fragment shader, 439, 440,
GetQueryObjectuiv, 329 445, 469
GetRenderbufferParameteriv, 295, 338, GL ARB half ?oat pixel, 471
339, 461 GL ARB matrix palette, 467
GetSeparableFilter, 268, 324 GL ARB multisample, 426, 465
GetShaderInfoLog, 90, 333 GL ARB multitexture, 427, 465
GetShaderiv, 90, 332, 334 GL ARB occlusion query, 440, 469
GetShaderSource, 334 GL ARB pixel buffer object, 452, 471
GetString, 327, 328, 410 GL ARB point parameters, 435, 466
GetStringi, 328 GL ARB point sprite, 447, 470
GetTexEnv, 318, 454 GL ARB shader objects, 439, 441, 445,
GetTexEnviv, 318 469
GetTexGen, 318 GL ARB shading language 100, 446,
GetTexGeniv, 318 469
GetTexImage, 216, 268, 320–326 GL ARB shadow, 434, 467, 470
GetTexLevelParameter, 318, 319 GL ARB shadow ambient, 468
GetTexParameter, 295, 318, 319 GL ARB texture border clamp, 428,
GetTexParameterfv, 216, 218 466
GetTexParameterI, 318 GL ARB texture compression, 425, 466
GetTexParameterIiv, 319 GL ARB texture cube map, 426, 466
GetTexParameterIuiv, 319 GL ARB texture env add, 427, 466
GetTexParameteriv, 216, 218 GL ARB texture env combine, 427,
GetTexparameteriv, 318 467
GetTransformFeedbackVarying, 103, GL ARB texture env crossbar, 436, 467
104 GL ARB texture env dot3, 427, 467
GetUniform*, 336 GL ARB texture ?oat, 471
GetUniformfv, 335 GL ARB texture mirrored repeat, 436,
GetUniformiv, 335 467
GetUniformLocation, 97, 98, 101 GL ARB texture non power of two,
GetUniformuiv, 336 446, 469
GetVertexAttribdv, 334, 335 GL ARB texture rectangle, 470
GetVertexAttribfv, 334, 335 GL ARB transpose matrix, 428, 465
GetVertexAttribIiv, 334, 335 GL ARB vertex blend, 466
GetVertexAttribIuiv, 334, 335 GL ARB vertex buffer object, 439,
GetVertexAttribiv, 334, 335 440, 468
GetVertexAttribPointerv, 335 GL ARB vertex program, 433, 436, 468
gl , 103, 236, 237 GL ARB vertex shader, 439, 441, 445,
GL ARB color buffer ?oat, 471 469
GL ARB depth texture, 434, 467 GL ARB window pos, 436, 468
GL ARB draw buffers, 446, 470 GL ATI separate stencil, 447
GL ARB fragment program, 440, 468, gl BackColor, 79, 86, 108, 407
470 gl BackSecondaryColor, 79, 86, 108,
407
Version 3.0 (September 23, 2008)INDEX 481
gl ClipDistance, 108, 459 GL NV blend square, 434
gl ClipDistance[], 69 GL PERSPECTIVE CORRECT HINT,
gl ClipVertex, 69, 108, 459 452
gl Color, 234 gl PointSize, 108, 118
GL EXT bgra, 416 gl Position, 102, 108
GL EXT blend color, 420 gl PrimitiveID, 235
GL EXT blend equation separate, 447 gl SecondaryColor, 234
GL EXT blend func separate, 435 GL SGI color matrix, 419
GL EXT blend logic op, 412, 447 GL SGIS generate mipmap, 433
GL EXT blend minmax, 420 GL SGIS multitexture, 424
GL EXT blend subtract, 420 GL SGIS texture edge clamp, 418
GL EXT color subtable, 419 GL SGIS texture lod, 418
GL EXT color table, 419 gl TexCoord, 108
GL EXT convolution, 419 gl VertexID, 107, 108, 235
GL EXT copy texture, 413 gljhyperpage, 102
GL EXT draw range elements, 418 GLX ARB fbcon?g ?oat, 471
GL EXT fog coord, 434 GREATER, 202, 226, 244–246
GL EXT histogram, 420 GREEN, 139, 153, 270, 272, 321, 361,
GL EXT multi draw arrays, 434 369, 373, 374, 376, 391
GL EXT packed pixels, 417 GREEN BIAS, 164
GL EXT polygon offset, 412 GREEN BITS, 295, 409
GL EXT rescale normal, 417 GREEN INTEGER, 153
GL EXT secondary color, 435 GREEN SCALE, 164
GL EXT separate specular color, 417
HALF FLOAT, 29, 152, 270, 271, 273
GL EXT shadow funcs, 440
Hint, 313, 409
GL EXT stencil two side, 447
HINT BIT, 341
GL EXT stencil wrap, 435
HISTOGRAM, 148, 172, 325, 326
GL EXT subtexture, 413
Histogram, 147, 148, 172, 312
GL EXT texture, 412, 413
HISTOGRAM ALPHA SIZE, 326
GL EXT texture3D, 416
HISTOGRAM BLUE SIZE, 326
GL EXT texture lod bias, 436
HISTOGRAM FORMAT, 326
GL EXT texture object, 413
HISTOGRAM GREEN SIZE, 326
GL EXT texture sRGB, 452
HISTOGRAM LUMINANCE SIZE,
GL EXT vertex array, 411
326
gl FogFragCoord, 71, 108
HISTOGRAM RED SIZE, 326
gl FragColor, 235, 236, 258, 259
HISTOGRAM SINK, 326
gl FragCoord, 234
HISTOGRAM WIDTH, 326
gl FragCoord.z, 396
gl FragData, 236, 259
INCR, 245
gl FragData[n], 235, 236
INCR WRAP, 245, 435
gl FragDepth, 235, 236, 396
INDEX, 337, 391
gl FrontColor, 79, 86, 108
Index, 24, 26
gl FrontFacing, 235
Index*, 406
gl FrontSecondaryColor, 79, 86, 108
Index[type]v, 32
GL HP convolution border modes, 419
Version 3.0 (September 23, 2008)INDEX 482
INDEX ARRAY, 31, 36 217, 236, 237, 256, 258, 259,
INDEX ARRAY POINTER, 327 264–266, 268–270, 272, 274,
INDEX LOGIC OP, 253 277, 278, 280, 283, 285, 287,
INDEX OFFSET, 139, 164, 373 288, 294, 299, 304, 306, 309,
INDEX SHIFT, 139, 164, 373 317, 320–322, 329, 331, 335–
IndexMask, 260, 261 338, 406, 407, 459, 460
IndexPointer, 24, 29, 30, 311, 406 INVALID VALUE, 16, 17, 27, 29, 31,
INFO LOG LENGTH, 332, 334 33–35, 41, 44, 45, 52, 55, 64,
InitNames, 303, 409 65, 81, 89, 94, 95, 97, 102,
INT, 29, 94, 98, 103, 152, 272, 273, 310, 103, 117, 118, 124, 137, 139,
319, 337 140, 142, 143, 145, 148, 178,
INT SAMPLER 1D, 98 187–189, 192, 194–196, 198,
INT SAMPLER 1D ARRAY, 98 199, 211, 218, 230, 236, 242,
INT SAMPLER 2D, 98 248, 256, 258, 260, 262, 264,
INT SAMPLER 2D ARRAY, 98 283, 287, 288, 298, 299, 301,
INT SAMPLER 3D, 98 309, 316, 319, 321, 322, 328,
INT SAMPLER CUBE, 98 331, 335, 407, 408, 453
INT VEC2, 94, 98, 103 INVERT, 245, 254
INT VEC3, 94, 98, 103 Is, 312
INT VEC4, 94, 98, 103 IsBuffer, 330
INTENSITY, 149, 166, 167, 179, 184, IsEnabled, 242, 250, 316, 343
186, 202, 203, 221, 222, 225, IsEnabledi, 250, 316
322, 361, 374, 408, 412 IsFramebuffer, 336
INTENSITY12, 184 IsList, 311, 409
INTENSITY16, 184 IsProgram, 332
INTENSITY4, 184 IsQuery, 328
INTENSITY8, 184 IsRenderbuffer, 338
INTERLEAVED ATTRIBS, 66, 102, IsShader, 332
103, 333 IsTexture, 322, 323
INTERLEAVED ATTRIBS, 381 IsVertexArray, 331
InterleavedArrays, 24, 36, 37, 311
KEEP, 245, 246, 364
INTERPOLATE, 223
INVALID ENUM, 16, 17, 31, 45, 56,
LEFT, 248, 256, 257, 259, 260, 263, 269
60, 81, 138, 144, 149, 151,
LEQUAL, 202, 215, 226, 244–246, 360,
192, 197, 199, 200, 216, 256,
440
258, 264, 268, 269, 321, 323–
LESS, 202, 226, 244–246, 365
326, 338, 339, 461
Light, 80–82
INVALID FRAMEBUFFER OPERATION,
LIGHTi, 81, 399, 407
17, 23, 143, 147, 151, 174,
Light*, 407
197, 269, 274, 277, 295
LIGHT0, 81
INVALID OPERATION, 17, 24, 39, 42,
LIGHT MODEL AMBIENT, 82
44–46, 48, 56, 62, 64–67, 89,
LIGHT MODEL COLOR CONTROL,
91, 92, 95, 97, 100, 101, 109,
82
110, 138, 140, 151, 155, 178,
LIGHT MODEL LOCAL VIEWER,
188, 192, 196, 198–200, 212,
82
Version 3.0 (September 23, 2008)INDEX 483
LIGHT MODEL TWO SIDE, 82 LUMINANCE12 ALPHA12, 184
LIGHTING, 76, 407 LUMINANCE12 ALPHA4, 184
LIGHTING BIT, 341 LUMINANCE16, 184
LightModel, 80, 82 LUMINANCE16 ALPHA16, 184
LightModel*, 407 LUMINANCE4, 184
LINE, 133, 135, 136, 301, 302, 357, 412 LUMINANCE4 ALPHA4, 184
LINE BIT, 341 LUMINANCE6 ALPHA2, 184
LINE LOOP, 20, 65 LUMINANCE8, 184
LINE RESET TOKEN, 308 LUMINANCE8 ALPHA8, 184
LINE SMOOTH, 124, 129 LUMINANCE ALPHA, 153, 161, 166,
LINE SMOOTH HINT, 314 167, 178, 179, 184–186, 221,
LINE STIPPLE, 126, 407 222, 270–272, 321, 322, 408
LINE STRIP, 20, 65, 301
MAJOR VERSION, 328
LINE TOKEN, 308
Map*, 409
LINEAR, 105, 202, 207–209, 211, 213,
Map1, 297–299, 316
215, 230, 277, 289, 337
MAP1 COLOR 4, 298
LINEAR ATTENUATION, 82
MAP1 INDEX, 298
LINEAR MIPMAP LINEAR, 202,
MAP1 NORMAL, 298
209–211, 290
MAP1 TEXTURE COORD 1, 298, 300
LINEAR MIPMAP NEAREST, 202,
MAP1 TEXTURE COORD 2, 298, 300
209–211, 290
MAP1 TEXTURE COORD 3, 298
LINES, 20, 64, 65, 127
MAP1 TEXTURE COORD 4, 298
LineStipple, 126, 407
MAP1 VERTEX 3, 298
LineWidth, 124, 407
MAP1 VERTEX 4, 298
LINK STATUS, 91, 332
Map2, 298, 299, 316
LinkProgram, 67, 91, 92, 94, 95, 97,
MAP2 VERTEX 3, 300
101–103, 237, 312
MAP2 VERTEX 4, 300
LIST BIT, 341
MAP COLOR, 139, 164, 165
ListBase, 310, 312, 409
MAP FLUSH EXPLICIT BIT, 43–45
LOAD, 265
MAP INVALIDATE BUFFER BIT, 43,
LoadIdentity, 53, 406
44
LoadMatrix, 52, 53, 406
MAP INVALIDATE RANGE BIT, 43,
LoadMatrix[fd], 53
44
LoadName, 303, 304, 409
MAP READ BIT, 42–45
LoadTransposeMatrix, 53, 406
MAP STENCIL, 139, 165
LoadTransposeMatrix[fd], 53
MAP UNSYNCHRONIZED BIT, 43,
LOGIC OP, 253, 447, 449
44
LogicOp, 253, 254
MAP VERTEX 3, 300
LOWER LEFT, 119, 122
MAP VERTEX 4, 300
LUMINANCE, 153, 161, 166, 167, 178,
MAP WRITE BIT, 42–45
179, 184–186, 202, 203, 215,
Mapf12g, 299
221, 222, 225, 270–272, 321,
MapBuffer, 42, 44, 65, 67, 311, 460
322, 360, 361, 374, 376, 401,
MapBufferRange, 42–45, 311, 460
408, 412
MapGrid*, 409
LUMINANCE12, 184
Version 3.0 (September 23, 2008)INDEX 484
MapGrid1, 301 MAX PIXEL MAP TABLE, 140, 164
MapGrid2, 301 MAX PROGRAM TEXEL OFFSET,
mat2, 93 205
mat2x3, 93 MAX RENDERBUFFER SIZE, 283
mat2x4, 93 MAX SAMPLES, 283, 285
mat3, 93 MAX TEXTURE COORDS, 25, 28,
mat3x2, 93 38, 56, 317, 448
mat3x4, 93 MAX TEXTURE IMAGE UNITS,
mat4, 93 106, 234, 448
mat4x2, 93 MAX TEXTURE LOD BIAS, 205
mat4x3, 93 MAX TEXTURE SIZE, 188, 287
Material, 24, 80–82, 85, 398 MAX TEXTURE UNITS, 17, 56, 228,
Material*, 406 340, 448
MATRIX MODE, 56 MAX TRANSFORM FEEDBACK
MatrixMode, 52, 406 INTERLEAVED
MAX, 248, 250 COMPONENTS, 103
MAX 3D TEXTURE SIZE, 188, 287 MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS,
MAX ARRAY TEXTURE LAYERS, 65, 66, 102, 331
188 MAX TRANSFORM FEEDBACK SEPARATE COMPONENTS,
MAX ATTRIB STACK DEPTH, 339, 103
409 MAX VARYING COMPONENTS,
MAX CLIENT ATTRIB STACK DEPTH, 101, 102, 459
339, 409 MAX VARYING FLOATS, 459
MAX CLIP DISTANCES, 459 MAX VERTEX ATTRIBS, 26–29, 31,
MAX CLIP PLANES, 459 38, 93, 95, 335
MAX COLOR ATTACHMENTS, 256, MAX VERTEX TEXTURE IMAGE UNITS,
257, 259, 279, 286, 294 106
MAX COLOR MATRIX STACK DEPTH, MAX VERTEX UNIFORM COMPONENTS,
323 96
MAX COMBINED TEXTURE IMAGE UNITS,MAX VIEWPORT DIMS, 329
56, 106, 317 MIN, 248, 250
MAX CONVOLUTION HEIGHT, 145, MIN PROGRAM TEXEL OFFSET,
325 205
MAX CONVOLUTION WIDTH, 145, MINMAX, 149, 172, 326
325 Minmax, 149, 173
MAX CUBE MAP TEXTURE SIZE, MINMAX FORMAT, 326
188, 287 MINMAX SINK, 326
MAX DRAW BUFFERS, MINOR VERSION, 328
236, 237, 248, 250, 258, 260, MIRRORED REPEAT, 202, 207, 436
264 MODELVIEW, 52, 56, 57
MAX ELEMENTS INDICES, 35 MODELVIEW MATRIX, 317
MAX ELEMENTS VERTICES, 35 MODULATE, 220–223, 362
MAX EVAL ORDER, 298, 299 MULT, 265
MAX FRAGMENT UNIFORM COMPONENTS,MultiDrawArrays, 34, 46, 108, 434
232 MultiDrawElements, 35, 46, 47, 108,
Version 3.0 (September 23, 2008)INDEX 485
434 NormalPointer, 24, 28–30, 36, 46, 311,
MULTISAMPLE, 117, 123, 129, 135, 406
173, 175, 242, 254, 255 NOTEQUAL, 202, 226, 244–246
MULTISAMPLE BIT, 341 NULL, 38, 39, 41, 43, 47, 90, 94, 98,
MultiTexCoord, 24, 25, 31 103, 331, 333, 334, 342, 348,
MultiTexCoord[size][type]v, 32 351
MultMatrix, 52, 53, 406 NUM COMPRESSED TEXTURE FORMATS,
MultMatrix[fd], 53 179
MultTransposeMatrix, 53, 406 NUM EXTENSIONS, 328
MultTransposeMatrix[fd], 53
OBJECT LINEAR, 59, 61, 318
N3F V3F, 36, 37 OBJECT PLANE, 59, 60
NAND, 254 ONE, 250, 251, 365
NEAREST, 105, 202, 207, 209, 211, ONE MINUS CONSTANT ALPHA,
213, 214, 225, 277, 289 251, 434
NEAREST MIPMAP LINEAR, 202, ONE MINUS CONSTANT COLOR,
209–211, 213, 215, 290 251, 434
NEAREST MIPMAP NEAREST, 202, ONE MINUS DST ALPHA, 251
209–211, 213, 214, 225, 290 ONE MINUS DST COLOR, 251, 434
NEVER, 202, 226, 244–246 ONE MINUS SRC ALPHA, 224, 251
NewList, 309, 310, 409 ONE MINUS SRC COLOR, 224, 251,
NICEST, 313 433
NO ERROR, 15 OPERANDn ALPHA, 220, 224, 228,
NONE, 107, 202, 215, 216, 225, 234, 453
254, 256–259, 264, 269, 278, OPERANDn RGB, 220, 224, 228, 453
291, 292, 319, 337, 360, 361, OR, 254
369, 460 OR INVERTED, 254
NOOP, 254 OR REVERSE, 254
noperspective, 88 ORDER, 320
NOR, 254 Ortho, 53, 55, 398, 406
Normal, 24, 25, 93 OUT OF MEMORY, 16, 17, 41, 44,
Normal3, 12, 25 284, 309
Normal3*, 406
PACK ALIGNMENT, 268, 372
Normal3[type]v, 32
PACK IMAGE HEIGHT, 268, 321, 372
Normal3d, 12
PACK LSB FIRST, 268, 372
Normal3dv, 13
PACK ROW LENGTH, 268, 372
Normal3f, 12
PACK SKIP IMAGES, 268, 321, 372
Normal3fv, 13
PACK SKIP PIXELS, 268, 372
NORMAL ARRAY, 31, 36, 38
PACK SKIP ROWS, 268, 372
NORMAL ARRAY BUFFER BINDING,
PACK SWAP BYTES, 268, 372
46
PASS THROUGH TOKEN, 308
NORMAL ARRAY POINTER, 327
PassThrough, 307, 409
NORMAL MAP, 59, 60, 426
PERSPECTIVE CORRECTION HINT,
NORMALIZE, 58, 406
314, 409
Version 3.0 (September 23, 2008)INDEX 486
PIXEL MAP A TO A, 140, 164 POLYGON, 20, 23, 65, 235, 407
PIXEL MAP B TO B, 140, 164 POLYGON BIT, 341
PIXEL MAP G TO G, 140, 164 POLYGON OFFSET FILL, 135
PIXEL MAP I TO A, 140, 165 POLYGON OFFSET LINE, 135
PIXEL MAP I TO B, 140, 165 POLYGON OFFSET POINT, 135
PIXEL MAP I TO G, 140, 165 POLYGON SMOOTH, 130, 135
PIXEL MAP I TO I, 140, 165 POLYGON SMOOTH HINT, 314
PIXEL MAP I TO R, 140, 165 POLYGON STIPPLE, 132, 408
PIXEL MAP R TO R, 140, 164 POLYGON STIPPLE BIT, 341
PIXEL MAP S TO S, 140, 165 POLYGON TOKEN, 308
PIXEL MODE BIT, 341 PolygonMode, 129, 133, 136, 304, 306,
PIXEL PACK BUFFER, 38, 40, 42, 45, 407
137, 266, 330, 331, 452 PolygonOffset, 134
PIXEL PACK BUFFER BINDING, PolygonStipple, 132, 137, 408
272, 320, 321 PopAttrib, 339, 340, 399, 409, 453
PIXEL UNPACK BUFFER, 38, 40, 42, PopClientAttrib, 24, 311, 339, 340, 409
45, 137, 330, 331, 452 PopMatrix, 57, 406
PIXEL UNPACK BUFFER BINDING, PopName, 303, 409
140, 151, 197 POSITION, 82, 318
PixelMap, 136, 139, 140, 278, 454 POST COLOR MATRIX x BIAS, 139
PixelStore, 24, 136, 137, 139, 268, 278, POST COLOR MATRIX x SCALE,
311 139
PixelTransfer, 136, 139, 170, 278 POST COLOR MATRIX ALPHA BIAS,
PixelZoom, 163, 173, 408 171
POINT, 133, 135, 136, 301, 302, 357, POST COLOR MATRIX ALPHA SCALE,
412 171
POINT BIT, 341 POST COLOR MATRIX BLUE BIAS,
POINT DISTANCE ATTENUATION, 171
118 POST COLOR MATRIX BLUE SCALE,
POINT FADE THRESHOLD SIZE, 171
118 POST COLOR MATRIX COLOR TABLE,
POINT SIZE MAX, 118 141, 172
POINT SIZE MIN, 118 POST COLOR MATRIX GREEN BIAS,
POINT SMOOTH, 118, 123, 407 171
POINT SMOOTH HINT, 314 POST COLOR MATRIX GREEN SCALE,
POINT SPRITE, 118, 119, 123, 219, 171
318, 407, 454 POST COLOR MATRIX RED BIAS,
POINT SPRITE COORD ORIGIN, 171
119, 122, 447, 448 POST COLOR MATRIX RED SCALE,
POINT TOKEN, 308 171
Pointer, 48 POST CONVOLUTION x BIAS, 139
PointParameter, 118, 435 POST CONVOLUTION x SCALE,
PointParameter*, 119 139
POINTS, 20, 64, 65, 301 POST CONVOLUTION ALPHA BIAS,
PointSize, 117 170
Version 3.0 (September 23, 2008)INDEX 487
POST CONVOLUTION ALPHA SCALE, Q, 59, 60, 318
170 QUAD STRIP, 22, 65, 235, 407
POST CONVOLUTION BLUE BIAS, QUADRATIC ATTENUATION, 82
170 QUADS, 23, 65, 235, 407
POST CONVOLUTION BLUE SCALE, QUERY BY REGION NO WAIT, 63
170 QUERY BY REGION WAIT, 63, 64
POST CONVOLUTION COLOR TABLE, QUERY COUNTER BITS, 329
141, 171 QUERY NO WAIT, 63
POST CONVOLUTION GREEN BIAS, QUERY RESULT, 329, 454
170 QUERY RESULT AVAILABLE, 329,
POST CONVOLUTION GREEN SCALE, 454
170 QUERY WAIT, 63
POST CONVOLUTION RED BIAS,
R, 59, 60, 318, 458
170
R11F G11F B10F, 180, 181, 183
POST CONVOLUTION RED SCALE,
R16, 180, 182
170
R16F, 180, 183
PREVIOUS, 222, 224, 363
R16I, 180, 183
PRIMARY COLOR, 224
R16UI, 180, 183
PRIMITIVES GENERATED, 67, 329
R32F, 180, 183
PrioritizeTextures, 218, 219, 409
R32I, 180, 183
PROJECTION, 52, 56, 57
R32UI, 180, 183
PROXY COLOR TABLE, 141, 144,
R3 G3 B2, 182
312
R8, 180, 182
PROXY HISTOGRAM, 148, 149, 312,
R8I, 180, 183
326
R8UI, 180, 183
PROXY POST COLOR MATRIX COLOR TABLE,
RASTERIZER DISCARD, 114
141, 312
RasterPos, 70, 109, 295, 304, 398, 436
PROXY POST CONVOLUTION COLOR TABLE,
RasterPos*, 407
141, 312
RasterPos2, 71
PROXY TEXTURE 1D, 178, 190, 216,
RasterPos3, 71
312, 319
RasterPos4, 71
PROXY TEXTURE 1D ARRAY, 178,
READ BUFFER, 269, 292, 296
189, 216, 312, 319
READ FRAMEBUFFER, 265, 279–
PROXY TEXTURE 2D, 178, 189, 216,
281, 285, 286, 294, 336, 367
312, 319
READ FRAMEBUFFER BINDING,
PROXY TEXTURE 2D ARRAY, 177,
143, 147, 197, 268–270, 274,
178, 216, 312, 319
277, 281
PROXY TEXTURE 3D, 177, 216, 312,
READ ONLY, 39, 44, 45
319
READ WRITE, 39, 41, 44, 45, 351
PROXY TEXTURE CUBE MAP, 178,
ReadBuffer, 257, 269, 278
189, 216, 312, 319
ReadPixels, 67, 136, 138, 152, 153, 155,
PushAttrib, 339, 340, 409, 453
166, 266–272, 274, 276, 295,
PushClientAttrib, 24, 311, 339, 340, 409
311, 321, 323, 408, 452
PushMatrix, 57, 406
Rect, 49, 130
PushName, 303, 409
Version 3.0 (September 23, 2008)INDEX 488
Rect*, 407 RG16I, 180, 183
RED, 139, 141, 153, 179, 182, 183, 186, RG16UI, 180, 183
202, 203, 221, 222, 225, 270, RG32F, 180, 183
272, 291, 321, 322, 361, 369, RG32I, 180, 183
373, 374, 376, 391 RG32UI, 180, 183
RED BIAS, 164 RG8, 180, 182
RED BITS, 295, 409 RG8I, 180, 183
RED INTEGER, 153 RG8UI, 180, 183
RED SCALE, 164 RG INTEGER, 153
REDUCE, 168, 170, 375 RGB, 153, 156, 160, 166, 167, 178, 179,
REFLECTION MAP, 59, 60, 426 182–184, 186, 220–222, 251,
RENDER, 304, 305, 392 270–272, 291, 321, 322, 412
RENDERBUFFER, 282, 283, 285, 295, RGB10, 182
337, 338, 370 RGB10 A2, 180, 183
RENDERBUFFER ALPHA SIZE, 339 RGB12, 182
RENDERBUFFER BINDING, 283 RGB16, 180, 182
RENDERBUFFER BLUE SIZE, 339 RGB16F, 180, 183
RENDERBUFFER DEPTH SIZE, 339 RGB16I, 180, 183
RENDERBUFFER GREEN SIZE, 339 RGB16UI, 180, 184
RENDERBUFFER HEIGHT, 284, 339 RGB32F, 180, 183
RENDERBUFFER INTERNAL FORMAT, RGB32I, 180, 184
284, 339 RGB32UI, 180, 184
RENDERBUFFER RED SIZE, 339 RGB4, 182
RENDERBUFFER SAMPLES, 284, RGB5, 182
293, 294, 339 RGB5 A1, 183
RENDERBUFFER STENCIL SIZE, RGB8, 180, 182
339 RGB8I, 180, 183
RENDERBUFFER WIDTH, 284, 339 RGB8UI, 180, 183
RenderbufferStorage, 284, 293, 311 RGB9 E5, 141, 181, 183, 227, 271
RenderbufferStorageMultisample, 283, RGB INTEGER, 153
284, 312 RGB SCALE, 220, 453
RENDERER, 327 RGBA, 142, 143, 146–149, 153, 156,
RenderMode, 304–307, 311, 409 160, 166, 167, 178, 179, 183,
REPEAT, 202, 207, 215, 360 184, 186, 221, 222, 270, 274,
REPLACE, 220, 221, 223, 245 291, 321, 322, 371, 374–377
REPLICATE BORDER, 168, 169 RGBA12, 183
RESCALE NORMAL, 58, 406 RGBA16, 180, 183
ResetHistogram, 325 RGBA16F, 180, 183
ResetMinmax, 326 RGBA16I, 180, 184
RETURN, 265 RGBA16UI, 180, 184
RG, 141, 153, 179, 182, 183, 186, 221, RGBA2, 183
222, 270, 272, 291, 321, 322, RGBA32F, 180, 183
458 RGBA32I, 180, 184
RG16, 180, 182 RGBA32UI, 180, 184
RG16F, 180, 183 RGBA4, 183
Version 3.0 (September 23, 2008)INDEX 489
RGBA8, 180, 183 SecondaryColor3, 26, 447
RGBA8I, 180, 184 SecondaryColor3*, 406
RGBA8UI, 180, 184 SecondaryColor3[type]v, 32
RGBA INTEGER, 153 SecondaryColorPointer, 24, 29, 30, 311,
RIGHT, 248, 256, 257, 259, 260, 263, 406
269 SELECT, 304, 305, 399
Rotate, 53, 54, 398, 406 SelectBuffer, 304, 305, 311, 327, 409
SELECTION BUFFER POINTER, 327
S, 59, 60, 318
SEPARABLE 2D, 146, 166, 189, 324,
SAMPLE ALPHA TO COVERAGE,
325
242
SeparableFilter2D, 137, 146
SAMPLE ALPHA TO ONE, 242, 243
SEPARATE ATTRIBS, 66, 102, 103,
SAMPLE BUFFERS, 116, 123, 129,
333
135, 173, 175, 242, 247, 254,
SEPARATE SPECULAR COLOR, 78
255, 261, 268, 274, 277, 278,
SET, 254
294
ShadeModel, 86, 407
SAMPLE COVERAGE, 242, 243
SHADER SOURCE LENGTH, 332,
SAMPLE COVERAGE INVERT, 242,
334
243
SHADER TYPE, 110, 332
SAMPLE COVERAGE VALUE, 242,
ShaderSource, 89, 90, 312, 334
243
SHADING LANGUAGE VERSION,
SampleCoverage, 243
327, 446, 451
sampler2D, 101
SHININESS, 82
SAMPLER 1D, 98
SHORT, 29, 152, 272, 273, 310
SAMPLER 1D ARRAY, 98
SINGLE COLOR, 77, 78, 354
SAMPLER 1D ARRAY SHADOW, 98
SLUMINANCE, 185, 226
SAMPLER 1D SHADOW, 98
SLUMINANCE8, 226
SAMPLER 2D, 98
SLUMINANCE8 ALPHA8, 225
SAMPLER 2D ARRAY, 98
SLUMINANCE ALPHA, 225
SAMPLER 2D ARRAY SHADOW, 98
SLUMINANCE ALPHA8, 185
SAMPLER 2D SHADOW, 98
SMOOTH, 86, 353
SAMPLER 3D, 98
SOURCE0 ALPHA, 441
SAMPLER CUBE, 98
SOURCE0 RGB, 441
SAMPLER CUBE SHADOW, 98
SOURCE1 ALPHA, 441
SAMPLES, 116, 117, 247, 278, 294
SOURCE1 RGB, 441
SAMPLES PASSED, 63, 64, 246, 329
SOURCE2 ALPHA, 441
Scale, 53, 54, 398, 406
SOURCE2 RGB, 441
Scissor, 242
SPECULAR, 82, 84
SCISSOR BIT, 341
SPHERE MAP, 59–61, 426
SCISSOR TEST, 242
SPOT CUTOFF, 82
SECONDARY COLOR ARRAY, 31,
SPOT DIRECTION, 82, 318
36
SPOT EXPONENT, 82
SECONDARY COLOR ARRAY POINTER,
SRC0 ALPHA, 441
327
SRC0 RGB, 441
SecondaryColor, 24, 26, 435
SRC1 ALPHA, 441
Version 3.0 (September 23, 2008)INDEX 490
SRC1 RGB, 441 T, 59, 318
SRC2 ALPHA, 441 T2F C3F V3F, 36, 37
SRC2 RGB, 441 T2F C4F N3F V3F, 36, 37
SRC ALPHA, 222, 224, 251, 363 T2F C4UB V3F, 36, 37
SRC ALPHA SATURATE, 251 T2F N3F V3F, 36, 37
SRC COLOR, 222, 224, 251, 363, 433 T2F V3F, 36, 37
SRCn ALPHA, 220, 224, 228, 453 T4F C4F N3F V4F, 36, 37
SRCn RGB, 220, 224, 228, 453 T4F V4F, 36, 37
SRGB, 225, 249, 252, 337 TABLE TOO LARGE, 17, 142, 148
SRGB8, 180, 183, 225 TexCoord, 24, 25
SRGB8 ALPHA8, 180, 183, 225 TexCoord*, 406
SRGB ALPHA, 225 TexCoord1, 25
STACK OVERFLOW, 17, 57, 304, 339 TexCoord2, 25
STACK UNDERFLOW, 17, 57, 304, TexCoord3, 25
339 TexCoord4, 25
STATIC COPY, 39, 40 TexCoordPointer, 24, 29–31, 36, 311,
STATIC DRAW, 39, 40, 351 406
STATIC READ, 39, 40 TexEnv, 56, 219, 228, 409, 453
STENCIL, 263, 264, 274, 336, 361, 369, TexEnv*, 119
459 TexGen, 56, 59, 60, 317
STENCIL ATTACHMENT, 281, 286, TexGen*, 406
292, 460 TexImage, 56, 194
STENCIL ATTACMENT, 459, 460 TexImage*, 408
STENCIL BITS, 276, 295, 409 TexImage1D, 137, 166, 168, 185, 189,
STENCIL BUFFER, 460 190, 193, 194, 197, 210, 216,
STENCIL BUFFER BIT, 261, 264, 276, 312
277, 341 TexImage2D, 137, 166, 168, 185, 188–
STENCIL INDEX, 141, 144, 151, 153, 190, 192, 194, 197, 210, 216,
163, 177, 266, 268, 270, 274, 312, 452
276, 284, 291, 321 TexImage3D, 137, 177, 185, 187, 189,
STENCIL INDEX1, 284 190, 194, 197, 210, 216, 312,
STENCIL INDEX16, 284 321
STENCIL INDEX4, 284 TexParameter, 56, 201, 409
STENCIL INDEX8, 284 TexParameter*, 408
STENCIL TEST, 244 TexParameter[if], 205, 210
StencilFunc, 244–246, 397 TexParameterf, 219
StencilFuncSeparate, 244, 245 TexParameterfv, 219
StencilMask, 261, 266, 397 TexParameterI, 201
StencilMaskSeparate, 261, 266 TexParameteri, 219
StencilOp, 244, 245 TexParameterIiv, 201
StencilOpSeparate, 244, 245 TexParameterIuiv, 201
STREAM COPY, 39, 40 TexParameteriv, 201, 219
STREAM DRAW, 39, 40 TexSubImage, 194
STREAM READ, 39, 40 TexSubImage*, 197, 201
SUBTRACT, 223
Version 3.0 (September 23, 2008)INDEX 491
TexSubImage1D, 137, 166, 193, 194, TEXTURE COMPONENTS, 320
196, 199 TEXTURE COMPRESSED IMAGE SIZE,
TexSubImage2D, 137, 166, 193–196, 198, 200, 319, 322
199 TEXTURE COMPRESSION HINT,
TexSubImage3D, 137, 193, 194, 196, 314
199 TEXTURE COORD ARRAY, 31, 36
TEXTURE, 52, 55–57, 222, 224, 288, TEXTURE COORD ARRAY POINTER,
291, 295, 337, 338, 363 327
TEXTUREi, 25, 56 TEXTURE CUBE MAP, 178, 189, 201,
TEXTURE0, 25, 32, 38, 56, 57, 299, 212, 216–218, 227, 318, 319,
306, 340, 350, 362 359, 409
TEXTURE1, 340 TEXTURE CUBE MAP *, 189
TEXTURE xD, 359 TEXTURE CUBE MAP NEGATIVE X,
TEXTURE 1D, 178, 190, 193, 201, 212, 189, 192, 194, 203, 287, 318,
216–218, 227, 287, 318, 320, 320
409 TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE 1D ARRAY, 178, 188, 189, 189, 192, 194, 203, 287, 318,
192, 194, 201, 212, 216–218, 320
318, 320, 359, 409 TEXTURE CUBE MAP NEGATIVE Z,
TEXTURE 2D, 56, 101, 178, 188, 192, 189, 192, 194, 203, 287, 319,
194, 201, 212, 216–218, 227, 321
287, 318, 320, 409 TEXTURE CUBE MAP POSITIVE X,
TEXTURE 2D ARRAY, 177, 178, 187, 188, 189, 192, 194, 203, 287,
194, 199–201, 212, 216–218, 318, 320
318, 320, 359, 409 TEXTURE CUBE MAP POSITIVE Y,
TEXTURE 3D, 177, 187, 194, 201, 212, 189, 192, 194, 203, 287, 318,
216–218, 227, 287, 318, 320, 320
409 TEXTURE CUBE MAP POSITIVE Z,
TEXTURE ALPHA SIZE, 319 189, 192, 194, 203, 287, 318,
TEXTURE ALPHA TYPE, 319 321
TEXTURE BASE LEVEL, 188, 201, TEXTURE CUBE MAP POSITIVE X,
202, 209, 210, 215, 290 369
TEXTURE BIT, 340, 341, 453 TEXTURE DEPTH, 198, 200, 320
TEXTURE BLUE SIZE, 319 TEXTURE DEPTH SIZE, 319
TEXTURE BLUE TYPE, 319 TEXTURE DEPTH TYPE, 319
TEXTURE BORDER, 198, 200, 320 TEXTURE ENV, 219, 220, 318, 409
TEXTURE BORDER COLOR, 201, TEXTURE ENV COLOR, 220
202, 208, 215, 319, 461 TEXTURE ENV MODE, 220, 228, 427
TEXTURE COMPARE FAIL VALUE ARB, TEXTURE FILTER CONTROL, 219,
468 318, 409
TEXTURE COMPARE FUNC, 202, TEXTURE GEN *, 406
215, 222, 225 TEXTURE GEN MODE, 59–61
TEXTURE COMPARE MODE, TEXTURE GEN Q, 61
107, 202, 215, 222, 225, 234, TEXTURE GEN R, 61
434 TEXTURE GEN S, 61
Version 3.0 (September 23, 2008)INDEX 492
TEXTURE GEN T, 61 333
TEXTURE GREEN SIZE, 319 TRANSFORM FEEDBACK BUFFER SIZE,
TEXTURE GREEN TYPE, 319 331
TEXTURE HEIGHT, 196, 198, 200, TRANSFORM FEEDBACK BUFFER START,
201, 320 331
TEXTURE INTENSITY SIZE, 319 TRANSFORM FEEDBACK PRIMITIVES WRITTEN,
TEXTURE INTENSITY TYPE, 319 66, 67, 329
TEXTURE INTERNAL FORMAT, TRANSFORM FEEDBACK VARYING MAX LENGTH,
198, 200, 320 103, 333
TEXTURE LOD BIAS, 202, 204, 219, TRANSFORM FEEDBACK VARYINGS,
409, 436 103, 333
TEXTURE LUMINANCE SIZE, 319 TransformFeedbackVaryings, 66, 102,
TEXTURE LUMINANCE TYPE, 319 103, 311
TEXTURE MAG FILTER, 202, 213– Translate, 53, 54, 398, 406
215, 225 TRANSPOSE COLOR MATRIX, 317,
TEXTURE MAX LEVEL, 201, 202, 323
210, 215, 290 TRANSPOSE MODELVIEW MATRIX,
TEXTURE MAX LOD, 201, 202, 205, 317
215, 454 TRANSPOSE PROJECTION MATRIX,
TEXTURE MIN FILTER, 202, 207– 317
210, 213–215, 225, 289, 290 TRANSPOSE TEXTURE MATRIX,
TEXTURE MIN LOD, 201, 202, 205, 317
215, 454 TRIANGLE FAN, 22, 65
TEXTURE PRIORITY, 201, 202, 215, TRIANGLE STRIP, 21, 65
219, 409 TRIANGLES, 22, 23, 64–66
TEXTURE RECTANGLE ARB, 470 TRUE, 23, 29, 39, 44, 45, 70, 77, 79,
TEXTURE RED SIZE, 319 86, 90, 91, 100, 110, 119, 122,
TEXTURE RED TYPE, 319 137, 139, 148, 149, 202, 203,
TEXTURE RESIDENT, 215, 218, 319 212, 218, 235, 243, 260, 268,
TEXTURE SHARED SIZE, 319 271, 311, 316, 323, 325, 326,
TEXTURE STENCIL SIZE, 319 328–332, 335, 336, 338, 345,
TEXTURE WIDTH, 196, 198, 200, 320 353, 358, 365, 366, 407, 433
TEXTURE WRAP R, 202, 206, 207,
Uniform, 99
408
Uniform*, 96, 100, 101
TEXTURE WRAP S, 202, 206, 207,
Uniform*ffvg, 99
408
Uniform*ifvg, 99
TEXTURE WRAP T, 202, 206, 207,
Uniform*uifvg, 99
408
Uniform1ifvg, 99, 101
TEXTUREn, 224, 228
Uniform1iv, 100
TRANSFORM BIT, 341
Uniform2fif uig*, 100
TRANSFORM FEEDBACK BUFFER,
Uniform4ffvg, 100
65, 67
Uniform4ifvg, 100
TRANSFORM FEEDBACK BUFFER BINDING,
Uniformf1,2,3,4gui, 99
331
Uniformf1,2,3,4guiv, 99
TRANSFORM FEEDBACK BUFFER MODE,
Version 3.0 (September 23, 2008)INDEX 493
UniformMatrix*, 448 UNSIGNED INT SAMPLER 1D, 98
UniformMatrix2x4fv, 99 UNSIGNED INT SAMPLER 1D ARRAY,
UniformMatrix3fv, 100 98
UniformMatrixf234gfv, 99 UNSIGNED INT SAMPLER 2D, 98
UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gfv, UNSIGNED INT SAMPLER 2D ARRAY,
99, 451 98
UnmapBuffer, 43, 45, 46, 311 UNSIGNED INT SAMPLER 3D, 98
UNPACK ALIGNMENT, 137, 154, UNSIGNED INT SAMPLER CUBE,
177, 372 98
UNPACK IMAGE HEIGHT, 137, 177, UNSIGNED INT VEC2, 94, 98, 103
372 UNSIGNED INT VEC3, 94, 98, 103
UNPACK LSB FIRST, 137, 161, 372 UNSIGNED INT VEC4, 94, 98, 103
UNPACK ROW LENGTH, 137, 154, UNSIGNED NORMALIZED, 319, 337
177, 372 UNSIGNED SHORT, 29, 34, 152, 158,
UNPACK SKIP IMAGES, 137, 177, 272, 273, 310, 320, 321
189, 372 UNSIGNED SHORT 1 5 5 5 REV,
UNPACK SKIP PIXELS, 137, 154, 152, 156, 158, 273
161, 372 UNSIGNED SHORT 4 4 4 4, 152,
UNPACK SKIP ROWS, 137, 154, 161, 156, 158, 273
372 UNSIGNED SHORT 4 4 4 4 REV,
UNPACK SWAP BYTES, 137, 151, 152, 156, 158, 273
154, 372 UNSIGNED SHORT 5 5 5 1, 152,
UNSIGNED BYTE, 29, 34, 37, 152, 156, 158, 273
157, 272, 273, 310, 401 UNSIGNED SHORT 5 6 5, 152, 156,
UNSIGNED BYTE 2 3 3 REV, 152, 158, 273
156, 157, 273 UNSIGNED SHORT 5 6 5 REV, 152,
UNSIGNED BYTE 3 3 2, 152, 156, 156, 158, 273
157, 273 UPPER LEFT, 119, 122, 356
UNSIGNED INT, 29, 34, 94, 98, 103, UseProgram, 67, 92, 104
152, 159, 272, 273, 310, 319–
V2F, 36, 37
321, 337
V3F, 36, 37
UNSIGNED INT 10 10 10 2, 152, 156,
VALIDATE STATUS, 109, 332
159, 273
ValidateProgram, 109, 110, 312, 332
UNSIGNED INT 10F 11F 11F REV,
vec2, 93
152, 156, 159, 160, 271, 273
vec3, 93
UNSIGNED INT 24 8, 151, 152, 156,
vec4, 93, 100
159, 268, 272, 273
VENDOR, 327
UNSIGNED INT 2 10 10 10 REV,
VERSION, 327, 328
152, 156, 159, 273
Vertex, 11, 24, 71, 93, 300
UNSIGNED INT 5 9 9 9 REV, 152,
Vertex*, 406
156, 159, 160, 182, 271–273
Vertex2, 24, 27, 49
UNSIGNED INT 8 8 8 8, 152, 156,
Vertex2sv, 11
159, 273
Vertex3, 24, 27
UNSIGNED INT 8 8 8 8 REV, 152,
Vertex3f, 11
156, 159, 273
Version 3.0 (September 23, 2008)INDEX 494
Vertex4, 24, 27 WGL ARB multisample, 426
Vertex[size][type]v, 33 WGL ARB pixel format ?oat, 471
VERTEX ARRAY, 31, 38 WindowPos, 71, 73, 304, 436, 447
VERTEX ARRAY BINDING, 317, 335 WindowPos*, 407
VERTEX ARRAY POINTER, 327 WindowPos2, 71
VERTEX ATTRIB ARRAY BUFFER BINDING,WindowPos3, 71
335, 449 WRITE ONLY, 39, 44, 45
VERTEX ATTRIB ARRAY ENABLED,
XOR, 254
335
VERTEX ATTRIB ARRAY INTEGER,
ZERO, 245, 250, 251, 365
335
VERTEX ATTRIB ARRAY NORMALIZED,
335
VERTEX ATTRIB ARRAY POINTER,
335
VERTEX ATTRIB ARRAY SIZE, 335
VERTEX ATTRIB ARRAY STRIDE,
335
VERTEX ATTRIB ARRAY TYPE,
335
VERTEX PROGRAM POINT SIZE,
118
VERTEX PROGRAM TWO SIDE, 79,
80, 407
VERTEX SHADER, 89, 332
VertexAttrib, 24, 26, 63
VertexAttrib*, 27, 28, 93, 406, 453
VertexAttrib1*, 27
VertexAttrib2*, 27
VertexAttrib3*, 27
VertexAttrib4, 26
VertexAttrib4*, 27
VertexAttrib4N, 27
VertexAttrib4Nub, 27
VertexAttrib[size][type]v, 32
VertexAttrib[size]N[type]v, 32
VertexAttribI, 27
VertexAttribI4, 27
VertexAttribI[size][type]v, 32
VertexAttribIPointer, 29, 30, 311, 335
VertexAttribPointer, 24, 29, 30, 48, 311,
335, 407
VertexPointer, 24, 28, 30, 38, 311, 406
Viewport, 51
VIEWPORT BIT, 341
Version 3.0 (September 23, 2008)